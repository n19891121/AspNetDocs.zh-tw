---
uid: web-forms/overview/data-access/introduction/creating-a-business-logic-layer-vb
title: 建立商業邏輯層（VB） |Microsoft Docs
author: rick-anderson
description: 在本教學課程中，我們將瞭解如何將您的商務規則集中化為商業邏輯層（BLL），以作為在 t 之間交換資料的媒介。
ms.author: riande
ms.date: 03/31/2010
ms.assetid: 142e5181-29ce-4bb9-907b-2a0becf7928b
msc.legacyurl: /web-forms/overview/data-access/introduction/creating-a-business-logic-layer-vb
msc.type: authoredcontent
ms.openlocfilehash: 2ee4789ea9567b7bcd70eb63695e0b1d73076dc2
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/06/2020
ms.locfileid: "78605382"
---
# <a name="creating-a-business-logic-layer-vb"></a><span data-ttu-id="43d7e-103">建立商業邏輯層 (VB)</span><span class="sxs-lookup"><span data-stu-id="43d7e-103">Creating a Business Logic Layer (VB)</span></span>

<span data-ttu-id="43d7e-104">由[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="43d7e-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="43d7e-105">[下載範例應用程式](https://download.microsoft.com/download/5/d/7/5d7571fc-d0b7-4798-ad4a-c976c02363ce/ASPNET_Data_Tutorial_2_VB.exe)或[下載 PDF](creating-a-business-logic-layer-vb/_static/datatutorial02vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="43d7e-105">[Download Sample App](https://download.microsoft.com/download/5/d/7/5d7571fc-d0b7-4798-ad4a-c976c02363ce/ASPNET_Data_Tutorial_2_VB.exe) or [Download PDF](creating-a-business-logic-layer-vb/_static/datatutorial02vb1.pdf)</span></span>

> <span data-ttu-id="43d7e-106">在本教學課程中，我們將瞭解如何將您的商務規則集中化為商業邏輯層（BLL），以做為展示層和 DAL 之間資料交換的媒介。</span><span class="sxs-lookup"><span data-stu-id="43d7e-106">In this tutorial we'll see how to centralize your business rules into a Business Logic Layer (BLL) that serves as an intermediary for data exchange between the presentation layer and the DAL.</span></span>

## <a name="introduction"></a><span data-ttu-id="43d7e-107">簡介</span><span class="sxs-lookup"><span data-stu-id="43d7e-107">Introduction</span></span>

<span data-ttu-id="43d7e-108">在[第一個教學](creating-a-data-access-layer-vb.md)課程中建立的資料存取層（DAL）會將資料存取邏輯與展示邏輯明確隔開。</span><span class="sxs-lookup"><span data-stu-id="43d7e-108">The Data Access Layer (DAL) created in the [first tutorial](creating-a-data-access-layer-vb.md) cleanly separates the data access logic from the presentation logic.</span></span> <span data-ttu-id="43d7e-109">不過，DAL 會將資料存取詳細資料與展示層完全分隔，而不會強制執行任何可能適用的商務規則。</span><span class="sxs-lookup"><span data-stu-id="43d7e-109">However, while the DAL cleanly separates the data access details from the presentation layer, it does not enforce any business rules that may apply.</span></span> <span data-ttu-id="43d7e-110">例如，針對我們的應用程式，建議您在 [`Discontinued`] 欄位設定為1時，不允許修改 `Products` 資料表的 `CategoryID` 或 `SupplierID` 欄位，或者我們可能會想要強制執行資歷規則，以禁止員工被雇用之後的某人管理的情況。</span><span class="sxs-lookup"><span data-stu-id="43d7e-110">For example, for our application we may want to disallow the `CategoryID` or `SupplierID` fields of the `Products` table to be modified when the `Discontinued` field is set to 1, or we might want to enforce seniority rules, prohibiting situations in which an employee is managed by someone who was hired after them.</span></span> <span data-ttu-id="43d7e-111">另一個常見的情況是授權，可能只有特定角色的使用者可以刪除產品或變更 `UnitPrice` 值。</span><span class="sxs-lookup"><span data-stu-id="43d7e-111">Another common scenario is authorization perhaps only users in a particular role can delete products or can change the `UnitPrice` value.</span></span>

<span data-ttu-id="43d7e-112">在本教學課程中，我們將瞭解如何將這些商務規則集中成商業邏輯層（BLL），做為展示層和 DAL 之間資料交換的媒介。</span><span class="sxs-lookup"><span data-stu-id="43d7e-112">In this tutorial we'll see how to centralize these business rules into a Business Logic Layer (BLL) that serves as an intermediary for data exchange between the presentation layer and the DAL.</span></span> <span data-ttu-id="43d7e-113">在真實世界的應用程式中，BLL 應該實作為個別的類別庫專案;不過，在這些教學課程中，我們會將 BLL 實作為 `App_Code` 資料夾中一系列的類別，以便簡化專案結構。</span><span class="sxs-lookup"><span data-stu-id="43d7e-113">In a real-world application, the BLL should be implemented as a separate Class Library project; however, for these tutorials we'll implement the BLL as a series of classes in our `App_Code` folder in order to simplify the project structure.</span></span> <span data-ttu-id="43d7e-114">[圖 1] 說明展示層、BLL 和 DAL 之間的架構關聯性。</span><span class="sxs-lookup"><span data-stu-id="43d7e-114">Figure 1 illustrates the architectural relationships among the presentation layer, BLL, and DAL.</span></span>

![BLL 會將展示層與資料存取層隔開，並強加商務規則](creating-a-business-logic-layer-vb/_static/image1.png)

<span data-ttu-id="43d7e-116">**圖 1**： BLL 會將展示層與資料存取層隔開，並強加商務規則</span><span class="sxs-lookup"><span data-stu-id="43d7e-116">**Figure 1**: The BLL Separates the Presentation Layer from the Data Access Layer and Imposes Business Rules</span></span>

<span data-ttu-id="43d7e-117">我們也可以將此邏輯直接放在具有部分類別的具類型資料集，而不是建立個別的類別來執行[商務邏輯](http://en.wikipedia.org/wiki/Business_logic)。</span><span class="sxs-lookup"><span data-stu-id="43d7e-117">Rather than creating separate classes to implement our [business logic](http://en.wikipedia.org/wiki/Business_logic), we could alternatively place this logic directly in the Typed DataSet with partial classes.</span></span> <span data-ttu-id="43d7e-118">如需建立和擴充具類型資料集的範例，請參閱第一個教學課程。</span><span class="sxs-lookup"><span data-stu-id="43d7e-118">For an example of creating and extending a Typed DataSet, refer back to the first tutorial.</span></span>

## <a name="step-1-creating-the-bll-classes"></a><span data-ttu-id="43d7e-119">步驟1：建立 BLL 類別</span><span class="sxs-lookup"><span data-stu-id="43d7e-119">Step 1: Creating the BLL Classes</span></span>

<span data-ttu-id="43d7e-120">我們的 BLL 將由四個類別組成，分別用於 DAL 中的每個 TableAdapter;這些 BLL 類別中的每一個都有方法可從 DAL 中的個別 TableAdapter 進行抓取、插入、更新和刪除，並套用適當的商務規則。</span><span class="sxs-lookup"><span data-stu-id="43d7e-120">Our BLL will be composed of four classes, one for each TableAdapter in the DAL; each of these BLL classes will have methods for retrieving, inserting, updating, and deleting from the respective TableAdapter in the DAL, applying the appropriate business rules.</span></span>

<span data-ttu-id="43d7e-121">為了更明確地分隔 DAL 和 BLL 相關類別，讓我們在 `App_Code` 資料夾中建立兩個子資料夾，`DAL` 和 `BLL`。</span><span class="sxs-lookup"><span data-stu-id="43d7e-121">To more cleanly separate the DAL- and BLL-related classes, let's create two subfolders in the `App_Code` folder, `DAL` and `BLL`.</span></span> <span data-ttu-id="43d7e-122">只要以滑鼠右鍵按一下方案總管中的 [`App_Code`] 資料夾，然後選擇 [新增資料夾] 即可。</span><span class="sxs-lookup"><span data-stu-id="43d7e-122">Simply right-click on the `App_Code` folder in the Solution Explorer and choose New Folder.</span></span> <span data-ttu-id="43d7e-123">建立這兩個資料夾之後，請將第一個教學課程中建立的具類型資料集移至 `DAL` 子資料夾。</span><span class="sxs-lookup"><span data-stu-id="43d7e-123">After creating these two folders, move the Typed DataSet created in the first tutorial into the `DAL` subfolder.</span></span>

<span data-ttu-id="43d7e-124">接下來，在 `BLL` 子資料夾中建立四個 BLL 類別檔案。</span><span class="sxs-lookup"><span data-stu-id="43d7e-124">Next, create the four BLL class files in the `BLL` subfolder.</span></span> <span data-ttu-id="43d7e-125">若要完成這項操作，請以滑鼠右鍵按一下 [`BLL`] 子資料夾，選擇 [加入新專案]，然後選擇 [類別] 範本。</span><span class="sxs-lookup"><span data-stu-id="43d7e-125">To accomplish this, right-click on the `BLL` subfolder, choose Add a New Item, and choose the Class template.</span></span> <span data-ttu-id="43d7e-126">將四個類別命名為 `ProductsBLL`、`CategoriesBLL`、`SuppliersBLL`和 `EmployeesBLL`。</span><span class="sxs-lookup"><span data-stu-id="43d7e-126">Name the four classes `ProductsBLL`, `CategoriesBLL`, `SuppliersBLL`, and `EmployeesBLL`.</span></span>

![將四個新類別新增至 App_Code 資料夾](creating-a-business-logic-layer-vb/_static/image2.png)

<span data-ttu-id="43d7e-128">**圖 2**：將四個新類別新增至 `App_Code` 資料夾</span><span class="sxs-lookup"><span data-stu-id="43d7e-128">**Figure 2**: Add Four New Classes to the `App_Code` Folder</span></span>

<span data-ttu-id="43d7e-129">接下來，讓我們將方法新增至每個類別，以直接包裝第一個教學課程中為 Tableadapter 所定義的方法。</span><span class="sxs-lookup"><span data-stu-id="43d7e-129">Next, let's add methods to each of the classes to simply wrap the methods defined for the TableAdapters from the first tutorial.</span></span> <span data-ttu-id="43d7e-130">現在，這些方法只會直接呼叫 DAL;我們稍後會傳回以新增任何所需的商務邏輯。</span><span class="sxs-lookup"><span data-stu-id="43d7e-130">For now, these methods will just call directly into the DAL; we'll return later to add any needed business logic.</span></span>

> [!NOTE]
> <span data-ttu-id="43d7e-131">如果您使用 Visual Studio Standard Edition 或更新版本（也就是您*不*是使用 Visual Web Developer），您可以選擇使用[類別設計工具](https://msdn.microsoft.com/library/default.asp?url=/library/dv_vstechart/html/clssdsgnr.asp)以視覺化方式設計您的類別。</span><span class="sxs-lookup"><span data-stu-id="43d7e-131">If you are using Visual Studio Standard Edition or above (that is, you're *not* using Visual Web Developer), you can optionally design your classes visually using the [Class Designer](https://msdn.microsoft.com/library/default.asp?url=/library/dv_vstechart/html/clssdsgnr.asp).</span></span> <span data-ttu-id="43d7e-132">如需 Visual Studio 中這項新功能的詳細資訊，請參閱[類別設計工具的 Blog](https://blogs.msdn.com/classdesigner/default.aspx) 。</span><span class="sxs-lookup"><span data-stu-id="43d7e-132">Refer to the [Class Designer Blog](https://blogs.msdn.com/classdesigner/default.aspx) for more information on this new feature in Visual Studio.</span></span>

<span data-ttu-id="43d7e-133">針對 `ProductsBLL` 類別，我們需要新增總共七個方法：</span><span class="sxs-lookup"><span data-stu-id="43d7e-133">For the `ProductsBLL` class we need to add a total of seven methods:</span></span>

- <span data-ttu-id="43d7e-134">`GetProducts()` 傳回所有產品</span><span class="sxs-lookup"><span data-stu-id="43d7e-134">`GetProducts()` returns all products</span></span>
- <span data-ttu-id="43d7e-135">`GetProductByProductID(productID)` 傳回具有指定產品識別碼的產品</span><span class="sxs-lookup"><span data-stu-id="43d7e-135">`GetProductByProductID(productID)` returns the product with the specified product ID</span></span>
- <span data-ttu-id="43d7e-136">`GetProductsByCategoryID(categoryID)` 傳回指定分類中的所有產品</span><span class="sxs-lookup"><span data-stu-id="43d7e-136">`GetProductsByCategoryID(categoryID)` returns all products from the specified category</span></span>
- <span data-ttu-id="43d7e-137">`GetProductsBySupplier(supplierID)` 傳回指定供應商的所有產品</span><span class="sxs-lookup"><span data-stu-id="43d7e-137">`GetProductsBySupplier(supplierID)` returns all products from the specified supplier</span></span>
- <span data-ttu-id="43d7e-138">`AddProduct(productName, supplierID, categoryID, quantityPerUnit, unitPrice, unitsInStock, unitsOnOrder, reorderLevel, discontinued)` 會使用傳入的值，將新的產品插入資料庫中。傳回新插入之記錄的 `ProductID` 值</span><span class="sxs-lookup"><span data-stu-id="43d7e-138">`AddProduct(productName, supplierID, categoryID, quantityPerUnit, unitPrice, unitsInStock, unitsOnOrder, reorderLevel, discontinued)` inserts a new product into the database using the values passed-in; returns the `ProductID` value of the newly inserted record</span></span>
- <span data-ttu-id="43d7e-139">`UpdateProduct(productName, supplierID, categoryID, quantityPerUnit, unitPrice, unitsInStock, unitsOnOrder, reorderLevel, discontinued, productID)` 使用傳入的值來更新資料庫中的現有產品;如果已更新精確的一個資料列，則傳回 `True`，否則為 `False`</span><span class="sxs-lookup"><span data-stu-id="43d7e-139">`UpdateProduct(productName, supplierID, categoryID, quantityPerUnit, unitPrice, unitsInStock, unitsOnOrder, reorderLevel, discontinued, productID)` updates an existing product in the database using the passed-in values; returns `True` if precisely one row was updated, `False` otherwise</span></span>
- <span data-ttu-id="43d7e-140">`DeleteProduct(productID)` 從資料庫刪除指定的產品</span><span class="sxs-lookup"><span data-stu-id="43d7e-140">`DeleteProduct(productID)` deletes the specified product from the database</span></span>

<span data-ttu-id="43d7e-141">ProductsBLL .vb</span><span class="sxs-lookup"><span data-stu-id="43d7e-141">ProductsBLL.vb</span></span>

[!code-vb[Main](creating-a-business-logic-layer-vb/samples/sample1.vb)]

<span data-ttu-id="43d7e-142">只傳回資料 `GetProducts`、`GetProductByProductID`、`GetProductsByCategoryID`和 `GetProductBySuppliersID` 的方法相當簡單，因為它們只是向下呼叫 DAL。</span><span class="sxs-lookup"><span data-stu-id="43d7e-142">The methods that simply return data `GetProducts`, `GetProductByProductID`, `GetProductsByCategoryID`, and `GetProductBySuppliersID` are fairly straightforward as they simply call down into the DAL.</span></span> <span data-ttu-id="43d7e-143">雖然在某些情況下，可能會有需要在此層級上執行的商務規則（例如以目前登入的使用者或使用者所屬的角色為基礎的授權規則），但我們只會將這些方法保持原狀。</span><span class="sxs-lookup"><span data-stu-id="43d7e-143">While in some scenarios there may be business rules that need to be implemented at this level (such as authorization rules based on the currently logged on user or the role to which the user belongs), we'll simply leave these methods as-is.</span></span> <span data-ttu-id="43d7e-144">針對這些方法，BLL 僅做為 proxy，展示層會從資料存取層存取基礎資料。</span><span class="sxs-lookup"><span data-stu-id="43d7e-144">For these methods, then, the BLL serves merely as a proxy through which the presentation layer accesses the underlying data from the Data Access Layer.</span></span>

<span data-ttu-id="43d7e-145">`AddProduct` 和 `UpdateProduct` 方法都會將各種產品欄位的值當做參數，並分別新增產品或更新現有的產品。</span><span class="sxs-lookup"><span data-stu-id="43d7e-145">The `AddProduct` and `UpdateProduct` methods both take in as parameters the values for the various product fields and add a new product or update an existing one, respectively.</span></span> <span data-ttu-id="43d7e-146">由於許多 `Product` 資料表的資料行都可以接受 `NULL` 值（`CategoryID`、`SupplierID`和 `UnitPrice`等等，因此，對應到這類資料行之 `AddProduct` 和 `UpdateProduct` 的輸入參數會使用[可為 null 的類型](https://msdn.microsoft.com/library/1t3y8s4s(v=vs.80).aspx)。</span><span class="sxs-lookup"><span data-stu-id="43d7e-146">Since many of the `Product` table's columns can accept `NULL` values (`CategoryID`, `SupplierID`, and `UnitPrice`, to name a few), those input parameters for `AddProduct` and `UpdateProduct` that map to such columns use [nullable types](https://msdn.microsoft.com/library/1t3y8s4s(v=vs.80).aspx).</span></span> <span data-ttu-id="43d7e-147">可為 null 的型別是 .NET 2.0 的新方法，並提供一種技術來指出是否應 `Nothing`實數值型別。</span><span class="sxs-lookup"><span data-stu-id="43d7e-147">Nullable types are new to .NET 2.0 and provide a technique for indicating whether a value type should, instead, be `Nothing`.</span></span> <span data-ttu-id="43d7e-148">如需詳細資訊，請參閱[Paul Vick](http://www.panopticoncentral.net/)的 Blog 專案[有關可為](http://www.panopticoncentral.net/archive/2004/06/04/1180.aspx)null 的型別和 VB 的事實，以及[可為 null](https://msdn.microsoft.com/library/b3h38hb0%28VS.80%29.aspx)的結構的技術檔。</span><span class="sxs-lookup"><span data-stu-id="43d7e-148">Refer to the [Paul Vick](http://www.panopticoncentral.net/)'s blog entry [The Truth About Nullable Types and VB](http://www.panopticoncentral.net/archive/2004/06/04/1180.aspx) and the technical documentation for the [Nullable](https://msdn.microsoft.com/library/b3h38hb0%28VS.80%29.aspx) structure for more information.</span></span>

<span data-ttu-id="43d7e-149">這三種方法都會傳回布林值，指出資料列是否已插入、更新或刪除，因為作業可能不會產生受影響的資料列。</span><span class="sxs-lookup"><span data-stu-id="43d7e-149">All three methods return a Boolean value indicating whether a row was inserted, updated, or deleted since the operation may not result in an affected row.</span></span> <span data-ttu-id="43d7e-150">例如，如果網頁開發人員呼叫 `DeleteProduct` 傳入不存在產品的 `ProductID`，發出到資料庫的 `DELETE` 語句就不會有任何影響，因此 `DeleteProduct` 方法會傳回 `False`。</span><span class="sxs-lookup"><span data-stu-id="43d7e-150">For example, if the page developer calls `DeleteProduct` passing in a `ProductID` for a non-existent product, the `DELETE` statement issued to the database will have no affect and therefore the `DeleteProduct` method will return `False`.</span></span>

<span data-ttu-id="43d7e-151">請注意，當加入新產品或更新現有產品時，我們會將新的或修改過的產品域值視為純量的清單，而不是接受 `ProductsRow` 實例。</span><span class="sxs-lookup"><span data-stu-id="43d7e-151">Note that when adding a new product or updating an existing one we take in the new or modified product's field values as a list of scalars as opposed to accepting a `ProductsRow` instance.</span></span> <span data-ttu-id="43d7e-152">因為 `ProductsRow` 類別衍生自 ADO.NET `DataRow` 類別，但沒有預設的無參數函式，所以已選擇此方法。</span><span class="sxs-lookup"><span data-stu-id="43d7e-152">This approach was chosen because the `ProductsRow` class derives from the ADO.NET `DataRow` class, which doesn't have a default parameterless constructor.</span></span> <span data-ttu-id="43d7e-153">若要建立新的 `ProductsRow` 實例，我們必須先建立 `ProductsDataTable` 實例，然後再叫用其 `NewProductRow()` 方法（我們會在 `AddProduct`中這麼做）。</span><span class="sxs-lookup"><span data-stu-id="43d7e-153">In order to create a new `ProductsRow` instance, we must first create a `ProductsDataTable` instance and then invoke its `NewProductRow()` method (which we do in `AddProduct`).</span></span> <span data-ttu-id="43d7e-154">當我們使用 ObjectDataSource 來插入和更新產品時，這種缺點會 rears 標頭。</span><span class="sxs-lookup"><span data-stu-id="43d7e-154">This shortcoming rears its head when we turn to inserting and updating products using the ObjectDataSource.</span></span> <span data-ttu-id="43d7e-155">簡單地說，ObjectDataSource 會嘗試建立輸入參數的實例。</span><span class="sxs-lookup"><span data-stu-id="43d7e-155">In short, the ObjectDataSource will try to create an instance of the input parameters.</span></span> <span data-ttu-id="43d7e-156">如果 BLL 方法預期 `ProductsRow` 實例，ObjectDataSource 會嘗試建立一個，但因為沒有預設的無參數的函式，而導致失敗。</span><span class="sxs-lookup"><span data-stu-id="43d7e-156">If the BLL method expects a `ProductsRow` instance, the ObjectDataSource will try to create one, but fail due to the lack of a default parameterless constructor.</span></span> <span data-ttu-id="43d7e-157">如需此問題的詳細資訊，請參閱下列兩個 ASP.NET 論壇文章：[使用強型別資料集更新 ObjectDataSources](https://forums.asp.net/1098630/ShowPost.aspx)，以及[ObjectDataSource 和強型別資料集的問題](https://forums.asp.net/1048212/ShowPost.aspx)。</span><span class="sxs-lookup"><span data-stu-id="43d7e-157">For more information on this problem, refer to the following two ASP.NET Forums posts: [Updating ObjectDataSources with Strongly-Typed DataSets](https://forums.asp.net/1098630/ShowPost.aspx), and [Problem With ObjectDataSource and Strongly-Typed DataSet](https://forums.asp.net/1048212/ShowPost.aspx).</span></span>

<span data-ttu-id="43d7e-158">接下來，在 `AddProduct` 和 `UpdateProduct`中，程式碼會建立 `ProductsRow` 實例，並在其中填入剛傳入的值。</span><span class="sxs-lookup"><span data-stu-id="43d7e-158">Next, in both `AddProduct` and `UpdateProduct`, the code creates a `ProductsRow` instance and populates it with the values just passed in.</span></span> <span data-ttu-id="43d7e-159">將值指派給 DataColumns 的 DataRow 時，可能會發生各種欄位層級的驗證檢查。</span><span class="sxs-lookup"><span data-stu-id="43d7e-159">When assigning values to DataColumns of a DataRow various field-level validation checks can occur.</span></span> <span data-ttu-id="43d7e-160">因此，以手動方式將傳入的值放回 DataRow，有助於確保傳遞給 BLL 方法的資料有效性。</span><span class="sxs-lookup"><span data-stu-id="43d7e-160">Therefore, manually putting the passed in values back into a DataRow helps ensure the validity of the data being passed to the BLL method.</span></span> <span data-ttu-id="43d7e-161">不幸的是，Visual Studio 所產生的強型別 DataRow 類別不會使用可為 null 的型別。</span><span class="sxs-lookup"><span data-stu-id="43d7e-161">Unfortunately the strongly-typed DataRow classes generated by Visual Studio do not use nullable types.</span></span> <span data-ttu-id="43d7e-162">相反地，若要表示 DataRow 中的特定 DataColumn 應該對應至 `NULL` 資料庫值，我們必須使用 `SetColumnNameNull()` 方法。</span><span class="sxs-lookup"><span data-stu-id="43d7e-162">Rather, to indicate that a particular DataColumn in a DataRow should correspond to a `NULL` database value we must use the `SetColumnNameNull()` method.</span></span>

<span data-ttu-id="43d7e-163">在 `UpdateProduct` 我們會先載入產品，使用 `GetProductByProductID(productID)`進行更新。</span><span class="sxs-lookup"><span data-stu-id="43d7e-163">In `UpdateProduct` we first load in the product to update using `GetProductByProductID(productID)`.</span></span> <span data-ttu-id="43d7e-164">雖然這似乎不是資料庫的不必要行程，但這項額外的旅程會在未來探索開放式平行存取的教學課程中證明值得。</span><span class="sxs-lookup"><span data-stu-id="43d7e-164">While this may seem like an unnecessary trip to the database, this extra trip will prove worthwhile in future tutorials that explore optimistic concurrency.</span></span> <span data-ttu-id="43d7e-165">開放式平行存取是一項技術，可確保同時處理相同資料的兩位使用者不會意外地覆寫另一項變更。</span><span class="sxs-lookup"><span data-stu-id="43d7e-165">Optimistic concurrency is a technique to ensure that two users who are simultaneously working on the same data don't accidentally overwrite one another's changes.</span></span> <span data-ttu-id="43d7e-166">抓取整個記錄也能讓您更輕鬆地在 BLL 中建立更新方法，只會修改 DataRow 資料行的子集。</span><span class="sxs-lookup"><span data-stu-id="43d7e-166">Grabbing the entire record also makes it easier to create update methods in the BLL that only modify a subset of the DataRow's columns.</span></span> <span data-ttu-id="43d7e-167">當我們探索 `SuppliersBLL` 類別時，我們會看到這類範例。</span><span class="sxs-lookup"><span data-stu-id="43d7e-167">When we explore the `SuppliersBLL` class we'll see such an example.</span></span>

<span data-ttu-id="43d7e-168">最後請注意，`ProductsBLL` 類別已套用[DataObject 屬性](https://msdn.microsoft.com/library/system.componentmodel.dataobjectattribute.aspx)（在檔案頂端附近的 class 語句之前的 `[System.ComponentModel.DataObject]` 語法），而方法則具有[DataObjectMethodAttribute 屬性](https://msdn.microsoft.com/library/system.componentmodel.dataobjectmethodattribute.aspx)。</span><span class="sxs-lookup"><span data-stu-id="43d7e-168">Finally, note that the `ProductsBLL` class has the [DataObject attribute](https://msdn.microsoft.com/library/system.componentmodel.dataobjectattribute.aspx) applied to it (the `[System.ComponentModel.DataObject]` syntax right before the class statement near the top of the file) and the methods have [DataObjectMethodAttribute attributes](https://msdn.microsoft.com/library/system.componentmodel.dataobjectmethodattribute.aspx).</span></span> <span data-ttu-id="43d7e-169">`DataObject` 屬性會將類別標記為適用于系結至[ObjectDataSource 控制項](https://msdn.microsoft.com/library/9a4kyhcx.aspx)的物件，而 `DataObjectMethodAttribute` 則表示方法的用途。</span><span class="sxs-lookup"><span data-stu-id="43d7e-169">The `DataObject` attribute marks the class as being an object suitable for binding to an [ObjectDataSource control](https://msdn.microsoft.com/library/9a4kyhcx.aspx), whereas the `DataObjectMethodAttribute` indicates the purpose of the method.</span></span> <span data-ttu-id="43d7e-170">如我們在未來的教學課程中所見，ASP.NET 2.0 的 ObjectDataSource 可讓您輕鬆地以宣告方式從類別存取資料。</span><span class="sxs-lookup"><span data-stu-id="43d7e-170">As we'll see in future tutorials, ASP.NET 2.0's ObjectDataSource makes it easy to declaratively access data from a class.</span></span> <span data-ttu-id="43d7e-171">為了協助篩選在 ObjectDataSource 的 wizard 中系結的可能類別清單，根據預設，只有標示為 `DataObjects` 的類別會顯示在 wizard 的下拉式清單中。</span><span class="sxs-lookup"><span data-stu-id="43d7e-171">To help filter the list of possible classes to bind to in the ObjectDataSource's wizard, by default only those classes marked as `DataObjects` are shown in the wizard's drop-down list.</span></span> <span data-ttu-id="43d7e-172">`ProductsBLL` 類別也會在沒有這些屬性的情況下運作，但新增它們可讓您更輕鬆地在 ObjectDataSource 的 wizard 中使用。</span><span class="sxs-lookup"><span data-stu-id="43d7e-172">The `ProductsBLL` class will work just as well without these attributes, but adding them makes it easier to work with in the ObjectDataSource's wizard.</span></span>

## <a name="adding-the-other-classes"></a><span data-ttu-id="43d7e-173">新增其他類別</span><span class="sxs-lookup"><span data-stu-id="43d7e-173">Adding the Other Classes</span></span>

<span data-ttu-id="43d7e-174">在 `ProductsBLL` 類別完成後，我們仍需要新增類別，以使用分類、供應商和員工。</span><span class="sxs-lookup"><span data-stu-id="43d7e-174">With the `ProductsBLL` class complete, we still need to add the classes for working with categories, suppliers, and employees.</span></span> <span data-ttu-id="43d7e-175">請花點時間使用上述範例中的概念來建立下列類別和方法：</span><span class="sxs-lookup"><span data-stu-id="43d7e-175">Take a moment to create the following classes and methods using the concepts from the example above:</span></span>

- <span data-ttu-id="43d7e-176">**CategoriesBLL.cs**</span><span class="sxs-lookup"><span data-stu-id="43d7e-176">**CategoriesBLL.cs**</span></span>

    - `GetCategories()`
    - `GetCategoryByCategoryID(categoryID)`
- <span data-ttu-id="43d7e-177">**SuppliersBLL.cs**</span><span class="sxs-lookup"><span data-stu-id="43d7e-177">**SuppliersBLL.cs**</span></span>

    - `GetSuppliers()`
    - `GetSupplierBySupplierID(supplierID)`
    - `GetSuppliersByCountry(country)`
    - `UpdateSupplierAddress(supplierID, address, city, country)`
- <span data-ttu-id="43d7e-178">**EmployeesBLL.cs**</span><span class="sxs-lookup"><span data-stu-id="43d7e-178">**EmployeesBLL.cs**</span></span>

    - `GetEmployees()`
    - `GetEmployeeByEmployeeID(employeeID)`
    - `GetEmployeesByManager(managerID)`

<span data-ttu-id="43d7e-179">其中一個值得注意的方法是 `SuppliersBLL` 類別的 `UpdateSupplierAddress` 方法。</span><span class="sxs-lookup"><span data-stu-id="43d7e-179">The one method worth noting is the `SuppliersBLL` class's `UpdateSupplierAddress` method.</span></span> <span data-ttu-id="43d7e-180">這個方法會提供介面來僅更新供應商的位址資訊。</span><span class="sxs-lookup"><span data-stu-id="43d7e-180">This method provides an interface for updating just the supplier's address information.</span></span> <span data-ttu-id="43d7e-181">就內部而言，這個方法會針對指定的 `supplierID` （使用 `GetSupplierBySupplierID`）讀取 `SupplierDataRow` 物件，並設定其位址相關的屬性，然後向下呼叫 `SupplierDataTable`的 `Update` 方法。</span><span class="sxs-lookup"><span data-stu-id="43d7e-181">Internally, this method reads in the `SupplierDataRow` object for the specified `supplierID` (using `GetSupplierBySupplierID`), sets its address-related properties, and then calls down into the `SupplierDataTable`'s `Update` method.</span></span> <span data-ttu-id="43d7e-182">`UpdateSupplierAddress` 方法如下：</span><span class="sxs-lookup"><span data-stu-id="43d7e-182">The `UpdateSupplierAddress` method follows:</span></span>

[!code-vb[Main](creating-a-business-logic-layer-vb/samples/sample2.vb)]

<span data-ttu-id="43d7e-183">請參閱這篇文章的下載，以取得 BLL 類別的完整執行。</span><span class="sxs-lookup"><span data-stu-id="43d7e-183">Refer to this article's download for my complete implementation of the BLL classes.</span></span>

## <a name="step-2-accessing-the-typed-datasets-through-the-bll-classes"></a><span data-ttu-id="43d7e-184">步驟2：透過 BLL 類別存取具類型的資料集</span><span class="sxs-lookup"><span data-stu-id="43d7e-184">Step 2: Accessing the Typed DataSets Through the BLL Classes</span></span>

<span data-ttu-id="43d7e-185">在第一個教學課程中，我們看到了以程式設計方式直接使用具型別資料集的範例，但是加入了 BLL 類別，展示層應改為針對 BLL 進行處理。</span><span class="sxs-lookup"><span data-stu-id="43d7e-185">In the first tutorial we saw examples of working directly with the Typed DataSet programmatically, but with the addition of our BLL classes, the presentation tier should work against the BLL instead.</span></span> <span data-ttu-id="43d7e-186">在第一個教學課程的 `AllProducts.aspx` 範例中，`ProductsTableAdapter` 是用來將產品清單系結至 GridView，如下列程式碼所示：</span><span class="sxs-lookup"><span data-stu-id="43d7e-186">In the `AllProducts.aspx` example from the first tutorial, the `ProductsTableAdapter` was used to bind the list of products to a GridView, as shown in the following code:</span></span>

[!code-vb[Main](creating-a-business-logic-layer-vb/samples/sample3.vb)]

<span data-ttu-id="43d7e-187">若要使用新的 BLL 類別，只需變更第一行程式碼就能將 `ProductsTableAdapter` 物件取代為 `ProductBLL` 物件：</span><span class="sxs-lookup"><span data-stu-id="43d7e-187">To use the new BLL classes, all that needs to be changed is the first line of code simply replace the `ProductsTableAdapter` object with a `ProductBLL` object:</span></span>

[!code-vb[Main](creating-a-business-logic-layer-vb/samples/sample4.vb)]

<span data-ttu-id="43d7e-188">您也可以使用 ObjectDataSource，以宣告方式（也可以是具類型的資料集）來存取 BLL 類別。</span><span class="sxs-lookup"><span data-stu-id="43d7e-188">The BLL classes can also be accessed declaratively (as can the Typed DataSet) by using the ObjectDataSource.</span></span> <span data-ttu-id="43d7e-189">我們將在下列教學課程中更詳細地討論 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="43d7e-189">We'll be discussing the ObjectDataSource in greater detail in the following tutorials.</span></span>

<span data-ttu-id="43d7e-190">[![顯示在 GridView 中的產品清單](creating-a-business-logic-layer-vb/_static/image4.png)](creating-a-business-logic-layer-vb/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="43d7e-190">[![The List of Products is Displayed in a GridView](creating-a-business-logic-layer-vb/_static/image4.png)](creating-a-business-logic-layer-vb/_static/image3.png)</span></span>

<span data-ttu-id="43d7e-191">**圖 3**：產品清單會顯示在 GridView 中（[按一下以觀看完整大小的影像](creating-a-business-logic-layer-vb/_static/image5.png)）</span><span class="sxs-lookup"><span data-stu-id="43d7e-191">**Figure 3**: The List of Products is Displayed in a GridView ([Click to view full-size image](creating-a-business-logic-layer-vb/_static/image5.png))</span></span>

## <a name="step-3-adding-field-level-validation-to-the-datarow-classes"></a><span data-ttu-id="43d7e-192">步驟3：將欄位層級驗證加入至 DataRow 類別</span><span class="sxs-lookup"><span data-stu-id="43d7e-192">Step 3: Adding Field-Level Validation to the DataRow Classes</span></span>

<span data-ttu-id="43d7e-193">欄位層級驗證是在插入或更新時，與商務物件的屬性值有關的檢查。</span><span class="sxs-lookup"><span data-stu-id="43d7e-193">Field-level validation are checks that pertains to the property values of the business objects when inserting or updating.</span></span> <span data-ttu-id="43d7e-194">產品的部分欄位層級驗證規則包括：</span><span class="sxs-lookup"><span data-stu-id="43d7e-194">Some field-level validation rules for products include:</span></span>

- <span data-ttu-id="43d7e-195">`ProductName` 欄位的長度必須是40個字元或更少</span><span class="sxs-lookup"><span data-stu-id="43d7e-195">The `ProductName` field must be 40 characters or less in length</span></span>
- <span data-ttu-id="43d7e-196">`QuantityPerUnit` 欄位的長度必須為20個字元或更少</span><span class="sxs-lookup"><span data-stu-id="43d7e-196">The `QuantityPerUnit` field must be 20 characters or less in length</span></span>
- <span data-ttu-id="43d7e-197">[`ProductID`]、[`ProductName`] 和 [`Discontinued`] 欄位是必要的，但所有其他欄位都是選擇性的</span><span class="sxs-lookup"><span data-stu-id="43d7e-197">The `ProductID`, `ProductName`, and `Discontinued` fields are required, but all other fields are optional</span></span>
- <span data-ttu-id="43d7e-198">[`UnitPrice`]、[`UnitsInStock`]、[`UnitsOnOrder`] 和 [`ReorderLevel`] 欄位必須大於或等於零</span><span class="sxs-lookup"><span data-stu-id="43d7e-198">The `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, and `ReorderLevel` fields must be greater than or equal to zero</span></span>

<span data-ttu-id="43d7e-199">這些規則可以和應該在資料庫層級表示。</span><span class="sxs-lookup"><span data-stu-id="43d7e-199">These rules can and should be expressed at the database level.</span></span> <span data-ttu-id="43d7e-200">[`ProductName`] 和 [`QuantityPerUnit`] 欄位的字元限制是由 `Products` 資料表（分別`nvarchar(40)` 和 `nvarchar(20)`）中這些資料行的資料類型所捕捉。</span><span class="sxs-lookup"><span data-stu-id="43d7e-200">The character limit on the `ProductName` and `QuantityPerUnit` fields are captured by the data types of those columns in the `Products` table (`nvarchar(40)` and `nvarchar(20)`, respectively).</span></span> <span data-ttu-id="43d7e-201">如果資料庫資料表資料行允許 `NULL`，則是否需要欄位，並將其表示為選擇性。</span><span class="sxs-lookup"><span data-stu-id="43d7e-201">Whether fields are required and optional are expressed by if the database table column allows `NULL` s.</span></span> <span data-ttu-id="43d7e-202">有四個[check 條件約束](https://msdn.microsoft.com/library/ms188258.aspx)可確保只有大於或等於零的值，才能將它放入 `UnitPrice`、`UnitsInStock`、`UnitsOnOrder`或 `ReorderLevel` 資料行中。</span><span class="sxs-lookup"><span data-stu-id="43d7e-202">Four [check constraints](https://msdn.microsoft.com/library/ms188258.aspx) exist that ensure that only values greater than or equal to zero can make it into the `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, or `ReorderLevel` columns.</span></span>

<span data-ttu-id="43d7e-203">除了在資料庫中強制執行這些規則之外，也應該在資料集層級強制執行它們。</span><span class="sxs-lookup"><span data-stu-id="43d7e-203">In addition to enforcing these rules at the database they should also be enforced at the DataSet level.</span></span> <span data-ttu-id="43d7e-204">事實上，對於每個 DataTable 的 DataColumns 集，其欄位長度以及值是否為必要或選擇性。</span><span class="sxs-lookup"><span data-stu-id="43d7e-204">In fact, the field length and whether a value is required or optional are already captured for each DataTable's set of DataColumns.</span></span> <span data-ttu-id="43d7e-205">若要查看自動提供的現有欄位層級驗證，請移至 [DataSet 設計工具]，從其中一個 Datatable 選取一個欄位，然後移至 [屬性視窗]。</span><span class="sxs-lookup"><span data-stu-id="43d7e-205">To see the existing field-level validation automatically provided, go to the DataSet Designer, select a field from one of the DataTables and then go to the Properties window.</span></span> <span data-ttu-id="43d7e-206">如 [圖 4] 所示，`ProductsDataTable` 中的 `QuantityPerUnit` DataColumn 最大長度為20個字元，並允許 `NULL` 值。</span><span class="sxs-lookup"><span data-stu-id="43d7e-206">As Figure 4 shows, the `QuantityPerUnit` DataColumn in the `ProductsDataTable` has a maximum length of 20 characters and does allow `NULL` values.</span></span> <span data-ttu-id="43d7e-207">如果我們嘗試將 `ProductsDataRow`的 `QuantityPerUnit` 屬性設定為超過20個字元的字串值，則會擲回 `ArgumentException`。</span><span class="sxs-lookup"><span data-stu-id="43d7e-207">If we attempt to set the `ProductsDataRow`'s `QuantityPerUnit` property to a string value longer than 20 characters an `ArgumentException` will be thrown.</span></span>

<span data-ttu-id="43d7e-208">[![DataColumn 提供基本欄位層級驗證](creating-a-business-logic-layer-vb/_static/image7.png)](creating-a-business-logic-layer-vb/_static/image6.png)</span><span class="sxs-lookup"><span data-stu-id="43d7e-208">[![The DataColumn Provides Basic Field-Level Validation](creating-a-business-logic-layer-vb/_static/image7.png)](creating-a-business-logic-layer-vb/_static/image6.png)</span></span>

<span data-ttu-id="43d7e-209">**圖 4**： DataColumn 提供基本欄位層級驗證（[按一下以觀看完整大小的影像](creating-a-business-logic-layer-vb/_static/image8.png)）</span><span class="sxs-lookup"><span data-stu-id="43d7e-209">**Figure 4**: The DataColumn Provides Basic Field-Level Validation ([Click to view full-size image](creating-a-business-logic-layer-vb/_static/image8.png))</span></span>

<span data-ttu-id="43d7e-210">可惜的是，我們無法透過屬性視窗指定界限檢查，例如 `UnitPrice` 值必須大於或等於零。</span><span class="sxs-lookup"><span data-stu-id="43d7e-210">Unfortunately, we can't specify bounds checks, such as the `UnitPrice` value must be greater than or equal to zero, through the Properties window.</span></span> <span data-ttu-id="43d7e-211">為了提供這種類型的欄位層級驗證，我們必須為 DataTable 的[ColumnChanging](https://msdn.microsoft.com/library/system.data.datatable.columnchanging%28VS.80%29.aspx)事件建立事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="43d7e-211">In order to provide this type of field-level validation we need to create an event handler for the DataTable's [ColumnChanging](https://msdn.microsoft.com/library/system.data.datatable.columnchanging%28VS.80%29.aspx) event.</span></span> <span data-ttu-id="43d7e-212">如[先前教學](creating-a-data-access-layer-vb.md)課程中所述，透過使用部分類別，可以擴充具類型資料集所建立的資料集、Datatable 和 DataRow 物件。</span><span class="sxs-lookup"><span data-stu-id="43d7e-212">As mentioned in the [preceding tutorial](creating-a-data-access-layer-vb.md), the DataSet, DataTables, and DataRow objects created by the Typed DataSet can be extended through the use of partial classes.</span></span> <span data-ttu-id="43d7e-213">我們可以使用這項技術來建立 `ProductsDataTable` 類別的 `ColumnChanging` 事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="43d7e-213">Using this technique we can create a `ColumnChanging` event handler for the `ProductsDataTable` class.</span></span> <span data-ttu-id="43d7e-214">首先，在名為 `ProductsDataTable.ColumnChanging.vb`的 `App_Code` 資料夾中建立類別。</span><span class="sxs-lookup"><span data-stu-id="43d7e-214">Start by creating a class in the `App_Code` folder named `ProductsDataTable.ColumnChanging.vb`.</span></span>

<span data-ttu-id="43d7e-215">[![將新類別新增至 [App_Code] 資料夾](creating-a-business-logic-layer-vb/_static/image10.png)](creating-a-business-logic-layer-vb/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="43d7e-215">[![Add a New Class to the App_Code Folder](creating-a-business-logic-layer-vb/_static/image10.png)](creating-a-business-logic-layer-vb/_static/image9.png)</span></span>

<span data-ttu-id="43d7e-216">**圖 5**：將新類別新增至 [`App_Code`] 資料夾（[按一下以查看完整大小的影像](creating-a-business-logic-layer-vb/_static/image11.png)）</span><span class="sxs-lookup"><span data-stu-id="43d7e-216">**Figure 5**: Add a New Class to the `App_Code` Folder ([Click to view full-size image](creating-a-business-logic-layer-vb/_static/image11.png))</span></span>

<span data-ttu-id="43d7e-217">接下來，建立 `ColumnChanging` 事件的事件處理常式，以確保 `UnitPrice`、`UnitsInStock`、`UnitsOnOrder`和 `ReorderLevel` 資料行值（如果不是 `NULL`）大於或等於零。</span><span class="sxs-lookup"><span data-stu-id="43d7e-217">Next, create an event handler for the `ColumnChanging` event that ensures that the `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, and `ReorderLevel` column values (if not `NULL`) are greater than or equal to zero.</span></span> <span data-ttu-id="43d7e-218">如果任何這類資料行超出範圍，就會擲回 `ArgumentException`。</span><span class="sxs-lookup"><span data-stu-id="43d7e-218">If any such column is out of range, throw an `ArgumentException`.</span></span>

<span data-ttu-id="43d7e-219">ProductsDataTable. ColumnChanging .vb</span><span class="sxs-lookup"><span data-stu-id="43d7e-219">ProductsDataTable.ColumnChanging.vb</span></span>

[!code-vb[Main](creating-a-business-logic-layer-vb/samples/sample5.vb)]

## <a name="step-4-adding-custom-business-rules-to-the-blls-classes"></a><span data-ttu-id="43d7e-220">步驟4：將自訂商務規則新增至 BLL 的類別</span><span class="sxs-lookup"><span data-stu-id="43d7e-220">Step 4: Adding Custom Business Rules to the BLL's Classes</span></span>

<span data-ttu-id="43d7e-221">除了欄位層級的驗證之外，可能還有高階的自訂商務規則，其中牽涉到在單一資料行層級無法表示的不同實體或概念，例如：</span><span class="sxs-lookup"><span data-stu-id="43d7e-221">In addition to field-level validation, there may be high-level custom business rules that involve different entities or concepts not expressible at the single column level, such as:</span></span>

- <span data-ttu-id="43d7e-222">如果產品已停止，則無法更新其 `UnitPrice`</span><span class="sxs-lookup"><span data-stu-id="43d7e-222">If a product is discontinued, its `UnitPrice` cannot be updated</span></span>
- <span data-ttu-id="43d7e-223">員工的居住國家/地區必須與其居住的經理國家/地區相同</span><span class="sxs-lookup"><span data-stu-id="43d7e-223">An employee's country of residence must be the same as their manager's country of residence</span></span>
- <span data-ttu-id="43d7e-224">如果產品是供應商所提供的唯一產品，則無法中止</span><span class="sxs-lookup"><span data-stu-id="43d7e-224">A product cannot be discontinued if it is the only product provided by the supplier</span></span>

<span data-ttu-id="43d7e-225">BLL 類別應該包含檢查，以確保遵守應用程式的商務規則。</span><span class="sxs-lookup"><span data-stu-id="43d7e-225">The BLL classes should contain checks to ensure adherence to the application's business rules.</span></span> <span data-ttu-id="43d7e-226">這些檢查可以直接加入至它們所套用的方法。</span><span class="sxs-lookup"><span data-stu-id="43d7e-226">These checks can be added directly to the methods to which they apply.</span></span>

<span data-ttu-id="43d7e-227">假設我們的商務規則規定，如果產品是來自給定供應商的唯一產品，就無法標示為已停止。</span><span class="sxs-lookup"><span data-stu-id="43d7e-227">Imagine that our business rules dictate that a product could not be marked discontinued if it was the only product from a given supplier.</span></span> <span data-ttu-id="43d7e-228">也就是說，如果產品*X*是我們從供應商*Y*購買的唯一產品，我們就無法將*X*標示為已中止;不過，如果供應商*Y*提供了三項產品： *A*、 *B*和*C*，則我們可以將任何和全部標示為已中止。</span><span class="sxs-lookup"><span data-stu-id="43d7e-228">That is, if product *X* was the only product we purchased from supplier *Y*, we could not mark *X* as discontinued; if, however, supplier *Y* supplied us with three products, *A*, *B*, and *C*, then we could mark any and all of these as discontinued.</span></span> <span data-ttu-id="43d7e-229">奇數的商務規則，但商務規則和共同意義不一定一致！</span><span class="sxs-lookup"><span data-stu-id="43d7e-229">An odd business rule, but business rules and common sense aren't always aligned!</span></span>

<span data-ttu-id="43d7e-230">若要在 `UpdateProducts` 方法中強制執行此商務規則，我們會先檢查 `Discontinued` 是否設定為 `True`，如果是，我們會呼叫 `GetProductsBySupplierID` 來判斷我們向此產品供應商購買的產品數量。</span><span class="sxs-lookup"><span data-stu-id="43d7e-230">To enforce this business rule in the `UpdateProducts` method we'd start by checking if `Discontinued` was set to `True` and, if so, we'd call `GetProductsBySupplierID` to determine how many products we purchased from this product's supplier.</span></span> <span data-ttu-id="43d7e-231">如果只有一個產品向此供應商購買，我們會擲回 `ApplicationException`。</span><span class="sxs-lookup"><span data-stu-id="43d7e-231">If only one product is purchased from this supplier, we throw an `ApplicationException`.</span></span>

[!code-vb[Main](creating-a-business-logic-layer-vb/samples/sample6.vb)]

## <a name="responding-to-validation-errors-in-the-presentation-tier"></a><span data-ttu-id="43d7e-232">回應展示層中的驗證錯誤</span><span class="sxs-lookup"><span data-stu-id="43d7e-232">Responding to Validation Errors in the Presentation Tier</span></span>

<span data-ttu-id="43d7e-233">從展示層呼叫 BLL 時，我們可以決定是否嘗試處理可能引發的任何例外狀況，或讓它們向上反升至 ASP.NET （這會引發 `HttpApplication`的 `Error` 事件）。</span><span class="sxs-lookup"><span data-stu-id="43d7e-233">When calling the BLL from the presentation tier we can decide whether to attempt to handle any exceptions that might be raised or let them bubble up to ASP.NET (which will raise the `HttpApplication`'s `Error` event).</span></span> <span data-ttu-id="43d7e-234">若要在以程式設計方式使用 BLL 時處理例外狀況，我們可以使用[Try .。。Catch](https://msdn.microsoft.com/library/fk6t46tz%28VS.80%29.aspx)區塊，如下列範例所示：</span><span class="sxs-lookup"><span data-stu-id="43d7e-234">To handle an exception when working with the BLL programmatically, we can use a [Try...Catch](https://msdn.microsoft.com/library/fk6t46tz%28VS.80%29.aspx) block, as the following example shows:</span></span>

[!code-vb[Main](creating-a-business-logic-layer-vb/samples/sample7.vb)]

<span data-ttu-id="43d7e-235">如我們在未來的教學課程中所見，當使用資料 Web 控制項來插入、更新或刪除資料時，可以直接在事件處理常式中處理從 BLL 中反升的例外狀況，而不需要將程式碼包裝在 `Try...Catch` 區塊中。</span><span class="sxs-lookup"><span data-stu-id="43d7e-235">As we'll see in future tutorials, handling exceptions that bubble up from the BLL when using a data Web control for inserting, updating, or deleting data can be handled directly in an event handler as opposed to having to wrap code in `Try...Catch` blocks.</span></span>

## <a name="summary"></a><span data-ttu-id="43d7e-236">總結</span><span class="sxs-lookup"><span data-stu-id="43d7e-236">Summary</span></span>

<span data-ttu-id="43d7e-237">架構完善的應用程式會建立成不同的層級，每個階層都會封裝特定的角色。</span><span class="sxs-lookup"><span data-stu-id="43d7e-237">A well architected application is crafted into distinct layers, each of which encapsulates a particular role.</span></span> <span data-ttu-id="43d7e-238">在此文章系列的第一個教學課程中，我們使用具類型的資料集建立了資料存取層;在本教學課程中，我們將商務邏輯層建立為應用程式 `App_Code` 資料夾中一系列的類別，以向下呼叫 DAL。</span><span class="sxs-lookup"><span data-stu-id="43d7e-238">In the first tutorial of this article series we created a Data Access Layer using Typed DataSets; in this tutorial we built a Business Logic Layer as a series of classes in our application's `App_Code` folder that call down into our DAL.</span></span> <span data-ttu-id="43d7e-239">BLL 會為我們的應用程式執列欄位層級和商務層級邏輯。</span><span class="sxs-lookup"><span data-stu-id="43d7e-239">The BLL implements the field-level and business-level logic for our application.</span></span> <span data-ttu-id="43d7e-240">除了建立個別的 BLL，如同我們在本教學課程中所做的，另一個選項是透過使用部分類別來擴充 Tableadapter 的方法。</span><span class="sxs-lookup"><span data-stu-id="43d7e-240">In addition to creating a separate BLL, as we did in this tutorial, another option is to extend the TableAdapters' methods through the use of partial classes.</span></span> <span data-ttu-id="43d7e-241">不過，使用這項技術並不允許我們覆寫現有的方法，也不會將 DAL 和我們的 BLL 與我們在本文中所採取的方法完全分開。</span><span class="sxs-lookup"><span data-stu-id="43d7e-241">However, using this technique does not allow us to override existing methods nor does it separate our DAL and our BLL as cleanly as the approach we've taken in this article.</span></span>

<span data-ttu-id="43d7e-242">當 DAL 和 BLL 完成後，我們就可以開始使用我們的展示層。</span><span class="sxs-lookup"><span data-stu-id="43d7e-242">With the DAL and BLL complete, we're ready to start on our presentation layer.</span></span> <span data-ttu-id="43d7e-243">在[下一個教學](master-pages-and-site-navigation-vb.md)課程中，我們將從資料存取主題中取得簡短的繞道，並定義一致的頁面配置，以便在整個教學課程中使用。</span><span class="sxs-lookup"><span data-stu-id="43d7e-243">In the [next tutorial](master-pages-and-site-navigation-vb.md) we'll take a brief detour from data access topics and define a consistent page layout for use throughout the tutorials.</span></span>

<span data-ttu-id="43d7e-244">快樂的程式設計！</span><span class="sxs-lookup"><span data-stu-id="43d7e-244">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="43d7e-245">關於作者</span><span class="sxs-lookup"><span data-stu-id="43d7e-245">About the Author</span></span>

<span data-ttu-id="43d7e-246">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，自1998起，有七個 ASP/ASP. NET 書籍和創辦人的[4GuysFromRolla.com](http://www.4guysfromrolla.com)。</span><span class="sxs-lookup"><span data-stu-id="43d7e-246">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="43d7e-247">Scott 以獨立的顧問、訓練員和作者的身分運作。</span><span class="sxs-lookup"><span data-stu-id="43d7e-247">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="43d7e-248">他的最新著作是[*在24小時內讓自己的 ASP.NET 2.0*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="43d7e-248">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="43d7e-249">他可以在mitchell@4GuysFromRolla.com觸達[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="43d7e-249">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="43d7e-250">或者透過他的 blog，可以在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)找到。</span><span class="sxs-lookup"><span data-stu-id="43d7e-250">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="43d7e-251">特別感謝</span><span class="sxs-lookup"><span data-stu-id="43d7e-251">Special Thanks To</span></span>

<span data-ttu-id="43d7e-252">本教學課程系列已由許多有用的審核者所審查。</span><span class="sxs-lookup"><span data-stu-id="43d7e-252">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="43d7e-253">本教學課程的領導審查者為 Liz Shulok、Dennis Patterson、Carlos Santos 和 Hilton Giesenow。</span><span class="sxs-lookup"><span data-stu-id="43d7e-253">Lead reviewers for this tutorial were Liz Shulok, Dennis Patterson, Carlos Santos, and Hilton Giesenow.</span></span> <span data-ttu-id="43d7e-254">有興趣複習我即將發行的 MSDN 文章嗎？</span><span class="sxs-lookup"><span data-stu-id="43d7e-254">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="43d7e-255">若是如此，請在mitchell@4GuysFromRolla.com的那一行下拉式[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="43d7e-255">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="43d7e-256">[上一頁](creating-a-data-access-layer-vb.md)
> [下一頁](master-pages-and-site-navigation-vb.md)</span><span class="sxs-lookup"><span data-stu-id="43d7e-256">[Previous](creating-a-data-access-layer-vb.md)
[Next](master-pages-and-site-navigation-vb.md)</span></span>
