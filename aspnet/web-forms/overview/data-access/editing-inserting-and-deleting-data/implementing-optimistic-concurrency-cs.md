---
uid: web-forms/overview/data-access/editing-inserting-and-deleting-data/implementing-optimistic-concurrency-cs
title: 執行開放式平行存取C#（） |Microsoft Docs
author: rick-anderson
description: 對於允許多位使用者編輯資料的 web 應用程式，有兩位使用者可能同時編輯相同資料的風險。 在此 tutori 中 。
ms.author: riande
ms.date: 07/17/2006
ms.assetid: 56e15b33-93b8-43ad-8e19-44c6647ea05c
msc.legacyurl: /web-forms/overview/data-access/editing-inserting-and-deleting-data/implementing-optimistic-concurrency-cs
msc.type: authoredcontent
ms.openlocfilehash: 3cddb0efd28249ffc5708ece39c80581d078a5a2
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/06/2020
ms.locfileid: "78607979"
---
# <a name="implementing-optimistic-concurrency-c"></a><span data-ttu-id="aeff3-104">實作開放式同步存取 (C#)</span><span class="sxs-lookup"><span data-stu-id="aeff3-104">Implementing Optimistic Concurrency (C#)</span></span>

<span data-ttu-id="aeff3-105">由[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="aeff3-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="aeff3-106">[下載範例應用程式](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_21_CS.exe)或[下載 PDF](implementing-optimistic-concurrency-cs/_static/datatutorial21cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="aeff3-106">[Download Sample App](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_21_CS.exe) or [Download PDF](implementing-optimistic-concurrency-cs/_static/datatutorial21cs1.pdf)</span></span>

> <span data-ttu-id="aeff3-107">對於允許多位使用者編輯資料的 web 應用程式，有兩位使用者可能同時編輯相同資料的風險。</span><span class="sxs-lookup"><span data-stu-id="aeff3-107">For a web application that allows multiple users to edit data, there is the risk that two users may be editing the same data at the same time.</span></span> <span data-ttu-id="aeff3-108">在本教學課程中，我們將會實行開放式並行存取控制來處理這項風險。</span><span class="sxs-lookup"><span data-stu-id="aeff3-108">In this tutorial we'll implement optimistic concurrency control to handle this risk.</span></span>

## <a name="introduction"></a><span data-ttu-id="aeff3-109">簡介</span><span class="sxs-lookup"><span data-stu-id="aeff3-109">Introduction</span></span>

<span data-ttu-id="aeff3-110">對於只允許使用者查看資料的 web 應用程式，或僅包含可修改資料之單一使用者的 web 應用程式，不會有兩個並行使用者意外覆寫另一個變更的威脅。</span><span class="sxs-lookup"><span data-stu-id="aeff3-110">For web applications that only allow users to view data, or for those that include only a single user who can modify data, there's no threat of two concurrent users accidentally overwriting one another's changes.</span></span> <span data-ttu-id="aeff3-111">不過，對於允許多個使用者更新或刪除資料的 web 應用程式，可能會有一位使用者修改與另一位並行使用者的衝突。</span><span class="sxs-lookup"><span data-stu-id="aeff3-111">For web applications that allow multiple users to update or delete data, however, there's the potential for one user's modifications to clash with another concurrent user's.</span></span> <span data-ttu-id="aeff3-112">如果沒有任何並行原則，當兩個使用者同時編輯單一記錄時，認可其變更的使用者將會覆寫第一個所做的變更。</span><span class="sxs-lookup"><span data-stu-id="aeff3-112">Without any concurrency policy in place, when two users are simultaneously editing a single record, the user who commits her changes last will override the changes made by the first.</span></span>

<span data-ttu-id="aeff3-113">例如，假設有兩個使用者（Jisun 和 Sam）同時造訪應用程式中的網頁，讓訪客能夠透過 GridView 控制項更新和刪除產品。</span><span class="sxs-lookup"><span data-stu-id="aeff3-113">For example, imagine that two users, Jisun and Sam, were both visiting a page in our application that allowed visitors to update and delete the products through a GridView control.</span></span> <span data-ttu-id="aeff3-114">同時按一下 GridView 前後的 [編輯] 按鈕。</span><span class="sxs-lookup"><span data-stu-id="aeff3-114">Both click the Edit button in the GridView around the same time.</span></span> <span data-ttu-id="aeff3-115">Jisun 會將產品名稱變更為「Chai 茶」，並按一下 [更新] 按鈕。</span><span class="sxs-lookup"><span data-stu-id="aeff3-115">Jisun changes the product name to "Chai Tea" and clicks the Update button.</span></span> <span data-ttu-id="aeff3-116">最終結果是傳送到資料庫的 `UPDATE` 語句，它會設定*所有*產品的可更新欄位（即使 Jisun 只更新一個欄位，`ProductName`）。</span><span class="sxs-lookup"><span data-stu-id="aeff3-116">The net result is an `UPDATE` statement that is sent to the database, which sets *all* of the product's updateable fields (even though Jisun only updated one field, `ProductName`).</span></span> <span data-ttu-id="aeff3-117">在此時間點，資料庫的值為「Chai 茶」、「飲料」、「供應商外來液體等等，這是此特定產品。</span><span class="sxs-lookup"><span data-stu-id="aeff3-117">At this point in time, the database has the values "Chai Tea," the category Beverages, the supplier Exotic Liquids, and so on for this particular product.</span></span> <span data-ttu-id="aeff3-118">不過，Sam 的螢幕上的 GridView 仍然會在可編輯的 GridView 資料列中，將產品名稱顯示為 "Chai"。</span><span class="sxs-lookup"><span data-stu-id="aeff3-118">However, the GridView on Sam's screen still shows the product name in the editable GridView row as "Chai".</span></span> <span data-ttu-id="aeff3-119">認可 Jisun 變更後的幾秒後，Sam 會將類別更新為 Condiments，然後按一下 [更新]。</span><span class="sxs-lookup"><span data-stu-id="aeff3-119">A few seconds after Jisun's changes have been committed, Sam updates the category to Condiments and clicks Update.</span></span> <span data-ttu-id="aeff3-120">這會導致 `UPDATE` 語句傳送到資料庫，將產品名稱設定為 "Chai"，`CategoryID` 對應的飲料分類識別碼等等。</span><span class="sxs-lookup"><span data-stu-id="aeff3-120">This results in an `UPDATE` statement sent to the database that sets the product name to "Chai," the `CategoryID` to the corresponding Beverages category ID, and so on.</span></span> <span data-ttu-id="aeff3-121">已覆寫 Jisun 對產品名稱所做的變更。</span><span class="sxs-lookup"><span data-stu-id="aeff3-121">Jisun's changes to the product name have been overwritten.</span></span> <span data-ttu-id="aeff3-122">[圖 1] 以圖形方式描繪這一系列的事件。</span><span class="sxs-lookup"><span data-stu-id="aeff3-122">Figure 1 graphically depicts this series of events.</span></span>

<span data-ttu-id="aeff3-123">[![當兩個使用者同時更新記錄時，有一位使用者變更可能會覆寫其他的](implementing-optimistic-concurrency-cs/_static/image2.png)](implementing-optimistic-concurrency-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="aeff3-123">[![When Two Users Simultaneously Update a Record There s Potential for One User s Changes to Overwrite the Other s](implementing-optimistic-concurrency-cs/_static/image2.png)](implementing-optimistic-concurrency-cs/_static/image1.png)</span></span>

<span data-ttu-id="aeff3-124">**圖 1**：當兩個使用者同時更新記錄時，有一位使用者變更的可能性可能會覆寫其他的（[按一下以觀看完整大小的影像](implementing-optimistic-concurrency-cs/_static/image3.png)）</span><span class="sxs-lookup"><span data-stu-id="aeff3-124">**Figure 1**: When Two Users Simultaneously Update a Record There s Potential for One User s Changes to Overwrite the Other s ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image3.png))</span></span>

<span data-ttu-id="aeff3-125">同樣地，當兩位使用者流覽頁面時，如果有其他使用者刪除記錄，則可能會有一位使用者在進行更新。</span><span class="sxs-lookup"><span data-stu-id="aeff3-125">Similarly, when two users are visiting a page, one user might be in the midst of updating a record when it is deleted by another user.</span></span> <span data-ttu-id="aeff3-126">或者，當使用者載入頁面，而當他們按一下 [刪除] 按鈕時，另一位使用者可能已修改該記錄的內容。</span><span class="sxs-lookup"><span data-stu-id="aeff3-126">Or, between when a user loads a page and when they click the Delete button, another user may have modified the contents of that record.</span></span>

<span data-ttu-id="aeff3-127">有三個可用的[並行控制](http://en.wikipedia.org/wiki/Concurrency_control)策略：</span><span class="sxs-lookup"><span data-stu-id="aeff3-127">There are three [concurrency control](http://en.wikipedia.org/wiki/Concurrency_control) strategies available:</span></span>

- <span data-ttu-id="aeff3-128">**不執行任何動作**-如果並行使用者正在修改相同的記錄，請讓最後一個認可獲勝（預設行為）</span><span class="sxs-lookup"><span data-stu-id="aeff3-128">**Do Nothing** -if concurrent users are modifying the same record, let the last commit win (the default behavior)</span></span>
- <span data-ttu-id="aeff3-129">[**開放式並行**](http://en.wikipedia.org/wiki/Optimistic_concurrency_control)存取-假設在每次可能會發生並行衝突，而大部分的時間都不會發生。因此，如果發生衝突，只要通知使用者他們的變更無法儲存，因為另一個使用者已修改相同的資料</span><span class="sxs-lookup"><span data-stu-id="aeff3-129">[**Optimistic Concurrency**](http://en.wikipedia.org/wiki/Optimistic_concurrency_control) - assume that while there may be concurrency conflicts every now and then, the vast majority of the time such conflicts won't arise; therefore, if a conflict does arise, simply inform the user that their changes can't be saved because another user has modified the same data</span></span>
- <span data-ttu-id="aeff3-130">封閉式**並行**存取-假設並行衝突很常見，而且使用者不會被告知他們的變更因其他使用者的並行活動而未儲存;因此，當某位使用者開始更新記錄時，請將它鎖定，藉此防止任何其他使用者編輯或刪除該記錄，直到使用者認可其修改為止</span><span class="sxs-lookup"><span data-stu-id="aeff3-130">**Pessimistic Concurrency** - assume that concurrency conflicts are commonplace and that users won't tolerate being told their changes weren't saved due to another user's concurrent activity; therefore, when one user starts updating a record, lock it, thereby preventing any other users from editing or deleting that record until the user commits their modifications</span></span>

<span data-ttu-id="aeff3-131">到目前為止，我們所有的教學課程都已使用預設的並行解析策略，也就是我們讓最後的寫入獲勝。</span><span class="sxs-lookup"><span data-stu-id="aeff3-131">All of our tutorials thus far have used the default concurrency resolution strategy - namely, we've let the last write win.</span></span> <span data-ttu-id="aeff3-132">在本教學課程中，我們將探討如何執行開放式並行存取控制。</span><span class="sxs-lookup"><span data-stu-id="aeff3-132">In this tutorial we'll examine how to implement optimistic concurrency control.</span></span>

> [!NOTE]
> <span data-ttu-id="aeff3-133">我們不會在本教學課程系列中探討封閉式並行範例。</span><span class="sxs-lookup"><span data-stu-id="aeff3-133">We won't look at pessimistic concurrency examples in this tutorial series.</span></span> <span data-ttu-id="aeff3-134">不常使用封閉式平行存取，因為這類鎖定（如果未正確釋放）可能會防止其他使用者更新資料。</span><span class="sxs-lookup"><span data-stu-id="aeff3-134">Pessimistic concurrency is rarely used because such locks, if not properly relinquished, can prevent other users from updating data.</span></span> <span data-ttu-id="aeff3-135">例如，如果使用者鎖定記錄進行編輯，然後在解除鎖定前保留一天，則在原始使用者傳回並完成其更新之前，其他使用者都無法更新該記錄。</span><span class="sxs-lookup"><span data-stu-id="aeff3-135">For example, if a user locks a record for editing and then leaves for the day before unlocking it, no other user will be able to update that record until the original user returns and completes his update.</span></span> <span data-ttu-id="aeff3-136">因此，在使用封閉式平行存取的情況下，通常會有一個超時時間，如果達到，則會取消鎖定。</span><span class="sxs-lookup"><span data-stu-id="aeff3-136">Therefore, in situations where pessimistic concurrency is used, there's typically a timeout that, if reached, cancels the lock.</span></span> <span data-ttu-id="aeff3-137">「票證銷售網站」會在使用者完成訂單程式時，鎖定特定的座位位置，這是封閉式並行存取控制的範例。</span><span class="sxs-lookup"><span data-stu-id="aeff3-137">Ticket sales websites, which lock a particular seating location for short period while the user completes the order process, is an example of pessimistic concurrency control.</span></span>

## <a name="step-1-looking-at-how-optimistic-concurrency-is-implemented"></a><span data-ttu-id="aeff3-138">步驟1：查看開放式平行存取的執行方式</span><span class="sxs-lookup"><span data-stu-id="aeff3-138">Step 1: Looking at How Optimistic Concurrency is Implemented</span></span>

<span data-ttu-id="aeff3-139">開放式並行存取控制的運作方式是確保更新或刪除的記錄具有與更新或刪除進程啟動時相同的值。</span><span class="sxs-lookup"><span data-stu-id="aeff3-139">Optimistic concurrency control works by ensuring that the record being updated or deleted has the same values as it did when the updating or deleting process started.</span></span> <span data-ttu-id="aeff3-140">例如，按一下可編輯之 GridView 中的 [編輯] 按鈕時，會從資料庫讀取記錄的值，並顯示在文字方塊和其他 Web 控制項中。</span><span class="sxs-lookup"><span data-stu-id="aeff3-140">For example, when clicking the Edit button in an editable GridView, the record's values are read from the database and displayed in TextBoxes and other Web controls.</span></span> <span data-ttu-id="aeff3-141">這些原始值是由 GridView 儲存。</span><span class="sxs-lookup"><span data-stu-id="aeff3-141">These original values are saved by the GridView.</span></span> <span data-ttu-id="aeff3-142">之後，在使用者進行變更並按一下 [更新] 按鈕之後，原始值加上新的值就會傳送到商務邏輯層，然後再向下到資料存取層。</span><span class="sxs-lookup"><span data-stu-id="aeff3-142">Later, after the user makes her changes and clicks the Update button, the original values plus the new values are sent to the Business Logic Layer, and then down to the Data Access Layer.</span></span> <span data-ttu-id="aeff3-143">資料存取層必須發出 SQL 語句，只有在使用者開始編輯的原始值與仍在資料庫中的值相同時，才會更新記錄。</span><span class="sxs-lookup"><span data-stu-id="aeff3-143">The Data Access Layer must issue a SQL statement that will only update the record if the original values that the user started editing are identical to the values still in the database.</span></span> <span data-ttu-id="aeff3-144">[圖 2] 描繪了這一系列的事件。</span><span class="sxs-lookup"><span data-stu-id="aeff3-144">Figure 2 depicts this sequence of events.</span></span>

<span data-ttu-id="aeff3-145">[若要成功更新或刪除 ![，原始值必須等於目前的資料庫值](implementing-optimistic-concurrency-cs/_static/image5.png)](implementing-optimistic-concurrency-cs/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="aeff3-145">[![For the Update or Delete to Succeed, the Original Values Must Be Equal to the Current Database Values](implementing-optimistic-concurrency-cs/_static/image5.png)](implementing-optimistic-concurrency-cs/_static/image4.png)</span></span>

<span data-ttu-id="aeff3-146">**圖 2**：若要讓 Update 或 Delete 成功，原始值必須等於目前的資料庫值（[按一下以查看完整大小的影像](implementing-optimistic-concurrency-cs/_static/image6.png)）</span><span class="sxs-lookup"><span data-stu-id="aeff3-146">**Figure 2**: For the Update or Delete to Succeed, the Original Values Must Be Equal to the Current Database Values ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image6.png))</span></span>

<span data-ttu-id="aeff3-147">有各種方法可以執行開放式平行存取（請參閱[Peter A. Bromberg](http://peterbromberg.net/)的[開放式平行存取邏輯](http://www.eggheadcafe.com/articles/20050719.asp)，以瞭解一些選項）。</span><span class="sxs-lookup"><span data-stu-id="aeff3-147">There are various approaches to implementing optimistic concurrency (see [Peter A. Bromberg](http://peterbromberg.net/)'s [Optimistic Concurrency Updating Logic](http://www.eggheadcafe.com/articles/20050719.asp) for a brief look at a number of options).</span></span> <span data-ttu-id="aeff3-148">ADO.NET 具類型資料集提供一個可以只以核取方塊的滴答來設定的實作為。</span><span class="sxs-lookup"><span data-stu-id="aeff3-148">The ADO.NET Typed DataSet provides one implementation that can be configured with just the tick of a checkbox.</span></span> <span data-ttu-id="aeff3-149">針對具類型資料集中的 TableAdapter 啟用開放式平行存取，會增強 TableAdapter 的 `UPDATE` 和 `DELETE` 語句，以包含 `WHERE` 子句中所有原始值的比較。</span><span class="sxs-lookup"><span data-stu-id="aeff3-149">Enabling optimistic concurrency for a TableAdapter in the Typed DataSet augments the TableAdapter's `UPDATE` and `DELETE` statements to include a comparison of all of the original values in the `WHERE` clause.</span></span> <span data-ttu-id="aeff3-150">例如，如果目前的資料庫值等於在 GridView 中更新記錄時原先抓取的值，則下列 `UPDATE` 語句會更新產品的名稱和價格。</span><span class="sxs-lookup"><span data-stu-id="aeff3-150">The following `UPDATE` statement, for example, updates the name and price of a product only if the current database values are equal to the values that were originally retrieved when updating the record in the GridView.</span></span> <span data-ttu-id="aeff3-151">`@ProductName` 和 `@UnitPrice` 參數包含使用者輸入的新值，而 `@original_ProductName` 和 `@original_UnitPrice` 包含在按下 [編輯] 按鈕時，原先載入至 GridView 的值：</span><span class="sxs-lookup"><span data-stu-id="aeff3-151">The `@ProductName` and `@UnitPrice` parameters contain the new values entered by the user, whereas `@original_ProductName` and `@original_UnitPrice` contain the values that were originally loaded into the GridView when the Edit button was clicked:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample1.sql)]

> [!NOTE]
> <span data-ttu-id="aeff3-152">為了方便閱讀，已簡化此 `UPDATE` 語句。</span><span class="sxs-lookup"><span data-stu-id="aeff3-152">This `UPDATE` statement has been simplified for readability.</span></span> <span data-ttu-id="aeff3-153">實際上，`WHERE` 子句中的 `UnitPrice` 檢查會比較複雜，因為 `UnitPrice` 可以包含 `NULL` s，並檢查 `NULL = NULL` 是否一律傳回 False （相反地，您必須使用 `IS NULL`）。</span><span class="sxs-lookup"><span data-stu-id="aeff3-153">In practice, the `UnitPrice` check in the `WHERE` clause would be more involved since `UnitPrice` can contain `NULL` s and checking if `NULL = NULL` always returns False (instead you must use `IS NULL`).</span></span>

<span data-ttu-id="aeff3-154">除了使用不同的基礎 `UPDATE` 語句外，將 TableAdapter 設定為使用開放式平行存取也會修改其 DB 直接方法的簽章。</span><span class="sxs-lookup"><span data-stu-id="aeff3-154">In addition to using a different underlying `UPDATE` statement, configuring a TableAdapter to use optimistic concurrency also modifies the signature of its DB direct methods.</span></span> <span data-ttu-id="aeff3-155">回想一下我們的第一個教學課程：[*建立資料存取層*](../introduction/creating-a-data-access-layer-cs.md)，該 DB 直接方法就是接受純量值清單做為輸入參數（而不是強型別 DataRow 或 DataTable 實例）的方式。</span><span class="sxs-lookup"><span data-stu-id="aeff3-155">Recall from our first tutorial, [*Creating a Data Access Layer*](../introduction/creating-a-data-access-layer-cs.md), that DB direct methods were those that accepts a list of scalar values as input parameters (rather than a strongly-typed DataRow or DataTable instance).</span></span> <span data-ttu-id="aeff3-156">使用開放式平行存取時，DB direct `Update()` 和 `Delete()` 方法也會包含原始值的輸入參數。</span><span class="sxs-lookup"><span data-stu-id="aeff3-156">When using optimistic concurrency, the DB direct `Update()` and `Delete()` methods include input parameters for the original values as well.</span></span> <span data-ttu-id="aeff3-157">此外，使用批次更新模式的 BLL 中的程式碼（`Update()` 接受 Datarow 和 Datatable 的方法多載，而不是純量值）也必須變更。</span><span class="sxs-lookup"><span data-stu-id="aeff3-157">Moreover, the code in the BLL for using the batch update pattern (the `Update()` method overloads that accept DataRows and DataTables rather than scalar values) must be changed as well.</span></span>

<span data-ttu-id="aeff3-158">我們會改為建立一個名為 `NorthwindOptimisticConcurrency`的新型別資料集，並在其中新增使用開放式平行存取的 `Products` TableAdapter，而不是擴充現有 DAL 的 Tableadapter 來使用開放式平行存取（這會需要變更 BLL 以配合）。</span><span class="sxs-lookup"><span data-stu-id="aeff3-158">Rather than extend our existing DAL's TableAdapters to use optimistic concurrency (which would necessitate changing the BLL to accommodate), let's instead create a new Typed DataSet named `NorthwindOptimisticConcurrency`, to which we'll add a `Products` TableAdapter that uses optimistic concurrency.</span></span> <span data-ttu-id="aeff3-159">之後，我們將建立一個 `ProductsOptimisticConcurrencyBLL` 的商務邏輯層級類別，其中具有適當的修改可支援開放式平行存取 DAL。</span><span class="sxs-lookup"><span data-stu-id="aeff3-159">Following that, we'll create a `ProductsOptimisticConcurrencyBLL` Business Logic Layer class that has the appropriate modifications to support the optimistic concurrency DAL.</span></span> <span data-ttu-id="aeff3-160">一旦這是基礎，我們就準備好建立 ASP.NET 網頁。</span><span class="sxs-lookup"><span data-stu-id="aeff3-160">Once this groundwork has been laid, we'll be ready to create the ASP.NET page.</span></span>

## <a name="step-2-creating-a-data-access-layer-that-supports-optimistic-concurrency"></a><span data-ttu-id="aeff3-161">步驟2：建立支援開放式平行存取的資料存取層</span><span class="sxs-lookup"><span data-stu-id="aeff3-161">Step 2: Creating a Data Access Layer That Supports Optimistic Concurrency</span></span>

<span data-ttu-id="aeff3-162">若要建立新的具類型資料集，請以滑鼠右鍵按一下 [`App_Code`] 資料夾內的 [`DAL`] 資料夾，然後加入名為 `NorthwindOptimisticConcurrency`的新資料集。</span><span class="sxs-lookup"><span data-stu-id="aeff3-162">To create a new Typed DataSet, right-click on the `DAL` folder within the `App_Code` folder and add a new DataSet named `NorthwindOptimisticConcurrency`.</span></span> <span data-ttu-id="aeff3-163">如我們在第一個教學課程中所見，這麼做會將新的 TableAdapter 新增至具類型的資料集，並自動啟動 TableAdapter 設定 Wizard。</span><span class="sxs-lookup"><span data-stu-id="aeff3-163">As we saw in the first tutorial, doing so will add a new TableAdapter to the Typed DataSet, automatically launching the TableAdapter Configuration Wizard.</span></span> <span data-ttu-id="aeff3-164">在第一個畫面中，系統會提示您指定要連接的資料庫-使用 `Web.config`的 [`NORTHWNDConnectionString`] 設定連接到相同的 Northwind 資料庫。</span><span class="sxs-lookup"><span data-stu-id="aeff3-164">In the first screen, we're prompted to specify the database to connect to - connect to the same Northwind database using the `NORTHWNDConnectionString` setting from `Web.config`.</span></span>

<span data-ttu-id="aeff3-165">[![連接到相同的 Northwind 資料庫](implementing-optimistic-concurrency-cs/_static/image8.png)](implementing-optimistic-concurrency-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="aeff3-165">[![Connect to the Same Northwind Database](implementing-optimistic-concurrency-cs/_static/image8.png)](implementing-optimistic-concurrency-cs/_static/image7.png)</span></span>

<span data-ttu-id="aeff3-166">**圖 3**：連接到相同的 Northwind 資料庫（[按一下以觀看完整大小的影像](implementing-optimistic-concurrency-cs/_static/image9.png)）</span><span class="sxs-lookup"><span data-stu-id="aeff3-166">**Figure 3**: Connect to the Same Northwind Database ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image9.png))</span></span>

<span data-ttu-id="aeff3-167">接下來，系統會提示您如何查詢資料：透過特定 SQL 語句、新的預存程式或現有的預存程式。</span><span class="sxs-lookup"><span data-stu-id="aeff3-167">Next, we are prompted as to how to query the data: through an ad-hoc SQL statement, a new stored procedure, or an existing stored procedure.</span></span> <span data-ttu-id="aeff3-168">因為我們在原始 DAL 中使用臨機操作 SQL 查詢，所以也請在這裡使用此選項。</span><span class="sxs-lookup"><span data-stu-id="aeff3-168">Since we used ad-hoc SQL queries in our original DAL, use this option here as well.</span></span>

<span data-ttu-id="aeff3-169">[![使用臨機操作 SQL 語句來指定要取出的資料](implementing-optimistic-concurrency-cs/_static/image11.png)](implementing-optimistic-concurrency-cs/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="aeff3-169">[![Specify the Data to Retrieve Using an Ad-Hoc SQL Statement](implementing-optimistic-concurrency-cs/_static/image11.png)](implementing-optimistic-concurrency-cs/_static/image10.png)</span></span>

<span data-ttu-id="aeff3-170">**圖 4**：使用臨機操作 SQL 語句指定要抓取的資料（[按一下以查看完整大小的影像](implementing-optimistic-concurrency-cs/_static/image12.png)）</span><span class="sxs-lookup"><span data-stu-id="aeff3-170">**Figure 4**: Specify the Data to Retrieve Using an Ad-Hoc SQL Statement ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image12.png))</span></span>

<span data-ttu-id="aeff3-171">在下列畫面上，輸入要用來取出產品資訊的 SQL 查詢。</span><span class="sxs-lookup"><span data-stu-id="aeff3-171">On the following screen, enter the SQL query to use to retrieve the product information.</span></span> <span data-ttu-id="aeff3-172">讓我們使用與原始 DAL 中的 `Products` TableAdapter 完全相同的 SQL 查詢，這會傳回所有 `Product` 資料行以及產品的供應商和類別目錄名稱：</span><span class="sxs-lookup"><span data-stu-id="aeff3-172">Let's use the exact same SQL query used for the `Products` TableAdapter from our original DAL, which returns all of the `Product` columns along with the product's supplier and category names:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample2.sql)]

<span data-ttu-id="aeff3-173">[![從原始 DAL 中的產品 TableAdapter 使用相同的 SQL 查詢](implementing-optimistic-concurrency-cs/_static/image14.png)](implementing-optimistic-concurrency-cs/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="aeff3-173">[![Use the Same SQL Query from the Products TableAdapter in the Original DAL](implementing-optimistic-concurrency-cs/_static/image14.png)](implementing-optimistic-concurrency-cs/_static/image13.png)</span></span>

<span data-ttu-id="aeff3-174">**圖 5**：從原始 DAL 中的 `Products` TableAdapter 使用相同的 SQL 查詢（[按一下以查看完整大小的影像](implementing-optimistic-concurrency-cs/_static/image15.png)）</span><span class="sxs-lookup"><span data-stu-id="aeff3-174">**Figure 5**: Use the Same SQL Query from the `Products` TableAdapter in the Original DAL ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image15.png))</span></span>

<span data-ttu-id="aeff3-175">在移至下一個畫面之前，請按一下 [Advanced Options] 按鈕。</span><span class="sxs-lookup"><span data-stu-id="aeff3-175">Before moving onto the next screen, click the Advanced Options button.</span></span> <span data-ttu-id="aeff3-176">若要讓此 TableAdapter 採用開放式並行存取控制，只要勾選 [使用開放式平行存取] 核取方塊即可。</span><span class="sxs-lookup"><span data-stu-id="aeff3-176">To have this TableAdapter employ optimistic concurrency control, simply check the "Use optimistic concurrency" checkbox.</span></span>

<span data-ttu-id="aeff3-177">[藉由檢查 &quot;使用開放式平行存取&quot; 核取方塊，![啟用開放式並行存取控制](implementing-optimistic-concurrency-cs/_static/image17.png)](implementing-optimistic-concurrency-cs/_static/image16.png)</span><span class="sxs-lookup"><span data-stu-id="aeff3-177">[![Enable Optimistic Concurrency Control by Checking the &quot;Use optimistic concurrency&quot; CheckBox](implementing-optimistic-concurrency-cs/_static/image17.png)](implementing-optimistic-concurrency-cs/_static/image16.png)</span></span>

<span data-ttu-id="aeff3-178">**圖 6**：藉由勾選 [使用開放式平行存取] 核取方塊來啟用開放式並行存取控制（[按一下以查看完整大小的影像](implementing-optimistic-concurrency-cs/_static/image18.png)）</span><span class="sxs-lookup"><span data-stu-id="aeff3-178">**Figure 6**: Enable Optimistic Concurrency Control by Checking the "Use optimistic concurrency" CheckBox ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image18.png))</span></span>

<span data-ttu-id="aeff3-179">最後，指出 TableAdapter 應該使用同時填滿 DataTable 並傳回 DataTable 的資料存取模式。也表示應該建立 DB 直接方法。</span><span class="sxs-lookup"><span data-stu-id="aeff3-179">Lastly, indicate that the TableAdapter should use the data access patterns that both fill a DataTable and return a DataTable; also indicate that the DB direct methods should be created.</span></span> <span data-ttu-id="aeff3-180">將的方法名稱變更為將 DataTable 模式從，傳回至 GetProducts，以便鏡像我們在原始 DAL 中使用的命名慣例。</span><span class="sxs-lookup"><span data-stu-id="aeff3-180">Change the method name for the Return a DataTable pattern from GetData to GetProducts, so as to mirror the naming conventions we used in our original DAL.</span></span>

<span data-ttu-id="aeff3-181">[![讓 TableAdapter 利用所有資料存取模式](implementing-optimistic-concurrency-cs/_static/image20.png)](implementing-optimistic-concurrency-cs/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="aeff3-181">[![Have the TableAdapter Utilize All Data Access Patterns](implementing-optimistic-concurrency-cs/_static/image20.png)](implementing-optimistic-concurrency-cs/_static/image19.png)</span></span>

<span data-ttu-id="aeff3-182">**圖 7**：讓 TableAdapter 利用所有資料存取模式（[按一下以查看完整大小的影像](implementing-optimistic-concurrency-cs/_static/image21.png)）</span><span class="sxs-lookup"><span data-stu-id="aeff3-182">**Figure 7**: Have the TableAdapter Utilize All Data Access Patterns ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image21.png))</span></span>

<span data-ttu-id="aeff3-183">完成 wizard 之後，DataSet 設計工具會包含強型別 `Products` DataTable 和 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="aeff3-183">After completing the wizard, the DataSet Designer will include a strongly-typed `Products` DataTable and TableAdapter.</span></span> <span data-ttu-id="aeff3-184">請花點時間將 DataTable 從 `Products` 重新命名為 `ProductsOptimisticConcurrency`，您可以在 DataTable 的標題列上按一下滑鼠右鍵，然後從內容功能表中選擇 [重新命名]，來執行此動作。</span><span class="sxs-lookup"><span data-stu-id="aeff3-184">Take a moment to rename the DataTable from `Products` to `ProductsOptimisticConcurrency`, which you can do by right-clicking on the DataTable's title bar and choosing Rename from the context menu.</span></span>

<span data-ttu-id="aeff3-185">[![DataTable 和 TableAdapter 已加入至具類型的資料集](implementing-optimistic-concurrency-cs/_static/image23.png)](implementing-optimistic-concurrency-cs/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="aeff3-185">[![A DataTable and TableAdapter Have Been Added to the Typed DataSet](implementing-optimistic-concurrency-cs/_static/image23.png)](implementing-optimistic-concurrency-cs/_static/image22.png)</span></span>

<span data-ttu-id="aeff3-186">**圖 8**： DataTable 和 TableAdapter 已加入至具類型的資料集（[按一下以查看完整大小的影像](implementing-optimistic-concurrency-cs/_static/image24.png)）</span><span class="sxs-lookup"><span data-stu-id="aeff3-186">**Figure 8**: A DataTable and TableAdapter Have Been Added to the Typed DataSet ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image24.png))</span></span>

<span data-ttu-id="aeff3-187">若要查看 `ProductsOptimisticConcurrency` TableAdapter （使用開放式平行存取）和產品 TableAdapter （不是）之間的 `UPDATE` 和 `DELETE` 查詢之間的差異，請按一下 [TableAdapter]，然後移至 [屬性視窗]。</span><span class="sxs-lookup"><span data-stu-id="aeff3-187">To see the differences between the `UPDATE` and `DELETE` queries between the `ProductsOptimisticConcurrency` TableAdapter (which uses optimistic concurrency) and the Products TableAdapter (which doesn't), click on the TableAdapter and go to the Properties window.</span></span> <span data-ttu-id="aeff3-188">在 [`DeleteCommand`] 和 [`UpdateCommand` 屬性] 的 [`CommandText` 子屬性] 中，您可以看到在叫用 DAL 的更新或刪除相關方法時，傳送至資料庫的實際 SQL 語法。</span><span class="sxs-lookup"><span data-stu-id="aeff3-188">In the `DeleteCommand` and `UpdateCommand` properties' `CommandText` subproperties you can see the actual SQL syntax that is sent to the database when the DAL's update or delete-related methods are invoked.</span></span> <span data-ttu-id="aeff3-189">針對 `ProductsOptimisticConcurrency` TableAdapter，使用的 `DELETE` 語句是：</span><span class="sxs-lookup"><span data-stu-id="aeff3-189">For the `ProductsOptimisticConcurrency` TableAdapter the `DELETE` statement used is:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample3.sql)]

<span data-ttu-id="aeff3-190">而在原始 DAL 中，產品 TableAdapter 的 `DELETE` 語句是更簡單的：</span><span class="sxs-lookup"><span data-stu-id="aeff3-190">Whereas the `DELETE` statement for the Product TableAdapter in our original DAL is the much simpler:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample4.sql)]

<span data-ttu-id="aeff3-191">如您所見，使用開放式平行存取之 TableAdapter 的 `DELETE` 語句中的 `WHERE` 子句，包括每個 `Product` 資料表的現有資料行值與上一次填入 GridView （或 DetailsView 或 FormView）時的原始值之間的比較。</span><span class="sxs-lookup"><span data-stu-id="aeff3-191">As you can see, the `WHERE` clause in the `DELETE` statement for the TableAdapter that uses optimistic concurrency includes a comparison between each of the `Product` table's existing column values and the original values at the time the GridView (or DetailsView or FormView) was last populated.</span></span> <span data-ttu-id="aeff3-192">由於 `ProductID`、`ProductName`和 `Discontinued` 以外的所有欄位都可以有 `NULL` 值，因此會包含額外的參數和檢查，以正確比較 `NULL` 子句中 `WHERE` 的值。</span><span class="sxs-lookup"><span data-stu-id="aeff3-192">Since all fields other than `ProductID`, `ProductName`, and `Discontinued` can have `NULL` values, additional parameters and checks are included to correctly compare `NULL` values in the `WHERE` clause.</span></span>

<span data-ttu-id="aeff3-193">在本教學課程中，我們不會將任何額外的 Datatable 新增至開放式啟用平行存取的資料集，因為我們的 ASP.NET 網頁只會提供更新和刪除產品資訊。</span><span class="sxs-lookup"><span data-stu-id="aeff3-193">We won't be adding any additional DataTables to the optimistic concurrency-enabled DataSet for this tutorial, as our ASP.NET page will only provide updating and deleting product information.</span></span> <span data-ttu-id="aeff3-194">不過，我們仍然需要將 `GetProductByProductID(productID)` 方法新增至 `ProductsOptimisticConcurrency` TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="aeff3-194">However, we do still need to add the `GetProductByProductID(productID)` method to the `ProductsOptimisticConcurrency` TableAdapter.</span></span>

<span data-ttu-id="aeff3-195">若要完成此動作，請以滑鼠右鍵按一下 TableAdapter 的標題列（`Fill` 上方的區域並 `GetProducts` 方法名稱），然後從內容功能表選擇 [加入查詢]。</span><span class="sxs-lookup"><span data-stu-id="aeff3-195">To accomplish this, right-click on the TableAdapter's title bar (the area right above the `Fill` and `GetProducts` method names) and choose Add Query from the context menu.</span></span> <span data-ttu-id="aeff3-196">這會啟動 [TableAdapter 查詢設定] Wizard。</span><span class="sxs-lookup"><span data-stu-id="aeff3-196">This will launch the TableAdapter Query Configuration Wizard.</span></span> <span data-ttu-id="aeff3-197">如同我們的 TableAdapter 初始設定，您可以選擇使用臨機操作 SQL 語句來建立 `GetProductByProductID(productID)` 方法（請參閱 [圖 4]）。</span><span class="sxs-lookup"><span data-stu-id="aeff3-197">As with our TableAdapter's initial configuration, opt to create the `GetProductByProductID(productID)` method using an ad-hoc SQL statement (see Figure 4).</span></span> <span data-ttu-id="aeff3-198">因為 `GetProductByProductID(productID)` 方法會傳回特定產品的相關資訊，表示此查詢是傳回資料列的 `SELECT` 查詢類型。</span><span class="sxs-lookup"><span data-stu-id="aeff3-198">Since the `GetProductByProductID(productID)` method returns information about a particular product, indicate that this query is a `SELECT` query type that returns rows.</span></span>

<span data-ttu-id="aeff3-199">[![將查詢類型標記為 &quot;SELECT，這會傳回資料列&quot;](implementing-optimistic-concurrency-cs/_static/image26.png)](implementing-optimistic-concurrency-cs/_static/image25.png)</span><span class="sxs-lookup"><span data-stu-id="aeff3-199">[![Mark the Query Type as a &quot;SELECT which returns rows&quot;](implementing-optimistic-concurrency-cs/_static/image26.png)](implementing-optimistic-concurrency-cs/_static/image25.png)</span></span>

<span data-ttu-id="aeff3-200">**圖 9**：將查詢類型標記為「`SELECT` 傳回資料列」（[按一下以查看完整大小的影像](implementing-optimistic-concurrency-cs/_static/image27.png)）</span><span class="sxs-lookup"><span data-stu-id="aeff3-200">**Figure 9**: Mark the Query Type as a "`SELECT` which returns rows" ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image27.png))</span></span>

<span data-ttu-id="aeff3-201">在下一個畫面中，我們會提示您提供要使用的 SQL 查詢，並預先載入 TableAdapter 的預設查詢。</span><span class="sxs-lookup"><span data-stu-id="aeff3-201">On the next screen we're prompted for the SQL query to use, with the TableAdapter's default query pre-loaded.</span></span> <span data-ttu-id="aeff3-202">擴大現有的查詢，以包含子句 `WHERE ProductID = @ProductID`，如 [圖 10] 所示。</span><span class="sxs-lookup"><span data-stu-id="aeff3-202">Augment the existing query to include the clause `WHERE ProductID = @ProductID`, as shown in Figure 10.</span></span>

<span data-ttu-id="aeff3-203">[![將 WHERE 子句加入預先載入的查詢，以傳回特定的產品記錄](implementing-optimistic-concurrency-cs/_static/image29.png)](implementing-optimistic-concurrency-cs/_static/image28.png)</span><span class="sxs-lookup"><span data-stu-id="aeff3-203">[![Add a WHERE Clause to the Pre-Loaded Query to Return a Specific Product Record](implementing-optimistic-concurrency-cs/_static/image29.png)](implementing-optimistic-concurrency-cs/_static/image28.png)</span></span>

<span data-ttu-id="aeff3-204">**圖 10**：將 `WHERE` 子句新增至預先載入的查詢，以傳回特定的產品記錄（[按一下以查看完整大小的影像](implementing-optimistic-concurrency-cs/_static/image30.png)）</span><span class="sxs-lookup"><span data-stu-id="aeff3-204">**Figure 10**: Add a `WHERE` Clause to the Pre-Loaded Query to Return a Specific Product Record ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image30.png))</span></span>

<span data-ttu-id="aeff3-205">最後，將產生的方法名稱變更為 `FillByProductID` 並 `GetProductByProductID`。</span><span class="sxs-lookup"><span data-stu-id="aeff3-205">Finally, change the generated method names to `FillByProductID` and `GetProductByProductID`.</span></span>

<span data-ttu-id="aeff3-206">[![將方法重新命名為 FillByProductID 和 GetProductByProductID](implementing-optimistic-concurrency-cs/_static/image32.png)](implementing-optimistic-concurrency-cs/_static/image31.png)</span><span class="sxs-lookup"><span data-stu-id="aeff3-206">[![Rename the Methods to FillByProductID and GetProductByProductID](implementing-optimistic-concurrency-cs/_static/image32.png)](implementing-optimistic-concurrency-cs/_static/image31.png)</span></span>

<span data-ttu-id="aeff3-207">**圖 11**：將方法重新命名為 `FillByProductID` 和 `GetProductByProductID` （[按一下以查看完整大小的影像](implementing-optimistic-concurrency-cs/_static/image33.png)）</span><span class="sxs-lookup"><span data-stu-id="aeff3-207">**Figure 11**: Rename the Methods to `FillByProductID` and `GetProductByProductID` ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image33.png))</span></span>

<span data-ttu-id="aeff3-208">完成此嚮導之後，TableAdapter 現在會包含兩個用來抓取資料的方法： `GetProducts()`，它會傳回*所有*產品;和 `GetProductByProductID(productID)`，它會傳回指定的產品。</span><span class="sxs-lookup"><span data-stu-id="aeff3-208">With this wizard complete, the TableAdapter now contains two methods for retrieving data: `GetProducts()`, which returns *all* products; and `GetProductByProductID(productID)`, which returns the specified product.</span></span>

## <a name="step-3-creating-a-business-logic-layer-for-the-optimistic-concurrency-enabled-dal"></a><span data-ttu-id="aeff3-209">步驟3：為開放式平行存取啟用的 DAL 建立商務邏輯層</span><span class="sxs-lookup"><span data-stu-id="aeff3-209">Step 3: Creating a Business Logic Layer for the Optimistic Concurrency-Enabled DAL</span></span>

<span data-ttu-id="aeff3-210">我們現有的 `ProductsBLL` 類別具有同時使用批次更新和 DB 直接模式的範例。</span><span class="sxs-lookup"><span data-stu-id="aeff3-210">Our existing `ProductsBLL` class has examples of using both the batch update and DB direct patterns.</span></span> <span data-ttu-id="aeff3-211">`AddProduct` 方法和 `UpdateProduct` 多載都會使用批次更新模式，並將 `ProductRow` 實例傳入 TableAdapter 的 Update 方法。</span><span class="sxs-lookup"><span data-stu-id="aeff3-211">The `AddProduct` method and `UpdateProduct` overloads both use the batch update pattern, passing in a `ProductRow` instance to the TableAdapter's Update method.</span></span> <span data-ttu-id="aeff3-212">另一方面，`DeleteProduct` 方法會使用資料庫直接模式，呼叫 TableAdapter 的 `Delete(productID)` 方法。</span><span class="sxs-lookup"><span data-stu-id="aeff3-212">The `DeleteProduct` method, on the other hand, uses the DB direct pattern, calling the TableAdapter's `Delete(productID)` method.</span></span>

<span data-ttu-id="aeff3-213">有了新的 `ProductsOptimisticConcurrency` TableAdapter，DB 直接方法現在也需要傳入原始值。</span><span class="sxs-lookup"><span data-stu-id="aeff3-213">With the new `ProductsOptimisticConcurrency` TableAdapter, the DB direct methods now require that the original values also be passed in.</span></span> <span data-ttu-id="aeff3-214">例如，`Delete` 方法現在需要10個輸入參數：原始 `ProductID`、`ProductName`、`SupplierID`、`CategoryID`、`QuantityPerUnit`、`UnitPrice`、`UnitsInStock`、`UnitsOnOrder`、`ReorderLevel`和 `Discontinued`。</span><span class="sxs-lookup"><span data-stu-id="aeff3-214">For example, the `Delete` method now expects ten input parameters: the original `ProductID`, `ProductName`, `SupplierID`, `CategoryID`, `QuantityPerUnit`, `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, `ReorderLevel`, and `Discontinued`.</span></span> <span data-ttu-id="aeff3-215">它會在傳送至資料庫之 `DELETE` 語句的 `WHERE` 子句中使用這些額外的輸入參數值，只有在資料庫目前的值對應到原始的值時，才會刪除指定的記錄。</span><span class="sxs-lookup"><span data-stu-id="aeff3-215">It uses these additional input parameters' values in `WHERE` clause of the `DELETE` statement sent to the database, only deleting the specified record if the database's current values map up to the original ones.</span></span>

<span data-ttu-id="aeff3-216">雖然用於批次更新模式之 TableAdapter `Update` 方法的方法簽章未變更，但記錄原始和新值所需的程式碼具有。</span><span class="sxs-lookup"><span data-stu-id="aeff3-216">While the method signature for the TableAdapter's `Update` method used in the batch update pattern hasn't changed, the code needed to record the original and new values has.</span></span> <span data-ttu-id="aeff3-217">因此，讓我們建立新的商務邏輯層級，以使用新的 DAL，而不是嘗試將開放式平行存取的 DAL 用於現有的 `ProductsBLL` 類別。</span><span class="sxs-lookup"><span data-stu-id="aeff3-217">Therefore, rather than attempt to use the optimistic concurrency-enabled DAL with our existing `ProductsBLL` class, let's create a new Business Logic Layer class for working with our new DAL.</span></span>

<span data-ttu-id="aeff3-218">將名為 `ProductsOptimisticConcurrencyBLL` 的類別新增至 [`App_Code`] 資料夾內的 [`BLL`] 資料夾。</span><span class="sxs-lookup"><span data-stu-id="aeff3-218">Add a class named `ProductsOptimisticConcurrencyBLL` to the `BLL` folder within the `App_Code` folder.</span></span>

![將 ProductsOptimisticConcurrencyBLL 類別新增至 BLL 資料夾](implementing-optimistic-concurrency-cs/_static/image34.png)

<span data-ttu-id="aeff3-220">**圖 12**：將 `ProductsOptimisticConcurrencyBLL` 類別新增到 BLL 資料夾</span><span class="sxs-lookup"><span data-stu-id="aeff3-220">**Figure 12**: Add the `ProductsOptimisticConcurrencyBLL` Class to the BLL Folder</span></span>

<span data-ttu-id="aeff3-221">接下來，將下列程式碼新增至 `ProductsOptimisticConcurrencyBLL` 類別：</span><span class="sxs-lookup"><span data-stu-id="aeff3-221">Next, add the following code to the `ProductsOptimisticConcurrencyBLL` class:</span></span>

[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample5.cs)]

<span data-ttu-id="aeff3-222">請注意，在類別宣告的開頭使用 `NorthwindOptimisticConcurrencyTableAdapters` 語句。</span><span class="sxs-lookup"><span data-stu-id="aeff3-222">Note the using `NorthwindOptimisticConcurrencyTableAdapters` statement above the start of the class declaration.</span></span> <span data-ttu-id="aeff3-223">`NorthwindOptimisticConcurrencyTableAdapters` 命名空間包含 `ProductsOptimisticConcurrencyTableAdapter` 類別，它會提供 DAL 的方法。</span><span class="sxs-lookup"><span data-stu-id="aeff3-223">The `NorthwindOptimisticConcurrencyTableAdapters` namespace contains the `ProductsOptimisticConcurrencyTableAdapter` class, which provides the DAL's methods.</span></span> <span data-ttu-id="aeff3-224">此外，在類別宣告之前，您會發現 `System.ComponentModel.DataObject` 屬性，它會指示 Visual Studio 在 ObjectDataSource wizard 的下拉式清單中包含此類別。</span><span class="sxs-lookup"><span data-stu-id="aeff3-224">Also before the class declaration you'll find the `System.ComponentModel.DataObject` attribute, which instructs Visual Studio to include this class in the ObjectDataSource wizard's drop-down list.</span></span>

<span data-ttu-id="aeff3-225">`ProductsOptimisticConcurrencyBLL`的 `Adapter` 屬性可讓您快速存取 `ProductsOptimisticConcurrencyTableAdapter` 類別的實例，並遵循原始 BLL 類別（`ProductsBLL`、`CategoriesBLL`等等）中使用的模式。</span><span class="sxs-lookup"><span data-stu-id="aeff3-225">The `ProductsOptimisticConcurrencyBLL`'s `Adapter` property provides quick access to an instance of the `ProductsOptimisticConcurrencyTableAdapter` class, and follows the pattern used in our original BLL classes (`ProductsBLL`, `CategoriesBLL`, and so on).</span></span> <span data-ttu-id="aeff3-226">最後，`GetProducts()` 方法只會向下呼叫 DAL 的 `GetProducts()` 方法，並傳回針對資料庫中的每個產品記錄，填入 `ProductsOptimisticConcurrencyRow` 實例的 `ProductsOptimisticConcurrencyDataTable` 物件。</span><span class="sxs-lookup"><span data-stu-id="aeff3-226">Finally, the `GetProducts()` method simply calls down into the DAL's `GetProducts()` method and returns a `ProductsOptimisticConcurrencyDataTable` object populated with a `ProductsOptimisticConcurrencyRow` instance for each product record in the database.</span></span>

## <a name="deleting-a-product-using-the-db-direct-pattern-with-optimistic-concurrency"></a><span data-ttu-id="aeff3-227">使用資料庫直接模式與開放式平行存取來刪除產品</span><span class="sxs-lookup"><span data-stu-id="aeff3-227">Deleting a Product Using the DB Direct Pattern with Optimistic Concurrency</span></span>

<span data-ttu-id="aeff3-228">針對使用開放式平行存取的 DAL 使用 DB direct 模式時，必須將新的和原始值傳遞給這些方法。</span><span class="sxs-lookup"><span data-stu-id="aeff3-228">When using the DB direct pattern against a DAL that uses optimistic concurrency, the methods must be passed the new and original values.</span></span> <span data-ttu-id="aeff3-229">若要刪除，則不會有任何新的值，因此只需要傳入原始值。</span><span class="sxs-lookup"><span data-stu-id="aeff3-229">For deleting, there are no new values, so only the original values need be passed in.</span></span> <span data-ttu-id="aeff3-230">在 BLL 中，我們必須接受所有原始參數做為輸入參數。</span><span class="sxs-lookup"><span data-stu-id="aeff3-230">In our BLL, then, we must accept all of the original parameters as input parameters.</span></span> <span data-ttu-id="aeff3-231">讓我們在 `ProductsOptimisticConcurrencyBLL` 類別中的 `DeleteProduct` 方法使用 DB 直接方法。</span><span class="sxs-lookup"><span data-stu-id="aeff3-231">Let's have the `DeleteProduct` method in the `ProductsOptimisticConcurrencyBLL` class use the DB direct method.</span></span> <span data-ttu-id="aeff3-232">這表示此方法需要將所有十個產品資料欄位當做輸入參數，並將其傳遞給 DAL，如下列程式碼所示：</span><span class="sxs-lookup"><span data-stu-id="aeff3-232">This means that this method needs to take in all ten product data fields as input parameters, and pass these to the DAL, as shown in the following code:</span></span>

[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample6.cs)]

<span data-ttu-id="aeff3-233">如果原始值-最後載入 GridView （或 DetailsView 或 FormView）中的值，當使用者按一下 [刪除] 按鈕時，就會與資料庫中的值不同，`WHERE` 子句不會與任何資料庫記錄相符，而且不會影響任何記錄。</span><span class="sxs-lookup"><span data-stu-id="aeff3-233">If the original values - those values that were last loaded into the GridView (or DetailsView or FormView) - differ from the values in the database when the user clicks the Delete button the `WHERE` clause won't match up with any database record and no records will be affected.</span></span> <span data-ttu-id="aeff3-234">因此，TableAdapter 的 `Delete` 方法會傳回 `0`，而 BLL 的 `DeleteProduct` 方法將會傳回 `false`。</span><span class="sxs-lookup"><span data-stu-id="aeff3-234">Hence, the TableAdapter's `Delete` method will return `0` and the BLL's `DeleteProduct` method will return `false`.</span></span>

## <a name="updating-a-product-using-the-batch-update-pattern-with-optimistic-concurrency"></a><span data-ttu-id="aeff3-235">使用批次更新模式與開放式平行存取來更新產品</span><span class="sxs-lookup"><span data-stu-id="aeff3-235">Updating a Product Using the Batch Update Pattern with Optimistic Concurrency</span></span>

<span data-ttu-id="aeff3-236">如先前所述，不論是否採用開放式平行存取，適用于批次更新模式的 TableAdapter `Update` 方法都會有相同的方法簽章。</span><span class="sxs-lookup"><span data-stu-id="aeff3-236">As noted earlier, the TableAdapter's `Update` method for the batch update pattern has the same method signature regardless of whether or not optimistic concurrency is employed.</span></span> <span data-ttu-id="aeff3-237">也就是說，`Update` 方法需要 DataRow、Datarow 陣列、DataTable 或具類型資料集。</span><span class="sxs-lookup"><span data-stu-id="aeff3-237">Namely, the `Update` method expects a DataRow, an array of DataRows, a DataTable, or a Typed DataSet.</span></span> <span data-ttu-id="aeff3-238">沒有其他輸入參數可用於指定原始值。</span><span class="sxs-lookup"><span data-stu-id="aeff3-238">There are no additional input parameters for specifying the original values.</span></span> <span data-ttu-id="aeff3-239">這是可能的，因為 DataTable 會追蹤其 DataRow 的原始和修改值。</span><span class="sxs-lookup"><span data-stu-id="aeff3-239">This is possible because the DataTable keeps track of the original and modified values for its DataRow(s).</span></span> <span data-ttu-id="aeff3-240">當 DAL 發出其 `UPDATE` 語句時，`@original_ColumnName` 參數會填入 DataRow 的原始值，而 `@ColumnName` 參數則會填入 DataRow 的修改值。</span><span class="sxs-lookup"><span data-stu-id="aeff3-240">When the DAL issues its `UPDATE` statement, the `@original_ColumnName` parameters are populated with the DataRow's original values, whereas the `@ColumnName` parameters are populated with the DataRow's modified values.</span></span>

<span data-ttu-id="aeff3-241">在 `ProductsBLL` 類別（使用我們的原始非開放式平行存取 DAL）中，當使用批次更新模式來更新產品資訊時，我們的程式碼會執行下列一連串的事件：</span><span class="sxs-lookup"><span data-stu-id="aeff3-241">In the `ProductsBLL` class (which uses our original, non-optimistic concurrency DAL), when using the batch update pattern to update product information our code performs the following sequence of events:</span></span>

1. <span data-ttu-id="aeff3-242">使用 TableAdapter 的 `GetProductByProductID(productID)` 方法，將目前的資料庫產品資訊讀入 `ProductRow` 實例</span><span class="sxs-lookup"><span data-stu-id="aeff3-242">Read the current database product information into a `ProductRow` instance using the TableAdapter's `GetProductByProductID(productID)` method</span></span>
2. <span data-ttu-id="aeff3-243">將新值指派給步驟1中的 `ProductRow` 實例</span><span class="sxs-lookup"><span data-stu-id="aeff3-243">Assign the new values to the `ProductRow` instance from Step 1</span></span>
3. <span data-ttu-id="aeff3-244">呼叫 TableAdapter 的 `Update` 方法，傳入 `ProductRow` 實例</span><span class="sxs-lookup"><span data-stu-id="aeff3-244">Call the TableAdapter's `Update` method, passing in the `ProductRow` instance</span></span>

<span data-ttu-id="aeff3-245">不過，這一系列的步驟將不會正確支援開放式平行存取，因為在步驟1中填入的 `ProductRow` 會直接從資料庫填入，這表示 DataRow 所使用的原始值是目前存在於資料庫中，而不是在編輯程式開始時系結至 GridView 的資料。</span><span class="sxs-lookup"><span data-stu-id="aeff3-245">This sequence of steps, however, won't correctly support optimistic concurrency because the `ProductRow` populated in Step 1 is populated directly from the database, meaning that the original values used by the DataRow are those that currently exist in the database, and not those that were bound to the GridView at the start of the editing process.</span></span> <span data-ttu-id="aeff3-246">相反地，在使用開放式平行存取的 DAL 時，我們需要改變 `UpdateProduct` 方法多載，以使用下列步驟：</span><span class="sxs-lookup"><span data-stu-id="aeff3-246">Instead, when using an optimistic concurrency-enabled DAL, we need to alter the `UpdateProduct` method overloads to use the following steps:</span></span>

1. <span data-ttu-id="aeff3-247">使用 TableAdapter 的 `GetProductByProductID(productID)` 方法，將目前的資料庫產品資訊讀入 `ProductsOptimisticConcurrencyRow` 實例</span><span class="sxs-lookup"><span data-stu-id="aeff3-247">Read the current database product information into a `ProductsOptimisticConcurrencyRow` instance using the TableAdapter's `GetProductByProductID(productID)` method</span></span>
2. <span data-ttu-id="aeff3-248">將*原始*值指派給步驟1中的 `ProductsOptimisticConcurrencyRow` 實例</span><span class="sxs-lookup"><span data-stu-id="aeff3-248">Assign the *original* values to the `ProductsOptimisticConcurrencyRow` instance from Step 1</span></span>
3. <span data-ttu-id="aeff3-249">呼叫 `ProductsOptimisticConcurrencyRow` 實例的 `AcceptChanges()` 方法，指示 DataRow 其目前的值為「原始」</span><span class="sxs-lookup"><span data-stu-id="aeff3-249">Call the `ProductsOptimisticConcurrencyRow` instance's `AcceptChanges()` method, which instructs the DataRow that its current values are the "original" ones</span></span>
4. <span data-ttu-id="aeff3-250">將*新*值指派給 `ProductsOptimisticConcurrencyRow` 實例</span><span class="sxs-lookup"><span data-stu-id="aeff3-250">Assign the *new* values to the `ProductsOptimisticConcurrencyRow` instance</span></span>
5. <span data-ttu-id="aeff3-251">呼叫 TableAdapter 的 `Update` 方法，傳入 `ProductsOptimisticConcurrencyRow` 實例</span><span class="sxs-lookup"><span data-stu-id="aeff3-251">Call the TableAdapter's `Update` method, passing in the `ProductsOptimisticConcurrencyRow` instance</span></span>

<span data-ttu-id="aeff3-252">步驟1會針對指定的產品記錄，讀取所有目前的資料庫值。</span><span class="sxs-lookup"><span data-stu-id="aeff3-252">Step 1 reads in all of the current database values for the specified product record.</span></span> <span data-ttu-id="aeff3-253">這個步驟在 `UpdateProduct` 多載中是多餘的，會更新*所有*的產品資料行（因為在步驟2中會覆寫這些值），但對於那些只將資料行值子集當做輸入參數傳入的多載而言，是不可或缺的。</span><span class="sxs-lookup"><span data-stu-id="aeff3-253">This step is superfluous in the `UpdateProduct` overload that updates *all* of the product columns (as these values are overwritten in Step 2), but is essential for those overloads where only a subset of the column values are passed in as input parameters.</span></span> <span data-ttu-id="aeff3-254">將原始值指派給 `ProductsOptimisticConcurrencyRow` 實例之後，就會呼叫 `AcceptChanges()` 方法，這會將目前的 DataRow 值標示為要在 `UPDATE` 語句的 `@original_ColumnName` 參數中使用的原始值。</span><span class="sxs-lookup"><span data-stu-id="aeff3-254">Once the original values have been assigned to the `ProductsOptimisticConcurrencyRow` instance, the `AcceptChanges()` method is called, which marks the current DataRow values as the original values to be used in the `@original_ColumnName` parameters in the `UPDATE` statement.</span></span> <span data-ttu-id="aeff3-255">接下來，新的參數值會指派給 `ProductsOptimisticConcurrencyRow`，最後，會叫用 `Update` 方法，並傳入 DataRow。</span><span class="sxs-lookup"><span data-stu-id="aeff3-255">Next, the new parameter values are assigned to the `ProductsOptimisticConcurrencyRow` and, finally, the `Update` method is invoked, passing in the DataRow.</span></span>

<span data-ttu-id="aeff3-256">下列程式碼顯示接受所有產品資料欄位做為輸入參數的 `UpdateProduct` 多載。</span><span class="sxs-lookup"><span data-stu-id="aeff3-256">The following code shows the `UpdateProduct` overload that accepts all product data fields as input parameters.</span></span> <span data-ttu-id="aeff3-257">雖然此處未顯示，但本教學課程的下載中所包含的 `ProductsOptimisticConcurrencyBLL` 類別也包含 `UpdateProduct` 多載，只接受產品的名稱和價格做為輸入參數。</span><span class="sxs-lookup"><span data-stu-id="aeff3-257">While not shown here, the `ProductsOptimisticConcurrencyBLL` class included in the download for this tutorial also contains an `UpdateProduct` overload that accepts just the product's name and price as input parameters.</span></span>

[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample7.cs)]

## <a name="step-4-passing-the-original-and-new-values-from-the-aspnet-page-to-the-bll-methods"></a><span data-ttu-id="aeff3-258">步驟4：將 ASP.NET 網頁中的原始和新值傳遞給 BLL 方法</span><span class="sxs-lookup"><span data-stu-id="aeff3-258">Step 4: Passing the Original and New Values From the ASP.NET Page to the BLL Methods</span></span>

<span data-ttu-id="aeff3-259">當 DAL 和 BLL 完成後，剩下的工作就是建立一個 ASP.NET 網頁，它可以利用內建在系統中的開放式平行存取邏輯。</span><span class="sxs-lookup"><span data-stu-id="aeff3-259">With the DAL and BLL complete, all that remains is to create an ASP.NET page that can utilize the optimistic concurrency logic built in to the system.</span></span> <span data-ttu-id="aeff3-260">具體而言，資料 Web 控制項（GridView、DetailsView 或 FormView）必須記住其原始值，而 ObjectDataSource 必須將這兩組值傳遞給商務邏輯層。</span><span class="sxs-lookup"><span data-stu-id="aeff3-260">Specifically, the data Web control (the GridView, DetailsView, or FormView) must remember its original values and the ObjectDataSource must pass both sets of values to the Business Logic Layer.</span></span> <span data-ttu-id="aeff3-261">此外，ASP.NET 網頁必須設定為適當地處理並行違規。</span><span class="sxs-lookup"><span data-stu-id="aeff3-261">Furthermore, the ASP.NET page must be configured to gracefully handle concurrency violations.</span></span>

<span data-ttu-id="aeff3-262">一開始先開啟 [`EditInsertDelete`] 資料夾中的 [`OptimisticConcurrency.aspx`] 頁面，並將 GridView 新增至設計工具，將其 `ID` 屬性設定為 [`ProductsGrid`]。</span><span class="sxs-lookup"><span data-stu-id="aeff3-262">Start by opening the `OptimisticConcurrency.aspx` page in the `EditInsertDelete` folder and adding a GridView to the Designer, setting its `ID` property to `ProductsGrid`.</span></span> <span data-ttu-id="aeff3-263">從 GridView 的智慧標籤中，選擇建立名為 `ProductsOptimisticConcurrencyDataSource`的新 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="aeff3-263">From the GridView's smart tag, opt to create a new ObjectDataSource named `ProductsOptimisticConcurrencyDataSource`.</span></span> <span data-ttu-id="aeff3-264">因為我們想要讓此 ObjectDataSource 使用支援開放式平行存取的 DAL，請將它設定為使用 `ProductsOptimisticConcurrencyBLL` 物件。</span><span class="sxs-lookup"><span data-stu-id="aeff3-264">Since we want this ObjectDataSource to use the DAL that supports optimistic concurrency, configure it to use the `ProductsOptimisticConcurrencyBLL` object.</span></span>

<span data-ttu-id="aeff3-265">[![讓 ObjectDataSource 使用 ProductsOptimisticConcurrencyBLL 物件](implementing-optimistic-concurrency-cs/_static/image36.png)](implementing-optimistic-concurrency-cs/_static/image35.png)</span><span class="sxs-lookup"><span data-stu-id="aeff3-265">[![Have the ObjectDataSource Use the ProductsOptimisticConcurrencyBLL Object](implementing-optimistic-concurrency-cs/_static/image36.png)](implementing-optimistic-concurrency-cs/_static/image35.png)</span></span>

<span data-ttu-id="aeff3-266">**圖 13**：讓 ObjectDataSource 使用 `ProductsOptimisticConcurrencyBLL` 物件（[按一下以觀看完整大小的影像](implementing-optimistic-concurrency-cs/_static/image37.png)）</span><span class="sxs-lookup"><span data-stu-id="aeff3-266">**Figure 13**: Have the ObjectDataSource Use the `ProductsOptimisticConcurrencyBLL` Object ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image37.png))</span></span>

<span data-ttu-id="aeff3-267">從 wizard 的下拉式清單中選擇 [`GetProducts`]、[`UpdateProduct`] 和 [`DeleteProduct`] 方法。</span><span class="sxs-lookup"><span data-stu-id="aeff3-267">Choose the `GetProducts`, `UpdateProduct`, and `DeleteProduct` methods from drop-down lists in the wizard.</span></span> <span data-ttu-id="aeff3-268">針對 UpdateProduct 方法，使用接受所有產品資料欄位的多載。</span><span class="sxs-lookup"><span data-stu-id="aeff3-268">For the UpdateProduct method, use the overload that accepts all of the product's data fields.</span></span>

## <a name="configuring-the-objectdatasource-controls-properties"></a><span data-ttu-id="aeff3-269">設定 ObjectDataSource 控制項的屬性</span><span class="sxs-lookup"><span data-stu-id="aeff3-269">Configuring the ObjectDataSource Control's Properties</span></span>

<span data-ttu-id="aeff3-270">完成 wizard 之後，ObjectDataSource 的宣告式標記看起來應該如下所示：</span><span class="sxs-lookup"><span data-stu-id="aeff3-270">After completing the wizard, the ObjectDataSource's declarative markup should look like the following:</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample8.aspx)]

<span data-ttu-id="aeff3-271">如您所見，`DeleteParameters` 集合在 `ProductsOptimisticConcurrencyBLL` 類別的 `DeleteProduct` 方法中，包含10個輸入參數的 `Parameter` 實例。</span><span class="sxs-lookup"><span data-stu-id="aeff3-271">As you can see, the `DeleteParameters` collection contains a `Parameter` instance for each of the ten input parameters in the `ProductsOptimisticConcurrencyBLL` class's `DeleteProduct` method.</span></span> <span data-ttu-id="aeff3-272">同樣地，`UpdateParameters` 集合會針對 `UpdateProduct`中的每個輸入參數包含 `Parameter` 實例。</span><span class="sxs-lookup"><span data-stu-id="aeff3-272">Likewise, the `UpdateParameters` collection contains a `Parameter` instance for each of the input parameters in `UpdateProduct`.</span></span>

<span data-ttu-id="aeff3-273">對於牽涉到資料修改的前述教學課程，我們會在此時移除 ObjectDataSource 的 `OldValuesParameterFormatString` 屬性，因為此屬性指出 BLL 方法預期會傳入舊的（或原始）值，以及新的值。</span><span class="sxs-lookup"><span data-stu-id="aeff3-273">For those previous tutorials that involved data modification, we'd remove the ObjectDataSource's `OldValuesParameterFormatString` property at this point, since this property indicates that the BLL method expects the old (or original) values to be passed in as well as the new values.</span></span> <span data-ttu-id="aeff3-274">此外，此屬性值也會指出原始值的輸入參數名稱。</span><span class="sxs-lookup"><span data-stu-id="aeff3-274">Furthermore, this property value indicates the input parameter names for the original values.</span></span> <span data-ttu-id="aeff3-275">因為我們會將原始值傳入 BLL，*請勿移除此*屬性。</span><span class="sxs-lookup"><span data-stu-id="aeff3-275">Since we are passing in the original values into the BLL, do *not* remove this property.</span></span>

> [!NOTE]
> <span data-ttu-id="aeff3-276">`OldValuesParameterFormatString` 屬性的值必須對應到需要原始值之 BLL 中的輸入參數名稱。</span><span class="sxs-lookup"><span data-stu-id="aeff3-276">The value of the `OldValuesParameterFormatString` property must map to the input parameter names in the BLL that expect the original values.</span></span> <span data-ttu-id="aeff3-277">因為我們將這些參數命名 `original_productName`、`original_supplierID`等等，所以您可以將 `OldValuesParameterFormatString` 屬性值保留為 `original_{0}`。</span><span class="sxs-lookup"><span data-stu-id="aeff3-277">Since we named these parameters `original_productName`, `original_supplierID`, and so on, you can leave the `OldValuesParameterFormatString` property value as `original_{0}`.</span></span> <span data-ttu-id="aeff3-278">不過，如果 BLL 方法的輸入參數具有如 `old_productName`、`old_supplierID`等等的名稱，您就必須將 `OldValuesParameterFormatString` 屬性更新為 `old_{0}`。</span><span class="sxs-lookup"><span data-stu-id="aeff3-278">If, however, the BLL methods' input parameters had names like `old_productName`, `old_supplierID`, and so on, you'd need to update the `OldValuesParameterFormatString` property to `old_{0}`.</span></span>

<span data-ttu-id="aeff3-279">有一個最後的屬性設定需要進行，才能讓 ObjectDataSource 正確地將原始值傳遞給 BLL 方法。</span><span class="sxs-lookup"><span data-stu-id="aeff3-279">There's one final property setting that needs to be made in order for the ObjectDataSource to correctly pass the original values to the BLL methods.</span></span> <span data-ttu-id="aeff3-280">ObjectDataSource 具有[ConflictDetection 屬性](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.conflictdetection.aspx)，可指派給[兩個值的其中一個](https://msdn.microsoft.com/library/system.web.ui.conflictoptions.aspx)：</span><span class="sxs-lookup"><span data-stu-id="aeff3-280">The ObjectDataSource has a [ConflictDetection property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.conflictdetection.aspx) that can be assigned to [one of two values](https://msdn.microsoft.com/library/system.web.ui.conflictoptions.aspx):</span></span>

- <span data-ttu-id="aeff3-281">`OverwriteChanges`-預設值;不會將原始值傳送給 BLL 方法的原始輸入參數</span><span class="sxs-lookup"><span data-stu-id="aeff3-281">`OverwriteChanges` - the default value; does not send the original values to the BLL methods' original input parameters</span></span>
- <span data-ttu-id="aeff3-282">`CompareAllValues`-會將原始值傳送給 BLL 方法;使用開放式平行存取時，請選擇此選項</span><span class="sxs-lookup"><span data-stu-id="aeff3-282">`CompareAllValues` - does send the original values to the BLL methods; choose this option when using optimistic concurrency</span></span>

<span data-ttu-id="aeff3-283">請花點時間將 `ConflictDetection` 屬性設為 `CompareAllValues`。</span><span class="sxs-lookup"><span data-stu-id="aeff3-283">Take a moment to set the `ConflictDetection` property to `CompareAllValues`.</span></span>

## <a name="configuring-the-gridviews-properties-and-fields"></a><span data-ttu-id="aeff3-284">設定 GridView 的屬性和欄位</span><span class="sxs-lookup"><span data-stu-id="aeff3-284">Configuring the GridView's Properties and Fields</span></span>

<span data-ttu-id="aeff3-285">已正確設定 ObjectDataSource 的屬性後，讓我們將注意力轉變成設定 GridView。</span><span class="sxs-lookup"><span data-stu-id="aeff3-285">With the ObjectDataSource's properties properly configured, let's turn our attention to setting up the GridView.</span></span> <span data-ttu-id="aeff3-286">首先，因為我們想要 GridView 支援編輯和刪除，請按一下 [啟用編輯]，然後從 GridView 的智慧標籤中啟用 [刪除] 核取方塊。</span><span class="sxs-lookup"><span data-stu-id="aeff3-286">First, since we want the GridView to support editing and deleting, click the Enable Editing and Enable Deleting checkboxes from the GridView's smart tag.</span></span> <span data-ttu-id="aeff3-287">這會加入 CommandField，其 `ShowEditButton` 和 `ShowDeleteButton` 皆設定為 `true`。</span><span class="sxs-lookup"><span data-stu-id="aeff3-287">This will add a CommandField whose `ShowEditButton` and `ShowDeleteButton` are both set to `true`.</span></span>

<span data-ttu-id="aeff3-288">當系結至 `ProductsOptimisticConcurrencyDataSource` ObjectDataSource 時，GridView 會針對每個產品的資料欄位包含一個欄位。</span><span class="sxs-lookup"><span data-stu-id="aeff3-288">When bound to the `ProductsOptimisticConcurrencyDataSource` ObjectDataSource, the GridView contains a field for each of the product's data fields.</span></span> <span data-ttu-id="aeff3-289">雖然這種 GridView 可以進行編輯，但使用者體驗卻是可接受的。</span><span class="sxs-lookup"><span data-stu-id="aeff3-289">While such a GridView can be edited, the user experience is anything but acceptable.</span></span> <span data-ttu-id="aeff3-290">`CategoryID` 和 `SupplierID` BoundFields 會轉譯成文字方塊，要求使用者輸入適當的類別和供應商做為識別碼編號。</span><span class="sxs-lookup"><span data-stu-id="aeff3-290">The `CategoryID` and `SupplierID` BoundFields will render as TextBoxes, requiring the user to enter the appropriate category and supplier as ID numbers.</span></span> <span data-ttu-id="aeff3-291">數值欄位不會有任何格式，而且沒有驗證控制項可確保已提供產品的名稱，而且單價、庫存單位、依訂單的單位和重新排序層級值都是正確的數值，而且大於或等於為零。</span><span class="sxs-lookup"><span data-stu-id="aeff3-291">There will be no formatting for the numeric fields and no validation controls to ensure that the product's name has been supplied and that the unit price, units in stock, units on order, and reorder level values are both proper numeric values and are greater than or equal to zero.</span></span>

<span data-ttu-id="aeff3-292">如我們在將*驗證控制項新增至編輯和插入介面*和*自訂資料修改介面*教學課程中所述，您可以使用 TemplateFields 取代 BoundFields 來自訂使用者介面。</span><span class="sxs-lookup"><span data-stu-id="aeff3-292">As we discussed in the *Adding Validation Controls to the Editing and Inserting Interfaces* and *Customizing the Data Modification Interface* tutorials, the user interface can be customized by replacing the BoundFields with TemplateFields.</span></span> <span data-ttu-id="aeff3-293">我已經用下列方式修改了這個 GridView 和其編輯介面：</span><span class="sxs-lookup"><span data-stu-id="aeff3-293">I've modified this GridView and its editing interface in the following ways:</span></span>

- <span data-ttu-id="aeff3-294">已移除 `ProductID`、`SupplierName`和 `CategoryName` BoundFields</span><span class="sxs-lookup"><span data-stu-id="aeff3-294">Removed the `ProductID`, `SupplierName`, and `CategoryName` BoundFields</span></span>
- <span data-ttu-id="aeff3-295">將 `ProductName` BoundField 轉換成 TemplateField，並新增 RequiredFieldValidation 控制項。</span><span class="sxs-lookup"><span data-stu-id="aeff3-295">Converted the `ProductName` BoundField to a TemplateField and added a RequiredFieldValidation control.</span></span>
- <span data-ttu-id="aeff3-296">將 `CategoryID` 和 `SupplierID` BoundFields 轉換為 TemplateFields，並將編輯介面調整為使用 Dropdownlist 進行，而不是文字方塊。</span><span class="sxs-lookup"><span data-stu-id="aeff3-296">Converted the `CategoryID` and `SupplierID` BoundFields to TemplateFields, and adjusted the editing interface to use DropDownLists rather than TextBoxes.</span></span> <span data-ttu-id="aeff3-297">在這些 TemplateFields 的 `ItemTemplates`中，會顯示 `CategoryName` 和 `SupplierName` 資料欄位。</span><span class="sxs-lookup"><span data-stu-id="aeff3-297">In these TemplateFields' `ItemTemplates`, the `CategoryName` and `SupplierName` data fields are displayed.</span></span>
- <span data-ttu-id="aeff3-298">已將 `UnitPrice`、`UnitsInStock`、`UnitsOnOrder`和 `ReorderLevel` BoundFields 轉換成 TemplateFields，並新增 CompareValidator 控制項。</span><span class="sxs-lookup"><span data-stu-id="aeff3-298">Converted the `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, and `ReorderLevel` BoundFields to TemplateFields and added CompareValidator controls.</span></span>

<span data-ttu-id="aeff3-299">由於我們已在先前的教學課程中檢查如何完成這些工作，因此我只會在此列出最終的宣告式語法，並將實作為實務。</span><span class="sxs-lookup"><span data-stu-id="aeff3-299">Since we've already examined how to accomplish these tasks in previous tutorials, I'll just list the final declarative syntax here and leave the implementation as practice.</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample9.aspx)]

<span data-ttu-id="aeff3-300">我們非常接近完整的範例。</span><span class="sxs-lookup"><span data-stu-id="aeff3-300">We're very close to having a fully-working example.</span></span> <span data-ttu-id="aeff3-301">不過，有幾個微妙差異將會蔓延，並造成我們的問題。</span><span class="sxs-lookup"><span data-stu-id="aeff3-301">However, there are a few subtleties that will creep up and cause us problems.</span></span> <span data-ttu-id="aeff3-302">此外，我們還需要一些介面，在發生並行違規時警示使用者。</span><span class="sxs-lookup"><span data-stu-id="aeff3-302">Additionally, we still need some interface that alerts the user when a concurrency violation has occurred.</span></span>

> [!NOTE]
> <span data-ttu-id="aeff3-303">為了讓資料 Web 控制項正確地將原始值傳遞給 ObjectDataSource （然後傳遞給 BLL），請務必將 GridView 的 `EnableViewState` 屬性設定為 `true` （預設值）。</span><span class="sxs-lookup"><span data-stu-id="aeff3-303">In order for a data Web control to correctly pass the original values to the ObjectDataSource (which are then passed to the BLL), it's vital that the GridView's `EnableViewState` property is set to `true` (the default).</span></span> <span data-ttu-id="aeff3-304">如果您停用 view 狀態，則在回傳時，原始值會遺失。</span><span class="sxs-lookup"><span data-stu-id="aeff3-304">If you disable view state, the original values are lost on postback.</span></span>

## <a name="passing-the-correct-original-values-to-the-objectdatasource"></a><span data-ttu-id="aeff3-305">將正確的原始值傳遞至 ObjectDataSource</span><span class="sxs-lookup"><span data-stu-id="aeff3-305">Passing the Correct Original Values to the ObjectDataSource</span></span>

<span data-ttu-id="aeff3-306">設定 GridView 的方式有幾個問題。</span><span class="sxs-lookup"><span data-stu-id="aeff3-306">There are a couple of problems with the way the GridView has been configured.</span></span> <span data-ttu-id="aeff3-307">如果 ObjectDataSource 的 `ConflictDetection` 屬性設定為 `CompareAllValues` （如我們所示），則由 GridView （或 DetailsView 或 FormView）叫用 ObjectDataSource 的 `Update()` 或 `Delete()` 方法時，ObjectDataSource 會嘗試將 GridView 的原始值複製到其適當的 `Parameter` 實例。</span><span class="sxs-lookup"><span data-stu-id="aeff3-307">If the ObjectDataSource's `ConflictDetection` property is set to `CompareAllValues` (as is ours), when the ObjectDataSource's `Update()` or `Delete()` methods are invoked by the GridView (or DetailsView or FormView), the ObjectDataSource attempts to copy the GridView's original values into its appropriate `Parameter` instances.</span></span> <span data-ttu-id="aeff3-308">如需此程式的圖形表示，請回頭參閱 [圖 2]。</span><span class="sxs-lookup"><span data-stu-id="aeff3-308">Refer back to Figure 2 for a graphical representation of this process.</span></span>

<span data-ttu-id="aeff3-309">具體而言，在每次資料系結至 GridView 時，GridView 的原始值都會指派給雙向資料系結語句中的值。</span><span class="sxs-lookup"><span data-stu-id="aeff3-309">Specifically, the GridView's original values are assigned the values in the two-way databinding statements each time the data is bound to the GridView.</span></span> <span data-ttu-id="aeff3-310">因此，所有必要的原始值都必須透過雙向資料系結來捕捉，而且是以可轉換的格式提供。</span><span class="sxs-lookup"><span data-stu-id="aeff3-310">Therefore, it's essential that the required original values all are captured via two-way databinding and that they are provided in a convertible format.</span></span>

<span data-ttu-id="aeff3-311">若要查看這是很重要的原因，請花一點時間造訪瀏覽器中的頁面。</span><span class="sxs-lookup"><span data-stu-id="aeff3-311">To see why this is important, take a moment to visit our page in a browser.</span></span> <span data-ttu-id="aeff3-312">如預期，GridView 會在最左邊的資料行中，使用 [編輯] 和 [刪除] 按鈕來列出每個產品。</span><span class="sxs-lookup"><span data-stu-id="aeff3-312">As expected, the GridView lists each product with an Edit and Delete button in the leftmost column.</span></span>

<span data-ttu-id="aeff3-313">[![在 GridView 中列出產品](implementing-optimistic-concurrency-cs/_static/image39.png)](implementing-optimistic-concurrency-cs/_static/image38.png)</span><span class="sxs-lookup"><span data-stu-id="aeff3-313">[![The Products are Listed in a GridView](implementing-optimistic-concurrency-cs/_static/image39.png)](implementing-optimistic-concurrency-cs/_static/image38.png)</span></span>

<span data-ttu-id="aeff3-314">**圖 14**：產品會列在 GridView 中（[按一下以觀看完整大小的影像](implementing-optimistic-concurrency-cs/_static/image40.png)）</span><span class="sxs-lookup"><span data-stu-id="aeff3-314">**Figure 14**: The Products are Listed in a GridView ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image40.png))</span></span>

<span data-ttu-id="aeff3-315">如果您按一下任何產品的 [刪除] 按鈕，則會擲回 `FormatException`。</span><span class="sxs-lookup"><span data-stu-id="aeff3-315">If you click the Delete button for any product, a `FormatException` is thrown.</span></span>

<span data-ttu-id="aeff3-316">[![嘗試刪除 FormatException 中的任何產品結果](implementing-optimistic-concurrency-cs/_static/image42.png)](implementing-optimistic-concurrency-cs/_static/image41.png)</span><span class="sxs-lookup"><span data-stu-id="aeff3-316">[![Attempting to Delete Any Product Results in a FormatException](implementing-optimistic-concurrency-cs/_static/image42.png)](implementing-optimistic-concurrency-cs/_static/image41.png)</span></span>

<span data-ttu-id="aeff3-317">**圖 15**：嘗試刪除 `FormatException` 中的任何產品結果（[按一下以觀看完整大小的影像](implementing-optimistic-concurrency-cs/_static/image43.png)）</span><span class="sxs-lookup"><span data-stu-id="aeff3-317">**Figure 15**: Attempting to Delete Any Product Results in a `FormatException` ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image43.png))</span></span>

<span data-ttu-id="aeff3-318">當 ObjectDataSource 嘗試讀取原始 `UnitPrice` 值時，就會引發 `FormatException`。</span><span class="sxs-lookup"><span data-stu-id="aeff3-318">The `FormatException` is raised when the ObjectDataSource attempts to read in the original `UnitPrice` value.</span></span> <span data-ttu-id="aeff3-319">由於 `ItemTemplate` 的 `UnitPrice` 會格式化為貨幣（`<%# Bind("UnitPrice", "{0:C}") %>`），因此它會包含貨幣符號，例如 $19.95。</span><span class="sxs-lookup"><span data-stu-id="aeff3-319">Since the `ItemTemplate` has the `UnitPrice` formatted as a currency (`<%# Bind("UnitPrice", "{0:C}") %>`), it includes a currency symbol, like $19.95.</span></span> <span data-ttu-id="aeff3-320">當 ObjectDataSource 嘗試將這個字串轉換成 `decimal`時，就會發生 `FormatException`。</span><span class="sxs-lookup"><span data-stu-id="aeff3-320">The `FormatException` occurs as the ObjectDataSource attempts to convert this string into a `decimal`.</span></span> <span data-ttu-id="aeff3-321">為了避免這個問題，我們有幾個選項：</span><span class="sxs-lookup"><span data-stu-id="aeff3-321">To circumvent this problem, we have a number of options:</span></span>

- <span data-ttu-id="aeff3-322">從 `ItemTemplate`中移除貨幣格式。</span><span class="sxs-lookup"><span data-stu-id="aeff3-322">Remove the currency formatting from the `ItemTemplate`.</span></span> <span data-ttu-id="aeff3-323">也就是說，而不是使用 `<%# Bind("UnitPrice", "{0:C}") %>`，而是只使用 `<%# Bind("UnitPrice") %>`。</span><span class="sxs-lookup"><span data-stu-id="aeff3-323">That is, instead of using `<%# Bind("UnitPrice", "{0:C}") %>`, simply use `<%# Bind("UnitPrice") %>`.</span></span> <span data-ttu-id="aeff3-324">其缺點在於價格已不再格式化。</span><span class="sxs-lookup"><span data-stu-id="aeff3-324">The downside of this is that the price is no longer formatted.</span></span>
- <span data-ttu-id="aeff3-325">在 `ItemTemplate`中顯示格式化為貨幣的 `UnitPrice`，但使用 `Eval` 關鍵字來完成這項操作。</span><span class="sxs-lookup"><span data-stu-id="aeff3-325">Display the `UnitPrice` formatted as a currency in the `ItemTemplate`, but use the `Eval` keyword to accomplish this.</span></span> <span data-ttu-id="aeff3-326">回想一下，`Eval` 會執行單向資料系結。</span><span class="sxs-lookup"><span data-stu-id="aeff3-326">Recall that `Eval` performs one-way databinding.</span></span> <span data-ttu-id="aeff3-327">我們仍然需要提供原始值的 `UnitPrice` 值，因此在 `ItemTemplate`中仍然需要雙向資料系結語句，但這可以放在 `Visible` 屬性設定為 `false`的標籤 Web 控制項中。</span><span class="sxs-lookup"><span data-stu-id="aeff3-327">We still need to provide the `UnitPrice` value for the original values, so we'll still need a two-way databinding statement in the `ItemTemplate`, but this can be placed in a Label Web control whose `Visible` property is set to `false`.</span></span> <span data-ttu-id="aeff3-328">我們可以在 ItemTemplate 中使用下列標記：</span><span class="sxs-lookup"><span data-stu-id="aeff3-328">We could use the following markup in the ItemTemplate:</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample10.aspx)]

- <span data-ttu-id="aeff3-329">使用 `<%# Bind("UnitPrice") %>`從 `ItemTemplate`移除貨幣格式。</span><span class="sxs-lookup"><span data-stu-id="aeff3-329">Remove the currency formatting from the `ItemTemplate`, using `<%# Bind("UnitPrice") %>`.</span></span> <span data-ttu-id="aeff3-330">在 GridView 的 `RowDataBound` 事件處理常式中，以程式設計方式存取顯示 `UnitPrice` 值的標籤 Web 控制項，並將其 `Text` 屬性設定為格式化版本。</span><span class="sxs-lookup"><span data-stu-id="aeff3-330">In the GridView's `RowDataBound` event handler, programmatically access the Label Web control within which the `UnitPrice` value is displayed and set its `Text` property to the formatted version.</span></span>
- <span data-ttu-id="aeff3-331">將 `UnitPrice` 保留為貨幣格式。</span><span class="sxs-lookup"><span data-stu-id="aeff3-331">Leave the `UnitPrice` formatted as a currency.</span></span> <span data-ttu-id="aeff3-332">在 GridView 的 `RowDeleting` 事件處理常式中，使用 `Decimal.Parse`，將現有的原始 `UnitPrice` 值（$19.95）取代為實際的十進位值。</span><span class="sxs-lookup"><span data-stu-id="aeff3-332">In the GridView's `RowDeleting` event handler, replace the existing original `UnitPrice` value ($19.95) with an actual decimal value using `Decimal.Parse`.</span></span> <span data-ttu-id="aeff3-333">我們已瞭解如何在 ASP.NET 網頁教學課程中[*處理 BLL 和 DAL 層級的例外*](handling-bll-and-dal-level-exceptions-in-an-asp-net-page-cs.md)狀況，以在 `RowUpdating` 事件處理常式中完成類似的作業。</span><span class="sxs-lookup"><span data-stu-id="aeff3-333">We saw how to accomplish something similar in the `RowUpdating` event handler in the [*Handling BLL- and DAL-Level Exceptions in an ASP.NET Page*](handling-bll-and-dal-level-exceptions-in-an-asp-net-page-cs.md) tutorial.</span></span>

<span data-ttu-id="aeff3-334">在我的範例中，我選擇使用第二個方法，加入隱藏的標籤 Web 控制項，其 `Text` 屬性是系結至未格式化 `UnitPrice` 值的雙向資料。</span><span class="sxs-lookup"><span data-stu-id="aeff3-334">For my example I chose to go with the second approach, adding a hidden Label Web control whose `Text` property is two-way data bound to the unformatted `UnitPrice` value.</span></span>

<span data-ttu-id="aeff3-335">解決此問題之後，請再次嘗試按一下任何產品的 [刪除] 按鈕。</span><span class="sxs-lookup"><span data-stu-id="aeff3-335">After solving this problem, try clicking the Delete button for any product again.</span></span> <span data-ttu-id="aeff3-336">這次當 ObjectDataSource 嘗試叫用 BLL 的 `UpdateProduct` 方法時，您會收到 `InvalidOperationException`。</span><span class="sxs-lookup"><span data-stu-id="aeff3-336">This time you'll get an `InvalidOperationException` when the ObjectDataSource attempts to invoke the BLL's `UpdateProduct` method.</span></span>

<span data-ttu-id="aeff3-337">[![ObjectDataSource 找不到具有所要傳送之輸入參數的方法](implementing-optimistic-concurrency-cs/_static/image45.png)](implementing-optimistic-concurrency-cs/_static/image44.png)</span><span class="sxs-lookup"><span data-stu-id="aeff3-337">[![The ObjectDataSource Cannot Find a Method with the Input Parameters it Wants to Send](implementing-optimistic-concurrency-cs/_static/image45.png)](implementing-optimistic-concurrency-cs/_static/image44.png)</span></span>

<span data-ttu-id="aeff3-338">**圖 16**： ObjectDataSource 找不到具有所要傳送之輸入參數的方法（[按一下以查看完整大小的影像](implementing-optimistic-concurrency-cs/_static/image46.png)）</span><span class="sxs-lookup"><span data-stu-id="aeff3-338">**Figure 16**: The ObjectDataSource Cannot Find a Method with the Input Parameters it Wants to Send ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image46.png))</span></span>

<span data-ttu-id="aeff3-339">查看例外狀況的訊息，可以清楚的是，ObjectDataSource 想要叫用具有 `original_CategoryName` 和 `original_SupplierName` 輸入參數的 BLL `DeleteProduct` 方法。</span><span class="sxs-lookup"><span data-stu-id="aeff3-339">Looking at the exception's message, it's clear that the ObjectDataSource wants to invoke a BLL `DeleteProduct` method that includes `original_CategoryName` and `original_SupplierName` input parameters.</span></span> <span data-ttu-id="aeff3-340">這是因為 `CategoryID` 和 `SupplierID` TemplateFields 的 `ItemTemplate` 目前包含具有 `CategoryName` 和 `SupplierName` 資料欄位的雙向 Bind 語句。</span><span class="sxs-lookup"><span data-stu-id="aeff3-340">This is because the `ItemTemplate` s for the `CategoryID` and `SupplierID` TemplateFields currently contain two-way Bind statements with the `CategoryName` and `SupplierName` data fields.</span></span> <span data-ttu-id="aeff3-341">相反地，我們需要在 `CategoryID` 和 `SupplierID` 資料欄位中包含 `Bind` 語句。</span><span class="sxs-lookup"><span data-stu-id="aeff3-341">Instead, we need to include `Bind` statements with the `CategoryID` and `SupplierID` data fields.</span></span> <span data-ttu-id="aeff3-342">若要完成此動作，請使用 `Eval` 語句來取代現有的 Bind 語句，然後加入隱藏的標籤控制項，其 `Text` 屬性會使用雙向資料系結系結至 `CategoryID` 和 `SupplierID` 資料欄位，如下所示：</span><span class="sxs-lookup"><span data-stu-id="aeff3-342">To accomplish this, replace the existing Bind statements with `Eval` statements, and then add hidden Label controls whose `Text` properties are bound to the `CategoryID` and `SupplierID` data fields using two-way databinding, as shown below:</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample11.aspx)]

<span data-ttu-id="aeff3-343">有了這些變更，我們現在可以成功刪除和編輯產品資訊！</span><span class="sxs-lookup"><span data-stu-id="aeff3-343">With these changes, we are now able to successfully delete and edit product information!</span></span> <span data-ttu-id="aeff3-344">在步驟5中，我們將探討如何確認偵測到並行違規。</span><span class="sxs-lookup"><span data-stu-id="aeff3-344">In Step 5 we'll look at how to verify that concurrency violations are being detected.</span></span> <span data-ttu-id="aeff3-345">但現在，請花幾分鐘的時間來嘗試更新和刪除一些記錄，以確保單一使用者的更新和刪除作業如預期般運作。</span><span class="sxs-lookup"><span data-stu-id="aeff3-345">But for now, take a few minutes to try updating and deleting a few records to ensure that updating and deleting for a single user works as expected.</span></span>

## <a name="step-5-testing-the-optimistic-concurrency-support"></a><span data-ttu-id="aeff3-346">步驟5：測試開放式平行存取支援</span><span class="sxs-lookup"><span data-stu-id="aeff3-346">Step 5: Testing the Optimistic Concurrency Support</span></span>

<span data-ttu-id="aeff3-347">為了確認偵測到並行違規（而不是造成資料被盲目覆寫），我們需要在此頁面開啟兩個瀏覽器視窗。</span><span class="sxs-lookup"><span data-stu-id="aeff3-347">In order to verify that concurrency violations are being detected (rather than resulting in data being blindly overwritten), we need to open two browser windows to this page.</span></span> <span data-ttu-id="aeff3-348">在這兩個瀏覽器實例中，按一下 [Chai] 的 [編輯] 按鈕。</span><span class="sxs-lookup"><span data-stu-id="aeff3-348">In both browser instances, click on the Edit button for Chai.</span></span> <span data-ttu-id="aeff3-349">然後，只在其中一個瀏覽器中，將名稱變更為 "Chai 茶"，然後按一下 [更新]。</span><span class="sxs-lookup"><span data-stu-id="aeff3-349">Then, in just one of the browsers, change the name to "Chai Tea" and click Update.</span></span> <span data-ttu-id="aeff3-350">更新應會成功，並將 GridView 還原為其預先編輯狀態，並以 "Chai 茶" 作為新的產品名稱。</span><span class="sxs-lookup"><span data-stu-id="aeff3-350">The update should succeed and return the GridView to its pre-editing state, with "Chai Tea" as the new product name.</span></span>

<span data-ttu-id="aeff3-351">不過，在另一個瀏覽器視窗實例中，[產品名稱] 文字方塊仍會顯示 "Chai"。</span><span class="sxs-lookup"><span data-stu-id="aeff3-351">In the other browser window instance, however, the product name TextBox still shows "Chai".</span></span> <span data-ttu-id="aeff3-352">在第二個瀏覽器視窗中，將 `UnitPrice` 更新為 `25.00`。</span><span class="sxs-lookup"><span data-stu-id="aeff3-352">In this second browser window, update the `UnitPrice` to `25.00`.</span></span> <span data-ttu-id="aeff3-353">如果沒有開放式平行存取支援，在第二個瀏覽器實例中按一下 [更新]，會將產品名稱變更回 "Chai"，因而覆寫第一個瀏覽器實例所做的變更。</span><span class="sxs-lookup"><span data-stu-id="aeff3-353">Without optimistic concurrency support, clicking update in the second browser instance would change the product name back to "Chai", thereby overwriting the changes made by the first browser instance.</span></span> <span data-ttu-id="aeff3-354">不過，在採用開放式平行存取的情況下，按一下第二個瀏覽器實例中的 [更新] 按鈕會導致[system.data.dbconcurrencyexception](https://msdn.microsoft.com/library/system.data.dbconcurrencyexception.aspx)。</span><span class="sxs-lookup"><span data-stu-id="aeff3-354">With optimistic concurrency employed, however, clicking the Update button in the second browser instance results in a [DBConcurrencyException](https://msdn.microsoft.com/library/system.data.dbconcurrencyexception.aspx).</span></span>

<span data-ttu-id="aeff3-355">[![偵測到並行違規時，則會擲回 System.data.dbconcurrencyexception](implementing-optimistic-concurrency-cs/_static/image48.png)](implementing-optimistic-concurrency-cs/_static/image47.png)</span><span class="sxs-lookup"><span data-stu-id="aeff3-355">[![When a Concurrency Violation is Detected, a DBConcurrencyException is Thrown](implementing-optimistic-concurrency-cs/_static/image48.png)](implementing-optimistic-concurrency-cs/_static/image47.png)</span></span>

<span data-ttu-id="aeff3-356">**圖 17**：偵測到並行違規時，會擲回 `DBConcurrencyException` （[按一下以查看完整大小的影像](implementing-optimistic-concurrency-cs/_static/image49.png)）</span><span class="sxs-lookup"><span data-stu-id="aeff3-356">**Figure 17**: When a Concurrency Violation is Detected, a `DBConcurrencyException` is Thrown ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image49.png))</span></span>

<span data-ttu-id="aeff3-357">只有在使用 DAL 的批次更新模式時，才會擲回 `DBConcurrencyException`。</span><span class="sxs-lookup"><span data-stu-id="aeff3-357">The `DBConcurrencyException` is only thrown when the DAL's batch update pattern is utilized.</span></span> <span data-ttu-id="aeff3-358">DB direct 模式不會引發例外狀況，只表示沒有任何資料列受到影響。</span><span class="sxs-lookup"><span data-stu-id="aeff3-358">The DB direct pattern does not raise an exception, it merely indicates that no rows were affected.</span></span> <span data-ttu-id="aeff3-359">為了說明這一點，請將瀏覽器實例的 GridView 同時傳回至其預先編輯狀態。</span><span class="sxs-lookup"><span data-stu-id="aeff3-359">To illustrate this, return both browser instances' GridView to their pre-editing state.</span></span> <span data-ttu-id="aeff3-360">接下來，在第一個瀏覽器實例中，按一下 [編輯] 按鈕，並將產品名稱從 "Chai 茶" 變更回 "Chai"，然後按一下 [更新]。</span><span class="sxs-lookup"><span data-stu-id="aeff3-360">Next, in the first browser instance, click the Edit button and change the product name from "Chai Tea" back to "Chai" and click Update.</span></span> <span data-ttu-id="aeff3-361">在第二個瀏覽器視窗中，按一下 [Chai] 的 [刪除] 按鈕。</span><span class="sxs-lookup"><span data-stu-id="aeff3-361">In the second browser window, click the Delete button for Chai.</span></span>

<span data-ttu-id="aeff3-362">按一下 [刪除] 時，此頁面會回傳，GridView 會叫用 ObjectDataSource 的 `Delete()` 方法，而 ObjectDataSource 會向下呼叫 `ProductsOptimisticConcurrencyBLL` 類別的 `DeleteProduct` 方法，並沿著原始值傳遞。</span><span class="sxs-lookup"><span data-stu-id="aeff3-362">Upon clicking Delete, the page posts back, the GridView invokes the ObjectDataSource's `Delete()` method, and the ObjectDataSource calls down into the `ProductsOptimisticConcurrencyBLL` class's `DeleteProduct` method, passing along the original values.</span></span> <span data-ttu-id="aeff3-363">第二個瀏覽器實例的原始 `ProductName` 值為 "Chai 茶"，這與資料庫中目前的 `ProductName` 值不相符。</span><span class="sxs-lookup"><span data-stu-id="aeff3-363">The original `ProductName` value for the second browser instance is "Chai Tea", which doesn't match up with the current `ProductName` value in the database.</span></span> <span data-ttu-id="aeff3-364">因此，對資料庫發出的 `DELETE` 語句會影響零個數據列，因為 `WHERE` 子句所滿足的資料庫中沒有任何記錄。</span><span class="sxs-lookup"><span data-stu-id="aeff3-364">Therefore the `DELETE` statement issued to the database affects zero rows since there's no record in the database that the `WHERE` clause satisfies.</span></span> <span data-ttu-id="aeff3-365">`DeleteProduct` 方法會傳回 `false`，而 ObjectDataSource 的資料會重新系結至 GridView。</span><span class="sxs-lookup"><span data-stu-id="aeff3-365">The `DeleteProduct` method returns `false` and the ObjectDataSource's data is rebound to the GridView.</span></span>

<span data-ttu-id="aeff3-366">從使用者的觀點來看，在第二個瀏覽器視窗中，按一下 [Chai 茶] 的 [刪除] 按鈕會使螢幕閃爍，而在送回後，產品仍然存在，但現在它會列為 "Chai" （第一個瀏覽器所做的產品名稱變更）實例）。</span><span class="sxs-lookup"><span data-stu-id="aeff3-366">From the end user's perspective, clicking on the Delete button for Chai Tea in the second browser window caused the screen to flash and, upon coming back, the product is still there, although now it's listed as "Chai" (the product name change made by the first browser instance).</span></span> <span data-ttu-id="aeff3-367">如果使用者再次按一下 [刪除] 按鈕，刪除將會成功，因為 GridView 的原始 `ProductName` 值（"Chai"）現在符合資料庫中的值。</span><span class="sxs-lookup"><span data-stu-id="aeff3-367">If the user clicks the Delete button again, the Delete will succeed, as the GridView's original `ProductName` value ("Chai") now matches up with the value in the database.</span></span>

<span data-ttu-id="aeff3-368">在這兩種情況下，使用者經驗都不太理想。</span><span class="sxs-lookup"><span data-stu-id="aeff3-368">In both of these cases, the user experience is far from ideal.</span></span> <span data-ttu-id="aeff3-369">當您使用批次更新模式時，我們很清楚不想要向使用者顯示 `DBConcurrencyException` 例外狀況的具體細節。</span><span class="sxs-lookup"><span data-stu-id="aeff3-369">We clearly don't want to show the user the nitty-gritty details of the `DBConcurrencyException` exception when using the batch update pattern.</span></span> <span data-ttu-id="aeff3-370">而使用 DB direct 模式時的行為，會因為使用者命令失敗而造成混淆，但並沒有精確的指示。</span><span class="sxs-lookup"><span data-stu-id="aeff3-370">And the behavior when using the DB direct pattern is somewhat confusing as the users command failed, but there was no precise indication of why.</span></span>

<span data-ttu-id="aeff3-371">若要解決這兩個問題，我們可以在頁面上建立標籤 Web 控制項，以提供更新或刪除失敗原因的說明。</span><span class="sxs-lookup"><span data-stu-id="aeff3-371">To remedy these two issues, we can create Label Web controls on the page that provide an explanation to why an update or delete failed.</span></span> <span data-ttu-id="aeff3-372">針對批次更新模式，我們可以判斷 GridView 的後置層級事件處理常式中是否發生 `DBConcurrencyException` 例外狀況，並視需要顯示警告標籤。</span><span class="sxs-lookup"><span data-stu-id="aeff3-372">For the batch update pattern, we can determine whether or not a `DBConcurrencyException` exception occurred in the GridView's post-level event handler, displaying the warning label as needed.</span></span> <span data-ttu-id="aeff3-373">對於 DB 直接方法，我們可以檢查 BLL 方法的傳回值（如果有一個資料列受到影響，則會 `true`，否則 `false`），並視需要顯示參考用訊息。</span><span class="sxs-lookup"><span data-stu-id="aeff3-373">For the DB direct method, we can examine the return value of the BLL method (which is `true` if one row was affected, `false` otherwise) and display an informational message as needed.</span></span>

## <a name="step-6-adding-informational-messages-and-displaying-them-in-the-face-of-a-concurrency-violation"></a><span data-ttu-id="aeff3-374">步驟6：新增參考用訊息，並在面臨並行違規時顯示它們</span><span class="sxs-lookup"><span data-stu-id="aeff3-374">Step 6: Adding Informational Messages and Displaying Them in the Face of a Concurrency Violation</span></span>

<span data-ttu-id="aeff3-375">發生並行違規時，所出現的行為取決於是否使用 DAL 的批次更新或 DB 直接模式。</span><span class="sxs-lookup"><span data-stu-id="aeff3-375">When a concurrency violation occurs, the behavior exhibited depends on whether the DAL's batch update or DB direct pattern was used.</span></span> <span data-ttu-id="aeff3-376">我們的教學課程會使用這兩種模式，並使用批次更新模式來進行更新，以及用來刪除的資料庫直接模式。</span><span class="sxs-lookup"><span data-stu-id="aeff3-376">Our tutorial uses both patterns, with the batch update pattern being used for updating and the DB direct pattern used for deleting.</span></span> <span data-ttu-id="aeff3-377">首先，讓我們在頁面中新增兩個標籤 Web 控制項，說明嘗試刪除或更新資料時，發生並行違規。</span><span class="sxs-lookup"><span data-stu-id="aeff3-377">To get started, let's add two Label Web controls to our page that explain that a concurrency violation occurred when attempting to delete or update data.</span></span> <span data-ttu-id="aeff3-378">將標籤控制項的 `Visible` 和 `EnableViewState` 屬性設定為 `false`;這會導致在每個頁面上都隱藏它們，但這些頁面造訪的 `Visible` 屬性是以程式設計方式設定為 `true`。</span><span class="sxs-lookup"><span data-stu-id="aeff3-378">Set the Label control's `Visible` and `EnableViewState` properties to `false`; this will cause them to be hidden on each page visit except for those particular page visits where their `Visible` property is programmatically set to `true`.</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample12.aspx)]

<span data-ttu-id="aeff3-379">除了設定其 `Visible`、`EnabledViewState`和 `Text` 屬性之外，我也將 `CssClass` 屬性設定為 [`Warning`]，這會使標籤以大、紅色、斜體、粗體字型顯示。</span><span class="sxs-lookup"><span data-stu-id="aeff3-379">In addition to setting their `Visible`, `EnabledViewState`, and `Text` properties, I've also set the `CssClass` property to `Warning`, which causes the Label's to be displayed in a large, red, italic, bold font.</span></span> <span data-ttu-id="aeff3-380">已定義此 CSS `Warning` 類別，並將其加入至樣式. CSS 中*檢查與插入、更新和刪除教學課程相關聯的事件*。</span><span class="sxs-lookup"><span data-stu-id="aeff3-380">This CSS `Warning` class was defined and added to Styles.css back in the *Examining the Events Associated with Inserting, Updating, and Deleting* tutorial.</span></span>

<span data-ttu-id="aeff3-381">加入這些標籤之後，Visual Studio 中的設計工具看起來應該類似 [圖 18]。</span><span class="sxs-lookup"><span data-stu-id="aeff3-381">After adding these Labels, the Designer in Visual Studio should look similar to Figure 18.</span></span>

<span data-ttu-id="aeff3-382">[![兩個標籤控制項已加入至頁面](implementing-optimistic-concurrency-cs/_static/image51.png)](implementing-optimistic-concurrency-cs/_static/image50.png)</span><span class="sxs-lookup"><span data-stu-id="aeff3-382">[![Two Label Controls Have Been Added to the Page](implementing-optimistic-concurrency-cs/_static/image51.png)](implementing-optimistic-concurrency-cs/_static/image50.png)</span></span>

<span data-ttu-id="aeff3-383">**圖 18**：已將兩個標籤控制項新增至頁面（[按一下以查看完整大小的影像](implementing-optimistic-concurrency-cs/_static/image52.png)）</span><span class="sxs-lookup"><span data-stu-id="aeff3-383">**Figure 18**: Two Label Controls Have Been Added to the Page ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image52.png))</span></span>

<span data-ttu-id="aeff3-384">有了這些 Web 控制項的標籤之後，我們就可以開始檢查如何判斷發生並行違規的時間，此時可以將適當標籤的 `Visible` 屬性設定為 `true`，顯示參考用訊息。</span><span class="sxs-lookup"><span data-stu-id="aeff3-384">With these Label Web controls in place, we're ready to examine how to determine when a concurrency violation has occurred, at which point the appropriate Label's `Visible` property can be set to `true`, displaying the informational message.</span></span>

## <a name="handling-concurrency-violations-when-updating"></a><span data-ttu-id="aeff3-385">在更新時處理並行違規</span><span class="sxs-lookup"><span data-stu-id="aeff3-385">Handling Concurrency Violations When Updating</span></span>

<span data-ttu-id="aeff3-386">讓我們先看看如何在使用批次更新模式時處理並行違規。</span><span class="sxs-lookup"><span data-stu-id="aeff3-386">Let's first look at how to handle concurrency violations when using the batch update pattern.</span></span> <span data-ttu-id="aeff3-387">因為與批次更新模式的違規會導致擲回 `DBConcurrencyException` 例外狀況，所以我們需要將程式碼新增至我們的 ASP.NET 網頁，以判斷更新程式期間是否發生 `DBConcurrencyException` 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="aeff3-387">Since such violations with the batch update pattern cause a `DBConcurrencyException` exception to be thrown, we need to add code to our ASP.NET page to determine whether a `DBConcurrencyException` exception occurred during the update process.</span></span> <span data-ttu-id="aeff3-388">若是如此，我們應該向使用者顯示一則訊息，說明他們的變更並未儲存，因為另一位使用者在開始編輯記錄和按一下 [更新] 按鈕時，修改了相同的資料。</span><span class="sxs-lookup"><span data-stu-id="aeff3-388">If so, we should display a message to the user explaining that their changes were not saved because another user had modified the same data between when they started editing the record and when they clicked the Update button.</span></span>

<span data-ttu-id="aeff3-389">如我們在 ASP.NET 網頁教學課程中*處理 BLL 和 DAL 層級的例外*狀況中所見，您可以在資料 Web 控制項的後置層級事件處理常式中偵測到和隱藏這類例外狀況。</span><span class="sxs-lookup"><span data-stu-id="aeff3-389">As we saw in the *Handling BLL- and DAL-Level Exceptions in an ASP.NET Page* tutorial, such exceptions can be detected and suppressed in the data Web control's post-level event handlers.</span></span> <span data-ttu-id="aeff3-390">因此，我們需要為 GridView 的 `RowUpdated` 事件建立事件處理常式，以檢查是否已擲回 `DBConcurrencyException` 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="aeff3-390">Therefore, we need to create an event handler for the GridView's `RowUpdated` event that checks if a `DBConcurrencyException` exception has been thrown.</span></span> <span data-ttu-id="aeff3-391">這個事件處理常式會傳遞在更新程式期間引發之任何例外狀況的參考，如以下的事件處理常式代碼所示：</span><span class="sxs-lookup"><span data-stu-id="aeff3-391">This event handler is passed a reference to any exception that was raised during the updating process, as shown in the event handler code below:</span></span>

[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample13.cs)]

<span data-ttu-id="aeff3-392">在 `DBConcurrencyException` 例外狀況的臉部中，此事件處理常式會顯示 `UpdateConflictMessage` Label 控制項，並指出已處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="aeff3-392">In the face of a `DBConcurrencyException` exception, this event handler displays the `UpdateConflictMessage` Label control and indicates that the exception has been handled.</span></span> <span data-ttu-id="aeff3-393">當此程式碼準備好時，當更新記錄時發生並行違規時，使用者的變更會遺失，因為他們會同時覆寫其他使用者的修改。</span><span class="sxs-lookup"><span data-stu-id="aeff3-393">With this code in place, when a concurrency violation occurs when updating a record, the user's changes are lost, since they would have overwritten another user's modifications at the same time.</span></span> <span data-ttu-id="aeff3-394">特別是，GridView 會回到其預先編輯狀態，並系結至目前的資料庫資料。</span><span class="sxs-lookup"><span data-stu-id="aeff3-394">In particular, the GridView is returned to its pre-editing state and bound to the current database data.</span></span> <span data-ttu-id="aeff3-395">這會使用其他使用者的變更（先前不可見）來更新 GridView 資料列。</span><span class="sxs-lookup"><span data-stu-id="aeff3-395">This will update the GridView row with the other user's changes, which were previously not visible.</span></span> <span data-ttu-id="aeff3-396">此外，`UpdateConflictMessage` Label 控制項也會向使用者說明剛剛發生的情況。</span><span class="sxs-lookup"><span data-stu-id="aeff3-396">Additionally, the `UpdateConflictMessage` Label control will explain to the user what just happened.</span></span> <span data-ttu-id="aeff3-397">[圖 19] 中詳述了這一系列的事件。</span><span class="sxs-lookup"><span data-stu-id="aeff3-397">This sequence of events is detailed in Figure 19.</span></span>

<span data-ttu-id="aeff3-398">[![使用者的更新在面臨並行違規時遺失](implementing-optimistic-concurrency-cs/_static/image54.png)](implementing-optimistic-concurrency-cs/_static/image53.png)</span><span class="sxs-lookup"><span data-stu-id="aeff3-398">[![A User s Updates are Lost in the Face of a Concurrency Violation](implementing-optimistic-concurrency-cs/_static/image54.png)](implementing-optimistic-concurrency-cs/_static/image53.png)</span></span>

<span data-ttu-id="aeff3-399">**圖 19**：遇到並行違規時，使用者的更新會遺失（[按一下以觀看完整大小的影像](implementing-optimistic-concurrency-cs/_static/image55.png)）</span><span class="sxs-lookup"><span data-stu-id="aeff3-399">**Figure 19**: A User s Updates are Lost in the Face of a Concurrency Violation ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image55.png))</span></span>

> [!NOTE]
> <span data-ttu-id="aeff3-400">或者，您可以將傳入 `GridViewUpdatedEventArgs` 物件的 `KeepInEditMode` 屬性設定為 true，而不是將 GridView 改成進入編輯狀態。</span><span class="sxs-lookup"><span data-stu-id="aeff3-400">Alternatively, rather than returning the GridView to the pre-editing state, we could leave the GridView in its editing state by setting the `KeepInEditMode` property of the passed-in `GridViewUpdatedEventArgs` object to true.</span></span> <span data-ttu-id="aeff3-401">不過，如果您採用這種方法，請務必將資料重新系結至 GridView （藉由叫用其 `DataBind()` 方法），以便將其他使用者的值載入至編輯介面。</span><span class="sxs-lookup"><span data-stu-id="aeff3-401">If you take this approach, however, be certain to rebind the data to the GridView (by invoking its `DataBind()` method) so that the other user's values are loaded into the editing interface.</span></span> <span data-ttu-id="aeff3-402">在此教學課程中可供下載的程式碼在 `RowUpdated` 事件處理常式中有這兩行程式碼會加上批註;只要取消批註這幾行程式碼，GridView 就會在並行違規之後保持編輯模式。</span><span class="sxs-lookup"><span data-stu-id="aeff3-402">The code available for download with this tutorial has these two lines of code in the `RowUpdated` event handler commented out; simply uncomment these lines of code to have the GridView remain in edit mode after a concurrency violation.</span></span>

## <a name="responding-to-concurrency-violations-when-deleting"></a><span data-ttu-id="aeff3-403">在刪除時回應並行違規</span><span class="sxs-lookup"><span data-stu-id="aeff3-403">Responding to Concurrency Violations When Deleting</span></span>

<span data-ttu-id="aeff3-404">使用 DB direct 模式時，不會在面臨並行違規的情況下引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="aeff3-404">With the DB direct pattern, there is no exception raised in the face of a concurrency violation.</span></span> <span data-ttu-id="aeff3-405">相反地，database 語句只會影響任何記錄，因為 WHERE 子句不會與任何記錄相符。</span><span class="sxs-lookup"><span data-stu-id="aeff3-405">Instead, the database statement simply affects no records, as the WHERE clause does not match with any record.</span></span> <span data-ttu-id="aeff3-406">在 BLL 中建立的所有資料修改方法，都是設計成會傳回布林值，指出它們是否只影響一筆記錄。</span><span class="sxs-lookup"><span data-stu-id="aeff3-406">All of the data modification methods created in the BLL have been designed such that they return a Boolean value indicating whether or not they affected precisely one record.</span></span> <span data-ttu-id="aeff3-407">因此，若要判斷刪除記錄時是否發生並行違規，我們可以檢查 BLL 的 `DeleteProduct` 方法的傳回值。</span><span class="sxs-lookup"><span data-stu-id="aeff3-407">Therefore, to determine if a concurrency violation occurred when deleting a record, we can examine the return value of the BLL's `DeleteProduct` method.</span></span>

<span data-ttu-id="aeff3-408">您可以透過傳遞至事件處理常式之 `ObjectDataSourceStatusEventArgs` 物件的 `ReturnValue` 屬性，在 ObjectDataSource 的 post 層級事件處理常式中檢查 BLL 方法的傳回值。</span><span class="sxs-lookup"><span data-stu-id="aeff3-408">The return value for a BLL method can be examined in the ObjectDataSource's post-level event handlers through the `ReturnValue` property of the `ObjectDataSourceStatusEventArgs` object passed into the event handler.</span></span> <span data-ttu-id="aeff3-409">因為我們想要從 `DeleteProduct` 方法判斷傳回值，所以我們需要為 ObjectDataSource 的 `Deleted` 事件建立事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="aeff3-409">Since we are interested in determining the return value from the `DeleteProduct` method, we need to create an event handler for the ObjectDataSource's `Deleted` event.</span></span> <span data-ttu-id="aeff3-410">`ReturnValue` 屬性的類型是 `object` 而且如果引發例外狀況，而且方法在可能傳回值之前已中斷，則可以 `null`。</span><span class="sxs-lookup"><span data-stu-id="aeff3-410">The `ReturnValue` property is of type `object` and can be `null` if an exception was raised and the method was interrupted before it could return a value.</span></span> <span data-ttu-id="aeff3-411">因此，我們應該先確定 `ReturnValue` 屬性不 `null`，而且是布林值。</span><span class="sxs-lookup"><span data-stu-id="aeff3-411">Therefore, we should first ensure that the `ReturnValue` property is not `null` and is a Boolean value.</span></span> <span data-ttu-id="aeff3-412">假設這種檢查通過，如果 `ReturnValue` `false`，我們會顯示 `DeleteConflictMessage` 標籤控制項。</span><span class="sxs-lookup"><span data-stu-id="aeff3-412">Assuming this check passes, we show the `DeleteConflictMessage` Label control if the `ReturnValue` is `false`.</span></span> <span data-ttu-id="aeff3-413">您可以使用下列程式碼來完成這項作業：</span><span class="sxs-lookup"><span data-stu-id="aeff3-413">This can be accomplished by using the following code:</span></span>

[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample14.cs)]

<span data-ttu-id="aeff3-414">在遇到並行違規時，會取消使用者的刪除要求。</span><span class="sxs-lookup"><span data-stu-id="aeff3-414">In the face of a concurrency violation, the user's delete request is canceled.</span></span> <span data-ttu-id="aeff3-415">GridView 會重新整理，顯示該記錄在使用者載入頁面和按一下 [刪除] 按鈕時所發生的變更。</span><span class="sxs-lookup"><span data-stu-id="aeff3-415">The GridView is refreshed, showing the changes that occurred for that record between the time the user loaded the page and when he clicked the Delete button.</span></span> <span data-ttu-id="aeff3-416">當這類違規過大幅簡化時，會顯示 [`DeleteConflictMessage`] 標籤，說明剛發生的情況（請參閱 [圖 20]）。</span><span class="sxs-lookup"><span data-stu-id="aeff3-416">When such a violation transpires, the `DeleteConflictMessage` Label is shown, explaining what just happened (see Figure 20).</span></span>

<span data-ttu-id="aeff3-417">[![在面臨並行違規時取消使用者的刪除](implementing-optimistic-concurrency-cs/_static/image57.png)](implementing-optimistic-concurrency-cs/_static/image56.png)</span><span class="sxs-lookup"><span data-stu-id="aeff3-417">[![A User s Delete is Canceled in the Face of a Concurrency Violation](implementing-optimistic-concurrency-cs/_static/image57.png)](implementing-optimistic-concurrency-cs/_static/image56.png)</span></span>

<span data-ttu-id="aeff3-418">**圖 20**：發生並行違規時，會取消使用者的刪除（[按一下以觀看完整大小的影像](implementing-optimistic-concurrency-cs/_static/image58.png)）</span><span class="sxs-lookup"><span data-stu-id="aeff3-418">**Figure 20**: A User s Delete is Canceled in the Face of a Concurrency Violation ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image58.png))</span></span>

## <a name="summary"></a><span data-ttu-id="aeff3-419">總結</span><span class="sxs-lookup"><span data-stu-id="aeff3-419">Summary</span></span>

<span data-ttu-id="aeff3-420">在允許多個並行使用者更新或刪除資料的每個應用程式中，有並行違規的機會。</span><span class="sxs-lookup"><span data-stu-id="aeff3-420">Opportunities for concurrency violations exist in every application that allows multiple, concurrent users to update or delete data.</span></span> <span data-ttu-id="aeff3-421">如果未考慮這類違規，則當兩個使用者同時更新最後寫入「獲勝」中取得的相同資料時，會覆寫其他使用者的變更。</span><span class="sxs-lookup"><span data-stu-id="aeff3-421">If such violations are not accounted for, when two users simultaneously update the same data whoever gets in the last write "wins," overwriting the other user's changes changes.</span></span> <span data-ttu-id="aeff3-422">或者，開發人員可以執行開放式或封閉式並行存取控制。</span><span class="sxs-lookup"><span data-stu-id="aeff3-422">Alternatively, developers can implement either optimistic or pessimistic concurrency control.</span></span> <span data-ttu-id="aeff3-423">開放式並行存取控制會假設並行違規不頻繁，而只是不允許會構成並行違規的 update 或 delete 命令。</span><span class="sxs-lookup"><span data-stu-id="aeff3-423">Optimistic concurrency control assumes that concurrency violations are infrequent and simply disallows an update or delete command that would constitute a concurrency violation.</span></span> <span data-ttu-id="aeff3-424">封閉式並行存取控制項會假設並行違規很頻繁，而只是拒絕一個使用者的 update 或 delete 命令是無法接受的。</span><span class="sxs-lookup"><span data-stu-id="aeff3-424">Pessimistic concurrency control assumes that concurrency violations are frequent and simply rejecting one user's update or delete command is not acceptable.</span></span> <span data-ttu-id="aeff3-425">使用封閉式並行存取控制時，更新記錄牽涉到鎖定，藉此防止任何其他使用者在鎖定時修改或刪除記錄。</span><span class="sxs-lookup"><span data-stu-id="aeff3-425">With pessimistic concurrency control, updating a record involves locking it, thereby preventing any other users from modifying or deleting the record while it is locked.</span></span>

<span data-ttu-id="aeff3-426">.NET 中的具類型資料集提供支援開放式並行存取控制的功能。</span><span class="sxs-lookup"><span data-stu-id="aeff3-426">The Typed DataSet in .NET provides functionality for supporting optimistic concurrency control.</span></span> <span data-ttu-id="aeff3-427">特別的是，發出到資料庫的 `UPDATE` 和 `DELETE` 語句包含所有資料表的資料行，因此，確保只有當記錄的目前資料符合使用者執行其更新或刪除時所擁有的原始資料時，才會發生更新或刪除。</span><span class="sxs-lookup"><span data-stu-id="aeff3-427">In particular, the `UPDATE` and `DELETE` statements issued to the database include all of the table's columns, thereby ensuring that the update or delete will only occur if the record's current data matches with the original data the user had when performing their update or delete.</span></span> <span data-ttu-id="aeff3-428">一旦將 DAL 設定為支援開放式平行存取，就需要更新 BLL 方法。</span><span class="sxs-lookup"><span data-stu-id="aeff3-428">Once the DAL has been configured to support optimistic concurrency, the BLL methods need to be updated.</span></span> <span data-ttu-id="aeff3-429">此外，您必須設定向下呼叫 BLL 的 ASP.NET 網頁，讓 ObjectDataSource 從其資料 Web 控制項抓取原始值，並將它們傳遞到 BLL 中。</span><span class="sxs-lookup"><span data-stu-id="aeff3-429">Additionally, the ASP.NET page that calls down into the BLL must be configured such that the ObjectDataSource retrieves the original values from its data Web control and passes them down into the BLL.</span></span>

<span data-ttu-id="aeff3-430">如我們在本教學課程中所見，在 ASP.NET web 應用程式中執行開放式並行存取控制牽涉到更新 DAL 和 BLL，並在 [ASP.NET] 頁面中新增支援。</span><span class="sxs-lookup"><span data-stu-id="aeff3-430">As we saw in this tutorial, implementing optimistic concurrency control in an ASP.NET web application involves updating the DAL and BLL and adding support in the ASP.NET page.</span></span> <span data-ttu-id="aeff3-431">此新增的工作是否為您的時間和投入量而定，取決於您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="aeff3-431">Whether or not this added work is a wise investment of your time and effort depends on your application.</span></span> <span data-ttu-id="aeff3-432">如果您不常有同時更新資料的並行使用者，或它們正在更新的資料與另一個不同，則並行控制不是關鍵問題。</span><span class="sxs-lookup"><span data-stu-id="aeff3-432">If you infrequently have concurrent users updating data, or the data they are updating is different from one another, then concurrency control is not a key issue.</span></span> <span data-ttu-id="aeff3-433">不過，如果您的網站上經常有多個使用者使用相同的資料，並行存取控制可協助防止某個使用者的更新或刪除意外覆寫另一個。</span><span class="sxs-lookup"><span data-stu-id="aeff3-433">If, however, you routinely have multiple users on your site working with the same data, concurrency control can help prevent one user's updates or deletes from unwittingly overwriting another's.</span></span>

<span data-ttu-id="aeff3-434">快樂的程式設計！</span><span class="sxs-lookup"><span data-stu-id="aeff3-434">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="aeff3-435">關於作者</span><span class="sxs-lookup"><span data-stu-id="aeff3-435">About the Author</span></span>

<span data-ttu-id="aeff3-436">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，自1998起，有七個 ASP/ASP. NET 書籍和創辦人的[4GuysFromRolla.com](http://www.4guysfromrolla.com)。</span><span class="sxs-lookup"><span data-stu-id="aeff3-436">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="aeff3-437">Scott 以獨立的顧問、訓練員和作者的身分運作。</span><span class="sxs-lookup"><span data-stu-id="aeff3-437">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="aeff3-438">他的最新著作是[*在24小時內讓自己的 ASP.NET 2.0*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="aeff3-438">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="aeff3-439">他可以在mitchell@4GuysFromRolla.com觸達[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="aeff3-439">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="aeff3-440">或者透過他的 blog，可以在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)找到。</span><span class="sxs-lookup"><span data-stu-id="aeff3-440">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="aeff3-441">[上一頁](customizing-the-data-modification-interface-cs.md)
> [下一頁](adding-client-side-confirmation-when-deleting-cs.md)</span><span class="sxs-lookup"><span data-stu-id="aeff3-441">[Previous](customizing-the-data-modification-interface-cs.md)
[Next](adding-client-side-confirmation-when-deleting-cs.md)</span></span>
