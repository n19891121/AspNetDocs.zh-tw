---
uid: web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-vb
title: 有效率地分頁大量資料 (VB) |Microsoft Docs
author: rick-anderson
description: 使用大量的資料，作為其基礎資料來源控制項 retriev 時，不適合資料簡報控制項的預設分頁選項...
ms.author: riande
ms.date: 08/15/2006
ms.assetid: 3e20e64a-8808-4b49-88d6-014e2629d56f
msc.legacyurl: /web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-vb
msc.type: authoredcontent
ms.openlocfilehash: dd1fd089bc4faa18fb2e8112b2820788c1f25ceb
ms.sourcegitcommit: 51b01b6ff8edde57d8243e4da28c9f1e7f1962b2
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/06/2019
ms.locfileid: "65130968"
---
# <a name="efficiently-paging-through-large-amounts-of-data-vb"></a><span data-ttu-id="082d8-103">有效率地分頁大量資料 (VB)</span><span class="sxs-lookup"><span data-stu-id="082d8-103">Efficiently Paging Through Large Amounts of Data (VB)</span></span>

<span data-ttu-id="082d8-104">藉由[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="082d8-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="082d8-105">[下載範例應用程式](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_VB.exe)或[下載 PDF](efficiently-paging-through-large-amounts-of-data-vb/_static/datatutorial25vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="082d8-105">[Download Sample App](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_VB.exe) or [Download PDF](efficiently-paging-through-large-amounts-of-data-vb/_static/datatutorial25vb1.pdf)</span></span>

> <span data-ttu-id="082d8-106">資料簡報控制項的預設分頁選項時，不適合使用大量的資料，當其基礎資料來源控制項擷取所有的記錄，即使在顯示的資料子集。</span><span class="sxs-lookup"><span data-stu-id="082d8-106">The default paging option of a data presentation control is unsuitable when working with large amounts of data, as its underlying data source control retrieves all records, even though only a subset of data is displayed.</span></span> <span data-ttu-id="082d8-107">必須在此情況下，我們開啟自訂分頁。</span><span class="sxs-lookup"><span data-stu-id="082d8-107">In such circumstances, we must turn to custom paging.</span></span>

## <a name="introduction"></a><span data-ttu-id="082d8-108">簡介</span><span class="sxs-lookup"><span data-stu-id="082d8-108">Introduction</span></span>

<span data-ttu-id="082d8-109">如我們所討論在先前的教學課程中，您可以實作分頁中有兩種,：</span><span class="sxs-lookup"><span data-stu-id="082d8-109">As we discussed in the preceding tutorial, paging can be implemented in one of two ways:</span></span>

- <span data-ttu-id="082d8-110">**預設的分頁**可實作只要選取 [啟用分頁] 選項中的資料 Web 控制項 s 智慧標籤; 不過，只要檢視的資料頁，ObjectDataSource 擷取*所有*的記錄，甚至是不過它們的子集會顯示在頁面</span><span class="sxs-lookup"><span data-stu-id="082d8-110">**Default Paging** can be implemented by simply checking the Enable Paging option in the data Web control s smart tag; however, whenever viewing a page of data, the ObjectDataSource retrieves *all* of the records, even though only a subset of them are displayed in the page</span></span>
- <span data-ttu-id="082d8-111">**自訂分頁**可改善效能的預設分頁擷取只有這些記錄從資料庫中要顯示使用者所要求資料的特定頁面，不過，自訂分頁牽涉到多一點工夫來實作比預設分頁</span><span class="sxs-lookup"><span data-stu-id="082d8-111">**Custom Paging** improves the performance of default paging by retrieving only those records from the database that need to be displayed for the particular page of data requested by the user; however, custom paging involves a bit more effort to implement than default paging</span></span>

<span data-ttu-id="082d8-112">由於易於實作只核取核取方塊，且您完成了 ！</span><span class="sxs-lookup"><span data-stu-id="082d8-112">Due to the ease of implementation just check a checkbox and you re done!</span></span> <span data-ttu-id="082d8-113">預設的分頁是一個不錯的選擇。</span><span class="sxs-lookup"><span data-stu-id="082d8-113">default paging is an attractive option.</span></span> <span data-ttu-id="082d8-114">在擷取的所有記錄，其 na ve 方法，可讓 implausible 的選擇時分頁夠大的資料或站台的數量，與許多並行使用者。</span><span class="sxs-lookup"><span data-stu-id="082d8-114">Its na�ve approach in retrieving all of the records, though, makes it an implausible choice when paging through sufficiently large amounts of data or for sites with many concurrent users.</span></span> <span data-ttu-id="082d8-115">在此情況下，我們必須啟用自訂分頁以提供回應的系統。</span><span class="sxs-lookup"><span data-stu-id="082d8-115">In such circumstances, we must turn to custom paging in order to provide a responsive system.</span></span>

<span data-ttu-id="082d8-116">自訂分頁的挑戰要能夠撰寫可傳回的精確記錄所需的特定頁面的資料集的查詢。</span><span class="sxs-lookup"><span data-stu-id="082d8-116">The challenge of custom paging is being able to write a query that returns the precise set of records needed for a particular page of data.</span></span> <span data-ttu-id="082d8-117">幸運的是，Microsoft SQL Server 2005 提供新的關鍵字排名結果，這讓我們撰寫可以有效率地擷取記錄的適當子集的查詢。</span><span class="sxs-lookup"><span data-stu-id="082d8-117">Fortunately, Microsoft SQL Server 2005 provides a new keyword for ranking results, which enables us to write a query that can efficiently retrieve the proper subset of records.</span></span> <span data-ttu-id="082d8-118">在本教學課程中，我們會看到如何使用這個新的 SQL Server 2005 關鍵字 GridView 控制項中實作自訂分頁。</span><span class="sxs-lookup"><span data-stu-id="082d8-118">In this tutorial we'll see how to use this new SQL Server 2005 keyword to implement custom paging in a GridView control.</span></span> <span data-ttu-id="082d8-119">使用者介面的自訂分頁時相同的預設分頁時，從一頁跳到下一步 時使用自訂分頁可以的差距速度比預設分頁。</span><span class="sxs-lookup"><span data-stu-id="082d8-119">While the user interface for custom paging is identical to that for default paging, stepping from one page to the next using custom paging can be several orders of magnitude faster than default paging.</span></span>

> [!NOTE]
> <span data-ttu-id="082d8-120">自訂分頁，所展現的確切的效能改善取決於正在呼叫透過記錄並放在資料庫伺服器上的負載的總數。</span><span class="sxs-lookup"><span data-stu-id="082d8-120">The exact performance gain exhibited by custom paging depends on the total number of records being paged through and the load being placed on the database server.</span></span> <span data-ttu-id="082d8-121">在本教學課程結尾處我們將探討一些粗略的計量，展示透過自訂分頁所獲得的效能優點。</span><span class="sxs-lookup"><span data-stu-id="082d8-121">At the end of this tutorial we'll look at some rough metrics that showcase the benefits in performance obtained through custom paging.</span></span>

## <a name="step-1-understanding-the-custom-paging-process"></a><span data-ttu-id="082d8-122">步驟 1：了解自訂分頁程序</span><span class="sxs-lookup"><span data-stu-id="082d8-122">Step 1: Understanding the Custom Paging Process</span></span>

<span data-ttu-id="082d8-123">當資料進行分頁，顯示在頁面中的精確記錄會依所要求的資料頁和每頁顯示的記錄數目而定。</span><span class="sxs-lookup"><span data-stu-id="082d8-123">When paging through data, the precise records displayed in a page depend upon the page of data being requested and the number of records displayed per page.</span></span> <span data-ttu-id="082d8-124">例如，想像一下，我們想要透過 81 的產品，頁面上顯示每頁 10 項產品。</span><span class="sxs-lookup"><span data-stu-id="082d8-124">For example, imagine that we wanted to page through the 81 products, displaying 10 products per page.</span></span> <span data-ttu-id="082d8-125">當您檢視第一頁，d 希望產品 1 到 10;檢視第二個頁面時 d 我們會想要的產品 11 到 20，依此類推。</span><span class="sxs-lookup"><span data-stu-id="082d8-125">When viewing the first page, we d want products 1 through 10; when viewing the second page we d be interested in products 11 through 20, and so on.</span></span>

<span data-ttu-id="082d8-126">有三個變數，以指定要擷取需要的記錄及呈現分頁介面的方式：</span><span class="sxs-lookup"><span data-stu-id="082d8-126">There are three variables that dictate what records need to be retrieved and how the paging interface should be rendered:</span></span>

- <span data-ttu-id="082d8-127">**啟動 資料列索引**要顯示的資料頁面中的第一列的索引; 此索引的頁面索引乘以每頁顯示的記錄，並新增一個計算。</span><span class="sxs-lookup"><span data-stu-id="082d8-127">**Start Row Index** the index of the first row in the page of data to display; this index can be calculated by multiplying the page index by the records to display per page and adding one.</span></span> <span data-ttu-id="082d8-128">比方說，當分頁 （其頁面索引為 0） 的第一頁的資料錄 10 次，啟動資料列索引為 0 \* 10 + 1 或 1; 第二個頁面 （頁面索引為 1），開始的資料列索引為 1 \* 10 + 1或 11。</span><span class="sxs-lookup"><span data-stu-id="082d8-128">For example, when paging through records 10 at a time, for the first page (whose page index is 0), the Start Row Index is 0 \* 10 + 1, or 1; for the second page (whose page index is 1), the Start Row Index is 1 \* 10 + 1, or 11.</span></span>
- <span data-ttu-id="082d8-129">**最大資料列**每頁顯示的資料錄的數目上限。</span><span class="sxs-lookup"><span data-stu-id="082d8-129">**Maximum Rows** the maximum number of records to display per page.</span></span> <span data-ttu-id="082d8-130">此變數被指最大資料列因為最後一個頁面有可能是較少的記錄傳回比頁面大小。</span><span class="sxs-lookup"><span data-stu-id="082d8-130">This variable is referred to as maximum rows since for the last page there may be fewer records returned than the page size.</span></span> <span data-ttu-id="082d8-131">比方說，當每個頁面的 81 產品 10 記錄進行分頁，第九個和最後一個頁面必須只有一項記錄。</span><span class="sxs-lookup"><span data-stu-id="082d8-131">For example, when paging through the 81 products 10 records per page, the ninth and final page will have just one record.</span></span> <span data-ttu-id="082d8-132">不過，任何頁面上，會不顯示較多的記錄超過最大資料列的值。</span><span class="sxs-lookup"><span data-stu-id="082d8-132">No page, though, will show more records than the Maximum Rows value.</span></span>
- <span data-ttu-id="082d8-133">**總計記錄計數**透過正在分頁的記錄總數。</span><span class="sxs-lookup"><span data-stu-id="082d8-133">**Total Record Count** the total number of records being paged through.</span></span> <span data-ttu-id="082d8-134">雖然此變數不是 t 需要判斷哪些記錄來擷取指定的頁面時，它會指示分頁介面。</span><span class="sxs-lookup"><span data-stu-id="082d8-134">While this variable isn t needed to determine what records to retrieve for a given page, it does dictate the paging interface.</span></span> <span data-ttu-id="082d8-135">比方說，如果有 81 產品正在透過分頁，分頁介面知道分頁 UI 中顯示九個的頁碼。</span><span class="sxs-lookup"><span data-stu-id="082d8-135">For example, if there are 81 products being paged through, the paging interface knows to display nine page numbers in the paging UI.</span></span>

<span data-ttu-id="082d8-136">使用預設分頁開始的資料列索引會計算為頁面索引和頁面大小加上一個項目，產品，而最大資料列，則只是頁面大小。</span><span class="sxs-lookup"><span data-stu-id="082d8-136">With default paging, the Start Row Index is computed as the product of the page index and the page size plus one, whereas the Maximum Rows is simply the page size.</span></span> <span data-ttu-id="082d8-137">因為預設的分頁，擷取所有記錄的是已知資料庫轉譯資料，每個資料列索引的任何頁面時，藉此讓 移至啟動的資料列索引資料列是簡單的工作。</span><span class="sxs-lookup"><span data-stu-id="082d8-137">Since default paging retrieves all of the records from the database when rendering any page of data, the index for each row is known, thereby making moving to Start Row Index row a trivial task.</span></span> <span data-ttu-id="082d8-138">此外，記錄總數是供使用，因為它 s DataTable （或任何物件用來保存資料庫的結果） 中的記錄數目。</span><span class="sxs-lookup"><span data-stu-id="082d8-138">Moreover, the Total Record Count is readily available, as it s simply the number of records in the DataTable (or whatever object is being used to hold the database results).</span></span>

<span data-ttu-id="082d8-139">指定在開始資料列索引和最大資料列變數，自訂的分頁實作必須只傳回之後，開始啟動資料列索引和最多的資料錄的最大資料列數目的記錄的精確子集。</span><span class="sxs-lookup"><span data-stu-id="082d8-139">Given the Start Row Index and Maximum Rows variables, a custom paging implementation must only return the precise subset of records starting at the Start Row Index and up to Maximum Rows number of records after that.</span></span> <span data-ttu-id="082d8-140">自訂分頁提供兩個挑戰：</span><span class="sxs-lookup"><span data-stu-id="082d8-140">Custom paging provides two challenges:</span></span>

- <span data-ttu-id="082d8-141">我們必須能夠有效率地將資料列索引與整個資料，以便我們可以開始傳回指定的開始資料列索引處的記錄，透過正在分頁中的每個資料列產生關聯</span><span class="sxs-lookup"><span data-stu-id="082d8-141">We must be able to efficiently associate a row index with each row in the entire data being paged through so that we can start returning records at the specified Start Row Index</span></span>
- <span data-ttu-id="082d8-142">我們需要提供透過正在分頁的記錄總數</span><span class="sxs-lookup"><span data-stu-id="082d8-142">We need to provide the total number of records being paged through</span></span>

<span data-ttu-id="082d8-143">在下面兩個步驟中，我們將檢驗這些兩個挑戰回應所需的 SQL 指令碼。</span><span class="sxs-lookup"><span data-stu-id="082d8-143">In the next two steps we'll examine the SQL script needed to respond to these two challenges.</span></span> <span data-ttu-id="082d8-144">除了 SQL 指令碼中，我們也要 BLL 和 DAL 中實作方法。</span><span class="sxs-lookup"><span data-stu-id="082d8-144">In addition to the SQL script, we'll also need to implement methods in the DAL and BLL.</span></span>

## <a name="step-2-returning-the-total-number-of-records-being-paged-through"></a><span data-ttu-id="082d8-145">步驟 2：傳回透過正在分頁的記錄總數</span><span class="sxs-lookup"><span data-stu-id="082d8-145">Step 2: Returning the Total Number of Records Being Paged Through</span></span>

<span data-ttu-id="082d8-146">我們將探討如何擷取所顯示的網頁記錄的精確子集之前，讓 s 先看看如何傳回透過正在分頁的記錄總數。</span><span class="sxs-lookup"><span data-stu-id="082d8-146">Before we examine how to retrieve the precise subset of records for the page being displayed, let s first look at how to return the total number of records being paged through.</span></span> <span data-ttu-id="082d8-147">這項資訊才能正確地設定 [分頁] 使用者介面。</span><span class="sxs-lookup"><span data-stu-id="082d8-147">This information is needed in order to properly configure the paging user interface.</span></span> <span data-ttu-id="082d8-148">可以使用來取得特定的 SQL 查詢所傳回的記錄總數[`COUNT`彙總函式](https://msdn.microsoft.com/library/ms175997.aspx)。</span><span class="sxs-lookup"><span data-stu-id="082d8-148">The total number of records returned by a particular SQL query can be obtained by using the [`COUNT` aggregate function](https://msdn.microsoft.com/library/ms175997.aspx).</span></span> <span data-ttu-id="082d8-149">例如，若要判斷中的記錄總數`Products`資料表中，我們可以使用下列查詢：</span><span class="sxs-lookup"><span data-stu-id="082d8-149">For example, to determine the total number of records in the `Products` table, we can use the following query:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample1.sql)]

<span data-ttu-id="082d8-150">可讓新增方法以傳回這項資訊我們 DAL 的 s。</span><span class="sxs-lookup"><span data-stu-id="082d8-150">Let s add a method to our DAL that returns this information.</span></span> <span data-ttu-id="082d8-151">特別的是，我們將建立一個稱為的 DAL 方法`TotalNumberOfProducts()`執行`SELECT`如上所示的陳述式。</span><span class="sxs-lookup"><span data-stu-id="082d8-151">In particular, we'll create a DAL method called `TotalNumberOfProducts()` that executes the `SELECT` statement shown above.</span></span>

<span data-ttu-id="082d8-152">首先開啟`Northwind.xsd`中的型別資料集檔案`App_Code/DAL`資料夾。</span><span class="sxs-lookup"><span data-stu-id="082d8-152">Start by opening the `Northwind.xsd` Typed DataSet file in the `App_Code/DAL` folder.</span></span> <span data-ttu-id="082d8-153">接下來，以滑鼠右鍵按一下`ProductsTableAdapter`設計工具中，然後選擇 加入查詢。</span><span class="sxs-lookup"><span data-stu-id="082d8-153">Next, right-click on the `ProductsTableAdapter` in the Designer and choose Add Query.</span></span> <span data-ttu-id="082d8-154">因為我們已在先前的教學課程中看到這可讓我們新增對 DAL 的方法，叫用時，會執行特定 SQL 陳述式或預存程序。</span><span class="sxs-lookup"><span data-stu-id="082d8-154">As we ve seen in previous tutorials, this will allow us to add a new method to the DAL that, when invoked, will execute a particular SQL statement or stored procedure.</span></span> <span data-ttu-id="082d8-155">如同我們在先前的教學課程中的 TableAdapter 方法，這次選擇使用特定 SQL 陳述式。</span><span class="sxs-lookup"><span data-stu-id="082d8-155">As with our TableAdapter methods in previous tutorials, for this one opt to use an ad-hoc SQL statement.</span></span>

![使用特定 SQL 陳述式](efficiently-paging-through-large-amounts-of-data-vb/_static/image1.png)

<span data-ttu-id="082d8-157">**圖 1**:使用特定 SQL 陳述式</span><span class="sxs-lookup"><span data-stu-id="082d8-157">**Figure 1**: Use an Ad-Hoc SQL Statement</span></span>

<span data-ttu-id="082d8-158">在下一個畫面中，我們可以指定何種查詢來建立。</span><span class="sxs-lookup"><span data-stu-id="082d8-158">On the next screen we can specify what type of query to create.</span></span> <span data-ttu-id="082d8-159">因為此查詢會傳回單一純量值中的記錄總數`Products`資料表選擇`SELECT`傳回單一值 選項。</span><span class="sxs-lookup"><span data-stu-id="082d8-159">Since this query will return a single, scalar value the total number of records in the `Products` table choose the `SELECT` which returns a singe value option.</span></span>

![設定用於傳回單一值的 SELECT 陳述式的查詢](efficiently-paging-through-large-amounts-of-data-vb/_static/image2.png)

<span data-ttu-id="082d8-161">**圖 2**:設定用於傳回單一值的 SELECT 陳述式的查詢</span><span class="sxs-lookup"><span data-stu-id="082d8-161">**Figure 2**: Configure the Query to Use a SELECT Statement that Returns a Single Value</span></span>

<span data-ttu-id="082d8-162">之後，指出要使用的查詢類型，我們接下來必須指定查詢。</span><span class="sxs-lookup"><span data-stu-id="082d8-162">After indicating the type of query to use, we must next specify the query.</span></span>

![使用選取的 COUNT(\*) 從產品的查詢](efficiently-paging-through-large-amounts-of-data-vb/_static/image3.png)

<span data-ttu-id="082d8-164">**圖 3**:使用 SELECT COUNT (\*) FROM 產品查詢</span><span class="sxs-lookup"><span data-stu-id="082d8-164">**Figure 3**: Use the SELECT COUNT(\*) FROM Products Query</span></span>

<span data-ttu-id="082d8-165">最後，指定方法的名稱。</span><span class="sxs-lookup"><span data-stu-id="082d8-165">Finally, specify the name for the method.</span></span> <span data-ttu-id="082d8-166">使用上述、 let s `TotalNumberOfProducts`。</span><span class="sxs-lookup"><span data-stu-id="082d8-166">As aforementioned, let s use `TotalNumberOfProducts`.</span></span>

![命名 DAL 方法 TotalNumberOfProducts](efficiently-paging-through-large-amounts-of-data-vb/_static/image4.png)

<span data-ttu-id="082d8-168">**圖 4**:命名 DAL 方法 TotalNumberOfProducts</span><span class="sxs-lookup"><span data-stu-id="082d8-168">**Figure 4**: Name the DAL Method TotalNumberOfProducts</span></span>

<span data-ttu-id="082d8-169">之後按一下 [完成]，精靈會將`TotalNumberOfProducts`DAL 的方法。</span><span class="sxs-lookup"><span data-stu-id="082d8-169">After clicking Finish, the wizard will add the `TotalNumberOfProducts` method to the DAL.</span></span> <span data-ttu-id="082d8-170">DAL 中的純量傳回方法會傳回可為 null 的型別，如果 SQL 查詢的結果是`NULL`。</span><span class="sxs-lookup"><span data-stu-id="082d8-170">The scalar returning methods in the DAL return nullable types, in case the result from the SQL query is `NULL`.</span></span> <span data-ttu-id="082d8-171">我們`COUNT`查詢，不過，一律會傳回非`NULL`值，不論如何，DAL 方法會傳回可為 null 的整數。</span><span class="sxs-lookup"><span data-stu-id="082d8-171">Our `COUNT` query, however, will always return a non-`NULL` value; regardless, the DAL method returns a nullable integer.</span></span>

<span data-ttu-id="082d8-172">除了使用 DAL 方法時，我們也會需要到 BLL 中的方法。</span><span class="sxs-lookup"><span data-stu-id="082d8-172">In addition to the DAL method, we also need a method in the BLL.</span></span> <span data-ttu-id="082d8-173">開啟`ProductsBLL`類別檔案，然後將`TotalNumberOfProducts`方法，只會呼叫向下到 DAL`TotalNumberOfProducts`方法：</span><span class="sxs-lookup"><span data-stu-id="082d8-173">Open the `ProductsBLL` class file and add a `TotalNumberOfProducts` method that simply calls down to the DAL s `TotalNumberOfProducts` method:</span></span>

[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample2.vb)]

<span data-ttu-id="082d8-174">DAL s`TotalNumberOfProducts`方法會傳回可為 null 的整數; 不過，我們建立的 ve`ProductsBLL`類別的`TotalNumberOfProducts`方法，讓它傳回標準的整數。</span><span class="sxs-lookup"><span data-stu-id="082d8-174">The DAL s `TotalNumberOfProducts` method returns a nullable integer; however, we ve created the `ProductsBLL` class s `TotalNumberOfProducts` method so that it returns a standard integer.</span></span> <span data-ttu-id="082d8-175">因此，我們需要有`ProductsBLL`類別 s`TotalNumberOfProducts`方法會傳回可為 null 的整數 DAL s 所傳回的值部分`TotalNumberOfProducts`方法。</span><span class="sxs-lookup"><span data-stu-id="082d8-175">Therefore, we need to have the `ProductsBLL` class s `TotalNumberOfProducts` method return the value portion of the nullable integer returned by the DAL s `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="082d8-176">若要在呼叫`GetValueOrDefault()`傳回的值可為 null 的整數，如果有的話，可為 null 的整數是否`null`，不過，它會傳回預設的整數值為 0。</span><span class="sxs-lookup"><span data-stu-id="082d8-176">The call to `GetValueOrDefault()` returns the value of the nullable integer, if it exists; if the nullable integer is `null`, however, it returns the default integer value, 0.</span></span>

## <a name="step-3-returning-the-precise-subset-of-records"></a><span data-ttu-id="082d8-177">步驟 3：傳回記錄的精確子集</span><span class="sxs-lookup"><span data-stu-id="082d8-177">Step 3: Returning the Precise Subset of Records</span></span>

<span data-ttu-id="082d8-178">下一步是建立 DAL 和 BLL 接受開始的資料列索引中的方法和稍早所述最大資料列變數，並傳回適當的記錄。</span><span class="sxs-lookup"><span data-stu-id="082d8-178">Our next task is to create methods in the DAL and BLL that accept the Start Row Index and Maximum Rows variables discussed earlier and return the appropriate records.</span></span> <span data-ttu-id="082d8-179">這樣做之前，可讓 s 先來看看所需的 SQL 指令碼。</span><span class="sxs-lookup"><span data-stu-id="082d8-179">Before we do that, let s first look at the needed SQL script.</span></span> <span data-ttu-id="082d8-180">我們面臨的挑戰是，我們必須能夠有效率地將索引指派給每個資料列中，這樣我們就可以還原起始數量為啟動的資料列索引 （最多的記錄最大記錄數目） 的記錄，透過正在分頁的整個結果。</span><span class="sxs-lookup"><span data-stu-id="082d8-180">The challenge facing us is that we must be able to efficiently assign an index to each row in the entire results being paged through so that we can return just those records starting at the Start Row Index (and up to the Maximum Records number of records).</span></span>

<span data-ttu-id="082d8-181">如果做為資料列索引的資料庫資料表中已經有資料行，這是不一項挑戰。</span><span class="sxs-lookup"><span data-stu-id="082d8-181">This is not a challenge if there is already a column in the database table that serves as a row index.</span></span> <span data-ttu-id="082d8-182">第一眼看我們可能會認為`Products`表格 s`ProductID`欄位即已足夠，因為第一項產品有`ProductID`為 1，2，第二個，依此類推。</span><span class="sxs-lookup"><span data-stu-id="082d8-182">At first glance we might think that the `Products` table s `ProductID` field would suffice, as the first product has `ProductID` of 1, the second a 2, and so on.</span></span> <span data-ttu-id="082d8-183">不過，正在刪除產品會留下間距的順序，請取消這種方法。</span><span class="sxs-lookup"><span data-stu-id="082d8-183">However, deleting a product leaves a gap in the sequence, nullifying this approach.</span></span>

<span data-ttu-id="082d8-184">有兩個一般技巧可用來有效率地將資料列索引產生關聯的資料進行分頁，因此會啟用要擷取的記錄的精確子集：</span><span class="sxs-lookup"><span data-stu-id="082d8-184">There are two general techniques used to efficiently associate a row index with the data to page through, thereby enabling the precise subset of records to be retrieved:</span></span>

- <span data-ttu-id="082d8-185">**使用 SQL Server 2005 s`ROW_NUMBER()`關鍵字**到 SQL Server 2005、 新`ROW_NUMBER()`關鍵字關聯每個傳回的記錄，根據某些排序次序。</span><span class="sxs-lookup"><span data-stu-id="082d8-185">**Using SQL Server 2005 s `ROW_NUMBER()` Keyword** new to SQL Server 2005, the `ROW_NUMBER()` keyword associates a ranking with each returned record based on some ordering.</span></span> <span data-ttu-id="082d8-186">這個等級可以作為每個資料列的資料列索引。</span><span class="sxs-lookup"><span data-stu-id="082d8-186">This ranking can be used as a row index for each row.</span></span>
- <span data-ttu-id="082d8-187">**使用資料表變數和`SET ROWCOUNT`**  SQL Server s [ `SET ROWCOUNT`陳述式](https://msdn.microsoft.com/library/ms188774.aspx)可用來指定查詢應處理終止; 之前的總記錄數目[資料表變數](http://www.sqlteam.com/item.asp?ItemID=9454)是可以保存表格式資料、 akin 至本機 T-SQL 變數[暫存資料表](http://www.sqlteam.com/item.asp?ItemID=2029)。</span><span class="sxs-lookup"><span data-stu-id="082d8-187">**Using a Table Variable and `SET ROWCOUNT`** SQL Server s [`SET ROWCOUNT` statement](https://msdn.microsoft.com/library/ms188774.aspx) can be used to specify how many total records a query should process before terminating; [table variables](http://www.sqlteam.com/item.asp?ItemID=9454) are local T-SQL variables that can hold tabular data, akin to [temporary tables](http://www.sqlteam.com/item.asp?ItemID=2029).</span></span> <span data-ttu-id="082d8-188">這個方法同樣適用於 Microsoft SQL Server 2005 和 SQL Server 2000 (而`ROW_NUMBER()`方法僅適用於 SQL Server 2005)。</span><span class="sxs-lookup"><span data-stu-id="082d8-188">This approach works equally well with both Microsoft SQL Server 2005 and SQL Server 2000 (whereas the `ROW_NUMBER()` approach only works with SQL Server 2005).</span></span>  
  
  <span data-ttu-id="082d8-189">這裡的概念是建立資料表變數具有`IDENTITY`資料行和資料表的主要金鑰，透過呼叫其中的資料，資料行。</span><span class="sxs-lookup"><span data-stu-id="082d8-189">The idea here is to create a table variable that has an `IDENTITY` column and columns for the primary keys of the table whose data is being paged through.</span></span> <span data-ttu-id="082d8-190">接下來，透過呼叫其中的資料，資料表的內容傾印到資料表變數中，藉此建立關聯的循序資料列的索引 (透過`IDENTITY`資料行) 資料表中的每一筆記錄。</span><span class="sxs-lookup"><span data-stu-id="082d8-190">Next, the contents of the table whose data is being paged through is dumped into the table variable, thereby associating a sequential row index (via the `IDENTITY` column) for each record in the table.</span></span> <span data-ttu-id="082d8-191">一旦已填入此資料表變數，`SELECT`資料表變數中，陳述式與基礎資料表的聯結，可以執行，以提取出特定的記錄。</span><span class="sxs-lookup"><span data-stu-id="082d8-191">Once the table variable has been populated, a `SELECT` statement on the table variable, joined with the underlying table, can be executed to pull out the particular records.</span></span> <span data-ttu-id="082d8-192">`SET ROWCOUNT`陳述式用來以智慧方式限制要傾印到資料表變數的記錄數目。</span><span class="sxs-lookup"><span data-stu-id="082d8-192">The `SET ROWCOUNT` statement is used to intelligently limit the number of records that need to be dumped into the table variable.</span></span>  
  
  <span data-ttu-id="082d8-193">這種方法的效率根據所要求的頁面數目為`SET ROWCOUNT`值會指派值開始的資料列索引，再加上最大資料列。</span><span class="sxs-lookup"><span data-stu-id="082d8-193">This approach s efficiency is based on the page number being requested, as the `SET ROWCOUNT` value is assigned the value of Start Row Index plus the Maximum Rows.</span></span> <span data-ttu-id="082d8-194">透過低編號的頁面，例如第一個分頁的資料的幾個頁面時這種方法是非常有效率。</span><span class="sxs-lookup"><span data-stu-id="082d8-194">When paging through low-numbered pages such as the first few pages of data this approach is very efficient.</span></span> <span data-ttu-id="082d8-195">不過，它所表現的預設分頁類似的效能時擷取即將結束頁面。</span><span class="sxs-lookup"><span data-stu-id="082d8-195">However, it exhibits default paging-like performance when retrieving a page near the end.</span></span>

<span data-ttu-id="082d8-196">本教學課程可讓您實作自訂分頁使用`ROW_NUMBER()`關鍵字。</span><span class="sxs-lookup"><span data-stu-id="082d8-196">This tutorial implements custom paging using the `ROW_NUMBER()` keyword.</span></span> <span data-ttu-id="082d8-197">如需有關使用資料表變數和`SET ROWCOUNT`技巧，請參閱 <<c2> [ 詳細有效率的方法之分頁透過大型結果集](http://www.4guysfromrolla.com/webtech/042606-1.shtml)。</span><span class="sxs-lookup"><span data-stu-id="082d8-197">For more information on using the table variable and `SET ROWCOUNT` technique, see [A More Efficient Method for Paging Through Large Result Sets](http://www.4guysfromrolla.com/webtech/042606-1.shtml).</span></span>

<span data-ttu-id="082d8-198">`ROW_NUMBER()`透過使用下列語法的特定順序傳回每一筆記錄與關鍵字相關聯的等級：</span><span class="sxs-lookup"><span data-stu-id="082d8-198">The `ROW_NUMBER()` keyword associated a ranking with each record returned over a particular ordering using the following syntax:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample3.sql)]

<span data-ttu-id="082d8-199">`ROW_NUMBER()` 傳回指定的陣序與指定的順序的每一筆記錄的數值。</span><span class="sxs-lookup"><span data-stu-id="082d8-199">`ROW_NUMBER()` returns a numerical value that specifies the rank for each record with regards to the indicated ordering.</span></span> <span data-ttu-id="082d8-200">例如，若要查看每項產品的順序排序大部分的陣序成本最低，我們可以使用下列查詢：</span><span class="sxs-lookup"><span data-stu-id="082d8-200">For example, to see the rank for each product, ordered from the most expensive to the least, we could use the following query:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample4.sql)]

<span data-ttu-id="082d8-201">圖 5 顯示這項查詢 s 透過 Visual Studio 中的 查詢 視窗中執行時的結果。</span><span class="sxs-lookup"><span data-stu-id="082d8-201">Figure 5 shows this query s results when run through the query window in Visual Studio.</span></span> <span data-ttu-id="082d8-202">請注意，產品會按照價格，以及每個資料列的價格陣序規範。</span><span class="sxs-lookup"><span data-stu-id="082d8-202">Note that the products are ordered by price, along with a price rank for each row.</span></span>

![價格陣序規範所包含的每個傳回的記錄](efficiently-paging-through-large-amounts-of-data-vb/_static/image5.png)

<span data-ttu-id="082d8-204">**圖 5**:價格陣序規範所包含的每個傳回的記錄</span><span class="sxs-lookup"><span data-stu-id="082d8-204">**Figure 5**: The Price Rank is Included for Each Returned Record</span></span>

> [!NOTE]
> <span data-ttu-id="082d8-205">`ROW_NUMBER()` 有許多新的排名函數，其中有一個 SQL Server 2005。</span><span class="sxs-lookup"><span data-stu-id="082d8-205">`ROW_NUMBER()` is just one of the many new ranking functions available in SQL Server 2005.</span></span> <span data-ttu-id="082d8-206">如需更深入瞭解`ROW_NUMBER()`，以及其他排名函式，讀取[傳回等級結果與 Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml)。</span><span class="sxs-lookup"><span data-stu-id="082d8-206">For a more thorough discussion of `ROW_NUMBER()`, along with the other ranking functions, read [Returning Ranked Results with Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml).</span></span>

<span data-ttu-id="082d8-207">當指定排名結果`ORDER BY`中的資料行`OVER`子句 (`UnitPrice`，在上述範例中)，SQL Server 必須排序結果。</span><span class="sxs-lookup"><span data-stu-id="082d8-207">When ranking the results by the specified `ORDER BY` column in the `OVER` clause (`UnitPrice`, in the above example), SQL Server must sort the results.</span></span> <span data-ttu-id="082d8-208">這是快速的作業，如果沒有叢集的索引上的結果，依排序的資料行，或是否涵蓋編製索引，但可以否則成本更高。</span><span class="sxs-lookup"><span data-stu-id="082d8-208">This is a quick operation if there is a clustered index over the column(s) the results are being ordered by, or if there is a covering index, but can be more costly otherwise.</span></span> <span data-ttu-id="082d8-209">若要改善夠大的查詢的效能，請考慮將結果依排序的資料行的非叢集索引。</span><span class="sxs-lookup"><span data-stu-id="082d8-209">To help improve performance for sufficiently large queries, consider adding a non-clustered index for the column by which the results are ordered by.</span></span> <span data-ttu-id="082d8-210">請參閱[排名函式和 SQL Server 2005 中的效能](http://www.sql-server-performance.com/ak_ranking_functions.asp)的效能考量，詳細查看。</span><span class="sxs-lookup"><span data-stu-id="082d8-210">See [Ranking Functions and Performance in SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) for a more detailed look at the performance considerations.</span></span>

<span data-ttu-id="082d8-211">所傳回的等級資訊`ROW_NUMBER()`無法直接用於`WHERE`子句。</span><span class="sxs-lookup"><span data-stu-id="082d8-211">The ranking information returned by `ROW_NUMBER()` cannot directly be used in the `WHERE` clause.</span></span> <span data-ttu-id="082d8-212">不過，使用衍生的資料表，傳回`ROW_NUMBER()`結果，然後可以出現在`WHERE`子句。</span><span class="sxs-lookup"><span data-stu-id="082d8-212">However, a derived table can be used to return the `ROW_NUMBER()` result, which can then appear in the `WHERE` clause.</span></span> <span data-ttu-id="082d8-213">例如，下列查詢會使用衍生的資料表傳回產品名稱和單價的資料行，連同`ROW_NUMBER()`結果，然後再使用`WHERE`子句只傳回這些產品的價格陣序規範為 11 到 20 之間：</span><span class="sxs-lookup"><span data-stu-id="082d8-213">For example, the following query uses a derived table to return the ProductName and UnitPrice columns, along with the `ROW_NUMBER()` result, and then uses a `WHERE` clause to only return those products whose price rank is between 11 and 20:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample5.sql)]

<span data-ttu-id="082d8-214">擴充這個概念更進一步，我們可以利用這種方法來擷取資料所需的啟動資料列索引和資料列的上限值的特定頁面：</span><span class="sxs-lookup"><span data-stu-id="082d8-214">Extending this concept a bit further, we can utilize this approach to retrieve a specific page of data given the desired Start Row Index and Maximum Rows values:</span></span>

[!code-html[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample6.html)]

> [!NOTE]
> <span data-ttu-id="082d8-215">我們將在本教學課程中，於稍後看到*`StartRowIndex`* 所提供的 ObjectDataSource 會編製索引開頭為零，而`ROW_NUMBER()`SQL Server 2005 所傳回的值編製索引從 1 開始。</span><span class="sxs-lookup"><span data-stu-id="082d8-215">As we will see later on in this tutorial, the *`StartRowIndex`* supplied by the ObjectDataSource is indexed starting at zero, whereas the `ROW_NUMBER()` value returned by SQL Server 2005 is indexed starting at 1.</span></span> <span data-ttu-id="082d8-216">因此，`WHERE`子句會傳回的記錄位置`PriceRank`必定大於*`StartRowIndex`* 且小於或等於*`StartRowIndex`*  + *`MaximumRows`*.</span><span class="sxs-lookup"><span data-stu-id="082d8-216">Therefore, the `WHERE` clause returns those records where `PriceRank` is strictly greater than *`StartRowIndex`* and less than or equal to *`StartRowIndex`* + *`MaximumRows`*.</span></span>

<span data-ttu-id="082d8-217">現在我們已討論過如何`ROW_NUMBER()`可以是用來擷取特定分頁開始的資料列索引和資料列數上限值的資料，我們現在必須實作此邏輯為 BLL 和 DAL 中的方法。</span><span class="sxs-lookup"><span data-stu-id="082d8-217">Now that we ve discussed how `ROW_NUMBER()` can be used to retrieve a particular page of data given the Start Row Index and Maximum Rows values, we now need to implement this logic as methods in the DAL and BLL.</span></span>

<span data-ttu-id="082d8-218">建立此查詢，我們必須決定的順序時的結果排列次序;可讓 s 依其名稱的字母順序排序的產品。</span><span class="sxs-lookup"><span data-stu-id="082d8-218">When creating this query we must decide the ordering by which the results will be ranked; let s sort the products by their name in alphabetical order.</span></span> <span data-ttu-id="082d8-219">這表示，使用自訂分頁實作在本教學課程中我們將無法建立自訂的分頁的報表，也可以儲存非。</span><span class="sxs-lookup"><span data-stu-id="082d8-219">This means that with the custom paging implementation in this tutorial we will not be able to create a custom paged report than can also be sorted.</span></span> <span data-ttu-id="082d8-220">在下一個教學課程中，不過，我們會看到如何可以提供這類功能。</span><span class="sxs-lookup"><span data-stu-id="082d8-220">In the next tutorial, though, we'll see how such functionality can be provided.</span></span>

<span data-ttu-id="082d8-221">在上一節中，我們會建立 DAL 方法當成特定 SQL 陳述式。</span><span class="sxs-lookup"><span data-stu-id="082d8-221">In the previous section we created the DAL method as an ad-hoc SQL statement.</span></span> <span data-ttu-id="082d8-222">不幸的是，在 Visual Studio 中使用 TableAdapter 精靈不 t，例如 T-SQL 剖析器`OVER`所使用的語法`ROW_NUMBER()`函式。</span><span class="sxs-lookup"><span data-stu-id="082d8-222">Unfortunately, the T-SQL parser in Visual Studio used by the TableAdapter wizard doesn t like the `OVER` syntax used by the `ROW_NUMBER()` function.</span></span> <span data-ttu-id="082d8-223">因此，我們必須建立這個 DAL 方法做為預存程序。</span><span class="sxs-lookup"><span data-stu-id="082d8-223">Therefore, we must create this DAL method as a stored procedure.</span></span> <span data-ttu-id="082d8-224">從 [檢視] 功能表 （或叫用的 Ctrl + Alt + S） 中選取 [伺服器總管] 中，展開`NORTHWND.MDF`節點。</span><span class="sxs-lookup"><span data-stu-id="082d8-224">Select the Server Explorer from the View menu (or hit Ctrl+Alt+S) and expand the `NORTHWND.MDF` node.</span></span> <span data-ttu-id="082d8-225">若要加入新的預存程序，以滑鼠右鍵按一下 預存程序 節點，並選擇 加入新的預存程序 （請參閱 圖 6）。</span><span class="sxs-lookup"><span data-stu-id="082d8-225">To add a new stored procedure, right-click on the Stored Procedures node and choose Add a New Stored Procedure (see Figure 6).</span></span>

![加入新的預存程序，透過產品的分頁](efficiently-paging-through-large-amounts-of-data-vb/_static/image6.png)

<span data-ttu-id="082d8-227">**圖 6**:加入新的預存程序，透過產品的分頁</span><span class="sxs-lookup"><span data-stu-id="082d8-227">**Figure 6**: Add a New Stored Procedure for Paging Through the Products</span></span>

<span data-ttu-id="082d8-228">這個預存程序應該接受兩個整數輸入的參數-`@startRowIndex`和`@maximumRows`並用`ROW_NUMBER()`函式依`ProductName`欄位中，僅傳回那些資料列大於指定`@startRowIndex`和小於或相等`@startRowIndex`  +  `@maximumRow` s。</span><span class="sxs-lookup"><span data-stu-id="082d8-228">This stored procedure should accept two integer input parameters - `@startRowIndex` and `@maximumRows` and use the `ROW_NUMBER()` function ordered by the `ProductName` field, returning only those rows greater than the specified `@startRowIndex` and less than or equal to `@startRowIndex` + `@maximumRow` s.</span></span> <span data-ttu-id="082d8-229">下列指令碼輸入新的預存程序，然後按一下 加入資料庫中的預存程序的 儲存 圖示。</span><span class="sxs-lookup"><span data-stu-id="082d8-229">Enter the following script into the new stored procedure and then click the Save icon to add the stored procedure to the database.</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample7.sql)]

<span data-ttu-id="082d8-230">建立預存程序之後, 請花一點時間加以測試。以滑鼠右鍵按一下`GetProductsPaged`預存程序 [伺服器總管] 中的名稱，然後選擇 [執行] 選項。</span><span class="sxs-lookup"><span data-stu-id="082d8-230">After creating the stored procedure, take a moment to test it out. Right-click on the `GetProductsPaged` stored procedure name in the Server Explorer and choose the Execute option.</span></span> <span data-ttu-id="082d8-231">Visual Studio 接著會提示您輸入的參數，如`@startRowIndex`和`@maximumRow`s （請參閱 圖 7）。</span><span class="sxs-lookup"><span data-stu-id="082d8-231">Visual Studio will then prompt you for the input parameters, `@startRowIndex` and `@maximumRow` s (see Figure 7).</span></span> <span data-ttu-id="082d8-232">請嘗試不同的值，並檢查結果。</span><span class="sxs-lookup"><span data-stu-id="082d8-232">Try different values and examine the results.</span></span>

![輸入的值@startRowIndex和@maximumRows參數](efficiently-paging-through-large-amounts-of-data-vb/_static/image7.png)

<span data-ttu-id="082d8-234"><strong>圖 7</strong>:輸入的值@startRowIndex和@maximumRows參數</span><span class="sxs-lookup"><span data-stu-id="082d8-234"><strong>Figure 7</strong>: Enter a Value for the @startRowIndex and @maximumRows Parameters</span></span>

<span data-ttu-id="082d8-235">在之後選擇這些輸入參數值，[輸出] 視窗會顯示結果。</span><span class="sxs-lookup"><span data-stu-id="082d8-235">After choosing these input parameters values, the Output window will show the results.</span></span> <span data-ttu-id="082d8-236">圖 8 顯示兩個 10 中傳遞時的結果`@startRowIndex`和`@maximumRows`參數。</span><span class="sxs-lookup"><span data-stu-id="082d8-236">Figure 8 shows the results when passing in 10 for both the `@startRowIndex` and `@maximumRows` parameters.</span></span>

<span data-ttu-id="082d8-237">[![會傳回記錄，就會出現在第二個頁面的資料](efficiently-paging-through-large-amounts-of-data-vb/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image8.png)</span><span class="sxs-lookup"><span data-stu-id="082d8-237">[![The Records That Would Appear in the Second Page of Data are Returned](efficiently-paging-through-large-amounts-of-data-vb/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image8.png)</span></span>

<span data-ttu-id="082d8-238">**圖 8**:記錄，就會出現在第二個頁面的資料會傳回 ([按一下以檢視完整大小的影像](efficiently-paging-through-large-amounts-of-data-vb/_static/image10.png))</span><span class="sxs-lookup"><span data-stu-id="082d8-238">**Figure 8**: The Records That Would Appear in the Second Page of Data are Returned ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image10.png))</span></span>

<span data-ttu-id="082d8-239">與這個預存程序建立，我們準備好建立`ProductsTableAdapter`方法。</span><span class="sxs-lookup"><span data-stu-id="082d8-239">With this stored procedure created, we re ready to create the `ProductsTableAdapter` method.</span></span> <span data-ttu-id="082d8-240">開啟`Northwind.xsd`具類型的資料集，以滑鼠右鍵按一下`ProductsTableAdapter`，然後選擇 加入查詢選項。</span><span class="sxs-lookup"><span data-stu-id="082d8-240">Open the `Northwind.xsd` Typed DataSet, right-click in the `ProductsTableAdapter`, and choose the Add Query option.</span></span> <span data-ttu-id="082d8-241">而不是建立使用特定 SQL 陳述式的查詢，建立使用現有的預存程序。</span><span class="sxs-lookup"><span data-stu-id="082d8-241">Instead of creating the query using an ad-hoc SQL statement, create it using an existing stored procedure.</span></span>

![建立使用現有的預存程序的 DAL 方法](efficiently-paging-through-large-amounts-of-data-vb/_static/image11.png)

<span data-ttu-id="082d8-243">**圖 9**:建立使用現有的預存程序的 DAL 方法</span><span class="sxs-lookup"><span data-stu-id="082d8-243">**Figure 9**: Create the DAL Method Using an Existing Stored Procedure</span></span>

<span data-ttu-id="082d8-244">接下來，我們會提示您選取要叫用的預存程序。</span><span class="sxs-lookup"><span data-stu-id="082d8-244">Next, we are prompted to select the stored procedure to invoke.</span></span> <span data-ttu-id="082d8-245">挑選`GetProductsPaged`預存程序，從下拉式清單。</span><span class="sxs-lookup"><span data-stu-id="082d8-245">Pick the `GetProductsPaged` stored procedure from the drop-down list.</span></span>

![選擇 GetProductsPaged 預存程序，從下拉式清單](efficiently-paging-through-large-amounts-of-data-vb/_static/image12.png)

<span data-ttu-id="082d8-247">**圖 10**:選擇 GetProductsPaged 預存程序，從下拉式清單</span><span class="sxs-lookup"><span data-stu-id="082d8-247">**Figure 10**: Choose the GetProductsPaged Stored Procedure from the Drop-Down List</span></span>

<span data-ttu-id="082d8-248">下一個畫面則會要求您的資料類型由預存程序： 表格式資料、 單一值或沒有值。</span><span class="sxs-lookup"><span data-stu-id="082d8-248">The next screen then asks you what kind of data is returned by the stored procedure: tabular data, a single value, or no value.</span></span> <span data-ttu-id="082d8-249">因為`GetProductsPaged`預存程序可以傳回多筆記錄，表示它會傳回表格式資料。</span><span class="sxs-lookup"><span data-stu-id="082d8-249">Since the `GetProductsPaged` stored procedure can return multiple records, indicate that it returns tabular data.</span></span>

![指出預存程序會傳回表格式資料](efficiently-paging-through-large-amounts-of-data-vb/_static/image13.png)

<span data-ttu-id="082d8-251">**圖 11**:指出預存程序會傳回表格式資料</span><span class="sxs-lookup"><span data-stu-id="082d8-251">**Figure 11**: Indicate that the Stored Procedure Returns Tabular Data</span></span>

<span data-ttu-id="082d8-252">最後，指明您要建立方法的名稱。</span><span class="sxs-lookup"><span data-stu-id="082d8-252">Finally, indicate the names of the methods you want to have created.</span></span> <span data-ttu-id="082d8-253">如同我們先前的教學課程，請繼續使用這兩種填滿方法 DataTable 及建立傳回 DataTable。</span><span class="sxs-lookup"><span data-stu-id="082d8-253">As with our previous tutorials, go ahead and create methods using both the Fill a DataTable and Return a DataTable.</span></span> <span data-ttu-id="082d8-254">第一個方法命名`FillPaged`而第二個`GetProductsPaged`。</span><span class="sxs-lookup"><span data-stu-id="082d8-254">Name the first method `FillPaged` and the second `GetProductsPaged`.</span></span>

![名稱方法 FillPaged 和 GetProductsPaged](efficiently-paging-through-large-amounts-of-data-vb/_static/image14.png)

<span data-ttu-id="082d8-256">**圖 12**:名稱方法 FillPaged 和 GetProductsPaged</span><span class="sxs-lookup"><span data-stu-id="082d8-256">**Figure 12**: Name the Methods FillPaged and GetProductsPaged</span></span>

<span data-ttu-id="082d8-257">此外若要建立 DAL 方法，以傳回特定頁面的產品，我們也要提供這類 BLL 中的功能。</span><span class="sxs-lookup"><span data-stu-id="082d8-257">In addition to created a DAL method to return a particular page of products, we also need to provide such functionality in the BLL.</span></span> <span data-ttu-id="082d8-258">DAL 方法，例如 BLL 的 GetProductsPaged 方法必須接受兩個整數輸入來指定開始的資料列索引和最大資料列，並必須傳回只在指定的範圍內的記錄。</span><span class="sxs-lookup"><span data-stu-id="082d8-258">Like the DAL method, the BLL s GetProductsPaged method must accept two integer inputs for specifying the Start Row Index and Maximum Rows, and must return just those records that fall within the specified range.</span></span> <span data-ttu-id="082d8-259">建立這類 BLL 方法在 ProductsBLL 類別只是呼叫向下的 DAL 的 GetProductsPaged 方法，就像這樣：</span><span class="sxs-lookup"><span data-stu-id="082d8-259">Create such a BLL method in the ProductsBLL class that merely calls down into the DAL s GetProductsPaged method, like so:</span></span>

[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample8.vb)]

<span data-ttu-id="082d8-260">您可以使用任何名稱對於 BLL 方法 s 輸入參數，但就像我們在不久之後，會選擇使用`startRowIndex`和`maximumRows`命名可以免去從額外的設定才能使用此方法的 ObjectDataSource 時的工作。</span><span class="sxs-lookup"><span data-stu-id="082d8-260">You can use any name for the BLL method s input parameters, but, as we will see shortly, choosing to use `startRowIndex` and `maximumRows` saves us from an extra bit of work when configuring an ObjectDataSource to use this method.</span></span>

## <a name="step-4-configuring-the-objectdatasource-to-use-custom-paging"></a><span data-ttu-id="082d8-261">步驟 4：設定要使用自訂分頁 ObjectDataSource</span><span class="sxs-lookup"><span data-stu-id="082d8-261">Step 4: Configuring the ObjectDataSource to Use Custom Paging</span></span>

<span data-ttu-id="082d8-262">存取完整的記錄的特定子集的 BLL 和 DAL 方法，我們準備好建立 GridView 控制該頁面，透過其基礎的記錄，使用自訂分頁。</span><span class="sxs-lookup"><span data-stu-id="082d8-262">With the BLL and DAL methods for accessing a particular subset of records complete, we re ready to create a GridView control that pages through its underlying records using custom paging.</span></span> <span data-ttu-id="082d8-263">首先開啟`EfficientPaging.aspx`頁面中`PagingAndSorting`資料夾中，加入頁面上的 GridView，並將它設定為使用新的 ObjectDataSource 控制項。</span><span class="sxs-lookup"><span data-stu-id="082d8-263">Start by opening the `EfficientPaging.aspx` page in the `PagingAndSorting` folder, add a GridView to the page, and configure it to use a new ObjectDataSource control.</span></span> <span data-ttu-id="082d8-264">我們過去的教學課程中，我們通常必須設定為使用 ObjectDataSource`ProductsBLL`類別的`GetProducts`方法。</span><span class="sxs-lookup"><span data-stu-id="082d8-264">In our past tutorials, we often had the ObjectDataSource configured to use the `ProductsBLL` class s `GetProducts` method.</span></span> <span data-ttu-id="082d8-265">此時，不過，我們想要使用`GetProductsPaged`方法相反地，因為`GetProducts`方法會傳回*所有*資料庫中的產品而`GetProductsPaged`傳回特定部分的記錄。</span><span class="sxs-lookup"><span data-stu-id="082d8-265">This time, however, we want to use the `GetProductsPaged` method instead, since the `GetProducts` method returns *all* of the products in the database whereas `GetProductsPaged` returns just a particular subset of records.</span></span>

![設定為使用 ProductsBLL 類別的 GetProductsPaged 方法的 ObjectDataSource](efficiently-paging-through-large-amounts-of-data-vb/_static/image15.png)

<span data-ttu-id="082d8-267">**圖 13**:設定為使用 ProductsBLL 類別的 GetProductsPaged 方法的 ObjectDataSource</span><span class="sxs-lookup"><span data-stu-id="082d8-267">**Figure 13**: Configure the ObjectDataSource to Use the ProductsBLL Class s GetProductsPaged Method</span></span>

<span data-ttu-id="082d8-268">之後重新建立唯讀的 GridView，花一點時間來設定 方法 下拉式清單中插入、 更新和刪除 （無） 索引標籤。</span><span class="sxs-lookup"><span data-stu-id="082d8-268">Since we re creating a read-only GridView, take a moment to set the method drop-down list in the INSERT, UPDATE, and DELETE tabs to (None).</span></span>

<span data-ttu-id="082d8-269">接下來，ObjectDataSource 精靈會提示我們輸入的來源`GetProductsPaged`方法 s`startRowIndex`和`maximumRows`輸入參數值。</span><span class="sxs-lookup"><span data-stu-id="082d8-269">Next, the ObjectDataSource wizard prompts us for the sources of the `GetProductsPaged` method s `startRowIndex` and `maximumRows` input parameters values.</span></span> <span data-ttu-id="082d8-270">這些輸入的參數實際上為 GridView 會自動因此保留來源設定為 None，按一下 [完成]。</span><span class="sxs-lookup"><span data-stu-id="082d8-270">These input parameters will actually be set by the GridView automatically, so simply leave the source set to None and click Finish.</span></span>

![保留為 「 無的輸入的參數來源](efficiently-paging-through-large-amounts-of-data-vb/_static/image16.png)

<span data-ttu-id="082d8-272">**圖 14**:保留為 「 無的輸入的參數來源</span><span class="sxs-lookup"><span data-stu-id="082d8-272">**Figure 14**: Leave the Input Parameter Sources as None</span></span>

<span data-ttu-id="082d8-273">完成 ObjectDataSource 精靈之後，GridView 會包含 BoundField 或 CheckBoxField 每個產品的資料欄位。</span><span class="sxs-lookup"><span data-stu-id="082d8-273">After completing the ObjectDataSource wizard, the GridView will contain a BoundField or CheckBoxField for each of the product data fields.</span></span> <span data-ttu-id="082d8-274">請隨意適當地調整 GridView 外觀。</span><span class="sxs-lookup"><span data-stu-id="082d8-274">Feel free to tailor the GridView s appearance as you see fit.</span></span> <span data-ttu-id="082d8-275">我選擇只顯示 ve `ProductName`， `CategoryName`， `SupplierName`， `QuantityPerUnit`，和`UnitPrice`BoundFields。</span><span class="sxs-lookup"><span data-stu-id="082d8-275">I ve opted to display only the `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, and `UnitPrice` BoundFields.</span></span> <span data-ttu-id="082d8-276">此外，設定 GridView，以支援分頁，藉由檢查它的智慧標籤中啟用分頁 核取方塊。</span><span class="sxs-lookup"><span data-stu-id="082d8-276">Also, configure the GridView to support paging by checking the Enable Paging checkbox in its smart tag.</span></span> <span data-ttu-id="082d8-277">在這些變更之後, 的 GridView 和 ObjectDataSource 的宣告式標記看起來應該如下所示：</span><span class="sxs-lookup"><span data-stu-id="082d8-277">After these changes, the GridView and ObjectDataSource declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample9.aspx)]

<span data-ttu-id="082d8-278">如果您瀏覽透過瀏覽器頁面，不過，GridView 是位置來找到。</span><span class="sxs-lookup"><span data-stu-id="082d8-278">If you visit the page through a browser, however, the GridView is no where to be found.</span></span>

![GridView 會不會顯示](efficiently-paging-through-large-amounts-of-data-vb/_static/image17.png)

<span data-ttu-id="082d8-280">**圖 15**:GridView 會不會顯示</span><span class="sxs-lookup"><span data-stu-id="082d8-280">**Figure 15**: The GridView is Not Displayed</span></span>

<span data-ttu-id="082d8-281">GridView 遺漏，因為 ObjectDataSource 是目前正在使用 0 做為值的兩個`GetProductsPaged``startRowIndex`和`maximumRows`輸入參數。</span><span class="sxs-lookup"><span data-stu-id="082d8-281">The GridView is missing because the ObjectDataSource is currently using 0 as the values for both of the `GetProductsPaged` `startRowIndex` and `maximumRows` input parameters.</span></span> <span data-ttu-id="082d8-282">因此，產生的 SQL 查詢會傳回任何記錄，並因此 GridView 不會顯示。</span><span class="sxs-lookup"><span data-stu-id="082d8-282">Hence, the resulting SQL query is returning no records and therefore the GridView is not displayed.</span></span>

<span data-ttu-id="082d8-283">若要解決此問題，我們需要設定要使用自訂分頁 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="082d8-283">To remedy this, we need to configure the ObjectDataSource to use custom paging.</span></span> <span data-ttu-id="082d8-284">這可以完成下列步驟：</span><span class="sxs-lookup"><span data-stu-id="082d8-284">This can be accomplished in the following steps:</span></span>

1. <span data-ttu-id="082d8-285">**設定 ObjectDataSource s`EnablePaging`屬性，以`true`** 這表示它必須將它傳遞至 ObjectDataSource`SelectMethod`兩個額外參數： 一個用來指定開始的資料列索引 ([ `StartRowIndexParameterName` ](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx))，和一個用來指定最大資料列 ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx))。</span><span class="sxs-lookup"><span data-stu-id="082d8-285">**Set the ObjectDataSource s `EnablePaging` property to `true`** this indicates to the ObjectDataSource that it must pass to the `SelectMethod` two additional parameters: one to specify the Start Row Index ([`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)), and one to specify the Maximum Rows ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).</span></span>
2. <span data-ttu-id="082d8-286">**設定 ObjectDataSource s`StartRowIndexParameterName`並`MaximumRowsParameterName`據此屬性**`StartRowIndexParameterName`並`MaximumRowsParameterName`屬性會指示傳入輸入參數的名稱`SelectMethod`自訂分頁進行。</span><span class="sxs-lookup"><span data-stu-id="082d8-286">**Set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` Properties Accordingly** the `StartRowIndexParameterName` and `MaximumRowsParameterName` properties indicate the names of the input parameters passed into the `SelectMethod` for custom paging purposes.</span></span> <span data-ttu-id="082d8-287">根據預設，這些參數名稱為`startIndexRow`並`maximumRows`，這就是為什麼要建立時`GetProductsPaged`方法在 BLL，我必須使用這些值的輸入參數。</span><span class="sxs-lookup"><span data-stu-id="082d8-287">By default, these parameter names are `startIndexRow` and `maximumRows`, which is why, when creating the `GetProductsPaged` method in the BLL, I used these values for the input parameters.</span></span> <span data-ttu-id="082d8-288">如果您選擇使用不同的參數名稱，對於 BLL s`GetProductsPaged`方法，例如`startIndex`並`maxRows`，則請針對您想要的範例設定 ObjectDataSource s`StartRowIndexParameterName`和`MaximumRowsParameterName`屬性據以 （例如針對 startIndex`StartRowIndexParameterName`並為 maxRows `MaximumRowsParameterName`)。</span><span class="sxs-lookup"><span data-stu-id="082d8-288">If you chose to use different parameter names for the BLL s `GetProductsPaged` method such as `startIndex` and `maxRows`, for example you would need to set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` properties accordingly (such as startIndex for `StartRowIndexParameterName` and maxRows for `MaximumRowsParameterName`).</span></span>
3. <span data-ttu-id="082d8-289">**設定 ObjectDataSource s [ `SelectCountMethod`屬性](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx)的總計數字的記錄正在分頁會透過傳回的方法名稱 (`TotalNumberOfProducts`)** 請記得，`ProductsBLL`類別的`TotalNumberOfProducts`方法會傳回透過執行的 DAL 方法正在分頁的記錄總數`SELECT COUNT(*) FROM Products`查詢。</span><span class="sxs-lookup"><span data-stu-id="082d8-289">**Set the ObjectDataSource s [`SelectCountMethod` Property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) to the Name of the Method that Returns the Total Number of Records Being Paged Through (`TotalNumberOfProducts`)** recall that the `ProductsBLL` class s `TotalNumberOfProducts` method returns the total number of records being paged through using a DAL method that executes a `SELECT COUNT(*) FROM Products` query.</span></span> <span data-ttu-id="082d8-290">ObjectDataSource 需要這項資訊才能正確地呈現分頁介面。</span><span class="sxs-lookup"><span data-stu-id="082d8-290">This information is needed by the ObjectDataSource in order to correctly render the paging interface.</span></span>
4. <span data-ttu-id="082d8-291">**移除`startRowIndex`並`maximumRows``<asp:Parameter>`從 ObjectDataSource s 宣告式標記的項目**在設定 ObjectDataSource 執行精靈時，Visual Studio 會自動加入兩個`<asp:Parameter>`項目針對`GetProductsPaged`方法 s 的輸入參數。</span><span class="sxs-lookup"><span data-stu-id="082d8-291">**Remove the `startRowIndex` and `maximumRows` `<asp:Parameter>` Elements from the ObjectDataSource s Declarative Markup** when configuring the ObjectDataSource through the wizard, Visual Studio automatically added two `<asp:Parameter>` elements for the `GetProductsPaged` method s input parameters.</span></span> <span data-ttu-id="082d8-292">藉由設定`EnablePaging`要`true`，將會自動傳遞這些參數; 它們也會出現在宣告式語法中，如果 ObjectDataSource 會嘗試傳遞*四*參數`GetProductsPaged`方法與兩個參數`TotalNumberOfProducts`方法。</span><span class="sxs-lookup"><span data-stu-id="082d8-292">By setting `EnablePaging` to `true`, these parameters will be passed automatically; if they also appear in the declarative syntax, the ObjectDataSource will attempt to pass *four* parameters to the `GetProductsPaged` method and two parameters to the `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="082d8-293">如果您忘了移除這些`<asp:Parameter>`項目，瀏覽的頁面，透過瀏覽器就會顯示如下的錯誤訊息：*ObjectDataSource 'ObjectDataSource1' 找不到 přepisuje neobecnou metodu 具有參數的 ' TotalNumberOfProducts': startRowIndex，maximumRows*。</span><span class="sxs-lookup"><span data-stu-id="082d8-293">If you forget to remove these `<asp:Parameter>` elements, when visiting the page through a browser you'll get an error message like: *ObjectDataSource 'ObjectDataSource1' could not find a non-generic method 'TotalNumberOfProducts' that has parameters: startRowIndex, maximumRows*.</span></span>

<span data-ttu-id="082d8-294">進行這些變更之後，ObjectDataSource s 宣告式語法看起來應該如下所示：</span><span class="sxs-lookup"><span data-stu-id="082d8-294">After making these changes, the ObjectDataSource s declarative syntax should look like the following:</span></span>

[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample10.aspx)]

<span data-ttu-id="082d8-295">請注意，`EnablePaging`並`SelectCountMethod`已設定屬性和`<asp:Parameter>`已移除項目。</span><span class="sxs-lookup"><span data-stu-id="082d8-295">Note that the `EnablePaging` and `SelectCountMethod` properties have been set and the `<asp:Parameter>` elements have been removed.</span></span> <span data-ttu-id="082d8-296">[圖 16] 顯示 [屬性] 視窗的螢幕擷取畫面進行這些變更之後。</span><span class="sxs-lookup"><span data-stu-id="082d8-296">Figure 16 shows a screen shot of the Properties window after these changes have been made.</span></span>

![若要使用自訂分頁，設定 ObjectDataSource 控制項](efficiently-paging-through-large-amounts-of-data-vb/_static/image18.png)

<span data-ttu-id="082d8-298">**圖 16**:若要使用自訂分頁，設定 ObjectDataSource 控制項</span><span class="sxs-lookup"><span data-stu-id="082d8-298">**Figure 16**: To Use Custom Paging, Configure the ObjectDataSource Control</span></span>

<span data-ttu-id="082d8-299">進行這些變更之後，請瀏覽此頁面，透過瀏覽器。</span><span class="sxs-lookup"><span data-stu-id="082d8-299">After making these changes, visit this page through a browser.</span></span> <span data-ttu-id="082d8-300">您應該會看到列出，10 項產品按字母順序排序。</span><span class="sxs-lookup"><span data-stu-id="082d8-300">You should see 10 products listed, ordered alphabetically.</span></span> <span data-ttu-id="082d8-301">請花一點時間逐步一頁資料一次。</span><span class="sxs-lookup"><span data-stu-id="082d8-301">Take a moment to step through the data one page at a time.</span></span> <span data-ttu-id="082d8-302">自訂分頁更有效率地進行大量資料頁面從使用者觀點的 s 預設分頁與自訂分頁之間的視覺化差異時，，因為它只會擷取所需為指定的頁面會顯示這些記錄使用。</span><span class="sxs-lookup"><span data-stu-id="082d8-302">While there is no visual difference from the end user s perspective between default paging and custom paging, custom paging more efficiently pages through large amounts of data as it only retrieves those records that need to be displayed for a given page.</span></span>

<span data-ttu-id="082d8-303">[![資料、 依產品名稱、 Ordered 是分頁使用自訂分頁](efficiently-paging-through-large-amounts-of-data-vb/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="082d8-303">[![The Data, Ordered by the Product s Name, is Paged Using Custom Paging](efficiently-paging-through-large-amounts-of-data-vb/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image19.png)</span></span>

<span data-ttu-id="082d8-304">**圖 17**:資料、 依產品名稱、 Ordered 是分頁使用自訂分頁 ([按一下以檢視完整大小的影像](efficiently-paging-through-large-amounts-of-data-vb/_static/image21.png))</span><span class="sxs-lookup"><span data-stu-id="082d8-304">**Figure 17**: The Data, Ordered by the Product s Name, is Paged Using Custom Paging ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image21.png))</span></span>

> [!NOTE]
> <span data-ttu-id="082d8-305">使用自訂分頁時，頁面計數 ObjectDataSource s 所傳回的值`SelectCountMethod`會儲存在 GridView 的檢視狀態。</span><span class="sxs-lookup"><span data-stu-id="082d8-305">With custom paging, the page count value returned by the ObjectDataSource�s `SelectCountMethod` is stored in the GridView�s view state.</span></span> <span data-ttu-id="082d8-306">其他的 GridView 變數`PageIndex`， `EditIndex`， `SelectedIndex`，`DataKeys`集合，並依此類推會儲存在*控制狀態*，其中會保存的 GridView s 的值為何`EnableViewState`屬性。</span><span class="sxs-lookup"><span data-stu-id="082d8-306">Other GridView variables the `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` collection, and so on are stored in *control state*, which is persisted regardless of the value of the GridView�s `EnableViewState` property.</span></span> <span data-ttu-id="082d8-307">因為`PageCount`值保存在回傳時使用的分頁介面包含連結帶您前往最後一頁，使用檢視狀態，請務必啟用 GridView 的檢視狀態。</span><span class="sxs-lookup"><span data-stu-id="082d8-307">Since the `PageCount` value is persisted across postbacks using view state, when using a paging interface that includes a link to take you to the last page, it is imperative that the GridView�s view state be enabled.</span></span> <span data-ttu-id="082d8-308">（如果分頁介面沒有直接連結到最後一個頁面上，則您可能會停用檢視狀態）。</span><span class="sxs-lookup"><span data-stu-id="082d8-308">(If your paging interface does not include a direct link to the last page, then you may disable view state.)</span></span>

<span data-ttu-id="082d8-309">按一下最後一個頁面連結造成回傳，並指示 GridView，以更新其`PageIndex`屬性。</span><span class="sxs-lookup"><span data-stu-id="082d8-309">Clicking the last page link causes a postback and instructs the GridView to update its `PageIndex` property.</span></span> <span data-ttu-id="082d8-310">按一下最後一個頁面連結時，如果 GridView 會將指派其`PageIndex`屬性設為其中一個值小於其`PageCount`屬性。</span><span class="sxs-lookup"><span data-stu-id="082d8-310">If the last page link is clicked, the GridView assigns its `PageIndex` property to a value one less than its `PageCount` property.</span></span> <span data-ttu-id="082d8-311">停用檢視狀態`PageCount`值將會遺失在回傳和`PageIndex`改為指派的最大整數值。</span><span class="sxs-lookup"><span data-stu-id="082d8-311">With view state disabled, the `PageCount` value is lost across postbacks and the `PageIndex` is assigned the maximum integer value instead.</span></span> <span data-ttu-id="082d8-312">GridView 接下來，會嘗試判斷起始的資料列索引乘以`PageSize`和`PageCount`屬性。</span><span class="sxs-lookup"><span data-stu-id="082d8-312">Next, the GridView attempts to determine the starting row index by multiplying the `PageSize` and `PageCount` properties.</span></span> <span data-ttu-id="082d8-313">這會導致`OverflowException`因為產品超過允許的最大整數大小。</span><span class="sxs-lookup"><span data-stu-id="082d8-313">This results in an `OverflowException` since the product exceeds the maximum allowed integer size.</span></span>

## <a name="implement-custom-paging-and-sorting"></a><span data-ttu-id="082d8-314">實作自訂分頁和排序</span><span class="sxs-lookup"><span data-stu-id="082d8-314">Implement Custom Paging and Sorting</span></span>

<span data-ttu-id="082d8-315">我們目前的自訂分頁實作需要的資料分頁透過的順序指定以靜態方式建立時`GetProductsPaged`預存程序。</span><span class="sxs-lookup"><span data-stu-id="082d8-315">Our current custom paging implementation requires that the order by which the data is paged through be specified statically when creating the `GetProductsPaged` stored procedure.</span></span> <span data-ttu-id="082d8-316">不過，您可能已記下 GridView s 智慧標籤會包含除了啟用分頁 選項之外，啟用排序核取方塊。</span><span class="sxs-lookup"><span data-stu-id="082d8-316">However, you may have noted that the GridView s smart tag contains an Enable Sorting checkbox in addition to the Enable Paging option.</span></span> <span data-ttu-id="082d8-317">不幸的是，加入我們目前的自訂分頁實作 GridView 的排序支援時，只會排序資料的目前檢視的網頁上的記錄。</span><span class="sxs-lookup"><span data-stu-id="082d8-317">Unfortunately, adding sorting support to the GridView with our current custom paging implementation will only sort the records on the currently viewed page of data.</span></span> <span data-ttu-id="082d8-318">比方說，如果您設定也支援分頁，並檢視資料的第一頁時再，依產品名稱，依遞減順序排序 GridView 它就會在第 1 頁上反轉產品的順序。</span><span class="sxs-lookup"><span data-stu-id="082d8-318">For example, if you configure the GridView to also support paging and then, when viewing the first page of data, sort by product name in descending order, it will reverse the order of the products on page 1.</span></span> <span data-ttu-id="082d8-319">如 [圖 18] 所示，例如顯示初探為第一項產品以反向字母順序，會忽略 71 其他產品隨附之後初探，依字母順序，排序時第一頁上的這些記錄會被視為在排序。</span><span class="sxs-lookup"><span data-stu-id="082d8-319">As Figure 18 shows, such shows Carnarvon Tigers as the first product when sorting in reverse alphabetical order, which ignores the 71 other products that come after Carnarvon Tigers, alphabetically; only those records on the first page are considered in the sorting.</span></span>

<span data-ttu-id="082d8-320">[![只顯示資料目前頁面上排序](efficiently-paging-through-large-amounts-of-data-vb/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="082d8-320">[![Only the Data Shown on the Current Page is Sorted](efficiently-paging-through-large-amounts-of-data-vb/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image22.png)</span></span>

<span data-ttu-id="082d8-321">**圖 18**:只顯示資料目前頁面上的排序 ([按一下以檢視完整大小的影像](efficiently-paging-through-large-amounts-of-data-vb/_static/image24.png))</span><span class="sxs-lookup"><span data-stu-id="082d8-321">**Figure 18**: Only the Data Shown on the Current Page is Sorted ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image24.png))</span></span>

<span data-ttu-id="082d8-322">因為排序作業後已擷取的資料，從 BLL s 排序只適用於資料的目前頁面`GetProductsPaged`方法，並且此方法只會傳回特定網頁的記錄。</span><span class="sxs-lookup"><span data-stu-id="082d8-322">The sorting only applies to the current page of data because the sorting is occurring after the data has been retrieved from the BLL s `GetProductsPaged` method, and this method only returns those records for the specific page.</span></span> <span data-ttu-id="082d8-323">若要實作正確排序，我們需要將排序運算式，以`GetProductsPaged`方法，以便資料可以適當地排序傳回的資料的特定頁面之前。</span><span class="sxs-lookup"><span data-stu-id="082d8-323">To implement sorting correctly, we need to pass the sort expression to the `GetProductsPaged` method so that the data can be ranked appropriately before returning the specific page of data.</span></span> <span data-ttu-id="082d8-324">我們將了解如何在我們的下一個教學課程中完成這項作業。</span><span class="sxs-lookup"><span data-stu-id="082d8-324">We'll see how to accomplish this in our next tutorial.</span></span>

## <a name="implementing-custom-paging-and-deleting"></a><span data-ttu-id="082d8-325">實作自訂分頁和刪除</span><span class="sxs-lookup"><span data-stu-id="082d8-325">Implementing Custom Paging and Deleting</span></span>

<span data-ttu-id="082d8-326">如果您啟用的 GridView，其資料使用自訂分頁技術，您會刪除從最後一頁的最後一筆記錄時發現的分頁中的刪除功能的 GridView 會消失而不是適當減量 GridView 的`PageIndex`.</span><span class="sxs-lookup"><span data-stu-id="082d8-326">If you enabling deleting functionality in a GridView whose data is paged using custom paging techniques you will find that when deleting the last record from the last page, the GridView disappears rather than appropriately decrementing the GridView s `PageIndex`.</span></span> <span data-ttu-id="082d8-327">若要重現這個錯誤，啟用刪除本教學課程只是我們剛才建立的。</span><span class="sxs-lookup"><span data-stu-id="082d8-327">To reproduce this bug, enable deleting for the tutorial just we just created.</span></span> <span data-ttu-id="082d8-328">移至最後一頁 （第 9 頁），因為我們會透過 81 產品，一次 10 項產品分頁，應該看到單一產品。</span><span class="sxs-lookup"><span data-stu-id="082d8-328">Go to the last page (page 9), where you should see a single product since we are paging through 81 products, 10 products at a time.</span></span> <span data-ttu-id="082d8-329">刪除此產品。</span><span class="sxs-lookup"><span data-stu-id="082d8-329">Delete this product.</span></span>

<span data-ttu-id="082d8-330">一旦刪除最後一個產品，也就是 GridView*應該*自動移至第八個頁面中，並使用預設分頁時的這類功能時顯露出來。</span><span class="sxs-lookup"><span data-stu-id="082d8-330">Upon deleting the last product, the GridView *should* automatically go to the eighth page, and such functionality is exhibited with default paging.</span></span> <span data-ttu-id="082d8-331">使用自訂分頁時，不過，在刪除最後一個產品的最後一頁之後, GridView 直接從畫面消失完全。</span><span class="sxs-lookup"><span data-stu-id="082d8-331">With custom paging, however, after deleting that last product on the last page, the GridView simply disappears from the screen altogether.</span></span> <span data-ttu-id="082d8-332">精確的原因*為什麼*發生這種情況有點已超出本教學課程的範圍，請參閱[刪除最後一個記錄的最後一頁從使用自訂分頁 GridView](http://scottonwriting.net/sowblog/posts/7326.aspx)的低層級的詳細資訊，告訴的來源此問題。</span><span class="sxs-lookup"><span data-stu-id="082d8-332">The precise reason *why* this happens is a bit beyond the scope of this tutorial; see [Deleting the Last Record on the Last Page from a GridView with Custom Paging](http://scottonwriting.net/sowblog/posts/7326.aspx) for the low-level details as to the source of this problem.</span></span> <span data-ttu-id="082d8-333">總之它因為下列一連串步驟，按一下 [刪除] 按鈕時，由 GridView 的 s:</span><span class="sxs-lookup"><span data-stu-id="082d8-333">In summary it s due to the following sequence of steps that are performed by the GridView when the Delete button is clicked:</span></span>

1. <span data-ttu-id="082d8-334">刪除記錄</span><span class="sxs-lookup"><span data-stu-id="082d8-334">Delete the record</span></span>
2. <span data-ttu-id="082d8-335">取得適當的記錄，以顯示指定`PageIndex`和 `PageSize`</span><span class="sxs-lookup"><span data-stu-id="082d8-335">Get the appropriate records to display for the specified `PageIndex` and `PageSize`</span></span>
3. <span data-ttu-id="082d8-336">檢查，確定`PageIndex`不會超過資料來源中的資料頁數，如果它存在，會自動遞減 GridView 的`PageIndex`屬性</span><span class="sxs-lookup"><span data-stu-id="082d8-336">Check to ensure that the `PageIndex` does not exceed the number of pages of data in the data source; if it does, automatically decrement the GridView s `PageIndex` property</span></span>
4. <span data-ttu-id="082d8-337">將適當的頁面資料的繫結至 GridView 使用在步驟 2 中取得的記錄</span><span class="sxs-lookup"><span data-stu-id="082d8-337">Bind the appropriate page of data to the GridView using the records obtained in Step 2</span></span>

<span data-ttu-id="082d8-338">問題的起因是該在步驟 2`PageIndex`時，使用擷取要顯示的記錄仍然`PageIndex`就已刪除其唯一記錄的最後一頁。</span><span class="sxs-lookup"><span data-stu-id="082d8-338">The problem stems from the fact that in Step 2 the `PageIndex` used when grabbing the records to display is still the `PageIndex` of the last page whose sole record was just deleted.</span></span> <span data-ttu-id="082d8-339">因此，在步驟 2*沒有*會傳回記錄，因為該最後一頁的資料不再包含任何記錄。</span><span class="sxs-lookup"><span data-stu-id="082d8-339">Therefore, in Step 2, *no* records are returned since that last page of data no longer contains any records.</span></span> <span data-ttu-id="082d8-340">然後，在步驟 3: GridView 發現，其`PageIndex`屬性大於資料來源中的頁面總數 （因為我們已刪除中的最後一頁的最後一個記錄），因此將其`PageIndex`屬性。</span><span class="sxs-lookup"><span data-stu-id="082d8-340">Then, in Step 3, the GridView realizes that its `PageIndex` property is greater than the total number of pages in the data source (since we ve deleted the last record in the last page) and therefore decrements its `PageIndex` property.</span></span> <span data-ttu-id="082d8-341">步驟 4 中的 GridView 會嘗試繫結到在步驟 2 中，擷取的資料不過，在步驟 2 中不傳回的任何記錄，因此導致空的 GridView。</span><span class="sxs-lookup"><span data-stu-id="082d8-341">In Step 4 the GridView attempts to bind itself to the data retrieved in Step 2; however, in Step 2 no records were returned, therefore resulting in an empty GridView.</span></span> <span data-ttu-id="082d8-342">使用預設分頁時，此問題不 t 介面因為在步驟 2*所有*從資料來源擷取記錄。</span><span class="sxs-lookup"><span data-stu-id="082d8-342">With default paging, this problem doesn t surface because in Step 2 *all* records are retrieved from the data source.</span></span>

<span data-ttu-id="082d8-343">若要修正此問題，我們會有兩個選項。</span><span class="sxs-lookup"><span data-stu-id="082d8-343">To fix this we have two options.</span></span> <span data-ttu-id="082d8-344">第一個是建立事件處理常式 GridView s`RowDeleted`決定只是已刪除的頁面中所顯示的多少筆記錄的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="082d8-344">The first is to create an event handler for the GridView s `RowDeleted` event handler that determines how many records were displayed in the page that was just deleted.</span></span> <span data-ttu-id="082d8-345">如果發生只有一筆記錄，然後將它刪除的記錄必須已經被最後一個，我們需要遞減 GridView 的`PageIndex`。</span><span class="sxs-lookup"><span data-stu-id="082d8-345">If there was only one record, then the record just deleted must have been the last one and we need to decrement the GridView s `PageIndex`.</span></span> <span data-ttu-id="082d8-346">當然，我們只想要更新`PageIndex`實際上已成功刪除作業時，這可藉由確保`e.Exception`屬性是`null`。</span><span class="sxs-lookup"><span data-stu-id="082d8-346">Of course, we only want to update the `PageIndex` if the delete operation was actually successful, which can be determined by ensuring that the `e.Exception` property is `null`.</span></span>

<span data-ttu-id="082d8-347">這種方式適用，因為它會更新`PageIndex`在步驟 1 之後但在步驟 2 之前。</span><span class="sxs-lookup"><span data-stu-id="082d8-347">This approach works because it updates the `PageIndex` after Step 1 but before Step 2.</span></span> <span data-ttu-id="082d8-348">因此，在步驟 2 中，會傳回適當的記錄集。</span><span class="sxs-lookup"><span data-stu-id="082d8-348">Therefore, in Step 2, the appropriate set of records is returned.</span></span> <span data-ttu-id="082d8-349">若要達成此目的，使用程式碼，如下所示：</span><span class="sxs-lookup"><span data-stu-id="082d8-349">To accomplish this, use code like the following:</span></span>

[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample11.vb)]

<span data-ttu-id="082d8-350">一種解決方法是建立 ObjectDataSource s 的事件處理常式`RowDeleted`事件，並設定`AffectedRows`屬性設為 1 的值。</span><span class="sxs-lookup"><span data-stu-id="082d8-350">An alternative workaround is to create an event handler for the ObjectDataSource s `RowDeleted` event and to set the `AffectedRows` property to a value of 1.</span></span> <span data-ttu-id="082d8-351">GridView 更新後刪除記錄在步驟 1 中 （但然後再重新擷取步驟 2 中的資料），其`PageIndex`如果一或多個資料列作業所影響的屬性。</span><span class="sxs-lookup"><span data-stu-id="082d8-351">After deleting the record in Step 1 (but before re-retrieving the data in Step 2), the GridView updates its `PageIndex` property if one or more rows were affected by the operation.</span></span> <span data-ttu-id="082d8-352">不過，`AffectedRows`屬性未設定 ObjectDataSource 的因此略過此步驟。</span><span class="sxs-lookup"><span data-stu-id="082d8-352">However, the `AffectedRows` property is not set by the ObjectDataSource and therefore this step is omitted.</span></span> <span data-ttu-id="082d8-353">具有執行此步驟的一種方法是手動設定`AffectedRows`如果順利完成刪除作業的屬性。</span><span class="sxs-lookup"><span data-stu-id="082d8-353">One way to have this step executed is to manually set the `AffectedRows` property if the delete operation completes successfully.</span></span> <span data-ttu-id="082d8-354">這可以使用如下的程式碼來完成：</span><span class="sxs-lookup"><span data-stu-id="082d8-354">This can be accomplished using code like the following:</span></span>

[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample12.vb)]

<span data-ttu-id="082d8-355">這兩個這些事件處理常式的程式碼可在程式碼後置類別`EfficientPaging.aspx`範例。</span><span class="sxs-lookup"><span data-stu-id="082d8-355">The code for both of these events handlers can be found in code-behind class of the `EfficientPaging.aspx` example.</span></span>

## <a name="comparing-the-performance-of-default-and-custom-paging"></a><span data-ttu-id="082d8-356">預設和自訂分頁的效能比較</span><span class="sxs-lookup"><span data-stu-id="082d8-356">Comparing the Performance of Default and Custom Paging</span></span>

<span data-ttu-id="082d8-357">因為自訂分頁只擷取所需的記錄，則傳回預設的分頁*所有*的每個頁面記錄檢視，它 s 清除自訂分頁的效率高於預設分頁。</span><span class="sxs-lookup"><span data-stu-id="082d8-357">Since custom paging only retrieves the needed records, whereas default paging returns *all* of the records for each page being viewed, it s clear that custom paging is more efficient than default paging.</span></span> <span data-ttu-id="082d8-358">但是就是如何更有效率的是自訂分頁嗎？</span><span class="sxs-lookup"><span data-stu-id="082d8-358">But just how much more efficient is custom paging?</span></span> <span data-ttu-id="082d8-359">從預設的分頁移至自訂分頁，可以看到什麼樣的效能提升？</span><span class="sxs-lookup"><span data-stu-id="082d8-359">What sort of performance gains can be seen by moving from default paging to custom paging?</span></span>

<span data-ttu-id="082d8-360">不幸的是，沒有 s 沒有一個大小是否符合所有這裡回答。</span><span class="sxs-lookup"><span data-stu-id="082d8-360">Unfortunately, there s no one size fits all answer here.</span></span> <span data-ttu-id="082d8-361">提升的效能取決於許多因素，最著名兩位透過正在分頁的記錄和負載的數字放在 web 伺服器和資料庫伺服器之間的資料庫伺服器和通訊通道。</span><span class="sxs-lookup"><span data-stu-id="082d8-361">The performance gain depends on a number of factors, the most prominent two being the number of records being paged through and the load placed on the database server and communication channels between the web server and database server.</span></span> <span data-ttu-id="082d8-362">對於具有少數數十個記錄的小型資料表，效能差異可能微不足道。</span><span class="sxs-lookup"><span data-stu-id="082d8-362">For small tables with just a few dozen records, the performance difference may be negligible.</span></span> <span data-ttu-id="082d8-363">對於大型資料表時，有數千到數十萬個資料列，不過，效能差異。 嚴重</span><span class="sxs-lookup"><span data-stu-id="082d8-363">For large tables, with thousands to hundreds of thousands of rows, though, the performance difference is acute.</span></span>

<span data-ttu-id="082d8-364">我的發行項[SQL Server 2005 的 ASP.NET 2.0 中的自訂分頁](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx)，包含造成效能時逐頁查看的資料庫資料表有下列兩個分頁技術之間的差異執行一些效能測試50,000 筆記錄。</span><span class="sxs-lookup"><span data-stu-id="082d8-364">An article of mine, [Custom Paging in ASP.NET 2.0 with SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), contains some performance tests I ran to exhibit the differences in performance between these two paging techniques when paging through a database table with 50,000 records.</span></span> <span data-ttu-id="082d8-365">在這些測試中，我檢查的時間來執行 SQL 伺服器層級的查詢 (使用[SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) 並在 ASP.NET 網頁使用[ASP.NET 追蹤功能，s](https://msdn.microsoft.com/library/y13fw6we.aspx)。</span><span class="sxs-lookup"><span data-stu-id="082d8-365">In these tests I examined both the time to execute the query at the SQL Server level (using [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) and at the ASP.NET page using [ASP.NET s tracing features](https://msdn.microsoft.com/library/y13fw6we.aspx).</span></span> <span data-ttu-id="082d8-366">請記住，這些測試已在使用單一的作用中使用者，我開發電腦上執行，因此非，不會模擬一般網站的負載模式。</span><span class="sxs-lookup"><span data-stu-id="082d8-366">Keep in mind that these tests were run on my development box with a single active user, and therefore are unscientific and do not mimic typical website load patterns.</span></span> <span data-ttu-id="082d8-367">不論如何，結果將說明的預設和自訂分頁的執行時間的相對差異時使用夠大的資料量。</span><span class="sxs-lookup"><span data-stu-id="082d8-367">Regardless, the results illustrate the relative differences in execution time for default and custom paging when working with sufficiently large amounts of data.</span></span>

|  | <span data-ttu-id="082d8-368">**Avg.持續時間 （秒）**</span><span class="sxs-lookup"><span data-stu-id="082d8-368">**Avg. Duration (sec)**</span></span> | <span data-ttu-id="082d8-369">**讀取**</span><span class="sxs-lookup"><span data-stu-id="082d8-369">**Reads**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="082d8-370">**預設分頁 SQL Profiler**</span><span class="sxs-lookup"><span data-stu-id="082d8-370">**Default Paging SQL Profiler**</span></span> | <span data-ttu-id="082d8-371">1.411</span><span class="sxs-lookup"><span data-stu-id="082d8-371">1.411</span></span> | <span data-ttu-id="082d8-372">383</span><span class="sxs-lookup"><span data-stu-id="082d8-372">383</span></span> |
| <span data-ttu-id="082d8-373">**自訂的分頁 SQL Profiler**</span><span class="sxs-lookup"><span data-stu-id="082d8-373">**Custom Paging SQL Profiler**</span></span> | <span data-ttu-id="082d8-374">0.002</span><span class="sxs-lookup"><span data-stu-id="082d8-374">0.002</span></span> | <span data-ttu-id="082d8-375">29</span><span class="sxs-lookup"><span data-stu-id="082d8-375">29</span></span> |
| <span data-ttu-id="082d8-376">**預設的分頁 ASP.NET 追蹤**</span><span class="sxs-lookup"><span data-stu-id="082d8-376">**Default Paging ASP.NET Trace**</span></span> | <span data-ttu-id="082d8-377">2.379</span><span class="sxs-lookup"><span data-stu-id="082d8-377">2.379</span></span> | <span data-ttu-id="082d8-378">*N/A*</span><span class="sxs-lookup"><span data-stu-id="082d8-378">*N/A*</span></span> |
| <span data-ttu-id="082d8-379">**自訂的分頁 ASP.NET 追蹤**</span><span class="sxs-lookup"><span data-stu-id="082d8-379">**Custom Paging ASP.NET Trace**</span></span> | <span data-ttu-id="082d8-380">0.029</span><span class="sxs-lookup"><span data-stu-id="082d8-380">0.029</span></span> | <span data-ttu-id="082d8-381">*N/A*</span><span class="sxs-lookup"><span data-stu-id="082d8-381">*N/A*</span></span> |

<span data-ttu-id="082d8-382">如您所見，擷取資料的特定頁面平均需要較少讀取 354，完成一小部分的時間。</span><span class="sxs-lookup"><span data-stu-id="082d8-382">As you can see, retrieving a particular page of data required 354 less reads on average and completed in a fraction of the time.</span></span> <span data-ttu-id="082d8-383">在 ASP.NET 頁面中，自訂頁面無法呈現在接近 1/100<sup>th</sup>所花費時間時使用的預設分頁。</span><span class="sxs-lookup"><span data-stu-id="082d8-383">At the ASP.NET page, custom the page was able to render in close to 1/100<sup>th</sup> of the time it took when using default paging.</span></span> <span data-ttu-id="082d8-384">請參閱[我的文章](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx)如對這些結果，以及程式碼和資料庫的詳細資訊，您可以下載重現您自己的環境中的這些測試。</span><span class="sxs-lookup"><span data-stu-id="082d8-384">See [my article](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) for more information on these results along with code and a database you can download to reproduce these tests in your own environment.</span></span>

## <a name="summary"></a><span data-ttu-id="082d8-385">總結</span><span class="sxs-lookup"><span data-stu-id="082d8-385">Summary</span></span>

<span data-ttu-id="082d8-386">預設的分頁是非常容易實作只檢查資料 Web 控制項 s 智慧標籤中啟用分頁的核取方塊，但這類簡單代價效能。</span><span class="sxs-lookup"><span data-stu-id="082d8-386">Default paging is a cinch to implement just check the Enable Paging checkbox in the data Web control s smart tag but such simplicity comes at the cost of performance.</span></span> <span data-ttu-id="082d8-387">使用預設分頁時，當使用者要求資料的任何頁面*所有*會傳回記錄，即使只有其中一小部分可能會顯示。</span><span class="sxs-lookup"><span data-stu-id="082d8-387">With default paging, when a user requests any page of data *all* records are returned, even though only a tiny fraction of them may be shown.</span></span> <span data-ttu-id="082d8-388">若要克服這樣的效能負荷，ObjectDataSource 會提供替代分頁選項自訂分頁。</span><span class="sxs-lookup"><span data-stu-id="082d8-388">To combat this performance overhead, the ObjectDataSource offers an alternative paging option custom paging.</span></span>

<span data-ttu-id="082d8-389">藉由擷取所需顯示，這些記錄分頁 s 效能問題的預設值為基礎加以改進自訂分頁時它 s 更為複雜，若要實作自訂分頁。</span><span class="sxs-lookup"><span data-stu-id="082d8-389">While custom paging improves upon default paging s performance issues by retrieving only those records that need to be displayed, it s more involved to implement custom paging.</span></span> <span data-ttu-id="082d8-390">首先，您必須正確 （且有效率地） 存取要求的記錄的特定子集是撰寫查詢。</span><span class="sxs-lookup"><span data-stu-id="082d8-390">First, a query must be written that correctly (and efficiently) accesses the specific subset of records requested.</span></span> <span data-ttu-id="082d8-391">這可在數種方式;在本教學課程中，我們檢查的是使用新的 SQL Server 2005 的`ROW_NUMBER()`陣序規範的函式的結果，然後只傳回結果的排名落在指定的範圍內。</span><span class="sxs-lookup"><span data-stu-id="082d8-391">This can be accomplished in a number of ways; the one we examined in this tutorial is to use SQL Server 2005 s new `ROW_NUMBER()` function to rank results, and then to return just those results whose ranking falls within a specified range.</span></span> <span data-ttu-id="082d8-392">此外，我們需要新增方法以確定透過正在分頁的記錄總數。</span><span class="sxs-lookup"><span data-stu-id="082d8-392">Furthermore, we need to add a means to determine the total number of records being paged through.</span></span> <span data-ttu-id="082d8-393">建立之後這些 DAL 和 BLL 方法，我們也需要設定 ObjectDataSource，讓它可以判斷多少的記錄總數正在透過分頁，以及可以正確地啟動資料列索引和最大資料列將值傳遞至 BLL。</span><span class="sxs-lookup"><span data-stu-id="082d8-393">After creating these DAL and BLL methods, we also need to configure the ObjectDataSource so that it can determine how many total records are being paged through and can correctly pass the Start Row Index and Maximum Rows values to the BLL.</span></span>

<span data-ttu-id="082d8-394">實作自訂分頁確實需要一些步驟，而且幾乎不簡單，只要預設的分頁功能，而自訂分頁時，需要夠大量的資料進行分頁。</span><span class="sxs-lookup"><span data-stu-id="082d8-394">While implementing custom paging does require a number of steps and is not nearly as simple as default paging, custom paging is a necessity when paging through sufficiently large amounts of data.</span></span> <span data-ttu-id="082d8-395">檢查結果顯示的自訂分頁可以減輕從 ASP.NET 頁面轉譯時間的秒數，可以一或多個大幅度減輕資料庫伺服器上的負載。</span><span class="sxs-lookup"><span data-stu-id="082d8-395">As the results examined showed, custom paging can shed seconds off of the ASP.NET page render time and can lighten the load on the database server by one ore more orders of magnitude.</span></span>

<span data-ttu-id="082d8-396">快樂地寫程式 ！</span><span class="sxs-lookup"><span data-stu-id="082d8-396">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="082d8-397">關於作者</span><span class="sxs-lookup"><span data-stu-id="082d8-397">About the Author</span></span>

<span data-ttu-id="082d8-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，作者的七個 ASP 書籍和的創辦人[4GuysFromRolla.com](http://www.4guysfromrolla.com)，自 1998 年從事 Microsoft Web 技術工作。</span><span class="sxs-lookup"><span data-stu-id="082d8-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="082d8-399">Scott 會擔任獨立的顧問、 培訓講師和作家。</span><span class="sxs-lookup"><span data-stu-id="082d8-399">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="082d8-400">他最新的著作是[ *Sams 教導您自己 ASP.NET 2.0 在 24 小時內*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="082d8-400">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="082d8-401">他可以在觸達[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="082d8-401">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="082d8-402">或透過他的部落格，這位於 [http://ScottOnWriting.NET](http://ScottOnWriting.NET)。</span><span class="sxs-lookup"><span data-stu-id="082d8-402">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="082d8-403">[上一頁](paging-and-sorting-report-data-vb.md)
> [下一頁](sorting-custom-paged-data-vb.md)</span><span class="sxs-lookup"><span data-stu-id="082d8-403">[Previous](paging-and-sorting-report-data-vb.md)
[Next](sorting-custom-paged-data-vb.md)</span></span>
