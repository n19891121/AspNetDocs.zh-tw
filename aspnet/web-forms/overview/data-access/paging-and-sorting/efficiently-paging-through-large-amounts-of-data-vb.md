---
uid: web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-vb
title: 有效率地將大量資料分頁 (VB) |Microsoft Docs
author: rick-anderson
description: 使用大量資料時，資料呈現控制項的預設分頁選項不適合，因為其基礎資料來源控制項 retriev .。。
ms.author: riande
ms.date: 08/15/2006
ms.assetid: 3e20e64a-8808-4b49-88d6-014e2629d56f
msc.legacyurl: /web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-vb
msc.type: authoredcontent
ms.openlocfilehash: d1c49e076e1c78e584f91fe2357a98da321f4260
ms.sourcegitcommit: 4e6d586faadbe4d9ef27122f86335ec9385134af
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/28/2020
ms.locfileid: "89045100"
---
# <a name="efficiently-paging-through-large-amounts-of-data-vb"></a><span data-ttu-id="49dfa-103">有效率地分頁大量資料 (VB)</span><span class="sxs-lookup"><span data-stu-id="49dfa-103">Efficiently Paging Through Large Amounts of Data (VB)</span></span>

<span data-ttu-id="49dfa-104">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="49dfa-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="49dfa-105">[下載範例應用程式](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_VB.exe) 或 [下載 PDF](efficiently-paging-through-large-amounts-of-data-vb/_static/datatutorial25vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="49dfa-105">[Download Sample App](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_VB.exe) or [Download PDF](efficiently-paging-through-large-amounts-of-data-vb/_static/datatutorial25vb1.pdf)</span></span>

> <span data-ttu-id="49dfa-106">使用大量資料時，資料展示檔控制項的預設分頁選項不適合，因為它的基礎資料來源控制項會抓取所有記錄，即使只顯示資料的子集也一樣。</span><span class="sxs-lookup"><span data-stu-id="49dfa-106">The default paging option of a data presentation control is unsuitable when working with large amounts of data, as its underlying data source control retrieves all records, even though only a subset of data is displayed.</span></span> <span data-ttu-id="49dfa-107">在這種情況下，我們必須開啟自訂分頁。</span><span class="sxs-lookup"><span data-stu-id="49dfa-107">In such circumstances, we must turn to custom paging.</span></span>

## <a name="introduction"></a><span data-ttu-id="49dfa-108">簡介</span><span class="sxs-lookup"><span data-stu-id="49dfa-108">Introduction</span></span>

<span data-ttu-id="49dfa-109">如先前的教學課程中所討論，您可以透過下列兩種方式之一來執行分頁：</span><span class="sxs-lookup"><span data-stu-id="49dfa-109">As we discussed in the preceding tutorial, paging can be implemented in one of two ways:</span></span>

- <span data-ttu-id="49dfa-110">只要勾選 data Web control 的智慧標籤中的 [啟用分頁] 選項，就可以實作為**預設分頁**;不過，每當您看到資料頁面時，ObjectDataSource 都會抓取*所有*的記錄，即使頁面中只會顯示其中的子集也一樣。</span><span class="sxs-lookup"><span data-stu-id="49dfa-110">**Default Paging** can be implemented by simply checking the Enable Paging option in the data Web control s smart tag; however, whenever viewing a page of data, the ObjectDataSource retrieves *all* of the records, even though only a subset of them are displayed in the page</span></span>
- <span data-ttu-id="49dfa-111">**自訂分頁** 藉由只針對使用者要求的特定資料頁面，只抓取需要顯示的資料庫記錄，來改善預設分頁的效能。不過，自訂分頁需要比預設分頁更費力地執行</span><span class="sxs-lookup"><span data-stu-id="49dfa-111">**Custom Paging** improves the performance of default paging by retrieving only those records from the database that need to be displayed for the particular page of data requested by the user; however, custom paging involves a bit more effort to implement than default paging</span></span>

<span data-ttu-id="49dfa-112">由於執行的便利性很簡單，請勾選核取方塊，然後再完成！</span><span class="sxs-lookup"><span data-stu-id="49dfa-112">Due to the ease of implementation just check a checkbox and you re done!</span></span> <span data-ttu-id="49dfa-113">預設分頁是一個吸引人的選項。</span><span class="sxs-lookup"><span data-stu-id="49dfa-113">default paging is an attractive option.</span></span> <span data-ttu-id="49dfa-114">不過，在抓取所有記錄的方法中，它會讓它成為 implausible 的選擇，以分頁處理足夠大量的資料，或針對具有許多並行使用者的網站。</span><span class="sxs-lookup"><span data-stu-id="49dfa-114">Its naive approach in retrieving all of the records, though, makes it an implausible choice when paging through sufficiently large amounts of data or for sites with many concurrent users.</span></span> <span data-ttu-id="49dfa-115">在這種情況下，我們必須開啟自訂分頁，才能提供回應式系統。</span><span class="sxs-lookup"><span data-stu-id="49dfa-115">In such circumstances, we must turn to custom paging in order to provide a responsive system.</span></span>

<span data-ttu-id="49dfa-116">自訂分頁的挑戰是能夠撰寫查詢，以傳回特定資料頁面所需的一組精確記錄。</span><span class="sxs-lookup"><span data-stu-id="49dfa-116">The challenge of custom paging is being able to write a query that returns the precise set of records needed for a particular page of data.</span></span> <span data-ttu-id="49dfa-117">幸運的是，Microsoft SQL Server 2005 提供了用於排名結果的新關鍵字，可讓我們撰寫可有效率地取出適當記錄子集的查詢。</span><span class="sxs-lookup"><span data-stu-id="49dfa-117">Fortunately, Microsoft SQL Server 2005 provides a new keyword for ranking results, which enables us to write a query that can efficiently retrieve the proper subset of records.</span></span> <span data-ttu-id="49dfa-118">在本教學課程中，我們將瞭解如何使用這個新的 SQL Server 2005 關鍵字，在 GridView 控制項中執行自訂分頁。</span><span class="sxs-lookup"><span data-stu-id="49dfa-118">In this tutorial we'll see how to use this new SQL Server 2005 keyword to implement custom paging in a GridView control.</span></span> <span data-ttu-id="49dfa-119">雖然自訂分頁的使用者介面與預設分頁的使用者介面完全相同，但使用自訂分頁從某個頁面逐步執行到下一個頁面，可能比預設分頁更快許多。</span><span class="sxs-lookup"><span data-stu-id="49dfa-119">While the user interface for custom paging is identical to that for default paging, stepping from one page to the next using custom paging can be several orders of magnitude faster than default paging.</span></span>

> [!NOTE]
> <span data-ttu-id="49dfa-120">自訂分頁所呈現的確切效能提升，取決於要進行分頁的記錄總數，以及要放置在資料庫伺服器上的負載。</span><span class="sxs-lookup"><span data-stu-id="49dfa-120">The exact performance gain exhibited by custom paging depends on the total number of records being paged through and the load being placed on the database server.</span></span> <span data-ttu-id="49dfa-121">在本教學課程結束時，我們將探討一些粗略的計量，以展示透過自訂分頁取得的效能優勢。</span><span class="sxs-lookup"><span data-stu-id="49dfa-121">At the end of this tutorial we'll look at some rough metrics that showcase the benefits in performance obtained through custom paging.</span></span>

## <a name="step-1-understanding-the-custom-paging-process"></a><span data-ttu-id="49dfa-122">步驟1：瞭解自訂分頁流程</span><span class="sxs-lookup"><span data-stu-id="49dfa-122">Step 1: Understanding the Custom Paging Process</span></span>

<span data-ttu-id="49dfa-123">逐頁查看資料時，頁面中顯示的精確記錄取決於所要求的資料頁面，以及每頁顯示的記錄數目。</span><span class="sxs-lookup"><span data-stu-id="49dfa-123">When paging through data, the precise records displayed in a page depend upon the page of data being requested and the number of records displayed per page.</span></span> <span data-ttu-id="49dfa-124">例如，假設我們想要逐頁查看81產品，每頁顯示10個產品。</span><span class="sxs-lookup"><span data-stu-id="49dfa-124">For example, imagine that we wanted to page through the 81 products, displaying 10 products per page.</span></span> <span data-ttu-id="49dfa-125">查看第一頁時，我們需要產品1到 10;當您看到第二頁時，我們會對產品11到20感興趣，依此類推。</span><span class="sxs-lookup"><span data-stu-id="49dfa-125">When viewing the first page, we d want products 1 through 10; when viewing the second page we d be interested in products 11 through 20, and so on.</span></span>

<span data-ttu-id="49dfa-126">有三個變數規定需要抓取哪些記錄，以及應如何轉譯分頁介面：</span><span class="sxs-lookup"><span data-stu-id="49dfa-126">There are three variables that dictate what records need to be retrieved and how the paging interface should be rendered:</span></span>

- <span data-ttu-id="49dfa-127">**開始資料列索引** ：要顯示的資料頁面中第一個資料列的索引;您可以藉由將頁面索引與每頁顯示的記錄相乘來計算此索引，並加入一個。</span><span class="sxs-lookup"><span data-stu-id="49dfa-127">**Start Row Index** the index of the first row in the page of data to display; this index can be calculated by multiplying the page index by the records to display per page and adding one.</span></span> <span data-ttu-id="49dfa-128">例如，當逐頁查看記錄10時，對於頁面索引為 0) 的第一頁 (，起始資料列索引為 0 \* 10 + 1，或 1; 對於頁面索引為 1) 的第二頁 (，起始資料列索引為 1 \* 10 + 1 或11。</span><span class="sxs-lookup"><span data-stu-id="49dfa-128">For example, when paging through records 10 at a time, for the first page (whose page index is 0), the Start Row Index is 0 \* 10 + 1, or 1; for the second page (whose page index is 1), the Start Row Index is 1 \* 10 + 1, or 11.</span></span>
- <span data-ttu-id="49dfa-129">**最大資料列** 數：每頁顯示的記錄數目上限。</span><span class="sxs-lookup"><span data-stu-id="49dfa-129">**Maximum Rows** the maximum number of records to display per page.</span></span> <span data-ttu-id="49dfa-130">此變數稱為最大資料列，自最後一頁起，傳回的記錄可能會少於頁面大小。</span><span class="sxs-lookup"><span data-stu-id="49dfa-130">This variable is referred to as maximum rows since for the last page there may be fewer records returned than the page size.</span></span> <span data-ttu-id="49dfa-131">例如，當逐頁查看每個頁面的81產品10筆記錄時，第九個和最後一個頁面將只會有一筆記錄。</span><span class="sxs-lookup"><span data-stu-id="49dfa-131">For example, when paging through the 81 products 10 records per page, the ninth and final page will have just one record.</span></span> <span data-ttu-id="49dfa-132">但是，沒有頁面會顯示比最大資料列值更多的記錄。</span><span class="sxs-lookup"><span data-stu-id="49dfa-132">No page, though, will show more records than the Maximum Rows value.</span></span>
- <span data-ttu-id="49dfa-133">**總記錄計數** 是要進行分頁的記錄總數。</span><span class="sxs-lookup"><span data-stu-id="49dfa-133">**Total Record Count** the total number of records being paged through.</span></span> <span data-ttu-id="49dfa-134">雖然此變數不需要用來判斷要針對特定頁面抓取哪些記錄，但它確實會指示分頁介面。</span><span class="sxs-lookup"><span data-stu-id="49dfa-134">While this variable isn t needed to determine what records to retrieve for a given page, it does dictate the paging interface.</span></span> <span data-ttu-id="49dfa-135">例如，如果有81的產品正在進行分頁，則分頁介面知道要在分頁 UI 中顯示九個頁碼。</span><span class="sxs-lookup"><span data-stu-id="49dfa-135">For example, if there are 81 products being paged through, the paging interface knows to display nine page numbers in the paging UI.</span></span>

<span data-ttu-id="49dfa-136">使用預設分頁時，開始資料列索引會計算為頁面索引和頁面大小加一的乘積，而最大資料列則只是頁面大小。</span><span class="sxs-lookup"><span data-stu-id="49dfa-136">With default paging, the Start Row Index is computed as the product of the page index and the page size plus one, whereas the Maximum Rows is simply the page size.</span></span> <span data-ttu-id="49dfa-137">由於預設分頁會在轉譯任何頁面的資料時，從資料庫取得所有記錄，因此每個資料列的索引都是已知的，因此將移到開始資料列索引資料列的簡單工作。</span><span class="sxs-lookup"><span data-stu-id="49dfa-137">Since default paging retrieves all of the records from the database when rendering any page of data, the index for each row is known, thereby making moving to Start Row Index row a trivial task.</span></span> <span data-ttu-id="49dfa-138">此外，記錄計數總計很容易使用，因為它只是 DataTable (中的記錄數目，或是用來保存資料庫結果) 的任何物件。</span><span class="sxs-lookup"><span data-stu-id="49dfa-138">Moreover, the Total Record Count is readily available, as it s simply the number of records in the DataTable (or whatever object is being used to hold the database results).</span></span>

<span data-ttu-id="49dfa-139">如果指定了開始資料列索引和最大資料列變數，自訂分頁執行就只能傳回從開始資料列索引開始的精確記錄子集，以及之後最多資料列數的記錄。</span><span class="sxs-lookup"><span data-stu-id="49dfa-139">Given the Start Row Index and Maximum Rows variables, a custom paging implementation must only return the precise subset of records starting at the Start Row Index and up to Maximum Rows number of records after that.</span></span> <span data-ttu-id="49dfa-140">自訂分頁提供兩個挑戰：</span><span class="sxs-lookup"><span data-stu-id="49dfa-140">Custom paging provides two challenges:</span></span>

- <span data-ttu-id="49dfa-141">我們必須能夠有效率地將資料列索引與要進行分頁的整個資料中的每個資料列產生關聯，以便我們可以在指定的開始資料列索引處開始傳回記錄</span><span class="sxs-lookup"><span data-stu-id="49dfa-141">We must be able to efficiently associate a row index with each row in the entire data being paged through so that we can start returning records at the specified Start Row Index</span></span>
- <span data-ttu-id="49dfa-142">我們需要提供已分頁的記錄總數</span><span class="sxs-lookup"><span data-stu-id="49dfa-142">We need to provide the total number of records being paged through</span></span>

<span data-ttu-id="49dfa-143">在接下來的兩個步驟中，我們將探討回應這兩個挑戰所需的 SQL 腳本。</span><span class="sxs-lookup"><span data-stu-id="49dfa-143">In the next two steps we'll examine the SQL script needed to respond to these two challenges.</span></span> <span data-ttu-id="49dfa-144">除了 SQL 腳本，我們也需要在 DAL 和 BLL 中執行方法。</span><span class="sxs-lookup"><span data-stu-id="49dfa-144">In addition to the SQL script, we'll also need to implement methods in the DAL and BLL.</span></span>

## <a name="step-2-returning-the-total-number-of-records-being-paged-through"></a><span data-ttu-id="49dfa-145">步驟2：傳回已分頁的記錄總數</span><span class="sxs-lookup"><span data-stu-id="49dfa-145">Step 2: Returning the Total Number of Records Being Paged Through</span></span>

<span data-ttu-id="49dfa-146">在我們檢查如何取出所顯示頁面的精確記錄子集之前，讓我們先看看如何傳回已分頁的記錄總數。</span><span class="sxs-lookup"><span data-stu-id="49dfa-146">Before we examine how to retrieve the precise subset of records for the page being displayed, let s first look at how to return the total number of records being paged through.</span></span> <span data-ttu-id="49dfa-147">需要這項資訊，才能正確設定分頁使用者介面。</span><span class="sxs-lookup"><span data-stu-id="49dfa-147">This information is needed in order to properly configure the paging user interface.</span></span> <span data-ttu-id="49dfa-148">您可以使用[ `COUNT` aggregate 函數](https://msdn.microsoft.com/library/ms175997.aspx)來取得特定 SQL 查詢所傳回的記錄總數。</span><span class="sxs-lookup"><span data-stu-id="49dfa-148">The total number of records returned by a particular SQL query can be obtained by using the [`COUNT` aggregate function](https://msdn.microsoft.com/library/ms175997.aspx).</span></span> <span data-ttu-id="49dfa-149">例如，若要判斷資料表中的總記錄數 `Products` ，我們可以使用下列查詢：</span><span class="sxs-lookup"><span data-stu-id="49dfa-149">For example, to determine the total number of records in the `Products` table, we can use the following query:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample1.sql)]

<span data-ttu-id="49dfa-150">讓 s 將方法新增至我們的 DAL，以傳回此資訊。</span><span class="sxs-lookup"><span data-stu-id="49dfa-150">Let s add a method to our DAL that returns this information.</span></span> <span data-ttu-id="49dfa-151">尤其是，我們將建立名為的 DAL 方法 `TotalNumberOfProducts()` ，以執行 `SELECT` 上面顯示的語句。</span><span class="sxs-lookup"><span data-stu-id="49dfa-151">In particular, we'll create a DAL method called `TotalNumberOfProducts()` that executes the `SELECT` statement shown above.</span></span>

<span data-ttu-id="49dfa-152">從開啟 `Northwind.xsd` 資料夾中具類型的資料集檔案開始 `App_Code/DAL` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-152">Start by opening the `Northwind.xsd` Typed DataSet file in the `App_Code/DAL` folder.</span></span> <span data-ttu-id="49dfa-153">接下來，以滑鼠右鍵按一下 `ProductsTableAdapter` 設計工具中的，然後選擇 [加入查詢]。</span><span class="sxs-lookup"><span data-stu-id="49dfa-153">Next, right-click on the `ProductsTableAdapter` in the Designer and choose Add Query.</span></span> <span data-ttu-id="49dfa-154">如先前的教學課程中所見，這可讓我們將新的方法加入 DAL，當叫用此方法時，將會執行特定的 SQL 語句或預存程式。</span><span class="sxs-lookup"><span data-stu-id="49dfa-154">As we ve seen in previous tutorials, this will allow us to add a new method to the DAL that, when invoked, will execute a particular SQL statement or stored procedure.</span></span> <span data-ttu-id="49dfa-155">如同先前教學課程中的 TableAdapter 方法，這是選擇使用臨機操作的 SQL 語句。</span><span class="sxs-lookup"><span data-stu-id="49dfa-155">As with our TableAdapter methods in previous tutorials, for this one opt to use an ad-hoc SQL statement.</span></span>

![使用特定 SQL 語句](efficiently-paging-through-large-amounts-of-data-vb/_static/image1.png)

<span data-ttu-id="49dfa-157">**圖 1**：使用特定 SQL 語句</span><span class="sxs-lookup"><span data-stu-id="49dfa-157">**Figure 1**: Use an Ad-Hoc SQL Statement</span></span>

<span data-ttu-id="49dfa-158">在下一個畫面中，可以指定要建立的查詢類型。</span><span class="sxs-lookup"><span data-stu-id="49dfa-158">On the next screen we can specify what type of query to create.</span></span> <span data-ttu-id="49dfa-159">因為此查詢會傳回單一純量值，所以資料表中的記錄總數會 `Products` 選擇傳回單一 `SELECT` 值選項。</span><span class="sxs-lookup"><span data-stu-id="49dfa-159">Since this query will return a single, scalar value the total number of records in the `Products` table choose the `SELECT` which returns a singe value option.</span></span>

![將查詢設定為使用會傳回單一值的 SELECT 語句](efficiently-paging-through-large-amounts-of-data-vb/_static/image2.png)

<span data-ttu-id="49dfa-161">**圖 2**：將查詢設定為使用會傳回單一值的 SELECT 語句</span><span class="sxs-lookup"><span data-stu-id="49dfa-161">**Figure 2**: Configure the Query to Use a SELECT Statement that Returns a Single Value</span></span>

<span data-ttu-id="49dfa-162">指出要使用的查詢類型之後，我們必須接著指定查詢。</span><span class="sxs-lookup"><span data-stu-id="49dfa-162">After indicating the type of query to use, we must next specify the query.</span></span>

![從 Products 查詢使用 SELECT COUNT ( \* ) ](efficiently-paging-through-large-amounts-of-data-vb/_static/image3.png)

<span data-ttu-id="49dfa-164">**圖 3**：使用 Products 查詢中的 SELECT COUNT (\*) </span><span class="sxs-lookup"><span data-stu-id="49dfa-164">**Figure 3**: Use the SELECT COUNT(\*) FROM Products Query</span></span>

<span data-ttu-id="49dfa-165">最後，指定方法的名稱。</span><span class="sxs-lookup"><span data-stu-id="49dfa-165">Finally, specify the name for the method.</span></span> <span data-ttu-id="49dfa-166">如前所述，讓我們使用 `TotalNumberOfProducts` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-166">As aforementioned, let s use `TotalNumberOfProducts`.</span></span>

![將 DAL 方法命名為 TotalNumberOfProducts](efficiently-paging-through-large-amounts-of-data-vb/_static/image4.png)

<span data-ttu-id="49dfa-168">**圖 4**：命名 DAL 方法 TotalNumberOfProducts</span><span class="sxs-lookup"><span data-stu-id="49dfa-168">**Figure 4**: Name the DAL Method TotalNumberOfProducts</span></span>

<span data-ttu-id="49dfa-169">按一下 [完成] 之後，嚮導會將 `TotalNumberOfProducts` 方法新增至 DAL。</span><span class="sxs-lookup"><span data-stu-id="49dfa-169">After clicking Finish, the wizard will add the `TotalNumberOfProducts` method to the DAL.</span></span> <span data-ttu-id="49dfa-170">當 SQL 查詢的結果為時，DAL 傳回的純量方法會傳回可為 null 的類型 `NULL` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-170">The scalar returning methods in the DAL return nullable types, in case the result from the SQL query is `NULL`.</span></span> <span data-ttu-id="49dfa-171">但是，我們 `COUNT` 的查詢一律會傳回非 `NULL` 值; 而是，DAL 方法會傳回可為 null 的整數。</span><span class="sxs-lookup"><span data-stu-id="49dfa-171">Our `COUNT` query, however, will always return a non-`NULL` value; regardless, the DAL method returns a nullable integer.</span></span>

<span data-ttu-id="49dfa-172">除了 DAL 方法之外，我們也需要 BLL 中的方法。</span><span class="sxs-lookup"><span data-stu-id="49dfa-172">In addition to the DAL method, we also need a method in the BLL.</span></span> <span data-ttu-id="49dfa-173">開啟 `ProductsBLL` 類別檔案，並新增 `TotalNumberOfProducts` 直接向下呼叫 DAL s 方法的方法 `TotalNumberOfProducts` ：</span><span class="sxs-lookup"><span data-stu-id="49dfa-173">Open the `ProductsBLL` class file and add a `TotalNumberOfProducts` method that simply calls down to the DAL s `TotalNumberOfProducts` method:</span></span>

[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample2.vb)]

<span data-ttu-id="49dfa-174">DAL s `TotalNumberOfProducts` 方法會傳回可為 null 的整數; 不過，我們已建立 `ProductsBLL` 類別的方法， `TotalNumberOfProducts` 使其傳回標準的整數。</span><span class="sxs-lookup"><span data-stu-id="49dfa-174">The DAL s `TotalNumberOfProducts` method returns a nullable integer; however, we ve created the `ProductsBLL` class s `TotalNumberOfProducts` method so that it returns a standard integer.</span></span> <span data-ttu-id="49dfa-175">因此，我們必須讓類別的 `ProductsBLL` `TotalNumberOfProducts` 方法傳回 DAL s 方法所傳回之可為 null 整數的值部分 `TotalNumberOfProducts` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-175">Therefore, we need to have the `ProductsBLL` class s `TotalNumberOfProducts` method return the value portion of the nullable integer returned by the DAL s `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="49dfa-176">的呼叫 `GetValueOrDefault()` 會傳回可為 null 的整數值（如果存在的話）; 如果可為 null 的整數，則會傳回 `null` 預設整數值0。</span><span class="sxs-lookup"><span data-stu-id="49dfa-176">The call to `GetValueOrDefault()` returns the value of the nullable integer, if it exists; if the nullable integer is `null`, however, it returns the default integer value, 0.</span></span>

## <a name="step-3-returning-the-precise-subset-of-records"></a><span data-ttu-id="49dfa-177">步驟3：傳回精確的記錄子集</span><span class="sxs-lookup"><span data-stu-id="49dfa-177">Step 3: Returning the Precise Subset of Records</span></span>

<span data-ttu-id="49dfa-178">下一項工作是在 DAL 和 BLL 中建立方法，以接受稍早所討論的開始資料列索引和最大資料列變數，並傳回適當的記錄。</span><span class="sxs-lookup"><span data-stu-id="49dfa-178">Our next task is to create methods in the DAL and BLL that accept the Start Row Index and Maximum Rows variables discussed earlier and return the appropriate records.</span></span> <span data-ttu-id="49dfa-179">在這麼做之前，讓我們先看看所需的 SQL 腳本。</span><span class="sxs-lookup"><span data-stu-id="49dfa-179">Before we do that, let s first look at the needed SQL script.</span></span> <span data-ttu-id="49dfa-180">面臨的挑戰是，我們必須能夠有效率地將索引指派給整個結果中的每個資料列，讓我們可以只傳回從開始資料列索引開始 (的記錄，以及最多記錄) 的記錄數目上限。</span><span class="sxs-lookup"><span data-stu-id="49dfa-180">The challenge facing us is that we must be able to efficiently assign an index to each row in the entire results being paged through so that we can return just those records starting at the Start Row Index (and up to the Maximum Records number of records).</span></span>

<span data-ttu-id="49dfa-181">如果資料庫資料表中已經有一個資料行做為資料列索引，這就不是一項挑戰。</span><span class="sxs-lookup"><span data-stu-id="49dfa-181">This is not a challenge if there is already a column in the database table that serves as a row index.</span></span> <span data-ttu-id="49dfa-182">乍看之下，我們可能會認為 `Products` 資料表的 `ProductID` 欄位就足夠了，因為第一個產品有 `ProductID` 1 個，第二個是2，依此類推。</span><span class="sxs-lookup"><span data-stu-id="49dfa-182">At first glance we might think that the `Products` table s `ProductID` field would suffice, as the first product has `ProductID` of 1, the second a 2, and so on.</span></span> <span data-ttu-id="49dfa-183">不過，刪除產品時，重此方法。</span><span class="sxs-lookup"><span data-stu-id="49dfa-183">However, deleting a product leaves a gap in the sequence, nullifying this approach.</span></span>

<span data-ttu-id="49dfa-184">有兩種一般技巧可用來有效率地將資料列索引與要逐頁查看的資料產生關聯，藉此啟用精確的記錄子集：</span><span class="sxs-lookup"><span data-stu-id="49dfa-184">There are two general techniques used to efficiently associate a row index with the data to page through, thereby enabling the precise subset of records to be retrieved:</span></span>

- <span data-ttu-id="49dfa-185">**使用 SQL Server 2005 s `ROW_NUMBER()` 關鍵字** new to SQL Server 2005， `ROW_NUMBER()` 關鍵字會根據某種順序將排名與每個傳回的記錄產生關聯。</span><span class="sxs-lookup"><span data-stu-id="49dfa-185">**Using SQL Server 2005 s `ROW_NUMBER()` Keyword** new to SQL Server 2005, the `ROW_NUMBER()` keyword associates a ranking with each returned record based on some ordering.</span></span> <span data-ttu-id="49dfa-186">此排名可作為每個資料列的資料列索引使用。</span><span class="sxs-lookup"><span data-stu-id="49dfa-186">This ranking can be used as a row index for each row.</span></span>
- <span data-ttu-id="49dfa-187">\*\*使用資料表變數和 `SET ROWCOUNT` \*\*SQL Server s [ `SET ROWCOUNT` 語句](https://msdn.microsoft.com/library/ms188774.aspx)可以用來指定在終止之前，查詢應該處理的總記錄數;[資料表變數](http://www.sqlteam.com/item.asp?ItemID=9454)是可保存表格式資料的本機 t-sql 變數，類似于[臨時表](http://www.sqlteam.com/item.asp?ItemID=2029)。</span><span class="sxs-lookup"><span data-stu-id="49dfa-187">**Using a Table Variable and `SET ROWCOUNT`** SQL Server s [`SET ROWCOUNT` statement](https://msdn.microsoft.com/library/ms188774.aspx) can be used to specify how many total records a query should process before terminating; [table variables](http://www.sqlteam.com/item.asp?ItemID=9454) are local T-SQL variables that can hold tabular data, akin to [temporary tables](http://www.sqlteam.com/item.asp?ItemID=2029).</span></span> <span data-ttu-id="49dfa-188">這種方法同樣適用于 Microsoft SQL Server 2005 和 SQL Server 2000 (，但此 `ROW_NUMBER()` 方法只適用于 SQL Server 2005) 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-188">This approach works equally well with both Microsoft SQL Server 2005 and SQL Server 2000 (whereas the `ROW_NUMBER()` approach only works with SQL Server 2005).</span></span>  
  
  <span data-ttu-id="49dfa-189">此處的概念是建立資料表變數，此變數具有 `IDENTITY` 資料要進行分頁的資料表之主鍵的資料行和資料行。</span><span class="sxs-lookup"><span data-stu-id="49dfa-189">The idea here is to create a table variable that has an `IDENTITY` column and columns for the primary keys of the table whose data is being paged through.</span></span> <span data-ttu-id="49dfa-190">接下來，將資料分頁的資料表內容傾印到資料表變數中，藉此將連續資料列索引 (透過 `IDENTITY` 資料表中每一筆記錄的資料行) 來建立關聯。</span><span class="sxs-lookup"><span data-stu-id="49dfa-190">Next, the contents of the table whose data is being paged through is dumped into the table variable, thereby associating a sequential row index (via the `IDENTITY` column) for each record in the table.</span></span> <span data-ttu-id="49dfa-191">一旦擴展資料表變數之後， `SELECT` 就可以執行資料表變數（與基礎資料表聯結）上的語句，以提取特定記錄。</span><span class="sxs-lookup"><span data-stu-id="49dfa-191">Once the table variable has been populated, a `SELECT` statement on the table variable, joined with the underlying table, can be executed to pull out the particular records.</span></span> <span data-ttu-id="49dfa-192">`SET ROWCOUNT`語句是用來以智慧方式限制必須傾印到資料表變數中的記錄數目。</span><span class="sxs-lookup"><span data-stu-id="49dfa-192">The `SET ROWCOUNT` statement is used to intelligently limit the number of records that need to be dumped into the table variable.</span></span>  
  
  <span data-ttu-id="49dfa-193">這種方法的效率是根據所要求的頁碼，因為 `SET ROWCOUNT` 值會被指派開始資料列索引的值加上最大資料列數。</span><span class="sxs-lookup"><span data-stu-id="49dfa-193">This approach s efficiency is based on the page number being requested, as the `SET ROWCOUNT` value is assigned the value of Start Row Index plus the Maximum Rows.</span></span> <span data-ttu-id="49dfa-194">當您透過低編號的頁面（例如前幾頁的資料）進行分頁時，此方法非常有效率。</span><span class="sxs-lookup"><span data-stu-id="49dfa-194">When paging through low-numbered pages such as the first few pages of data this approach is very efficient.</span></span> <span data-ttu-id="49dfa-195">不過，它會在抓取接近結尾的頁面時，展現預設的分頁效能。</span><span class="sxs-lookup"><span data-stu-id="49dfa-195">However, it exhibits default paging-like performance when retrieving a page near the end.</span></span>

<span data-ttu-id="49dfa-196">本教學課程會使用關鍵字來實行自訂分頁 `ROW_NUMBER()` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-196">This tutorial implements custom paging using the `ROW_NUMBER()` keyword.</span></span> <span data-ttu-id="49dfa-197">如需有關使用資料表變數和技術的詳細資訊 `SET ROWCOUNT` ，請參閱 [透過大型結果集進行分頁的更有效率的方法](http://www.4guysfromrolla.com/webtech/042606-1.shtml)。</span><span class="sxs-lookup"><span data-stu-id="49dfa-197">For more information on using the table variable and `SET ROWCOUNT` technique, see [A More Efficient Method for Paging Through Large Result Sets](http://www.4guysfromrolla.com/webtech/042606-1.shtml).</span></span>

<span data-ttu-id="49dfa-198">`ROW_NUMBER()`關鍵字會使用下列語法，針對特定排序傳回的每一筆記錄進行排名關聯：</span><span class="sxs-lookup"><span data-stu-id="49dfa-198">The `ROW_NUMBER()` keyword associated a ranking with each record returned over a particular ordering using the following syntax:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample3.sql)]

<span data-ttu-id="49dfa-199">`ROW_NUMBER()` 傳回數值，這個值會指定與指定順序相關的每一筆記錄排名。</span><span class="sxs-lookup"><span data-stu-id="49dfa-199">`ROW_NUMBER()` returns a numerical value that specifies the rank for each record with regards to the indicated ordering.</span></span> <span data-ttu-id="49dfa-200">例如，若要查看每項產品的排名（從最昂貴到最少），我們可以使用下列查詢：</span><span class="sxs-lookup"><span data-stu-id="49dfa-200">For example, to see the rank for each product, ordered from the most expensive to the least, we could use the following query:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample4.sql)]

<span data-ttu-id="49dfa-201">[圖 5] 顯示在 Visual Studio 中執行查詢視窗時的查詢結果。</span><span class="sxs-lookup"><span data-stu-id="49dfa-201">Figure 5 shows this query s results when run through the query window in Visual Studio.</span></span> <span data-ttu-id="49dfa-202">請注意，產品會依價格排序，以及每個資料列的價格等級。</span><span class="sxs-lookup"><span data-stu-id="49dfa-202">Note that the products are ordered by price, along with a price rank for each row.</span></span>

![每個傳回的記錄都會包含價格等級](efficiently-paging-through-large-amounts-of-data-vb/_static/image5.png)

<span data-ttu-id="49dfa-204">**圖 5**：每個傳回的記錄都會包含價格等級</span><span class="sxs-lookup"><span data-stu-id="49dfa-204">**Figure 5**: The Price Rank is Included for Each Returned Record</span></span>

> [!NOTE]
> <span data-ttu-id="49dfa-205">`ROW_NUMBER()` 只是 SQL Server 2005 中可用的許多新次序函數之一。</span><span class="sxs-lookup"><span data-stu-id="49dfa-205">`ROW_NUMBER()` is just one of the many new ranking functions available in SQL Server 2005.</span></span> <span data-ttu-id="49dfa-206">如需更詳盡的討論 `ROW_NUMBER()` ，以及其他次序函數，請 [使用 Microsoft SQL Server 2005 來讀取傳回排名的結果](http://www.4guysfromrolla.com/webtech/010406-1.shtml)。</span><span class="sxs-lookup"><span data-stu-id="49dfa-206">For a more thorough discussion of `ROW_NUMBER()`, along with the other ranking functions, read [Returning Ranked Results with Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml).</span></span>

<span data-ttu-id="49dfa-207">依子句中的指定資料行將結果排名 `ORDER BY` `OVER` (中 `UnitPrice` ，在上述範例) 中，SQL Server 必須排序結果。</span><span class="sxs-lookup"><span data-stu-id="49dfa-207">When ranking the results by the specified `ORDER BY` column in the `OVER` clause (`UnitPrice`, in the above example), SQL Server must sort the results.</span></span> <span data-ttu-id="49dfa-208">如果在資料行上有叢集索引，則這是一項快速的作業， (s) 結果是以排序，或有涵蓋索引，但在其他情況下可能更昂貴。</span><span class="sxs-lookup"><span data-stu-id="49dfa-208">This is a quick operation if there is a clustered index over the column(s) the results are being ordered by, or if there is a covering index, but can be more costly otherwise.</span></span> <span data-ttu-id="49dfa-209">若要協助改善足夠的大型查詢效能，請考慮針對用來排序結果的資料行加入非叢集索引。</span><span class="sxs-lookup"><span data-stu-id="49dfa-209">To help improve performance for sufficiently large queries, consider adding a non-clustered index for the column by which the results are ordered by.</span></span> <span data-ttu-id="49dfa-210">如需效能考慮的詳細資訊，請參閱 [SQL Server 2005 中的次序函數和效能](http://www.sql-server-performance.com/ak_ranking_functions.asp) 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-210">See [Ranking Functions and Performance in SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) for a more detailed look at the performance considerations.</span></span>

<span data-ttu-id="49dfa-211">傳回的排名資訊 `ROW_NUMBER()` 無法直接在子句中使用 `WHERE` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-211">The ranking information returned by `ROW_NUMBER()` cannot directly be used in the `WHERE` clause.</span></span> <span data-ttu-id="49dfa-212">不過，您可以使用衍生資料表來傳回 `ROW_NUMBER()` 結果，然後在子句中出現這些結果 `WHERE` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-212">However, a derived table can be used to return the `ROW_NUMBER()` result, which can then appear in the `WHERE` clause.</span></span> <span data-ttu-id="49dfa-213">例如，下列查詢會使用衍生資料表來傳回 ProductName 和單價資料行以及 `ROW_NUMBER()` 結果，然後使用 `WHERE` 子句來傳回價格等級介於11和20之間的產品：</span><span class="sxs-lookup"><span data-stu-id="49dfa-213">For example, the following query uses a derived table to return the ProductName and UnitPrice columns, along with the `ROW_NUMBER()` result, and then uses a `WHERE` clause to only return those products whose price rank is between 11 and 20:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample5.sql)]

<span data-ttu-id="49dfa-214">更進一步擴充這個概念，我們可以利用這種方法，根據所需的起始資料列索引和最大資料列值來抓取特定的資料頁面：</span><span class="sxs-lookup"><span data-stu-id="49dfa-214">Extending this concept a bit further, we can utilize this approach to retrieve a specific page of data given the desired Start Row Index and Maximum Rows values:</span></span>

[!code-html[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample6.html)]

> [!NOTE]
> <span data-ttu-id="49dfa-215">我們稍後會在本教學課程中看到， *`StartRowIndex`* ObjectDataSource 提供的是從零開始編制索引，而 `ROW_NUMBER()` SQL Server 2005 所傳回的值是從1開始編制索引。</span><span class="sxs-lookup"><span data-stu-id="49dfa-215">As we will see later on in this tutorial, the *`StartRowIndex`* supplied by the ObjectDataSource is indexed starting at zero, whereas the `ROW_NUMBER()` value returned by SQL Server 2005 is indexed starting at 1.</span></span> <span data-ttu-id="49dfa-216">因此， `WHERE` 子句 `PriceRank` 會傳回嚴格大於 *`StartRowIndex`* 和小於或等於的記錄 *`StartRowIndex`*  +  *`MaximumRows`* 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-216">Therefore, the `WHERE` clause returns those records where `PriceRank` is strictly greater than *`StartRowIndex`* and less than or equal to *`StartRowIndex`* + *`MaximumRows`*.</span></span>

<span data-ttu-id="49dfa-217">現在，我們已討論過如何在 `ROW_NUMBER()` 指定開始資料列索引和最大資料列值的情況下，用來取得特定頁面的資料，我們現在需要將此邏輯實作為 DAL 和 BLL 中的方法。</span><span class="sxs-lookup"><span data-stu-id="49dfa-217">Now that we ve discussed how `ROW_NUMBER()` can be used to retrieve a particular page of data given the Start Row Index and Maximum Rows values, we now need to implement this logic as methods in the DAL and BLL.</span></span>

<span data-ttu-id="49dfa-218">建立此查詢時，我們必須決定要將結果分級的順序;讓我們依字母順序排列產品的名稱。</span><span class="sxs-lookup"><span data-stu-id="49dfa-218">When creating this query we must decide the ordering by which the results will be ranked; let s sort the products by their name in alphabetical order.</span></span> <span data-ttu-id="49dfa-219">這表示，在本教學課程中使用自訂分頁執行時，我們將無法建立比也可以排序的自訂分頁報表。</span><span class="sxs-lookup"><span data-stu-id="49dfa-219">This means that with the custom paging implementation in this tutorial we will not be able to create a custom paged report than can also be sorted.</span></span> <span data-ttu-id="49dfa-220">但在下一個教學課程中，我們會看到如何提供這類功能。</span><span class="sxs-lookup"><span data-stu-id="49dfa-220">In the next tutorial, though, we'll see how such functionality can be provided.</span></span>

<span data-ttu-id="49dfa-221">在上一節中，我們建立了 DAL 方法作為臨機操作 SQL 語句。</span><span class="sxs-lookup"><span data-stu-id="49dfa-221">In the previous section we created the DAL method as an ad-hoc SQL statement.</span></span> <span data-ttu-id="49dfa-222">可惜的是，TableAdapter wizard 所使用 Visual Studio 中的 T-sql 剖析器不像函式所 `OVER` 使用的語法 `ROW_NUMBER()` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-222">Unfortunately, the T-SQL parser in Visual Studio used by the TableAdapter wizard doesn t like the `OVER` syntax used by the `ROW_NUMBER()` function.</span></span> <span data-ttu-id="49dfa-223">因此，我們必須將此 DAL 方法建立為預存程式。</span><span class="sxs-lookup"><span data-stu-id="49dfa-223">Therefore, we must create this DAL method as a stored procedure.</span></span> <span data-ttu-id="49dfa-224">選取 [View] 功能表中的 [伺服器總管] (或按 Ctrl + Alt + S) 並展開 `NORTHWND.MDF` 節點。</span><span class="sxs-lookup"><span data-stu-id="49dfa-224">Select the Server Explorer from the View menu (or hit Ctrl+Alt+S) and expand the `NORTHWND.MDF` node.</span></span> <span data-ttu-id="49dfa-225">若要加入新的預存程式，請以滑鼠右鍵按一下 [預存程式] 節點，然後選擇 [加入新的預存程式] (查看 [圖 6]) 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-225">To add a new stored procedure, right-click on the Stored Procedures node and choose Add a New Stored Procedure (see Figure 6).</span></span>

![加入新的預存程式，以透過產品進行分頁](efficiently-paging-through-large-amounts-of-data-vb/_static/image6.png)

<span data-ttu-id="49dfa-227">**圖 6**：加入新的預存程式，以透過產品進行分頁</span><span class="sxs-lookup"><span data-stu-id="49dfa-227">**Figure 6**: Add a New Stored Procedure for Paging Through the Products</span></span>

<span data-ttu-id="49dfa-228">這個預存程式應接受兩個整數輸入 `@startRowIndex` 參數 `@maximumRows` ，並使用 `ROW_NUMBER()` 依欄位排序的函式 `ProductName` ，只傳回大於指定 `@startRowIndex` 且小於或等於 s 的資料列 `@startRowIndex`  +  `@maximumRow` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-228">This stored procedure should accept two integer input parameters - `@startRowIndex` and `@maximumRows` and use the `ROW_NUMBER()` function ordered by the `ProductName` field, returning only those rows greater than the specified `@startRowIndex` and less than or equal to `@startRowIndex` + `@maximumRow` s.</span></span> <span data-ttu-id="49dfa-229">在新的預存程式中輸入下列腳本，然後按一下 [儲存] 圖示，將預存程式加入至資料庫。</span><span class="sxs-lookup"><span data-stu-id="49dfa-229">Enter the following script into the new stored procedure and then click the Save icon to add the stored procedure to the database.</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample7.sql)]

<span data-ttu-id="49dfa-230">在建立預存程式之後，請花點時間進行測試。以滑鼠右鍵按一下 `GetProductsPaged` 伺服器總管中的預存程式名稱，然後選擇 [執行] 選項。</span><span class="sxs-lookup"><span data-stu-id="49dfa-230">After creating the stored procedure, take a moment to test it out. Right-click on the `GetProductsPaged` stored procedure name in the Server Explorer and choose the Execute option.</span></span> <span data-ttu-id="49dfa-231">Visual Studio 接著會提示您輸入參數， `@startRowIndex` 而 `@maximumRow` (請參閱 [圖 7]) 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-231">Visual Studio will then prompt you for the input parameters, `@startRowIndex` and `@maximumRow` s (see Figure 7).</span></span> <span data-ttu-id="49dfa-232">請嘗試不同的值，並檢查結果。</span><span class="sxs-lookup"><span data-stu-id="49dfa-232">Try different values and examine the results.</span></span>

![輸入 @startRowIndex 和參數的值 @maximumRows](efficiently-paging-through-large-amounts-of-data-vb/_static/image7.png)

<span data-ttu-id="49dfa-234"><strong>圖 7</strong>：輸入 @startRowIndex 和參數的值 @maximumRows</span><span class="sxs-lookup"><span data-stu-id="49dfa-234"><strong>Figure 7</strong>: Enter a Value for the @startRowIndex and @maximumRows Parameters</span></span>

<span data-ttu-id="49dfa-235">選擇這些輸入參數值之後，輸出視窗會顯示結果。</span><span class="sxs-lookup"><span data-stu-id="49dfa-235">After choosing these input parameters values, the Output window will show the results.</span></span> <span data-ttu-id="49dfa-236">[圖 8] 顯示針對和參數傳入10時的 `@startRowIndex` 結果 `@maximumRows` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-236">Figure 8 shows the results when passing in 10 for both the `@startRowIndex` and `@maximumRows` parameters.</span></span>

<span data-ttu-id="49dfa-237">[![會傳回出現在第二頁數據的記錄](efficiently-paging-through-large-amounts-of-data-vb/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image8.png)</span><span class="sxs-lookup"><span data-stu-id="49dfa-237">[![The Records That Would Appear in the Second Page of Data are Returned](efficiently-paging-through-large-amounts-of-data-vb/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image8.png)</span></span>

<span data-ttu-id="49dfa-238">**圖 8**：會傳回出現在第二頁數據的記錄， ([按一下以查看完整大小的影像](efficiently-paging-through-large-amounts-of-data-vb/_static/image10.png)) </span><span class="sxs-lookup"><span data-stu-id="49dfa-238">**Figure 8**: The Records That Would Appear in the Second Page of Data are Returned ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image10.png))</span></span>

<span data-ttu-id="49dfa-239">建立此預存程式之後，我們就可以開始建立 `ProductsTableAdapter` 方法。</span><span class="sxs-lookup"><span data-stu-id="49dfa-239">With this stored procedure created, we re ready to create the `ProductsTableAdapter` method.</span></span> <span data-ttu-id="49dfa-240">開啟具 `Northwind.xsd` 類型的資料集，以滑鼠右鍵按一下 `ProductsTableAdapter` ，然後選擇 [加入查詢] 選項。</span><span class="sxs-lookup"><span data-stu-id="49dfa-240">Open the `Northwind.xsd` Typed DataSet, right-click in the `ProductsTableAdapter`, and choose the Add Query option.</span></span> <span data-ttu-id="49dfa-241">使用現有的預存程式，而不是使用臨機操作 SQL 語句來建立查詢。</span><span class="sxs-lookup"><span data-stu-id="49dfa-241">Instead of creating the query using an ad-hoc SQL statement, create it using an existing stored procedure.</span></span>

![使用現有的預存程式建立 DAL 方法](efficiently-paging-through-large-amounts-of-data-vb/_static/image11.png)

<span data-ttu-id="49dfa-243">**圖 9**：使用現有的預存程式建立 DAL 方法</span><span class="sxs-lookup"><span data-stu-id="49dfa-243">**Figure 9**: Create the DAL Method Using an Existing Stored Procedure</span></span>

<span data-ttu-id="49dfa-244">接下來，系統會提示您選取要叫用的預存程式。</span><span class="sxs-lookup"><span data-stu-id="49dfa-244">Next, we are prompted to select the stored procedure to invoke.</span></span> <span data-ttu-id="49dfa-245">`GetProductsPaged`從下拉式清單中選取預存程式。</span><span class="sxs-lookup"><span data-stu-id="49dfa-245">Pick the `GetProductsPaged` stored procedure from the drop-down list.</span></span>

![從下拉式清單中選擇 GetProductsPaged 預存程式](efficiently-paging-through-large-amounts-of-data-vb/_static/image12.png)

<span data-ttu-id="49dfa-247">**圖 10**：從下拉式清單選擇 GetProductsPaged 預存程式</span><span class="sxs-lookup"><span data-stu-id="49dfa-247">**Figure 10**: Choose the GetProductsPaged Stored Procedure from the Drop-Down List</span></span>

<span data-ttu-id="49dfa-248">接下來的畫面會詢問您預存程式所傳回的資料類型：表格式資料、單一值或無值。</span><span class="sxs-lookup"><span data-stu-id="49dfa-248">The next screen then asks you what kind of data is returned by the stored procedure: tabular data, a single value, or no value.</span></span> <span data-ttu-id="49dfa-249">由於 `GetProductsPaged` 預存程式可以傳回多個記錄，表示它會傳回表格式資料。</span><span class="sxs-lookup"><span data-stu-id="49dfa-249">Since the `GetProductsPaged` stored procedure can return multiple records, indicate that it returns tabular data.</span></span>

![指出預存程式會傳回表格式資料](efficiently-paging-through-large-amounts-of-data-vb/_static/image13.png)

<span data-ttu-id="49dfa-251">**圖 11**：指出預存程式傳回表格式資料</span><span class="sxs-lookup"><span data-stu-id="49dfa-251">**Figure 11**: Indicate that the Stored Procedure Returns Tabular Data</span></span>

<span data-ttu-id="49dfa-252">最後，指出您想要建立之方法的名稱。</span><span class="sxs-lookup"><span data-stu-id="49dfa-252">Finally, indicate the names of the methods you want to have created.</span></span> <span data-ttu-id="49dfa-253">如同先前的教學課程，請繼續進行，並使用「填滿 DataTable」和「傳回 DataTable」來建立方法。</span><span class="sxs-lookup"><span data-stu-id="49dfa-253">As with our previous tutorials, go ahead and create methods using both the Fill a DataTable and Return a DataTable.</span></span> <span data-ttu-id="49dfa-254">將第一個方法命名為第 `FillPaged` 二個 `GetProductsPaged` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-254">Name the first method `FillPaged` and the second `GetProductsPaged`.</span></span>

![將方法命名為 FillPaged 和 GetProductsPaged](efficiently-paging-through-large-amounts-of-data-vb/_static/image14.png)

<span data-ttu-id="49dfa-256">**圖 12**：將方法命名為 FillPaged 和 GetProductsPaged</span><span class="sxs-lookup"><span data-stu-id="49dfa-256">**Figure 12**: Name the Methods FillPaged and GetProductsPaged</span></span>

<span data-ttu-id="49dfa-257">除了建立 DAL 方法來傳回特定的產品頁面之外，我們也需要在 BLL 中提供這類功能。</span><span class="sxs-lookup"><span data-stu-id="49dfa-257">In addition to created a DAL method to return a particular page of products, we also need to provide such functionality in the BLL.</span></span> <span data-ttu-id="49dfa-258">與 DAL 方法相同，BLL s GetProductsPaged 方法必須接受兩個整數輸入，以指定開始資料列索引和最大資料列，而且必須只傳回落在指定範圍內的那些記錄。</span><span class="sxs-lookup"><span data-stu-id="49dfa-258">Like the DAL method, the BLL s GetProductsPaged method must accept two integer inputs for specifying the Start Row Index and Maximum Rows, and must return just those records that fall within the specified range.</span></span> <span data-ttu-id="49dfa-259">在 ProductsBLL 類別中建立這種類型的 BLL 方法，只會向下呼叫 DAL s GetProductsPaged 方法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="49dfa-259">Create such a BLL method in the ProductsBLL class that merely calls down into the DAL s GetProductsPaged method, like so:</span></span>

[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample8.vb)]

<span data-ttu-id="49dfa-260">您可以針對 BLL 方法的輸入參數使用任何名稱，但我們很快就會看到， `startRowIndex` `maximumRows` 在設定 ObjectDataSource 以使用此方法時，選擇使用並節省更多工作。</span><span class="sxs-lookup"><span data-stu-id="49dfa-260">You can use any name for the BLL method s input parameters, but, as we will see shortly, choosing to use `startRowIndex` and `maximumRows` saves us from an extra bit of work when configuring an ObjectDataSource to use this method.</span></span>

## <a name="step-4-configuring-the-objectdatasource-to-use-custom-paging"></a><span data-ttu-id="49dfa-261">步驟4：設定 ObjectDataSource 使用自訂分頁</span><span class="sxs-lookup"><span data-stu-id="49dfa-261">Step 4: Configuring the ObjectDataSource to Use Custom Paging</span></span>

<span data-ttu-id="49dfa-262">使用 BLL 和 DAL 方法來存取特定記錄子集之後，我們就可以開始建立 GridView 控制項，以使用自訂分頁來逐頁查看其基礎記錄。</span><span class="sxs-lookup"><span data-stu-id="49dfa-262">With the BLL and DAL methods for accessing a particular subset of records complete, we re ready to create a GridView control that pages through its underlying records using custom paging.</span></span> <span data-ttu-id="49dfa-263">首先 `EfficientPaging.aspx` ，開啟資料夾中的頁面 `PagingAndSorting` ，將 GridView 加入至頁面，並將它設定為使用新的 ObjectDataSource 控制項。</span><span class="sxs-lookup"><span data-stu-id="49dfa-263">Start by opening the `EfficientPaging.aspx` page in the `PagingAndSorting` folder, add a GridView to the page, and configure it to use a new ObjectDataSource control.</span></span> <span data-ttu-id="49dfa-264">在過去的教學課程中，我們通常會將 ObjectDataSource 設定為使用 `ProductsBLL` 類別 s `GetProducts` 方法。</span><span class="sxs-lookup"><span data-stu-id="49dfa-264">In our past tutorials, we often had the ObjectDataSource configured to use the `ProductsBLL` class s `GetProducts` method.</span></span> <span data-ttu-id="49dfa-265">不過，這次我們要改用 `GetProductsPaged` 方法，因為方法會傳回 `GetProducts` 資料庫中的 *所有* 產品，而只會傳回 `GetProductsPaged` 特定的記錄子集。</span><span class="sxs-lookup"><span data-stu-id="49dfa-265">This time, however, we want to use the `GetProductsPaged` method instead, since the `GetProducts` method returns *all* of the products in the database whereas `GetProductsPaged` returns just a particular subset of records.</span></span>

![將 ObjectDataSource 設定為使用 ProductsBLL 類別 s GetProductsPaged 方法](efficiently-paging-through-large-amounts-of-data-vb/_static/image15.png)

<span data-ttu-id="49dfa-267">**圖 13**：設定 ObjectDataSource 使用 ProductsBLL 類別的 GetProductsPaged 方法</span><span class="sxs-lookup"><span data-stu-id="49dfa-267">**Figure 13**: Configure the ObjectDataSource to Use the ProductsBLL Class s GetProductsPaged Method</span></span>

<span data-ttu-id="49dfa-268">由於我們要建立唯讀 GridView，請花點時間在 [插入]、[更新] 和 [刪除] 索引標籤中設定 [方法] 下拉式清單， ([無]) 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-268">Since we re creating a read-only GridView, take a moment to set the method drop-down list in the INSERT, UPDATE, and DELETE tabs to (None).</span></span>

<span data-ttu-id="49dfa-269">接下來，ObjectDataSource wizard 會提示我們輸入 `GetProductsPaged` 方法 `startRowIndex` 和 `maximumRows` 輸入參數值的來源。</span><span class="sxs-lookup"><span data-stu-id="49dfa-269">Next, the ObjectDataSource wizard prompts us for the sources of the `GetProductsPaged` method s `startRowIndex` and `maximumRows` input parameters values.</span></span> <span data-ttu-id="49dfa-270">這些輸入參數實際上會由 GridView 自動設定，因此只要將來源設定為 [無]，然後按一下 [完成] 即可。</span><span class="sxs-lookup"><span data-stu-id="49dfa-270">These input parameters will actually be set by the GridView automatically, so simply leave the source set to None and click Finish.</span></span>

![將輸入參數來源保留為無](efficiently-paging-through-large-amounts-of-data-vb/_static/image16.png)

<span data-ttu-id="49dfa-272">**圖 14**：將輸入參數來源保留為 None</span><span class="sxs-lookup"><span data-stu-id="49dfa-272">**Figure 14**: Leave the Input Parameter Sources as None</span></span>

<span data-ttu-id="49dfa-273">完成 ObjectDataSource wizard 之後，GridView 將會包含每個產品資料欄位的 BoundField 或 CheckBoxField。</span><span class="sxs-lookup"><span data-stu-id="49dfa-273">After completing the ObjectDataSource wizard, the GridView will contain a BoundField or CheckBoxField for each of the product data fields.</span></span> <span data-ttu-id="49dfa-274">您可以隨意調整 GridView 的外觀。</span><span class="sxs-lookup"><span data-stu-id="49dfa-274">Feel free to tailor the GridView s appearance as you see fit.</span></span> <span data-ttu-id="49dfa-275">我選擇只顯示 `ProductName` 、、 `CategoryName` `SupplierName` 、 `QuantityPerUnit` 和 `UnitPrice` BoundFields。</span><span class="sxs-lookup"><span data-stu-id="49dfa-275">I ve opted to display only the `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, and `UnitPrice` BoundFields.</span></span> <span data-ttu-id="49dfa-276">此外，請核取其智慧標籤中的 [啟用分頁] 核取方塊，將 GridView 設定為支援分頁。</span><span class="sxs-lookup"><span data-stu-id="49dfa-276">Also, configure the GridView to support paging by checking the Enable Paging checkbox in its smart tag.</span></span> <span data-ttu-id="49dfa-277">這些變更之後，GridView 和 ObjectDataSource 宣告式標記看起來應該類似下列內容：</span><span class="sxs-lookup"><span data-stu-id="49dfa-277">After these changes, the GridView and ObjectDataSource declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample9.aspx)]

<span data-ttu-id="49dfa-278">但是，如果您透過瀏覽器流覽網頁，則不需要找到 GridView。</span><span class="sxs-lookup"><span data-stu-id="49dfa-278">If you visit the page through a browser, however, the GridView is no where to be found.</span></span>

![GridView 未顯示](efficiently-paging-through-large-amounts-of-data-vb/_static/image17.png)

<span data-ttu-id="49dfa-280">**圖 15**：未顯示 GridView</span><span class="sxs-lookup"><span data-stu-id="49dfa-280">**Figure 15**: The GridView is Not Displayed</span></span>

<span data-ttu-id="49dfa-281">因為 ObjectDataSource 目前使用0做為 `GetProductsPaged` `startRowIndex` 和輸入參數的值，所以遺漏 GridView `maximumRows` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-281">The GridView is missing because the ObjectDataSource is currently using 0 as the values for both of the `GetProductsPaged` `startRowIndex` and `maximumRows` input parameters.</span></span> <span data-ttu-id="49dfa-282">因此，產生的 SQL 查詢不會傳回任何記錄，因此不會顯示 GridView。</span><span class="sxs-lookup"><span data-stu-id="49dfa-282">Hence, the resulting SQL query is returning no records and therefore the GridView is not displayed.</span></span>

<span data-ttu-id="49dfa-283">若要解決此情況，我們必須將 ObjectDataSource 設定為使用自訂分頁。</span><span class="sxs-lookup"><span data-stu-id="49dfa-283">To remedy this, we need to configure the ObjectDataSource to use custom paging.</span></span> <span data-ttu-id="49dfa-284">您可以在下列步驟中完成這項作業：</span><span class="sxs-lookup"><span data-stu-id="49dfa-284">This can be accomplished in the following steps:</span></span>

1. <span data-ttu-id="49dfa-285">\*\*將 objectdatasource s `EnablePaging` 屬性設為 `true` \*\* ，就會向 ObjectDataSource 指出它必須傳遞給 `SelectMethod` 兩個額外的參數：一個用來指定起始資料列索引 ([`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)) ，另一個則用來指定 () 的最大資料列 [`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx) 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-285">**Set the ObjectDataSource s `EnablePaging` property to `true`** this indicates to the ObjectDataSource that it must pass to the `SelectMethod` two additional parameters: one to specify the Start Row Index ([`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)), and one to specify the Maximum Rows ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).</span></span>
2. <span data-ttu-id="49dfa-286">**據此設定 ObjectDataSource `StartRowIndexParameterName` 和 `MaximumRowsParameterName` 屬性** `StartRowIndexParameterName` ，和 `MaximumRowsParameterName` 屬性會指出傳入的輸入參數名稱， `SelectMethod` 以供自訂分頁之用。</span><span class="sxs-lookup"><span data-stu-id="49dfa-286">**Set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` Properties Accordingly** the `StartRowIndexParameterName` and `MaximumRowsParameterName` properties indicate the names of the input parameters passed into the `SelectMethod` for custom paging purposes.</span></span> <span data-ttu-id="49dfa-287">根據預設，這些參數名稱是，而 `startIndexRow` `maximumRows` 這也是為什麼在 `GetProductsPaged` BLL 中建立方法時，我使用這些值做為輸入參數。</span><span class="sxs-lookup"><span data-stu-id="49dfa-287">By default, these parameter names are `startIndexRow` and `maximumRows`, which is why, when creating the `GetProductsPaged` method in the BLL, I used these values for the input parameters.</span></span> <span data-ttu-id="49dfa-288">如果您選擇對 BLL 的方法（例如和）使用不同的參數名稱，例如， `GetProductsPaged` `startIndex` `maxRows` 您將需要據以設定 ObjectDataSource `StartRowIndexParameterName` 和 `MaximumRowsParameterName` 屬性 (例如，) 的 startIndex for `StartRowIndexParameterName` 和 maxRows `MaximumRowsParameterName` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-288">If you chose to use different parameter names for the BLL s `GetProductsPaged` method such as `startIndex` and `maxRows`, for example you would need to set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` properties accordingly (such as startIndex for `StartRowIndexParameterName` and maxRows for `MaximumRowsParameterName`).</span></span>
3. <span data-ttu-id="49dfa-289">\*\*將 ObjectDataSource s [ `SelectCountMethod` 屬性](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx)設定為方法的名稱，此方法會傳回透過 (所分頁的記錄總數 `TotalNumberOfProducts`) \*\*回想一下， `ProductsBLL` 類別 s 方法會傳回 `TotalNumberOfProducts` 使用執行查詢的 DAL 方法來分頁的總記錄數 `SELECT COUNT(*) FROM Products` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-289">**Set the ObjectDataSource s [`SelectCountMethod` Property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) to the Name of the Method that Returns the Total Number of Records Being Paged Through (`TotalNumberOfProducts`)** recall that the `ProductsBLL` class s `TotalNumberOfProducts` method returns the total number of records being paged through using a DAL method that executes a `SELECT COUNT(*) FROM Products` query.</span></span> <span data-ttu-id="49dfa-290">ObjectDataSource 需要這項資訊，才能正確轉譯分頁介面。</span><span class="sxs-lookup"><span data-stu-id="49dfa-290">This information is needed by the ObjectDataSource in order to correctly render the paging interface.</span></span>
4. <span data-ttu-id="49dfa-291">當您透過 wizard 設定 ObjectDataSource 時， \*\* `startRowIndex` `maximumRows` `<asp:Parameter>` 從 ObjectDataSource 的宣告式標記中移除和元素\*\*，Visual Studio 自動新增 `<asp:Parameter>` `GetProductsPaged` 方法 s 輸入參數的兩個元素。</span><span class="sxs-lookup"><span data-stu-id="49dfa-291">**Remove the `startRowIndex` and `maximumRows` `<asp:Parameter>` Elements from the ObjectDataSource s Declarative Markup** when configuring the ObjectDataSource through the wizard, Visual Studio automatically added two `<asp:Parameter>` elements for the `GetProductsPaged` method s input parameters.</span></span> <span data-ttu-id="49dfa-292">藉由將設定 `EnablePaging` 為 `true` ，就會自動傳遞這些參數; 如果它們也出現在宣告式語法中，ObjectDataSource 會嘗試將 *四個* 參數傳遞給 `GetProductsPaged` 方法，並將兩個參數傳遞給 `TotalNumberOfProducts` 方法。</span><span class="sxs-lookup"><span data-stu-id="49dfa-292">By setting `EnablePaging` to `true`, these parameters will be passed automatically; if they also appear in the declarative syntax, the ObjectDataSource will attempt to pass *four* parameters to the `GetProductsPaged` method and two parameters to the `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="49dfa-293">如果您忘記移除這些專案 `<asp:Parameter>` ，當您透過瀏覽器流覽頁面時，將會收到類似下列的錯誤訊息： *ObjectDataSource ' ObjectDataSource1 ' 找不到具有參數： StartRowIndex，maximumRows 的非泛型方法 ' TotalNumberOfProducts '*。</span><span class="sxs-lookup"><span data-stu-id="49dfa-293">If you forget to remove these `<asp:Parameter>` elements, when visiting the page through a browser you'll get an error message like: *ObjectDataSource 'ObjectDataSource1' could not find a non-generic method 'TotalNumberOfProducts' that has parameters: startRowIndex, maximumRows*.</span></span>

<span data-ttu-id="49dfa-294">進行這些變更之後，ObjectDataSource 的宣告式語法看起來應該如下所示：</span><span class="sxs-lookup"><span data-stu-id="49dfa-294">After making these changes, the ObjectDataSource s declarative syntax should look like the following:</span></span>

[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample10.aspx)]

<span data-ttu-id="49dfa-295">請注意， `EnablePaging` 已 `SelectCountMethod` 設定和屬性，且已 `<asp:Parameter>` 移除這些元素。</span><span class="sxs-lookup"><span data-stu-id="49dfa-295">Note that the `EnablePaging` and `SelectCountMethod` properties have been set and the `<asp:Parameter>` elements have been removed.</span></span> <span data-ttu-id="49dfa-296">[圖 16] 顯示在進行這些變更之後，屬性視窗的螢幕擷取畫面。</span><span class="sxs-lookup"><span data-stu-id="49dfa-296">Figure 16 shows a screen shot of the Properties window after these changes have been made.</span></span>

![若要使用自訂分頁，請設定 ObjectDataSource 控制項](efficiently-paging-through-large-amounts-of-data-vb/_static/image18.png)

<span data-ttu-id="49dfa-298">**圖 16**：若要使用自訂分頁，請設定 ObjectDataSource 控制項</span><span class="sxs-lookup"><span data-stu-id="49dfa-298">**Figure 16**: To Use Custom Paging, Configure the ObjectDataSource Control</span></span>

<span data-ttu-id="49dfa-299">進行這些變更之後，請透過瀏覽器造訪此頁面。</span><span class="sxs-lookup"><span data-stu-id="49dfa-299">After making these changes, visit this page through a browser.</span></span> <span data-ttu-id="49dfa-300">您應該會看到依字母順序排列的10個產品。</span><span class="sxs-lookup"><span data-stu-id="49dfa-300">You should see 10 products listed, ordered alphabetically.</span></span> <span data-ttu-id="49dfa-301">花點時間逐一查看資料一頁。</span><span class="sxs-lookup"><span data-stu-id="49dfa-301">Take a moment to step through the data one page at a time.</span></span> <span data-ttu-id="49dfa-302">雖然使用者在預設分頁和自訂分頁之間沒有視覺差異，但是自訂頁面會透過大量資料更有效率地分頁，因為它只會抓取需要針對特定頁面顯示的記錄。</span><span class="sxs-lookup"><span data-stu-id="49dfa-302">While there is no visual difference from the end user s perspective between default paging and custom paging, custom paging more efficiently pages through large amounts of data as it only retrieves those records that need to be displayed for a given page.</span></span>

<span data-ttu-id="49dfa-303">[![依產品名稱排序的資料會使用自訂分頁進行分頁](efficiently-paging-through-large-amounts-of-data-vb/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="49dfa-303">[![The Data, Ordered by the Product s Name, is Paged Using Custom Paging](efficiently-paging-through-large-amounts-of-data-vb/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image19.png)</span></span>

<span data-ttu-id="49dfa-304">**圖 17**：依產品 s 名稱排序的資料會使用自訂分頁進行分頁 ([按一下以查看完整大小的影像](efficiently-paging-through-large-amounts-of-data-vb/_static/image21.png)) </span><span class="sxs-lookup"><span data-stu-id="49dfa-304">**Figure 17**: The Data, Ordered by the Product s Name, is Paged Using Custom Paging ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image21.png))</span></span>

> [!NOTE]
> <span data-ttu-id="49dfa-305">使用自訂分頁時，ObjectDataSource 所傳回的頁面計數值 `SelectCountMethod` 會儲存在 GridView 的檢視狀態中。</span><span class="sxs-lookup"><span data-stu-id="49dfa-305">With custom paging, the page count value returned by the ObjectDataSource's `SelectCountMethod` is stored in the GridView's view state.</span></span> <span data-ttu-id="49dfa-306">其他 GridView 變數 `PageIndex` ：、 `EditIndex` 、 `SelectedIndex` 、 `DataKeys` 集合等等都會儲存在 *控制項狀態*中，不論 GridView 的屬性值為何，都會保存該狀態 `EnableViewState` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-306">Other GridView variables the `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` collection, and so on are stored in *control state*, which is persisted regardless of the value of the GridView's `EnableViewState` property.</span></span> <span data-ttu-id="49dfa-307">由於此 `PageCount` 值會在使用 view 狀態的回傳之間保存，因此使用包含連結的頁面介面將您帶到最後一個頁面時，必須啟用 GridView 的檢視狀態。</span><span class="sxs-lookup"><span data-stu-id="49dfa-307">Since the `PageCount` value is persisted across postbacks using view state, when using a paging interface that includes a link to take you to the last page, it is imperative that the GridView's view state be enabled.</span></span> <span data-ttu-id="49dfa-308"> (如果您的分頁介面未包含最後一頁的直接連結，您可能會停用 [view state]。 ) </span><span class="sxs-lookup"><span data-stu-id="49dfa-308">(If your paging interface does not include a direct link to the last page, then you may disable view state.)</span></span>

<span data-ttu-id="49dfa-309">按一下 [最後一頁] 連結會導致回傳，並指示 GridView 更新其 `PageIndex` 屬性。</span><span class="sxs-lookup"><span data-stu-id="49dfa-309">Clicking the last page link causes a postback and instructs the GridView to update its `PageIndex` property.</span></span> <span data-ttu-id="49dfa-310">如果按一下 [最後一頁] 連結，GridView 會將其 `PageIndex` 屬性指派給一個小於其屬性的值 `PageCount` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-310">If the last page link is clicked, the GridView assigns its `PageIndex` property to a value one less than its `PageCount` property.</span></span> <span data-ttu-id="49dfa-311">停用 view 狀態時， `PageCount` 值會在回傳之間遺失， `PageIndex` 而會將最大整數值指派給。</span><span class="sxs-lookup"><span data-stu-id="49dfa-311">With view state disabled, the `PageCount` value is lost across postbacks and the `PageIndex` is assigned the maximum integer value instead.</span></span> <span data-ttu-id="49dfa-312">接下來，GridView 會透過將和屬性相乘來嘗試判斷起始資料列索引 `PageSize` `PageCount` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-312">Next, the GridView attempts to determine the starting row index by multiplying the `PageSize` and `PageCount` properties.</span></span> <span data-ttu-id="49dfa-313">這會導致， `OverflowException` 因為產品超過允許的整數大小上限。</span><span class="sxs-lookup"><span data-stu-id="49dfa-313">This results in an `OverflowException` since the product exceeds the maximum allowed integer size.</span></span>

## <a name="implement-custom-paging-and-sorting"></a><span data-ttu-id="49dfa-314">執行自訂分頁和排序</span><span class="sxs-lookup"><span data-stu-id="49dfa-314">Implement Custom Paging and Sorting</span></span>

<span data-ttu-id="49dfa-315">目前的自訂分頁執行需要在建立預存程式時，以靜態方式指定資料分頁的順序 `GetProductsPaged` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-315">Our current custom paging implementation requires that the order by which the data is paged through be specified statically when creating the `GetProductsPaged` stored procedure.</span></span> <span data-ttu-id="49dfa-316">不過，您可能已經注意到，除了啟用分頁選項以外，GridView 的智慧標籤還包含 [啟用排序] 核取方塊。</span><span class="sxs-lookup"><span data-stu-id="49dfa-316">However, you may have noted that the GridView s smart tag contains an Enable Sorting checkbox in addition to the Enable Paging option.</span></span> <span data-ttu-id="49dfa-317">可惜的是，使用目前的自訂分頁執行將排序支援新增至 GridView，只會在目前已查看的資料頁面上排序記錄。</span><span class="sxs-lookup"><span data-stu-id="49dfa-317">Unfortunately, adding sorting support to the GridView with our current custom paging implementation will only sort the records on the currently viewed page of data.</span></span> <span data-ttu-id="49dfa-318">例如，如果您將 GridView 設定為也支援分頁，然後在流覽資料的第一頁時，依產品名稱以遞減順序排序，就會反轉頁面1上產品的順序。</span><span class="sxs-lookup"><span data-stu-id="49dfa-318">For example, if you configure the GridView to also support paging and then, when viewing the first page of data, sort by product name in descending order, it will reverse the order of the products on page 1.</span></span> <span data-ttu-id="49dfa-319">如圖18所示，這種方式會在以反向字母順序排序時，顯示 Carnarvon 虎做為第一個產品，這會忽略 Carnarvon 虎之後的71其他產品（依字母順序）。只有第一個頁面上的記錄會被視為排序。</span><span class="sxs-lookup"><span data-stu-id="49dfa-319">As Figure 18 shows, such shows Carnarvon Tigers as the first product when sorting in reverse alphabetical order, which ignores the 71 other products that come after Carnarvon Tigers, alphabetically; only those records on the first page are considered in the sorting.</span></span>

<span data-ttu-id="49dfa-320">[![只會排序目前頁面上顯示的資料](efficiently-paging-through-large-amounts-of-data-vb/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="49dfa-320">[![Only the Data Shown on the Current Page is Sorted](efficiently-paging-through-large-amounts-of-data-vb/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image22.png)</span></span>

<span data-ttu-id="49dfa-321">**圖 18**：只有目前頁面上顯示的資料會排序 ([按一下以查看完整大小的影像](efficiently-paging-through-large-amounts-of-data-vb/_static/image24.png)) </span><span class="sxs-lookup"><span data-stu-id="49dfa-321">**Figure 18**: Only the Data Shown on the Current Page is Sorted ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image24.png))</span></span>

<span data-ttu-id="49dfa-322">排序只適用于目前的資料頁面，因為排序是在從 BLL s 方法取出資料之後發生 `GetProductsPaged` ，而且這個方法只會傳回特定頁面的那些記錄。</span><span class="sxs-lookup"><span data-stu-id="49dfa-322">The sorting only applies to the current page of data because the sorting is occurring after the data has been retrieved from the BLL s `GetProductsPaged` method, and this method only returns those records for the specific page.</span></span> <span data-ttu-id="49dfa-323">若要正確地執行排序，我們必須將排序運算式傳遞至 `GetProductsPaged` 方法，以便在傳回特定的資料頁面之前，先適當地排列資料的等級。</span><span class="sxs-lookup"><span data-stu-id="49dfa-323">To implement sorting correctly, we need to pass the sort expression to the `GetProductsPaged` method so that the data can be ranked appropriately before returning the specific page of data.</span></span> <span data-ttu-id="49dfa-324">我們將在下一個教學課程中瞭解如何完成這項工作。</span><span class="sxs-lookup"><span data-stu-id="49dfa-324">We'll see how to accomplish this in our next tutorial.</span></span>

## <a name="implementing-custom-paging-and-deleting"></a><span data-ttu-id="49dfa-325">執行自訂分頁和刪除</span><span class="sxs-lookup"><span data-stu-id="49dfa-325">Implementing Custom Paging and Deleting</span></span>

<span data-ttu-id="49dfa-326">如果您在使用自訂分頁技術來將資料分頁的 GridView 中啟用刪除功能，則會發現當您刪除最後一頁的最後一筆記錄時，GridView 會消失，而不會適當地遞減 GridView `PageIndex` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-326">If you enabling deleting functionality in a GridView whose data is paged using custom paging techniques you will find that when deleting the last record from the last page, the GridView disappears rather than appropriately decrementing the GridView s `PageIndex`.</span></span> <span data-ttu-id="49dfa-327">若要重現這個錯誤，請針對我們剛剛建立的教學課程啟用刪除。</span><span class="sxs-lookup"><span data-stu-id="49dfa-327">To reproduce this bug, enable deleting for the tutorial just we just created.</span></span> <span data-ttu-id="49dfa-328">移至最後一頁 (第9頁) ，您應該會在其中看到單一產品，因為我們會逐頁查看81產品、10個產品一次。</span><span class="sxs-lookup"><span data-stu-id="49dfa-328">Go to the last page (page 9), where you should see a single product since we are paging through 81 products, 10 products at a time.</span></span> <span data-ttu-id="49dfa-329">刪除此產品。</span><span class="sxs-lookup"><span data-stu-id="49dfa-329">Delete this product.</span></span>

<span data-ttu-id="49dfa-330">在刪除最後一個產品時，GridView *應該* 會自動移至第八個頁面，而這類功能會使用預設分頁來呈現。</span><span class="sxs-lookup"><span data-stu-id="49dfa-330">Upon deleting the last product, the GridView *should* automatically go to the eighth page, and such functionality is exhibited with default paging.</span></span> <span data-ttu-id="49dfa-331">不過，有了自訂分頁之後，在最後一頁上刪除最後一個產品之後，GridView 就完全從畫面中消失了。</span><span class="sxs-lookup"><span data-stu-id="49dfa-331">With custom paging, however, after deleting that last product on the last page, the GridView simply disappears from the screen altogether.</span></span> <span data-ttu-id="49dfa-332">發生這種情況的 *精確原因是此教學* 課程的範圍外，請參閱 [從 GridView 刪除最後一個頁面](http://scottonwriting.net/sowblog/posts/7326.aspx) 上的最後一筆記錄，其中包含有關此問題來源的低層級詳細資料的自訂分頁。</span><span class="sxs-lookup"><span data-stu-id="49dfa-332">The precise reason *why* this happens is a bit beyond the scope of this tutorial; see [Deleting the Last Record on the Last Page from a GridView with Custom Paging](http://scottonwriting.net/sowblog/posts/7326.aspx) for the low-level details as to the source of this problem.</span></span> <span data-ttu-id="49dfa-333">總而言之，這是因為按一下 [刪除] 按鈕時，GridView 所執行的下列步驟順序：</span><span class="sxs-lookup"><span data-stu-id="49dfa-333">In summary it s due to the following sequence of steps that are performed by the GridView when the Delete button is clicked:</span></span>

1. <span data-ttu-id="49dfa-334">刪除記錄</span><span class="sxs-lookup"><span data-stu-id="49dfa-334">Delete the record</span></span>
2. <span data-ttu-id="49dfa-335">取得要針對指定的和顯示的適當記錄 `PageIndex``PageSize`</span><span class="sxs-lookup"><span data-stu-id="49dfa-335">Get the appropriate records to display for the specified `PageIndex` and `PageSize`</span></span>
3. <span data-ttu-id="49dfa-336">檢查以確定不 `PageIndex` 會超過資料來源中的資料頁數; 如果有，則會自動遞減 GridView 的 `PageIndex` 屬性</span><span class="sxs-lookup"><span data-stu-id="49dfa-336">Check to ensure that the `PageIndex` does not exceed the number of pages of data in the data source; if it does, automatically decrement the GridView s `PageIndex` property</span></span>
4. <span data-ttu-id="49dfa-337">使用步驟2中取得的記錄，將適當的資料頁面系結至 GridView</span><span class="sxs-lookup"><span data-stu-id="49dfa-337">Bind the appropriate page of data to the GridView using the records obtained in Step 2</span></span>

<span data-ttu-id="49dfa-338">問題源自于步驟2中， `PageIndex` 當抓取要顯示的記錄時，所使用的也是 `PageIndex` 最後一頁剛刪除唯一記錄的情況。</span><span class="sxs-lookup"><span data-stu-id="49dfa-338">The problem stems from the fact that in Step 2 the `PageIndex` used when grabbing the records to display is still the `PageIndex` of the last page whose sole record was just deleted.</span></span> <span data-ttu-id="49dfa-339">因此，在步驟2中，因為最後一頁的資料已不再包含任何記錄，所以 *不* 會傳回任何記錄。</span><span class="sxs-lookup"><span data-stu-id="49dfa-339">Therefore, in Step 2, *no* records are returned since that last page of data no longer contains any records.</span></span> <span data-ttu-id="49dfa-340">然後，在步驟3中，GridView 發現其 `PageIndex` 屬性大於資料來源 (中的總頁數，因為我們已刪除最後一個) 頁面中的最後一筆記錄，因此會遞減其 `PageIndex` 屬性。</span><span class="sxs-lookup"><span data-stu-id="49dfa-340">Then, in Step 3, the GridView realizes that its `PageIndex` property is greater than the total number of pages in the data source (since we ve deleted the last record in the last page) and therefore decrements its `PageIndex` property.</span></span> <span data-ttu-id="49dfa-341">在步驟4中，GridView 會嘗試將本身系結至步驟2中所取出的資料;不過，在步驟2中，未傳回任何記錄，因此會產生空的 GridView。</span><span class="sxs-lookup"><span data-stu-id="49dfa-341">In Step 4 the GridView attempts to bind itself to the data retrieved in Step 2; however, in Step 2 no records were returned, therefore resulting in an empty GridView.</span></span> <span data-ttu-id="49dfa-342">使用預設分頁時，此問題並不會出現，因為在步驟2中， *所有* 記錄都會從資料來源取出。</span><span class="sxs-lookup"><span data-stu-id="49dfa-342">With default paging, this problem doesn t surface because in Step 2 *all* records are retrieved from the data source.</span></span>

<span data-ttu-id="49dfa-343">為了修正此問題，我們有兩個選項。</span><span class="sxs-lookup"><span data-stu-id="49dfa-343">To fix this we have two options.</span></span> <span data-ttu-id="49dfa-344">第一個方法是為 GridView 的事件處理常式建立事件處理常式 `RowDeleted` ，以決定要在頁面中顯示的記錄數目是剛才刪除的。</span><span class="sxs-lookup"><span data-stu-id="49dfa-344">The first is to create an event handler for the GridView s `RowDeleted` event handler that determines how many records were displayed in the page that was just deleted.</span></span> <span data-ttu-id="49dfa-345">如果只有一筆記錄，則剛刪除的記錄必須是最後一個記錄，而我們需要遞減 GridView `PageIndex` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-345">If there was only one record, then the record just deleted must have been the last one and we need to decrement the GridView s `PageIndex`.</span></span> <span data-ttu-id="49dfa-346">當然，我們只想要 `PageIndex` 在刪除作業真的成功時更新，這可以藉由確保 `e.Exception` 屬性為來判斷 `null` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-346">Of course, we only want to update the `PageIndex` if the delete operation was actually successful, which can be determined by ensuring that the `e.Exception` property is `null`.</span></span>

<span data-ttu-id="49dfa-347">這種方法的運作方式是因為它會 `PageIndex` 在步驟1之後，但在步驟2之前更新。</span><span class="sxs-lookup"><span data-stu-id="49dfa-347">This approach works because it updates the `PageIndex` after Step 1 but before Step 2.</span></span> <span data-ttu-id="49dfa-348">因此，在步驟2中，會傳回適當的一組記錄。</span><span class="sxs-lookup"><span data-stu-id="49dfa-348">Therefore, in Step 2, the appropriate set of records is returned.</span></span> <span data-ttu-id="49dfa-349">若要完成此動作，請使用如下所示的程式碼：</span><span class="sxs-lookup"><span data-stu-id="49dfa-349">To accomplish this, use code like the following:</span></span>

[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample11.vb)]

<span data-ttu-id="49dfa-350">替代的解決方法是為 ObjectDataSource s 事件建立事件處理常式 `RowDeleted` ，並將屬性設定 `AffectedRows` 為1的值。</span><span class="sxs-lookup"><span data-stu-id="49dfa-350">An alternative workaround is to create an event handler for the ObjectDataSource s `RowDeleted` event and to set the `AffectedRows` property to a value of 1.</span></span> <span data-ttu-id="49dfa-351">在步驟1中刪除記錄之後 (但在重新取得步驟 2) 中的資料之前， `PageIndex` 如果有一或多個資料列受作業影響，則 GridView 會更新其屬性。</span><span class="sxs-lookup"><span data-stu-id="49dfa-351">After deleting the record in Step 1 (but before re-retrieving the data in Step 2), the GridView updates its `PageIndex` property if one or more rows were affected by the operation.</span></span> <span data-ttu-id="49dfa-352">但是， `AffectedRows` 不會設定 ObjectDataSource 的屬性，因此會省略這個步驟。</span><span class="sxs-lookup"><span data-stu-id="49dfa-352">However, the `AffectedRows` property is not set by the ObjectDataSource and therefore this step is omitted.</span></span> <span data-ttu-id="49dfa-353">執行此步驟的其中一種方式，是 `AffectedRows` 在刪除作業成功完成時手動設定屬性。</span><span class="sxs-lookup"><span data-stu-id="49dfa-353">One way to have this step executed is to manually set the `AffectedRows` property if the delete operation completes successfully.</span></span> <span data-ttu-id="49dfa-354">您可以使用類似下列的程式碼來完成這項作業：</span><span class="sxs-lookup"><span data-stu-id="49dfa-354">This can be accomplished using code like the following:</span></span>

[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample12.vb)]

<span data-ttu-id="49dfa-355">這兩個事件處理常式的程式碼都可以在範例的程式碼後端類別中找到 `EfficientPaging.aspx` 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-355">The code for both of these events handlers can be found in code-behind class of the `EfficientPaging.aspx` example.</span></span>

## <a name="comparing-the-performance-of-default-and-custom-paging"></a><span data-ttu-id="49dfa-356">比較預設和自訂分頁的效能</span><span class="sxs-lookup"><span data-stu-id="49dfa-356">Comparing the Performance of Default and Custom Paging</span></span>

<span data-ttu-id="49dfa-357">由於自訂分頁只會抓取所需的記錄，而預設分頁會傳回所要查看之每個頁面的 *所有* 記錄，因此會清楚自訂分頁比預設分頁更有效率。</span><span class="sxs-lookup"><span data-stu-id="49dfa-357">Since custom paging only retrieves the needed records, whereas default paging returns *all* of the records for each page being viewed, it s clear that custom paging is more efficient than default paging.</span></span> <span data-ttu-id="49dfa-358">但自訂分頁的效率就愈高？</span><span class="sxs-lookup"><span data-stu-id="49dfa-358">But just how much more efficient is custom paging?</span></span> <span data-ttu-id="49dfa-359">從預設分頁移至自訂分頁可以看到哪些效能提升？</span><span class="sxs-lookup"><span data-stu-id="49dfa-359">What sort of performance gains can be seen by moving from default paging to custom paging?</span></span>

<span data-ttu-id="49dfa-360">可惜的是，這裡沒有一個大小適合的答案。</span><span class="sxs-lookup"><span data-stu-id="49dfa-360">Unfortunately, there s no one size fits all answer here.</span></span> <span data-ttu-id="49dfa-361">效能提升取決於許多因素，最重要的兩個是要進行分頁的記錄數目，以及放置於資料庫伺服器上的負載，以及 web 伺服器與資料庫伺服器之間的通道。</span><span class="sxs-lookup"><span data-stu-id="49dfa-361">The performance gain depends on a number of factors, the most prominent two being the number of records being paged through and the load placed on the database server and communication channels between the web server and database server.</span></span> <span data-ttu-id="49dfa-362">對於只有數十個記錄的小型資料表，效能差異可能會是微不足道。</span><span class="sxs-lookup"><span data-stu-id="49dfa-362">For small tables with just a few dozen records, the performance difference may be negligible.</span></span> <span data-ttu-id="49dfa-363">但是針對大型資料表，有數千到數百個數據列，效能差異很大。</span><span class="sxs-lookup"><span data-stu-id="49dfa-363">For large tables, with thousands to hundreds of thousands of rows, though, the performance difference is acute.</span></span>

<span data-ttu-id="49dfa-364">[ASP.NET 2.0 的自訂分頁（SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx)）包含一些效能測試，這些測試會在使用50000記錄進行資料庫資料表的分頁時，顯示這兩個分頁技術之間的效能差異。</span><span class="sxs-lookup"><span data-stu-id="49dfa-364">An article of mine, [Custom Paging in ASP.NET 2.0 with SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), contains some performance tests I ran to exhibit the differences in performance between these two paging techniques when paging through a database table with 50,000 records.</span></span> <span data-ttu-id="49dfa-365">在這些測試中，我同時探討了使用 [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) 的 SQL Server 層 (級執行查詢的時間，以及使用 [ASP.NET 追蹤功能](https://msdn.microsoft.com/library/y13fw6we.aspx)的 ASP.NET 網頁。</span><span class="sxs-lookup"><span data-stu-id="49dfa-365">In these tests I examined both the time to execute the query at the SQL Server level (using [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) and at the ASP.NET page using [ASP.NET s tracing features](https://msdn.microsoft.com/library/y13fw6we.aspx).</span></span> <span data-ttu-id="49dfa-366">請記住，這些測試是在具有單一作用中使用者的 [我的開發] 方塊上執行，因此 unscientific 且不會模擬一般網站負載模式。</span><span class="sxs-lookup"><span data-stu-id="49dfa-366">Keep in mind that these tests were run on my development box with a single active user, and therefore are unscientific and do not mimic typical website load patterns.</span></span> <span data-ttu-id="49dfa-367">無論如何，在使用足夠大量的資料時，結果都會說明預設和自訂分頁執行時間的相對差異。</span><span class="sxs-lookup"><span data-stu-id="49dfa-367">Regardless, the results illustrate the relative differences in execution time for default and custom paging when working with sufficiently large amounts of data.</span></span>

|  | <span data-ttu-id="49dfa-368">\*\*Avg. Duration (sec) \*\*</span><span class="sxs-lookup"><span data-stu-id="49dfa-368">**Avg. Duration (sec)**</span></span> | <span data-ttu-id="49dfa-369">**Reads**</span><span class="sxs-lookup"><span data-stu-id="49dfa-369">**Reads**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="49dfa-370">**預設分頁 SQL Profiler**</span><span class="sxs-lookup"><span data-stu-id="49dfa-370">**Default Paging SQL Profiler**</span></span> | <span data-ttu-id="49dfa-371">1.411</span><span class="sxs-lookup"><span data-stu-id="49dfa-371">1.411</span></span> | <span data-ttu-id="49dfa-372">383</span><span class="sxs-lookup"><span data-stu-id="49dfa-372">383</span></span> |
| <span data-ttu-id="49dfa-373">**自訂分頁 SQL Profiler**</span><span class="sxs-lookup"><span data-stu-id="49dfa-373">**Custom Paging SQL Profiler**</span></span> | <span data-ttu-id="49dfa-374">0.002</span><span class="sxs-lookup"><span data-stu-id="49dfa-374">0.002</span></span> | <span data-ttu-id="49dfa-375">29</span><span class="sxs-lookup"><span data-stu-id="49dfa-375">29</span></span> |
| <span data-ttu-id="49dfa-376">**預設分頁 ASP.NET 追蹤**</span><span class="sxs-lookup"><span data-stu-id="49dfa-376">**Default Paging ASP.NET Trace**</span></span> | <span data-ttu-id="49dfa-377">2.379</span><span class="sxs-lookup"><span data-stu-id="49dfa-377">2.379</span></span> | <span data-ttu-id="49dfa-378">*N/A*</span><span class="sxs-lookup"><span data-stu-id="49dfa-378">*N/A*</span></span> |
| <span data-ttu-id="49dfa-379">**自訂分頁 ASP.NET 追蹤**</span><span class="sxs-lookup"><span data-stu-id="49dfa-379">**Custom Paging ASP.NET Trace**</span></span> | <span data-ttu-id="49dfa-380">0.029</span><span class="sxs-lookup"><span data-stu-id="49dfa-380">0.029</span></span> | <span data-ttu-id="49dfa-381">*N/A*</span><span class="sxs-lookup"><span data-stu-id="49dfa-381">*N/A*</span></span> |

<span data-ttu-id="49dfa-382">如您所見，若要抓取特定的資料頁面，所需的平均資料量為354，並在一段時間內完成。</span><span class="sxs-lookup"><span data-stu-id="49dfa-382">As you can see, retrieving a particular page of data required 354 less reads on average and completed in a fraction of the time.</span></span> <span data-ttu-id="49dfa-383">在 [ASP.NET] 頁面上，自訂頁面在使用預設分頁時，可以在<sup>接近1/100 的</sup> 時間內轉譯。</span><span class="sxs-lookup"><span data-stu-id="49dfa-383">At the ASP.NET page, custom the page was able to render in close to 1/100<sup>th</sup> of the time it took when using default paging.</span></span> <span data-ttu-id="49dfa-384">請參閱 [我的文章](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) ，以取得這些結果的詳細資訊，以及您可以下載的程式碼和資料庫，以便在您自己的環境中重現這些測試。</span><span class="sxs-lookup"><span data-stu-id="49dfa-384">See [my article](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) for more information on these results along with code and a database you can download to reproduce these tests in your own environment.</span></span>

## <a name="summary"></a><span data-ttu-id="49dfa-385">總結</span><span class="sxs-lookup"><span data-stu-id="49dfa-385">Summary</span></span>

<span data-ttu-id="49dfa-386">預設分頁是一種標準化，可在資料 Web 控制項的智慧標籤中檢查 [啟用分頁] 核取方塊，但這種簡單的方式就是效能的成本。</span><span class="sxs-lookup"><span data-stu-id="49dfa-386">Default paging is a cinch to implement just check the Enable Paging checkbox in the data Web control s smart tag but such simplicity comes at the cost of performance.</span></span> <span data-ttu-id="49dfa-387">使用預設分頁時，當使用者要求任何頁面的資料時，會傳回 *所有* 記錄，雖然可能只會顯示一小部分的記錄。</span><span class="sxs-lookup"><span data-stu-id="49dfa-387">With default paging, when a user requests any page of data *all* records are returned, even though only a tiny fraction of them may be shown.</span></span> <span data-ttu-id="49dfa-388">為了對抗這項效能負擔，ObjectDataSource 提供了一個替代分頁選項自訂分頁。</span><span class="sxs-lookup"><span data-stu-id="49dfa-388">To combat this performance overhead, the ObjectDataSource offers an alternative paging option custom paging.</span></span>

<span data-ttu-id="49dfa-389">雖然自訂分頁可透過只抓取需要顯示的記錄來改善預設的分頁效能問題，但是更牽涉到執行自訂分頁。</span><span class="sxs-lookup"><span data-stu-id="49dfa-389">While custom paging improves upon default paging s performance issues by retrieving only those records that need to be displayed, it s more involved to implement custom paging.</span></span> <span data-ttu-id="49dfa-390">首先，必須以正確的方式撰寫查詢， (並有效率地) 存取所要求之記錄的特定子集。</span><span class="sxs-lookup"><span data-stu-id="49dfa-390">First, a query must be written that correctly (and efficiently) accesses the specific subset of records requested.</span></span> <span data-ttu-id="49dfa-391">這可以透過數種方式來完成;我們在本教學課程中所探討的是使用 SQL Server 2005 s new 函式 `ROW_NUMBER()` 來排名結果，然後只傳回排名落在指定範圍內的結果。</span><span class="sxs-lookup"><span data-stu-id="49dfa-391">This can be accomplished in a number of ways; the one we examined in this tutorial is to use SQL Server 2005 s new `ROW_NUMBER()` function to rank results, and then to return just those results whose ranking falls within a specified range.</span></span> <span data-ttu-id="49dfa-392">此外，我們還需要新增一個方法來判斷要進行分頁的記錄總數。</span><span class="sxs-lookup"><span data-stu-id="49dfa-392">Furthermore, we need to add a means to determine the total number of records being paged through.</span></span> <span data-ttu-id="49dfa-393">建立這些 DAL 和 BLL 方法之後，我們也需要設定 ObjectDataSource，讓它可以判斷要進行分頁的總記錄數，並且可以正確地將開始資料列索引和最大資料列值傳遞給 BLL。</span><span class="sxs-lookup"><span data-stu-id="49dfa-393">After creating these DAL and BLL methods, we also need to configure the ObjectDataSource so that it can determine how many total records are being paged through and can correctly pass the Start Row Index and Maximum Rows values to the BLL.</span></span>

<span data-ttu-id="49dfa-394">雖然執行自訂分頁的確需要一些步驟，而且不像預設分頁一樣簡單，但自訂分頁是分頁至足夠大量資料時的必要項。</span><span class="sxs-lookup"><span data-stu-id="49dfa-394">While implementing custom paging does require a number of steps and is not nearly as simple as default paging, custom paging is a necessity when paging through sufficiently large amounts of data.</span></span> <span data-ttu-id="49dfa-395">如所述，自訂分頁可能會縮減 ASP.NET 網頁轉譯時間的秒數，而且可以將資料庫伺服器上的負載淡化一或多個量值順序。</span><span class="sxs-lookup"><span data-stu-id="49dfa-395">As the results examined showed, custom paging can shed seconds off of the ASP.NET page render time and can lighten the load on the database server by one ore more orders of magnitude.</span></span>

<span data-ttu-id="49dfa-396">快樂程式設計！</span><span class="sxs-lookup"><span data-stu-id="49dfa-396">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="49dfa-397">關於作者</span><span class="sxs-lookup"><span data-stu-id="49dfa-397">About the Author</span></span>

<span data-ttu-id="49dfa-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，作者是七個 ASP/ASP. NET 書籍和創辦人 of [4GuysFromRolla.com](http://www.4guysfromrolla.com)，自1998起一直都在使用 Microsoft Web 技術。</span><span class="sxs-lookup"><span data-stu-id="49dfa-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="49dfa-399">Scott 以獨立顧問、訓練員和作者的形式運作。</span><span class="sxs-lookup"><span data-stu-id="49dfa-399">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="49dfa-400">他的最新書籍是 [*在24小時內 ASP.NET 2.0*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="49dfa-400">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="49dfa-401">您可以在此聯繫[ mitchell@4GuysFromRolla.com 。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="49dfa-401">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="49dfa-402">或者透過他的 blog （可在中找到） [http://ScottOnWriting.NET](http://ScottOnWriting.NET) 。</span><span class="sxs-lookup"><span data-stu-id="49dfa-402">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="49dfa-403">[上一個](paging-and-sorting-report-data-vb.md) 
> [下一步](sorting-custom-paged-data-vb.md)</span><span class="sxs-lookup"><span data-stu-id="49dfa-403">[Previous](paging-and-sorting-report-data-vb.md)
[Next](sorting-custom-paged-data-vb.md)</span></span>
