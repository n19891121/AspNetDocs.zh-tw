---
uid: web-forms/overview/data-access/paging-and-sorting/sorting-custom-paged-data-cs
title: 排序自訂的分頁C#資料（） |Microsoft Docs
author: rick-anderson
description: 在上一個教學課程中，我們已瞭解如何在 web 網頁上呈現資料時，執行自訂分頁。 在本教學課程中，我們會瞭解如何擴充前述的 。
ms.author: riande
ms.date: 08/15/2006
ms.assetid: 778baa4e-4af8-4665-947e-7a01d1a4dff2
msc.legacyurl: /web-forms/overview/data-access/paging-and-sorting/sorting-custom-paged-data-cs
msc.type: authoredcontent
ms.openlocfilehash: e55ed9b92814753e95bdfdf26c2f051df6f2630d
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/28/2019
ms.locfileid: "74642369"
---
# <a name="sorting-custom-paged-data-c"></a><span data-ttu-id="376d1-104">排序自訂的分頁資料 (C#)</span><span class="sxs-lookup"><span data-stu-id="376d1-104">Sorting Custom Paged Data (C#)</span></span>

<span data-ttu-id="376d1-105">由[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="376d1-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="376d1-106">[下載範例應用程式](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_26_CS.exe)或[下載 PDF](sorting-custom-paged-data-cs/_static/datatutorial26cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="376d1-106">[Download Sample App](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_26_CS.exe) or [Download PDF](sorting-custom-paged-data-cs/_static/datatutorial26cs1.pdf)</span></span>

> <span data-ttu-id="376d1-107">在上一個教學課程中，我們已瞭解如何在 web 網頁上呈現資料時，執行自訂分頁。</span><span class="sxs-lookup"><span data-stu-id="376d1-107">In the previous tutorial we learned how to implement custom paging when presenting data on a web page.</span></span> <span data-ttu-id="376d1-108">在本教學課程中，我們會瞭解如何擴充上述範例，以包含排序自訂分頁的支援。</span><span class="sxs-lookup"><span data-stu-id="376d1-108">In this tutorial we see how to extend the preceding example to include support for sorting custom paging.</span></span>

## <a name="introduction"></a><span data-ttu-id="376d1-109">簡介</span><span class="sxs-lookup"><span data-stu-id="376d1-109">Introduction</span></span>

<span data-ttu-id="376d1-110">相較于預設分頁，自訂分頁可以改善依數個量級排序資料分頁的效能，讓自訂分頁在分頁處理大量資料時，成為一種相當於事實上的分頁執行選擇。</span><span class="sxs-lookup"><span data-stu-id="376d1-110">Compared to default paging, custom paging can improve the performance of paging through data by several orders of magnitude, making custom paging the de facto paging implementation choice when paging through large amounts of data.</span></span> <span data-ttu-id="376d1-111">不過，執行自訂分頁比實作為預設分頁更為複雜，特別是在將排序加入至混合時。</span><span class="sxs-lookup"><span data-stu-id="376d1-111">Implementing custom paging is more involved than implementing default paging, however, especially when adding sorting to the mix.</span></span> <span data-ttu-id="376d1-112">在本教學課程中，我們將擴充前一個範例中的範例，以包含排序*和*自訂分頁的支援。</span><span class="sxs-lookup"><span data-stu-id="376d1-112">In this tutorial we'll extend the example from the preceding one to include support for sorting *and* custom paging.</span></span>

> [!NOTE]
> <span data-ttu-id="376d1-113">由於本教學課程是以先前的版本為基礎，因此在開始之前，請先從上一個教學課程的網頁（`EfficientPaging.aspx`）複製 `<asp:Content>` 元素內的宣告式語法，然後在 [`SortParameter.aspx`] 頁面的 [`<asp:Content>`] 元素之間貼上。</span><span class="sxs-lookup"><span data-stu-id="376d1-113">Since this tutorial builds upon the preceding one, before beginning take a moment to copy the declarative syntax within the `<asp:Content>` element from the preceding tutorial s web page (`EfficientPaging.aspx`) and paste it between the `<asp:Content>` element in the `SortParameter.aspx` page.</span></span> <span data-ttu-id="376d1-114">請回頭參閱將[驗證控制項新增至編輯和插入介面](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-cs.md)教學課程的步驟1，以深入瞭解如何將一個 ASP.NET 網頁的功能複寫至另一頁。</span><span class="sxs-lookup"><span data-stu-id="376d1-114">Refer back to Step 1 of the [Adding Validation Controls to the Editing and Inserting Interfaces](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-cs.md) tutorial for a more detailed discussion on replicating the functionality of one ASP.NET page to another.</span></span>

## <a name="step-1-reexamining-the-custom-paging-technique"></a><span data-ttu-id="376d1-115">步驟1： Reexamining 自訂分頁技術</span><span class="sxs-lookup"><span data-stu-id="376d1-115">Step 1: Reexamining the Custom Paging Technique</span></span>

<span data-ttu-id="376d1-116">若要讓自訂分頁正常運作，我們必須執行一些技術，讓它能夠有效率地抓取特定的記錄子集（給定起始資料列索引和最大資料列參數）。</span><span class="sxs-lookup"><span data-stu-id="376d1-116">For custom paging to work properly, we must implement some technique that can efficiently grab a particular subset of records given the Start Row Index and Maximum Rows parameters.</span></span> <span data-ttu-id="376d1-117">有一些技巧可以用來達成此目標。</span><span class="sxs-lookup"><span data-stu-id="376d1-117">There are a handful of techniques that can be used to achieve this aim.</span></span> <span data-ttu-id="376d1-118">在先前的教學課程中，我們探討了如何使用 Microsoft SQL Server 2005 s new `ROW_NUMBER()` 排名函式來完成這項工作。</span><span class="sxs-lookup"><span data-stu-id="376d1-118">In the preceding tutorial we looked at accomplishing this using Microsoft SQL Server 2005 s new `ROW_NUMBER()` ranking function.</span></span> <span data-ttu-id="376d1-119">簡單地說，`ROW_NUMBER()` 次序函數會將資料列編號指派給依指定排序次序排序之查詢所傳回的每個資料列。</span><span class="sxs-lookup"><span data-stu-id="376d1-119">In short, the `ROW_NUMBER()` ranking function assigns a row number to each row returned by a query that is ranked by a specified sort order.</span></span> <span data-ttu-id="376d1-120">然後藉由傳回編號結果的特定區段來取得適當的記錄子集。</span><span class="sxs-lookup"><span data-stu-id="376d1-120">The appropriate subset of records is then obtained by returning a particular section of the numbered results.</span></span> <span data-ttu-id="376d1-121">下列查詢說明如何使用這項技術，在依 `ProductName`的字母順序排序結果時，傳回編號為11到20的產品：</span><span class="sxs-lookup"><span data-stu-id="376d1-121">The following query illustrates how to use this technique to return those products numbered 11 through 20 when ranking the results ordered alphabetically by the `ProductName`:</span></span>

[!code-sql[Main](sorting-custom-paged-data-cs/samples/sample1.sql)]

<span data-ttu-id="376d1-122">這項技術適用于使用特定排序次序進行分頁（在此案例中`ProductName` 依字母順序排序），但必須修改查詢，以顯示依不同排序運算式排序的結果。</span><span class="sxs-lookup"><span data-stu-id="376d1-122">This technique works well for paging using a specific sort order (`ProductName` sorted alphabetically, in this case), but the query needs to be modified to show the results sorted by a different sort expression.</span></span> <span data-ttu-id="376d1-123">在理想的情況下，可以將上述查詢改寫成在 `OVER` 子句中使用參數，如下所示：</span><span class="sxs-lookup"><span data-stu-id="376d1-123">Ideally, the above query could be rewritten to use a parameter in the `OVER` clause, like so:</span></span>

[!code-sql[Main](sorting-custom-paged-data-cs/samples/sample2.sql)]

<span data-ttu-id="376d1-124">可惜的是，不允許參數化 `ORDER BY` 子句。</span><span class="sxs-lookup"><span data-stu-id="376d1-124">Unfortunately, parameterized `ORDER BY` clauses are not allowed.</span></span> <span data-ttu-id="376d1-125">相反地，我們必須建立可接受 `@sortExpression` 輸入參數的預存程式，但會使用下列其中一種因應措施：</span><span class="sxs-lookup"><span data-stu-id="376d1-125">Instead, we must create a stored procedure that accepts a `@sortExpression` input parameter, but uses one of the following workarounds:</span></span>

- <span data-ttu-id="376d1-126">針對每個可能使用的排序運算式撰寫硬式編碼的查詢;然後，使用 `IF/ELSE` T-sql 語句來判斷要執行的查詢。</span><span class="sxs-lookup"><span data-stu-id="376d1-126">Write hard-coded queries for each of the sort expressions that may be used; then, use `IF/ELSE` T-SQL statements to determine which query to execute.</span></span>
- <span data-ttu-id="376d1-127">使用 `CASE` 語句，根據 `@sortExpressio` n 輸入參數提供動態 `ORDER BY` 運算式;如需詳細資訊，請參閱[SQL `CASE` 語句的功能](http://www.4guysfromrolla.com/webtech/102704-1.shtml)中用來動態排序查詢結果一節的。</span><span class="sxs-lookup"><span data-stu-id="376d1-127">Use a `CASE` statement to provide dynamic `ORDER BY` expressions based on the `@sortExpressio` n input parameter; see the Used to Dynamically Sort Query Results section in [The Power of SQL `CASE` Statements](http://www.4guysfromrolla.com/webtech/102704-1.shtml) for more information.</span></span>
- <span data-ttu-id="376d1-128">將適當的查詢製作為預存程式中的字串，然後使用[`sp_executesql` 系統預存](https://msdn.microsoft.com/library/ms188001.aspx)程式來執行動態查詢。</span><span class="sxs-lookup"><span data-stu-id="376d1-128">Craft the appropriate query as a string in the stored procedure and then use [the `sp_executesql` system stored procedure](https://msdn.microsoft.com/library/ms188001.aspx) to execute the dynamic query.</span></span>

<span data-ttu-id="376d1-129">這些因應措施都有一些缺點。</span><span class="sxs-lookup"><span data-stu-id="376d1-129">Each of these workarounds has some drawbacks.</span></span> <span data-ttu-id="376d1-130">第一個選項並不像其他兩個一樣可維護，因為您需要為每個可能的排序運算式建立查詢。</span><span class="sxs-lookup"><span data-stu-id="376d1-130">The first option is not as maintainable as the other two as it requires that you create a query for each possible sort expression.</span></span> <span data-ttu-id="376d1-131">因此，如果您稍後決定要將新的可排序欄位加入至 GridView，您也必須返回並更新預存程式。</span><span class="sxs-lookup"><span data-stu-id="376d1-131">Therefore, if later you decide to add new, sortable fields to the GridView you will also need to go back and update the stored procedure.</span></span> <span data-ttu-id="376d1-132">第二種方法有一些微妙差異，會在依非字串資料庫資料行排序時引進效能考慮，而且也會與第一個的可維護性問題有所影響。</span><span class="sxs-lookup"><span data-stu-id="376d1-132">The second approach has some subtleties that introduce performance concerns when sorting by non-string database columns and also suffers from the same maintainability issues as the first.</span></span> <span data-ttu-id="376d1-133">第三個選擇（使用動態 SQL）會造成 SQL 插入式攻擊的風險，如果攻擊者能夠執行預存程式來傳入其選擇的輸入參數值。</span><span class="sxs-lookup"><span data-stu-id="376d1-133">And the third choice, which uses dynamic SQL, introduces the risk for a SQL injection attack if an attacker is able to execute the stored procedure passing in the input parameter values of their choosing.</span></span>

<span data-ttu-id="376d1-134">雖然這些方法都不是完美的，但我認為第三個選項是這三個最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="376d1-134">While none of these approaches is perfect, I think the third option is the best of the three.</span></span> <span data-ttu-id="376d1-135">隨著動態 SQL 的使用，它提供了其他兩個的彈性層級。</span><span class="sxs-lookup"><span data-stu-id="376d1-135">With its use of dynamic SQL, it offers a level of flexibility the other two do not.</span></span> <span data-ttu-id="376d1-136">此外，如果攻擊者能夠執行預存程式來傳入他所選的輸入參數，就只能利用 SQL 插入式攻擊。</span><span class="sxs-lookup"><span data-stu-id="376d1-136">Furthermore, a SQL injection attack can only be exploited if an attacker is able to execute the stored procedure passing in the input parameters of his choice.</span></span> <span data-ttu-id="376d1-137">由於 DAL 使用參數化查詢，因此 ADO.NET 會保護透過架構傳送至資料庫的參數，這表示只有在攻擊者可以直接執行預存程式時，SQL 插入式攻擊弱點才會存在。</span><span class="sxs-lookup"><span data-stu-id="376d1-137">Since the DAL uses parameterized queries, ADO.NET will protect those parameters that are sent to the database through the architecture, meaning that the SQL injection attack vulnerability only exists if the attacker can directly execute the stored procedure.</span></span>

<span data-ttu-id="376d1-138">若要執行這項功能，請在 Northwind 資料庫中建立名為 `GetProductsPagedAndSorted`的新預存程式。</span><span class="sxs-lookup"><span data-stu-id="376d1-138">To implement this functionality, create a new stored procedure in the Northwind database named `GetProductsPagedAndSorted`.</span></span> <span data-ttu-id="376d1-139">這個預存程式應接受三個輸入參數： `@sortExpression`、`nvarchar(100`類型的輸入參數），指定應該如何排序結果，並直接插入 `OVER` 子句中的 `ORDER BY` 文字後面。和 `@startRowIndex` 和 `@maximumRows`，從上一個教學課程中所檢查的 `GetProductsPaged` 預存程式中，相同的兩個整數輸入參數。</span><span class="sxs-lookup"><span data-stu-id="376d1-139">This stored procedure should accept three input parameters: `@sortExpression`, an input parameter of type `nvarchar(100`) that specifies how the results should be sorted and is injected directly after the `ORDER BY` text in the `OVER` clause; and `@startRowIndex` and `@maximumRows`, the same two integer input parameters from the `GetProductsPaged` stored procedure examined in the preceding tutorial.</span></span> <span data-ttu-id="376d1-140">使用下列腳本建立 `GetProductsPagedAndSorted` 預存程式：</span><span class="sxs-lookup"><span data-stu-id="376d1-140">Create the `GetProductsPagedAndSorted` stored procedure using the following script:</span></span>

[!code-sql[Main](sorting-custom-paged-data-cs/samples/sample3.sql)]

<span data-ttu-id="376d1-141">預存程式一開始會先確保已指定 `@sortExpression` 參數的值。</span><span class="sxs-lookup"><span data-stu-id="376d1-141">The stored procedure starts by ensuring that a value for the `@sortExpression` parameter has been specified.</span></span> <span data-ttu-id="376d1-142">如果遺失，則會依 `ProductID`將結果排序。</span><span class="sxs-lookup"><span data-stu-id="376d1-142">If it is missing, the results are ranked by `ProductID`.</span></span> <span data-ttu-id="376d1-143">接下來，會將動態 SQL 查詢結構化。</span><span class="sxs-lookup"><span data-stu-id="376d1-143">Next, the dynamic SQL query is constructed.</span></span> <span data-ttu-id="376d1-144">請注意，這裡的動態 SQL 查詢與先前用來從 Products 資料表中取出所有資料列的查詢稍有不同。</span><span class="sxs-lookup"><span data-stu-id="376d1-144">Note that the dynamic SQL query here differs slightly from our previous queries used to retrieve all rows from the Products table.</span></span> <span data-ttu-id="376d1-145">在先前的範例中，我們使用子查詢取得每個產品的相關聯類別和供應商名稱。</span><span class="sxs-lookup"><span data-stu-id="376d1-145">In prior examples, we obtained each product s associated category s and supplier s names using a subquery.</span></span> <span data-ttu-id="376d1-146">這項決定是在[建立資料存取層](../introduction/creating-a-data-access-layer-cs.md)教學課程中執行，而不是使用 `JOIN` s，因為 TableAdapter 無法自動為這類查詢建立相關聯的插入、更新和刪除方法。</span><span class="sxs-lookup"><span data-stu-id="376d1-146">This decision was made back in the [Creating a Data Access Layer](../introduction/creating-a-data-access-layer-cs.md) tutorial and was done in lieu of using `JOIN` s because the TableAdapter cannot automatically create the associated insert, update, and delete methods for such queries.</span></span> <span data-ttu-id="376d1-147">不過，`GetProductsPagedAndSorted` 預存程式必須使用 `JOIN` s，才會依據分類或供應商名稱來排序結果。</span><span class="sxs-lookup"><span data-stu-id="376d1-147">The `GetProductsPagedAndSorted` stored procedure, however, must use `JOIN` s for the results to be ordered by the category or supplier names.</span></span>

<span data-ttu-id="376d1-148">這個動態查詢是藉由串連靜態查詢部分和 `@sortExpression`、`@startRowIndex`和 `@maximumRows` 參數來建立的。</span><span class="sxs-lookup"><span data-stu-id="376d1-148">This dynamic query is built up by concatenating the static query portions and the `@sortExpression`, `@startRowIndex`, and `@maximumRows` parameters.</span></span> <span data-ttu-id="376d1-149">因為 `@startRowIndex` 和 `@maximumRows` 是整數參數，所以必須將它們轉換成 Nvarchars，才能正確串連。</span><span class="sxs-lookup"><span data-stu-id="376d1-149">Since `@startRowIndex` and `@maximumRows` are integer parameters, they must be converted into nvarchars in order to be correctly concatenated.</span></span> <span data-ttu-id="376d1-150">一旦建立此動態 SQL 查詢，它就會透過 `sp_executesql`來執行。</span><span class="sxs-lookup"><span data-stu-id="376d1-150">Once this dynamic SQL query has been constructed, it is executed via `sp_executesql`.</span></span>

<span data-ttu-id="376d1-151">請花點時間為 `@sortExpression`、`@startRowIndex`和 `@maximumRows` 參數的不同值測試此預存程式。</span><span class="sxs-lookup"><span data-stu-id="376d1-151">Take a moment to test this stored procedure with different values for the `@sortExpression`, `@startRowIndex`, and `@maximumRows` parameters.</span></span> <span data-ttu-id="376d1-152">在 伺服器總管中，以滑鼠右鍵按一下預存程式名稱，然後選擇 執行。</span><span class="sxs-lookup"><span data-stu-id="376d1-152">From the Server Explorer, right-click on the stored procedure name and choose Execute.</span></span> <span data-ttu-id="376d1-153">這會顯示 [執行預存程式] 對話方塊，您可以在其中輸入輸入參數（請參閱 [圖 1]）。</span><span class="sxs-lookup"><span data-stu-id="376d1-153">This will bring up the Run Stored Procedure dialog box into which you can enter the input parameters (see Figure 1).</span></span> <span data-ttu-id="376d1-154">若要依類別目錄名稱排序結果，請針對 `@sortExpression` 參數值使用 [類別目錄]。若要依供應商的公司名稱排序，請使用 [公司名稱]。</span><span class="sxs-lookup"><span data-stu-id="376d1-154">To sort the results by the category name, use CategoryName for the `@sortExpression` parameter value; to sort by the supplier s company name, use CompanyName.</span></span> <span data-ttu-id="376d1-155">提供參數值之後，按一下 [確定]。</span><span class="sxs-lookup"><span data-stu-id="376d1-155">After providing the parameters values, click OK.</span></span> <span data-ttu-id="376d1-156">結果會顯示在 [輸出] 視窗中。</span><span class="sxs-lookup"><span data-stu-id="376d1-156">The results are displayed in the Output window.</span></span> <span data-ttu-id="376d1-157">[圖 2] 顯示當以遞減順序依 `UnitPrice` 排序時，傳回11到20的產品時所得到的結果。</span><span class="sxs-lookup"><span data-stu-id="376d1-157">Figure 2 shows the results when returning products ranked 11 through 20 when ordering by the `UnitPrice` in descending order.</span></span>

![針對預存程式的三個輸入參數，嘗試不同的值](sorting-custom-paged-data-cs/_static/image1.png)

<span data-ttu-id="376d1-159">**圖 1**：針對預存程式的三個輸入參數，嘗試不同的值</span><span class="sxs-lookup"><span data-stu-id="376d1-159">**Figure 1**: Try Different Values for the Stored Procedure s Three Input Parameters</span></span>

<span data-ttu-id="376d1-160">[![預存程式的結果會顯示在輸出視窗](sorting-custom-paged-data-cs/_static/image3.png)](sorting-custom-paged-data-cs/_static/image2.png)</span><span class="sxs-lookup"><span data-stu-id="376d1-160">[![The Stored Procedure s Results are Shown in the Output Window](sorting-custom-paged-data-cs/_static/image3.png)](sorting-custom-paged-data-cs/_static/image2.png)</span></span>

<span data-ttu-id="376d1-161">**圖 2**：預存程式的結果會顯示在輸出視窗中（[按一下以查看完整大小的影像](sorting-custom-paged-data-cs/_static/image4.png)）</span><span class="sxs-lookup"><span data-stu-id="376d1-161">**Figure 2**: The Stored Procedure s Results are Shown in the Output Window ([Click to view full-size image](sorting-custom-paged-data-cs/_static/image4.png))</span></span>

> [!NOTE]
> <span data-ttu-id="376d1-162">當根據 `OVER` 子句中指定的 `ORDER BY` 資料行來排列結果的等級時，SQL Server 必須排序結果。</span><span class="sxs-lookup"><span data-stu-id="376d1-162">When ranking the results by the specified `ORDER BY` column in the `OVER` clause, SQL Server must sort the results.</span></span> <span data-ttu-id="376d1-163">如果在資料行上有叢集索引，則會將結果排序依據，或如果有涵蓋索引，則這是快速作業，否則會更耗費成本。</span><span class="sxs-lookup"><span data-stu-id="376d1-163">This is a quick operation if there is a clustered index over the column(s) the results are being ordered by or if there is a covering index, but can be more costly otherwise.</span></span> <span data-ttu-id="376d1-164">若要改善夠大的查詢效能，請考慮為結果排序依據的資料行加入非叢集索引。</span><span class="sxs-lookup"><span data-stu-id="376d1-164">To improve performance for sufficiently large queries, consider adding a non-clustered index for the column by which the results are ordered by.</span></span> <span data-ttu-id="376d1-165">如需詳細資訊，請參閱[SQL Server 2005 中的次序函數和效能](http://www.sql-server-performance.com/ak_ranking_functions.asp)。</span><span class="sxs-lookup"><span data-stu-id="376d1-165">Refer to [Ranking Functions and Performance in SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) for more details.</span></span>

## <a name="step-2-augmenting-the-data-access-and-business-logic-layers"></a><span data-ttu-id="376d1-166">步驟2：擴充資料存取和商務邏輯層</span><span class="sxs-lookup"><span data-stu-id="376d1-166">Step 2: Augmenting the Data Access and Business Logic Layers</span></span>

<span data-ttu-id="376d1-167">建立 `GetProductsPagedAndSorted` 預存程式之後，下一步就是提供方法，透過我們的應用程式架構來執行該預存程式。</span><span class="sxs-lookup"><span data-stu-id="376d1-167">With the `GetProductsPagedAndSorted` stored procedure created, our next step is to provide a means to execute that stored procedure through our application architecture.</span></span> <span data-ttu-id="376d1-168">這需要將適當的方法加入 DAL 和 BLL。</span><span class="sxs-lookup"><span data-stu-id="376d1-168">This entails adding an appropriate method to both the DAL and BLL.</span></span> <span data-ttu-id="376d1-169">首先，將方法新增至 DAL。</span><span class="sxs-lookup"><span data-stu-id="376d1-169">Let s start by adding a method to the DAL.</span></span> <span data-ttu-id="376d1-170">開啟 `Northwind.xsd` 類型資料集，以滑鼠右鍵按一下 `ProductsTableAdapter`，然後從內容功能表中選擇 [加入查詢] 選項。</span><span class="sxs-lookup"><span data-stu-id="376d1-170">Open the `Northwind.xsd` Typed DataSet, right-click on the `ProductsTableAdapter`, and choose the Add Query option from the context menu.</span></span> <span data-ttu-id="376d1-171">如同我們在先前的教學課程中所做的一樣，我們想要設定這個新的 DAL 方法，以使用現有的預存程式，在此情況下為 `GetProductsPagedAndSorted`。</span><span class="sxs-lookup"><span data-stu-id="376d1-171">As we did in the preceding tutorial, we want to configure this new DAL method to use an existing stored procedure - `GetProductsPagedAndSorted`, in this case.</span></span> <span data-ttu-id="376d1-172">一開始，表示您想要新的 TableAdapter 方法使用現有的預存程式。</span><span class="sxs-lookup"><span data-stu-id="376d1-172">Start by indicating that you want the new TableAdapter method to use an existing stored procedure.</span></span>

![選擇使用現有的預存程式](sorting-custom-paged-data-cs/_static/image5.png)

<span data-ttu-id="376d1-174">**圖 3**：選擇使用現有的預存程式</span><span class="sxs-lookup"><span data-stu-id="376d1-174">**Figure 3**: Choose to Use an Existing Stored Procedure</span></span>

<span data-ttu-id="376d1-175">若要指定要使用的預存程式，請從下一個畫面的下拉式清單中選取 [`GetProductsPagedAndSorted` 預存程式]。</span><span class="sxs-lookup"><span data-stu-id="376d1-175">To specify the stored procedure to use, select the `GetProductsPagedAndSorted` stored procedure from the drop-down list in the next screen.</span></span>

![使用 GetProductsPagedAndSorted 預存程式](sorting-custom-paged-data-cs/_static/image6.png)

<span data-ttu-id="376d1-177">**圖 4**：使用 GetProductsPagedAndSorted 預存程式</span><span class="sxs-lookup"><span data-stu-id="376d1-177">**Figure 4**: Use the GetProductsPagedAndSorted Stored Procedure</span></span>

<span data-ttu-id="376d1-178">這個預存程式會傳回一組記錄做為其結果，因此，在下一個畫面中，表示它會傳回表格式資料。</span><span class="sxs-lookup"><span data-stu-id="376d1-178">This stored procedure returns a set of records as its results so, in the next screen, indicate that it returns tabular data.</span></span>

![表示預存程式會傳回表格式資料](sorting-custom-paged-data-cs/_static/image7.png)

<span data-ttu-id="376d1-180">**圖 5**：表示預存程式會傳回表格式資料</span><span class="sxs-lookup"><span data-stu-id="376d1-180">**Figure 5**: Indicate that the Stored Procedure Returns Tabular Data</span></span>

<span data-ttu-id="376d1-181">最後，建立使用 [填滿 DataTable] 和 [傳回 DataTable 模式] 的 DAL 方法，分別命名 `FillPagedAndSorted` 和 `GetProductsPagedAndSorted`的方法。</span><span class="sxs-lookup"><span data-stu-id="376d1-181">Finally, create DAL methods that use both the Fill a DataTable and Return a DataTable patterns, naming the methods `FillPagedAndSorted` and `GetProductsPagedAndSorted`, respectively.</span></span>

![選擇方法名稱](sorting-custom-paged-data-cs/_static/image8.png)

<span data-ttu-id="376d1-183">**圖 6**：選擇方法名稱</span><span class="sxs-lookup"><span data-stu-id="376d1-183">**Figure 6**: Choose the Methods Names</span></span>

<span data-ttu-id="376d1-184">既然我們已經擴充 DAL，我們就準備好轉換成 BLL 了。</span><span class="sxs-lookup"><span data-stu-id="376d1-184">Now that we ve extended the DAL, we re ready to turn to the BLL.</span></span> <span data-ttu-id="376d1-185">開啟 `ProductsBLL` 類別檔案，並加入新的方法，`GetProductsPagedAndSorted`。</span><span class="sxs-lookup"><span data-stu-id="376d1-185">Open the `ProductsBLL` class file and add a new method, `GetProductsPagedAndSorted`.</span></span> <span data-ttu-id="376d1-186">這個方法必須接受三個輸入參數 `sortExpression`、`startRowIndex`和 `maximumRows`，而且應該只向下呼叫 DAL s `GetProductsPagedAndSorted` 方法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="376d1-186">This method needs to accept three input parameters `sortExpression`, `startRowIndex`, and `maximumRows` and should simply call down into the DAL s `GetProductsPagedAndSorted` method, like so:</span></span>

[!code-csharp[Main](sorting-custom-paged-data-cs/samples/sample4.cs)]

## <a name="step-3-configuring-the-objectdatasource-to-pass-in-the-sortexpression-parameter"></a><span data-ttu-id="376d1-187">步驟3：設定要傳入 SortExpression 參數的 ObjectDataSource</span><span class="sxs-lookup"><span data-stu-id="376d1-187">Step 3: Configuring the ObjectDataSource to Pass in the SortExpression Parameter</span></span>

<span data-ttu-id="376d1-188">增強 DAL 和 BLL 以包含利用 `GetProductsPagedAndSorted` 預存程式的方法，剩下的工作就是在 `SortParameter.aspx` 頁面中設定 ObjectDataSource，以使用新的 BLL 方法，並根據使用者已要求用來排序結果的資料行來傳入 `SortExpression` 參數。</span><span class="sxs-lookup"><span data-stu-id="376d1-188">Having augmented the DAL and BLL to include methods that utilize the `GetProductsPagedAndSorted` stored procedure, all that remains is to configure the ObjectDataSource in the `SortParameter.aspx` page to use the new BLL method and to pass in the `SortExpression` parameter based on the column that the user has requested to sort the results by.</span></span>

<span data-ttu-id="376d1-189">首先，將 ObjectDataSource s `SelectMethod` 從 `GetProductsPaged` 變更為 `GetProductsPagedAndSorted`。</span><span class="sxs-lookup"><span data-stu-id="376d1-189">Start by changing the ObjectDataSource s `SelectMethod` from `GetProductsPaged` to `GetProductsPagedAndSorted`.</span></span> <span data-ttu-id="376d1-190">這可以透過 [設定資料來源]、[屬性視窗] 或直接透過宣告式語法來完成。</span><span class="sxs-lookup"><span data-stu-id="376d1-190">This can be done through the Configure Data Source wizard, from the Properties window, or directly through the declarative syntax.</span></span> <span data-ttu-id="376d1-191">接下來，我們需要提供 ObjectDataSource s [`SortParameterName` 屬性](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.sortparametername.aspx)的值。</span><span class="sxs-lookup"><span data-stu-id="376d1-191">Next, we need to provide a value for the ObjectDataSource s [`SortParameterName` property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.sortparametername.aspx).</span></span> <span data-ttu-id="376d1-192">如果設定了這個屬性，ObjectDataSource 就會嘗試將 GridView 的 `SortExpression` 屬性傳入 `SelectMethod`。</span><span class="sxs-lookup"><span data-stu-id="376d1-192">If this property is set, the ObjectDataSource attempts to pass in the GridView s `SortExpression` property to the `SelectMethod`.</span></span> <span data-ttu-id="376d1-193">特別是，ObjectDataSource 會尋找其名稱等於 `SortParameterName` 屬性值的輸入參數。</span><span class="sxs-lookup"><span data-stu-id="376d1-193">In particular, the ObjectDataSource looks for an input parameter whose name is equal to the value of the `SortParameterName` property.</span></span> <span data-ttu-id="376d1-194">由於 BLL 的 `GetProductsPagedAndSorted` 方法具有名為 `sortExpression`的排序運算式輸入參數，因此請將 ObjectDataSource s `SortExpression` 屬性設定為 sortExpression。</span><span class="sxs-lookup"><span data-stu-id="376d1-194">Since the BLL s `GetProductsPagedAndSorted` method has the sort expression input parameter named `sortExpression`, set the ObjectDataSource s `SortExpression` property to sortExpression .</span></span>

<span data-ttu-id="376d1-195">進行這兩項變更之後，ObjectDataSource 的宣告式語法看起來應該如下所示：</span><span class="sxs-lookup"><span data-stu-id="376d1-195">After making these two changes, the ObjectDataSource s declarative syntax should look similar to the following:</span></span>

[!code-aspx[Main](sorting-custom-paged-data-cs/samples/sample5.aspx)]

> [!NOTE]
> <span data-ttu-id="376d1-196">如同先前的教學課程，請確定 ObjectDataSource 不會在其 SelectParameters 集合*中包含 sortExpression* 、StartRowIndex 或 maximumRows 輸入參數。</span><span class="sxs-lookup"><span data-stu-id="376d1-196">As with the preceding tutorial, ensure that the ObjectDataSource does *not* include the sortExpression, startRowIndex, or maximumRows input parameters in its SelectParameters collection.</span></span>

<span data-ttu-id="376d1-197">若要在 GridView 中啟用排序，只要勾選 GridView s 智慧標籤中的 [啟用排序] 核取方塊，將 GridView 的 `AllowSorting` 屬性設定為 `true`，並使每個資料行的標頭文字呈現為 LinkButton。</span><span class="sxs-lookup"><span data-stu-id="376d1-197">To enable sorting in the GridView, simply check the Enable Sorting checkbox in the GridView s smart tag, which sets the GridView s `AllowSorting` property to `true` and causing the header text for each column to be rendered as a LinkButton.</span></span> <span data-ttu-id="376d1-198">當終端使用者按一下其中一個標頭 LinkButtons 時，就會發生回傳接踵而來和下列步驟：</span><span class="sxs-lookup"><span data-stu-id="376d1-198">When the end user clicks on one of the header LinkButtons, a postback ensues and the following steps transpire:</span></span>

1. <span data-ttu-id="376d1-199">GridView 會將其[`SortExpression` 屬性](https://msdn.microsoft.com/library/system.web.ui.webcontrols.gridview.sortexpression.aspx)更新為按一下標題連結之欄位的 `SortExpression` 值</span><span class="sxs-lookup"><span data-stu-id="376d1-199">The GridView updates its [`SortExpression` property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.gridview.sortexpression.aspx) to the value of the `SortExpression` of the field whose header link was clicked</span></span>
2. <span data-ttu-id="376d1-200">ObjectDataSource 會叫用 BLL 的 `GetProductsPagedAndSorted` 方法，並傳入 GridView 的 `SortExpression` 屬性，做為方法 s `sortExpression` 輸入參數的值（以及適當的 `startRowIndex` 和 `maximumRows` 輸入參數值）</span><span class="sxs-lookup"><span data-stu-id="376d1-200">The ObjectDataSource invokes the BLL s `GetProductsPagedAndSorted` method, passing in the GridView s `SortExpression` property as the value for the method s `sortExpression` input parameter (along with the appropriate `startRowIndex` and `maximumRows` input parameter values)</span></span>
3. <span data-ttu-id="376d1-201">BLL 會叫用 DAL s `GetProductsPagedAndSorted` 方法</span><span class="sxs-lookup"><span data-stu-id="376d1-201">The BLL invokes the DAL s `GetProductsPagedAndSorted` method</span></span>
4. <span data-ttu-id="376d1-202">DAL 會執行 `GetProductsPagedAndSorted` 預存程式，傳入 `@sortExpression` 參數（連同 `@startRowIndex` 和 `@maximumRows` 輸入參數值）</span><span class="sxs-lookup"><span data-stu-id="376d1-202">The DAL executes the `GetProductsPagedAndSorted` stored procedure, passing in the `@sortExpression` parameter (along with the `@startRowIndex` and `@maximumRows` input parameter values)</span></span>
5. <span data-ttu-id="376d1-203">預存程式會將適當的資料子集傳回給 BLL，並將其傳回至 ObjectDataSource;然後，此資料會系結至 GridView、轉譯為 HTML，然後傳送給終端使用者</span><span class="sxs-lookup"><span data-stu-id="376d1-203">The stored procedure returns the appropriate subset of data to the BLL, which returns it to the ObjectDataSource; this data is then bound to the GridView, rendered into HTML, and sent down to the end user</span></span>

<span data-ttu-id="376d1-204">[圖 7] 顯示依 `UnitPrice` 以遞增順序排序時的第一頁結果。</span><span class="sxs-lookup"><span data-stu-id="376d1-204">Figure 7 shows the first page of results when sorted by the `UnitPrice` in ascending order.</span></span>

<span data-ttu-id="376d1-205">[![結果會依單價排序](sorting-custom-paged-data-cs/_static/image10.png)](sorting-custom-paged-data-cs/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="376d1-205">[![The Results are Sorted by the UnitPrice](sorting-custom-paged-data-cs/_static/image10.png)](sorting-custom-paged-data-cs/_static/image9.png)</span></span>

<span data-ttu-id="376d1-206">**圖 7**：結果依單價排序（[按一下以觀看完整大小的影像](sorting-custom-paged-data-cs/_static/image11.png)）</span><span class="sxs-lookup"><span data-stu-id="376d1-206">**Figure 7**: The Results are Sorted by the UnitPrice ([Click to view full-size image](sorting-custom-paged-data-cs/_static/image11.png))</span></span>

<span data-ttu-id="376d1-207">雖然目前的執行可以依產品名稱、類別目錄名稱、每個單位的數量和單價來正確排序結果，但嘗試依供應商名稱訂購結果會導致執行時間例外狀況（請參閱 [圖 8]）。</span><span class="sxs-lookup"><span data-stu-id="376d1-207">While the current implementation can correctly sort the results by product name, category name, quantity per unit, and unit price, attempting to order the results by the supplier name results in a runtime exception (see Figure 8).</span></span>

![嘗試依供應商排序結果會導致下列執行時間例外狀況](sorting-custom-paged-data-cs/_static/image12.png)

<span data-ttu-id="376d1-209">**圖 8**：嘗試依供應商排序結果會導致下列執行時間例外狀況</span><span class="sxs-lookup"><span data-stu-id="376d1-209">**Figure 8**: Attempting to Sort the Results by the Supplier Results in the Following Runtime Exception</span></span>

<span data-ttu-id="376d1-210">發生這個例外狀況的原因是 GridView `SupplierName` BoundField 的 `SortExpression` 設定為 `SupplierName`。</span><span class="sxs-lookup"><span data-stu-id="376d1-210">This exception occurs because the `SortExpression` of the GridView s `SupplierName` BoundField is set to `SupplierName`.</span></span> <span data-ttu-id="376d1-211">不過，實際上會呼叫 `Suppliers` 資料表中的供應商名稱，`CompanyName` 我們已將此資料行名稱的別名設為 `SupplierName`。</span><span class="sxs-lookup"><span data-stu-id="376d1-211">However, the supplier s name in the `Suppliers` table is actually called `CompanyName` we have been aliased this column name as `SupplierName`.</span></span> <span data-ttu-id="376d1-212">不過，`ROW_NUMBER()` 函數所使用的 `OVER` 子句不能使用別名，而且必須使用實際的資料行名稱。</span><span class="sxs-lookup"><span data-stu-id="376d1-212">However, the `OVER` clause used by the `ROW_NUMBER()` function cannot use the alias and must use the actual column name.</span></span> <span data-ttu-id="376d1-213">因此，請將 `SupplierName` BoundField s `SortExpression` 從「商」變更為「公司名稱」（請參閱 [圖 9]）。</span><span class="sxs-lookup"><span data-stu-id="376d1-213">Therefore, change the `SupplierName` BoundField s `SortExpression` from SupplierName to CompanyName (see Figure 9).</span></span> <span data-ttu-id="376d1-214">如 [圖 10] 所示，在這項變更之後，供應商可以排序結果。</span><span class="sxs-lookup"><span data-stu-id="376d1-214">As Figure 10 shows, after this change the results can be sorted by the supplier.</span></span>

![將 [BoundField] SortExpression 變更為 [公司名稱]](sorting-custom-paged-data-cs/_static/image13.png)

<span data-ttu-id="376d1-216">**圖 9**：將 [BoundField] SortExpression 變更為 [公司名稱]</span><span class="sxs-lookup"><span data-stu-id="376d1-216">**Figure 9**: Change the SupplierName BoundField s SortExpression to CompanyName</span></span>

<span data-ttu-id="376d1-217">[![現在可以依供應商排序結果](sorting-custom-paged-data-cs/_static/image15.png)](sorting-custom-paged-data-cs/_static/image14.png)</span><span class="sxs-lookup"><span data-stu-id="376d1-217">[![The Results Can Now Be Sorted by Supplier](sorting-custom-paged-data-cs/_static/image15.png)](sorting-custom-paged-data-cs/_static/image14.png)</span></span>

<span data-ttu-id="376d1-218">**圖 10**：現在可以依供應商排序結果（[按一下以觀看完整大小的影像](sorting-custom-paged-data-cs/_static/image16.png)）</span><span class="sxs-lookup"><span data-stu-id="376d1-218">**Figure 10**: The Results Can Now Be Sorted by Supplier ([Click to view full-size image](sorting-custom-paged-data-cs/_static/image16.png))</span></span>

## <a name="summary"></a><span data-ttu-id="376d1-219">總結</span><span class="sxs-lookup"><span data-stu-id="376d1-219">Summary</span></span>

<span data-ttu-id="376d1-220">我們在前一個教學課程中檢查的自訂分頁執行，需要在設計階段指定結果排序所依據的順序。</span><span class="sxs-lookup"><span data-stu-id="376d1-220">The custom paging implementation we examined in the preceding tutorial required that the order by which the results were to be sorted be specified at design time.</span></span> <span data-ttu-id="376d1-221">簡單地說，這表示我們所實行的自訂分頁執行無法同時提供排序功能。</span><span class="sxs-lookup"><span data-stu-id="376d1-221">In short, this meant that the custom paging implementation we implemented could not, at the same time, provide sorting capabilities.</span></span> <span data-ttu-id="376d1-222">在本教學課程中，我們會克服了這項限制，方法是從第一個延伸預存程式，以包含可供排序結果的 `@sortExpression` 輸入參數。</span><span class="sxs-lookup"><span data-stu-id="376d1-222">In this tutorial we overcame this limitation by extending the stored procedure from the first to include a `@sortExpression` input parameter by which the results could be sorted.</span></span>

<span data-ttu-id="376d1-223">建立這個預存程式並在 DAL 和 BLL 中建立新的方法之後，我們就能夠藉由設定 ObjectDataSource，將 GridView 的 current `SortExpression` 屬性傳入 BLL `SelectMethod`，來實作為排序和自訂分頁的 GridView。</span><span class="sxs-lookup"><span data-stu-id="376d1-223">After creating this stored procedure and creating new methods in the DAL and BLL, we were able to implement a GridView that offered both sorting and custom paging by configuring the ObjectDataSource to pass in the GridView s current `SortExpression` property to the BLL `SelectMethod`.</span></span>

<span data-ttu-id="376d1-224">快樂的程式設計！</span><span class="sxs-lookup"><span data-stu-id="376d1-224">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="376d1-225">關於作者</span><span class="sxs-lookup"><span data-stu-id="376d1-225">About the Author</span></span>

<span data-ttu-id="376d1-226">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，自1998起，有七個 ASP/ASP. NET 書籍和創辦人的[4GuysFromRolla.com](http://www.4guysfromrolla.com)。</span><span class="sxs-lookup"><span data-stu-id="376d1-226">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="376d1-227">Scott 以獨立的顧問、訓練員和作者的身分運作。</span><span class="sxs-lookup"><span data-stu-id="376d1-227">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="376d1-228">他的最新著作是[*在24小時內讓自己的 ASP.NET 2.0*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="376d1-228">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="376d1-229">他可以在mitchell@4GuysFromRolla.com觸達[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="376d1-229">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="376d1-230">或者透過他的 blog，可以在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)找到。</span><span class="sxs-lookup"><span data-stu-id="376d1-230">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="376d1-231">特別感謝</span><span class="sxs-lookup"><span data-stu-id="376d1-231">Special Thanks To</span></span>

<span data-ttu-id="376d1-232">本教學課程系列已由許多有用的審核者所審查。</span><span class="sxs-lookup"><span data-stu-id="376d1-232">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="376d1-233">本教學課程的領導審查者為 Carlos Santos。</span><span class="sxs-lookup"><span data-stu-id="376d1-233">Lead reviewer for this tutorial was Carlos Santos.</span></span> <span data-ttu-id="376d1-234">有興趣複習我即將發行的 MSDN 文章嗎？</span><span class="sxs-lookup"><span data-stu-id="376d1-234">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="376d1-235">若是如此，請在mitchell@4GuysFromRolla.com的那一行下拉式[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="376d1-235">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="376d1-236">[上一頁](efficiently-paging-through-large-amounts-of-data-cs.md)
> [下一頁](creating-a-customized-sorting-user-interface-cs.md)</span><span class="sxs-lookup"><span data-stu-id="376d1-236">[Previous](efficiently-paging-through-large-amounts-of-data-cs.md)
[Next](creating-a-customized-sorting-user-interface-cs.md)</span></span>
