---
uid: web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-vb
title: 在架構中快取資料（VB） |Microsoft Docs
author: rick-anderson
description: 在上一個教學課程中，我們已瞭解如何在展示層套用快取。 在本教學課程中，我們將學習如何利用我們的分層 architectu 。
ms.author: riande
ms.date: 05/30/2007
ms.assetid: 5e189dd7-f4f9-4f28-9b3a-6cb7d392e9c7
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-vb
msc.type: authoredcontent
ms.openlocfilehash: dc991a205fa7e61f604bc0f26e9b24b3faefd3d3
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/06/2020
ms.locfileid: "78551006"
---
# <a name="caching-data-in-the-architecture-vb"></a><span data-ttu-id="720a2-104">在架構中快取資料 (VB)</span><span class="sxs-lookup"><span data-stu-id="720a2-104">Caching Data in the Architecture (VB)</span></span>

<span data-ttu-id="720a2-105">由[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="720a2-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="720a2-106">[下載範例應用程式](https://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_VB.exe)或[下載 PDF](caching-data-in-the-architecture-vb/_static/datatutorial59vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="720a2-106">[Download Sample App](https://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_VB.exe) or [Download PDF](caching-data-in-the-architecture-vb/_static/datatutorial59vb1.pdf)</span></span>

> <span data-ttu-id="720a2-107">在上一個教學課程中，我們已瞭解如何在展示層套用快取。</span><span class="sxs-lookup"><span data-stu-id="720a2-107">In the previous tutorial we learned how to apply caching at the Presentation Layer.</span></span> <span data-ttu-id="720a2-108">在本教學課程中，我們將學習如何利用我們的多層式架構，在商務邏輯層快取資料。</span><span class="sxs-lookup"><span data-stu-id="720a2-108">In this tutorial we learn how to take advantage of our layered architecture to cache data at the Business Logic Layer.</span></span> <span data-ttu-id="720a2-109">我們藉由擴充架構以包含快取層來完成這項操作。</span><span class="sxs-lookup"><span data-stu-id="720a2-109">We do this by extending the architecture to include a Caching Layer.</span></span>

## <a name="introduction"></a><span data-ttu-id="720a2-110">簡介</span><span class="sxs-lookup"><span data-stu-id="720a2-110">Introduction</span></span>

<span data-ttu-id="720a2-111">如我們在先前的教學課程中所見，快取 ObjectDataSource 的資料就像設定幾個屬性一樣簡單。</span><span class="sxs-lookup"><span data-stu-id="720a2-111">As we saw in the preceding tutorial, caching the ObjectDataSource s data is as simple as setting a couple of properties.</span></span> <span data-ttu-id="720a2-112">可惜的是，ObjectDataSource 會在展示層套用快取，這會將快取原則與 ASP.NET 網頁緊密耦合。</span><span class="sxs-lookup"><span data-stu-id="720a2-112">Unfortunately, the ObjectDataSource applies caching at the Presentation Layer, which tightly couples the caching policies with the ASP.NET page.</span></span> <span data-ttu-id="720a2-113">建立多層式架構的其中一個原因是允許中斷這類聯繫性。</span><span class="sxs-lookup"><span data-stu-id="720a2-113">One of the reasons for creating a layered architecture is to allow such couplings to be broken.</span></span> <span data-ttu-id="720a2-114">例如，商務邏輯層會將商務邏輯與 ASP.NET 網頁分開，而資料存取層則會將資料存取的細節分離。</span><span class="sxs-lookup"><span data-stu-id="720a2-114">The Business Logic Layer, for instance, decouples the business logic from the ASP.NET pages, while the Data Access Layer decouples the data access details.</span></span> <span data-ttu-id="720a2-115">這種分離商務邏輯和資料存取的細節是個比較好的部分，因為它可讓系統更容易閱讀、更容易維護，而且更有彈性地進行變更。</span><span class="sxs-lookup"><span data-stu-id="720a2-115">This decoupling of business logic and data access details is preferred, in part, because it makes the system more readable, more maintainable, and more flexible to change.</span></span> <span data-ttu-id="720a2-116">它也可讓開發人員在展示層上進行領域知識和部門的工作，而不需要熟悉資料庫的詳細資料，就能完成工作。</span><span class="sxs-lookup"><span data-stu-id="720a2-116">It also allows for domain knowledge and division of labor a developer working on the Presentation Layer doesn t need to be familiar with the database s details in order to do her job.</span></span> <span data-ttu-id="720a2-117">將快取原則與展示層分離，可提供類似的優點。</span><span class="sxs-lookup"><span data-stu-id="720a2-117">Decoupling the caching policy from the Presentation Layer offers similar benefits.</span></span>

<span data-ttu-id="720a2-118">在本教學課程中，我們將擴充我們的架構，以包含採用我們的快取原則的快取*層*（或簡稱 CL）。</span><span class="sxs-lookup"><span data-stu-id="720a2-118">In this tutorial we will augment our architecture to include a *Caching Layer* (or CL for short) that employs our caching policy.</span></span> <span data-ttu-id="720a2-119">快取層會包含一個 `ProductsCL` 類別，可讓您使用 `GetProducts()`、`GetProductsByCategoryID(categoryID)`等方法來存取產品資訊，而叫用時，會先嘗試從快取取得資料。</span><span class="sxs-lookup"><span data-stu-id="720a2-119">The Caching Layer will include a `ProductsCL` class that provides access to product information with methods like `GetProducts()`, `GetProductsByCategoryID(categoryID)`, and so forth, that, when invoked, will first attempt to retrieve the data from the cache.</span></span> <span data-ttu-id="720a2-120">如果快取是空的，這些方法會在 BLL 中叫用適當的 `ProductsBLL` 方法，進而從 DAL 取得資料。</span><span class="sxs-lookup"><span data-stu-id="720a2-120">If the cache is empty, these methods will invoke the appropriate `ProductsBLL` method in the BLL, which would in turn get the data from the DAL.</span></span> <span data-ttu-id="720a2-121">`ProductsCL` 方法會快取從 BLL 抓取的資料，然後再將它傳回。</span><span class="sxs-lookup"><span data-stu-id="720a2-121">The `ProductsCL` methods cache the data retrieved from the BLL before returning it.</span></span>

<span data-ttu-id="720a2-122">如 [圖 1] 所示，CL 位於簡報和商務邏輯層之間。</span><span class="sxs-lookup"><span data-stu-id="720a2-122">As Figure 1 shows, the CL resides between the Presentation and Business Logic Layers.</span></span>

![Caching 層（CL）是我們架構中的另一層](caching-data-in-the-architecture-vb/_static/image1.png)

<span data-ttu-id="720a2-124">**圖 1**： Caching 層（CL）是我們架構中的另一層</span><span class="sxs-lookup"><span data-stu-id="720a2-124">**Figure 1**: The Caching Layer (CL) is Another Layer in Our Architecture</span></span>

## <a name="step-1-creating-the-caching-layer-classes"></a><span data-ttu-id="720a2-125">步驟1：建立快取層類別</span><span class="sxs-lookup"><span data-stu-id="720a2-125">Step 1: Creating the Caching Layer Classes</span></span>

<span data-ttu-id="720a2-126">在本教學課程中，我們將建立一個非常簡單的 CL，其中有一個只有少數方法的單一類別 `ProductsCL`。</span><span class="sxs-lookup"><span data-stu-id="720a2-126">In this tutorial we will create a very simple CL with a single class `ProductsCL` that has only a handful of methods.</span></span> <span data-ttu-id="720a2-127">為整個應用程式建立完整的快取層，需要建立 `CategoriesCL`、`EmployeesCL`和 `SuppliersCL` 類別，並針對 BLL 中的每個資料存取或修改方法，在這些快取層類別中提供方法。</span><span class="sxs-lookup"><span data-stu-id="720a2-127">Building a complete Caching Layer for the entire application would require creating `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes, and providing a method in these Caching Layer classes for each data access or modification method in the BLL.</span></span> <span data-ttu-id="720a2-128">如同 BLL 和 DAL，快取層應該最好實作為個別的類別庫專案;不過，我們會將它實作為 [`App_Code`] 資料夾中的類別。</span><span class="sxs-lookup"><span data-stu-id="720a2-128">As with the BLL and DAL, the Caching Layer should ideally be implemented as a separate Class Library project; however, we will implement it as a class in the `App_Code` folder.</span></span>

<span data-ttu-id="720a2-129">為了更清楚地區分 CL 類別與 DAL 和 BLL 類別，讓 s 在 `App_Code` 資料夾中建立新的子資料夾。</span><span class="sxs-lookup"><span data-stu-id="720a2-129">To more cleanly separate the CL classes from the DAL and BLL classes, let s create a new subfolder in the `App_Code` folder.</span></span> <span data-ttu-id="720a2-130">以滑鼠右鍵按一下 方案總管中的 `App_Code` 資料夾，選擇 新增資料夾，然後將新資料夾命名為 `CL`。</span><span class="sxs-lookup"><span data-stu-id="720a2-130">Right-click on the `App_Code` folder in the Solution Explorer, choose New Folder, and name the new folder `CL`.</span></span> <span data-ttu-id="720a2-131">建立此資料夾之後，請將名為 `ProductsCL.vb`的新類別新增至其中。</span><span class="sxs-lookup"><span data-stu-id="720a2-131">After creating this folder, add to it a new class named `ProductsCL.vb`.</span></span>

![新增名為 CL 的新資料夾和名為 ProductsCL 的類別](caching-data-in-the-architecture-vb/_static/image2.png)

<span data-ttu-id="720a2-133">**圖 2**：新增名為 `CL` 的新資料夾，以及名為 `ProductsCL.vb` 的類別</span><span class="sxs-lookup"><span data-stu-id="720a2-133">**Figure 2**: Add a New Folder Named `CL` and a Class Named `ProductsCL.vb`</span></span>

<span data-ttu-id="720a2-134">`ProductsCL` 類別應該包含一組相同的資料存取和修改方法，如同在其對應的商務邏輯層級（`ProductsBLL`）中找到。</span><span class="sxs-lookup"><span data-stu-id="720a2-134">The `ProductsCL` class should include the same set of data access and modification methods as found in its corresponding Business Logic Layer class (`ProductsBLL`).</span></span> <span data-ttu-id="720a2-135">我們不會建立所有這些方法，而是只在這裡建立幾個，以瞭解 CL 所使用的模式。</span><span class="sxs-lookup"><span data-stu-id="720a2-135">Rather than creating all of these methods, let s just build a couple here to get a feel for the patterns used by the CL.</span></span> <span data-ttu-id="720a2-136">特別的是，我們會在步驟3中新增 `GetProducts()` 和 `GetProductsByCategoryID(categoryID)` 方法，並在步驟4中加入 `UpdateProduct` 多載。</span><span class="sxs-lookup"><span data-stu-id="720a2-136">In particular, we'll add the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods in Step 3 and an `UpdateProduct` overload in Step 4.</span></span> <span data-ttu-id="720a2-137">您可以在休閒中新增其餘的 `ProductsCL` 方法和 `CategoriesCL`、`EmployeesCL`和 `SuppliersCL` 類別。</span><span class="sxs-lookup"><span data-stu-id="720a2-137">You can add the remaining `ProductsCL` methods and `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes at your leisure.</span></span>

## <a name="step-2-reading-and-writing-to-the-data-cache"></a><span data-ttu-id="720a2-138">步驟2：讀取和寫入資料快取</span><span class="sxs-lookup"><span data-stu-id="720a2-138">Step 2: Reading and Writing to the Data Cache</span></span>

<span data-ttu-id="720a2-139">在上一個教學課程中探索的 ObjectDataSource 快取功能會在內部使用 ASP.NET 資料快取，來儲存從 BLL 取得的資料。</span><span class="sxs-lookup"><span data-stu-id="720a2-139">The ObjectDataSource caching feature explored in the preceding tutorial internally uses the ASP.NET data cache to store the data retrieved from the BLL.</span></span> <span data-ttu-id="720a2-140">您也可以從 ASP.NET 網頁的程式碼後置類別，或從 web 應用程式架構中的類別，以程式設計方式存取資料快取。</span><span class="sxs-lookup"><span data-stu-id="720a2-140">The data cache can also be accessed programmatically from ASP.NET pages code-behind classes or from the classes in the web application s architecture.</span></span> <span data-ttu-id="720a2-141">若要從 ASP.NET 網頁的程式碼後置類別讀取及寫入資料快取，請使用下列模式：</span><span class="sxs-lookup"><span data-stu-id="720a2-141">To read and write to the data cache from an ASP.NET page s code-behind class, use the following pattern:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample1.vb)]

<span data-ttu-id="720a2-142">[`Cache` 類別](https://msdn.microsoft.com/library/system.web.caching.cache.aspx)的[`Insert` 方法](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx)有數個多載。</span><span class="sxs-lookup"><span data-stu-id="720a2-142">The [`Cache` class](https://msdn.microsoft.com/library/system.web.caching.cache.aspx) s [`Insert` method](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx) has a number of overloads.</span></span> <span data-ttu-id="720a2-143">`Cache("key") = value` 和 `Cache.Insert(key, value)` 是同義的，而且會使用指定的索引鍵將專案新增至快取，但不含已定義的到期。</span><span class="sxs-lookup"><span data-stu-id="720a2-143">`Cache("key") = value` and `Cache.Insert(key, value)` are synonymous and both add an item to the cache using the specified key without a defined expiry.</span></span> <span data-ttu-id="720a2-144">一般來說，我們想要在將專案新增至快取時，指定到期時間、以時間為基礎的到期日，或兩者都是。</span><span class="sxs-lookup"><span data-stu-id="720a2-144">Typically, we want to specify an expiry when adding an item to the cache, either as a dependency, a time-based expiry, or both.</span></span> <span data-ttu-id="720a2-145">使用其中一個 `Insert` 方法的多載，以提供相依性或以時間為基礎的到期資訊。</span><span class="sxs-lookup"><span data-stu-id="720a2-145">Use one of the other `Insert` method s overloads to provide dependency- or time-based expiry information.</span></span>

<span data-ttu-id="720a2-146">快取層的方法必須先檢查要求的資料是否在快取中，如果是，則從該處傳回它。</span><span class="sxs-lookup"><span data-stu-id="720a2-146">The Caching Layer s methods need to first check if the requested data is in the cache and, if so, return it from there.</span></span> <span data-ttu-id="720a2-147">如果要求的資料不在快取中，則必須叫用適當的 BLL 方法。</span><span class="sxs-lookup"><span data-stu-id="720a2-147">If the requested data is not in the cache, the appropriate BLL method needs to be invoked.</span></span> <span data-ttu-id="720a2-148">它的傳回值應該快取然後傳回，如下列順序圖所示。</span><span class="sxs-lookup"><span data-stu-id="720a2-148">Its return value should be cached and then returned, as the following sequence diagram illustrates.</span></span>

![快取層方法會傳回快取中的資料（如果有的話）](caching-data-in-the-architecture-vb/_static/image3.png)

<span data-ttu-id="720a2-150">**圖 3**：快取層的方法會從快取傳回資料（如果有的話）</span><span class="sxs-lookup"><span data-stu-id="720a2-150">**Figure 3**: The Caching Layer s Methods Return Data from the Cache if it s Available</span></span>

<span data-ttu-id="720a2-151">[圖 3] 中所描述的順序是使用下列模式在 CL 類別中完成：</span><span class="sxs-lookup"><span data-stu-id="720a2-151">The sequence depicted in Figure 3 is accomplished in the CL classes using the following pattern:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample2.vb)]

<span data-ttu-id="720a2-152">在這裡， *type*是儲存在快取 `Northwind.ProductsDataTable`中的資料類型，例如， *key*是唯一識別快取專案的索引鍵。</span><span class="sxs-lookup"><span data-stu-id="720a2-152">Here, *Type* is the type of data being stored in the cache `Northwind.ProductsDataTable`, for example while *key* is the key that uniquely identifies the cache item.</span></span> <span data-ttu-id="720a2-153">如果具有指定之索引*鍵*的專案不在快取中，則會 `Nothing`*實例*，而且會從適當的 BLL 方法抓取資料，並將其新增至快取。</span><span class="sxs-lookup"><span data-stu-id="720a2-153">If the item with the specified *key* is not in the cache, then *instance* will be `Nothing` and the data will be retrieved from the appropriate BLL method and added to the cache.</span></span> <span data-ttu-id="720a2-154">當達到 `Return instance` 時，*實例*會包含資料的參考，不論是從快取或從 BLL 提取。</span><span class="sxs-lookup"><span data-stu-id="720a2-154">By the time `Return instance` is reached, *instance* contains a reference to the data, either from the cache or pulled from the BLL.</span></span>

<span data-ttu-id="720a2-155">從快取存取資料時，請務必使用上述模式。</span><span class="sxs-lookup"><span data-stu-id="720a2-155">Be sure to use the above pattern when accessing data from the cache.</span></span> <span data-ttu-id="720a2-156">下列模式（第一眼）看起來相當於，其中包含引進競爭條件的細微差異。</span><span class="sxs-lookup"><span data-stu-id="720a2-156">The following pattern, which, at first glance, looks equivalent, contains a subtle difference that introduces a race condition.</span></span> <span data-ttu-id="720a2-157">競爭情況很容易進行調試，因為它們會偶爾顯示，而且很容易重現。</span><span class="sxs-lookup"><span data-stu-id="720a2-157">Race conditions are difficult to debug because they reveal themselves sporadically and are difficult to reproduce.</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample3.vb)]

<span data-ttu-id="720a2-158">在此秒中，不正確的程式碼片段的差異在於，不會將快取專案的參考儲存在本機變數中，而是直接在條件陳述式*和*`Return`中存取資料快取。</span><span class="sxs-lookup"><span data-stu-id="720a2-158">The difference in this second, incorrect code snippet is that rather than storing a reference to the cached item in a local variable, the data cache is accessed directly in the conditional statement *and* in the `Return`.</span></span> <span data-ttu-id="720a2-159">假設到達此程式碼時，`Cache("key")` 不 `Nothing`，但在到達 `Return` 語句之前，系統會從快取中收回索引*鍵*。</span><span class="sxs-lookup"><span data-stu-id="720a2-159">Imagine that when this code is reached, `Cache("key")` is not `Nothing`, but before the `Return` statement is reached, the system evicts *key* from the cache.</span></span> <span data-ttu-id="720a2-160">在這種罕見的情況下，程式碼會傳回 `Nothing`，而不是預期類型的物件。</span><span class="sxs-lookup"><span data-stu-id="720a2-160">In this rare case, the code will return `Nothing` rather than an object of the expected type.</span></span>

> [!NOTE]
> <span data-ttu-id="720a2-161">資料快取是安全線程，因此您不需要同步處理簡單讀取或寫入的執行緒存取。</span><span class="sxs-lookup"><span data-stu-id="720a2-161">The data cache is thread-safe, so you don't need to synchronize thread access for simple reads or writes.</span></span> <span data-ttu-id="720a2-162">不過，如果您需要對快取中需要不可部分完成的資料執行多項作業，您必須負責實行鎖定或一些其他機制，以確保執行緒安全性。</span><span class="sxs-lookup"><span data-stu-id="720a2-162">However, if you need to perform multiple operations on data in the cache that need to be atomic, you are responsible for implementing a lock or some other mechanism to ensure thread safety.</span></span> <span data-ttu-id="720a2-163">如需詳細資訊，請參閱[同步存取 ASP.NET Cache](http://www.ddj.com/184406369) 。</span><span class="sxs-lookup"><span data-stu-id="720a2-163">See [Synchronizing Access to the ASP.NET Cache](http://www.ddj.com/184406369) for more information.</span></span>

<span data-ttu-id="720a2-164">您可以使用[`Remove` 方法](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx)，以程式設計方式從資料快取中收回專案，如下所示：</span><span class="sxs-lookup"><span data-stu-id="720a2-164">An item can be programmatically evicted from the data cache using the [`Remove` method](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx) like so:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample4.vb)]

## <a name="step-3-returning-product-information-from-theproductsclclass"></a><span data-ttu-id="720a2-165">步驟3：從`ProductsCL`類別傳回產品資訊</span><span class="sxs-lookup"><span data-stu-id="720a2-165">Step 3: Returning Product Information from the`ProductsCL`Class</span></span>

<span data-ttu-id="720a2-166">在本教學課程中，我們會執行兩個方法，以從 `ProductsCL` 類別傳回產品資訊： `GetProducts()` 和 `GetProductsByCategoryID(categoryID)`。</span><span class="sxs-lookup"><span data-stu-id="720a2-166">For this tutorial let s implement two methods for returning product information from the `ProductsCL` class: `GetProducts()` and `GetProductsByCategoryID(categoryID)`.</span></span> <span data-ttu-id="720a2-167">如同商務邏輯層中的 `ProductsBL` 類別，CL 中的 `GetProducts()` 方法會傳回所有產品的相關資訊做為 `Northwind.ProductsDataTable` 物件，而 `GetProductsByCategoryID(categoryID)` 會從指定的分類傳回所有產品。</span><span class="sxs-lookup"><span data-stu-id="720a2-167">Like with the `ProductsBL` class in the Business Logic Layer, the `GetProducts()` method in the CL returns information about all of the products as a `Northwind.ProductsDataTable` object, while `GetProductsByCategoryID(categoryID)` returns all of the products from a specified category.</span></span>

<span data-ttu-id="720a2-168">下列程式碼顯示 `ProductsCL` 類別中的部分方法：</span><span class="sxs-lookup"><span data-stu-id="720a2-168">The following code shows a portion of the methods in the `ProductsCL` class:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample5.vb)]

<span data-ttu-id="720a2-169">首先，請注意套用至類別和方法的 `DataObject` 和 `DataObjectMethodAttribute` 屬性。</span><span class="sxs-lookup"><span data-stu-id="720a2-169">First, note the `DataObject` and `DataObjectMethodAttribute` attributes applied to the class and methods.</span></span> <span data-ttu-id="720a2-170">這些屬性會將資訊提供給 ObjectDataSource s wizard，指出應該在 wizard s 步驟中顯示的類別和方法。</span><span class="sxs-lookup"><span data-stu-id="720a2-170">These attributes provide information to the ObjectDataSource s wizard, indicating what classes and methods should appear in the wizard s steps.</span></span> <span data-ttu-id="720a2-171">因為 CL 類別和方法會從展示層中的 ObjectDataSource 存取，所以我新增了這些屬性，以增強設計階段體驗。</span><span class="sxs-lookup"><span data-stu-id="720a2-171">Since the CL classes and methods will be accessed from an ObjectDataSource in the Presentation Layer, I added these attributes to enhance the design-time experience.</span></span> <span data-ttu-id="720a2-172">如需這些屬性及其效果的完整描述，請參閱[建立商務邏輯層](../introduction/creating-a-business-logic-layer-vb.md)教學課程。</span><span class="sxs-lookup"><span data-stu-id="720a2-172">Refer back to the [Creating a Business Logic Layer](../introduction/creating-a-business-logic-layer-vb.md) tutorial for a more thorough description on these attributes and their effects.</span></span>

<span data-ttu-id="720a2-173">在 `GetProducts()` 和 `GetProductsByCategoryID(categoryID)` 方法中，從 `GetCacheItem(key)` 方法傳回的資料會指派給本機變數。</span><span class="sxs-lookup"><span data-stu-id="720a2-173">In the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods, the data returned from the `GetCacheItem(key)` method is assigned to a local variable.</span></span> <span data-ttu-id="720a2-174">`GetCacheItem(key)` 方法（我們將在稍後檢查）會根據指定的索引*鍵*傳回快取中的特定專案。</span><span class="sxs-lookup"><span data-stu-id="720a2-174">The `GetCacheItem(key)` method, which we'll examine shortly, returns a particular item from the cache based on the specified *key*.</span></span> <span data-ttu-id="720a2-175">如果在快取中找不到這類資料，則會從對應的 `ProductsBLL` 類別方法中抓取，然後使用 `AddCacheItem(key, value)` 方法將其新增至快取。</span><span class="sxs-lookup"><span data-stu-id="720a2-175">If no such data is found in cache, it is retrieved from the corresponding `ProductsBLL` class method and then added to the cache using the `AddCacheItem(key, value)` method.</span></span>

<span data-ttu-id="720a2-176">`GetCacheItem(key)` 和 `AddCacheItem(key, value)` 方法會分別使用資料快取、讀取和寫入值的介面。</span><span class="sxs-lookup"><span data-stu-id="720a2-176">The `GetCacheItem(key)` and `AddCacheItem(key, value)` methods interface with the data cache, reading and writing values, respectively.</span></span> <span data-ttu-id="720a2-177">`GetCacheItem(key)` 方法是兩者中較簡單的方法。</span><span class="sxs-lookup"><span data-stu-id="720a2-177">The `GetCacheItem(key)` method is the simpler of the two.</span></span> <span data-ttu-id="720a2-178">它只會使用傳入的索引*鍵*傳回 Cache 類別的值：</span><span class="sxs-lookup"><span data-stu-id="720a2-178">It simply returns the value from the Cache class using the passed-in *key*:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample6.vb)]

<span data-ttu-id="720a2-179">`GetCacheItem(key)` 不會使用提供的索引*鍵值*，而是會呼叫 `GetCacheKey(key)` 方法，這會傳回前面加上 ProductsCache-的索引*鍵*。</span><span class="sxs-lookup"><span data-stu-id="720a2-179">`GetCacheItem(key)` does not use *key* value as supplied, but instead calls the `GetCacheKey(key)` method, which returns the *key* prepended with ProductsCache-.</span></span> <span data-ttu-id="720a2-180">`AddCacheItem(key, value)` 方法也會使用 `MasterCacheKeyArray`（保存字串 ProductsCache），如我們稍後所見。</span><span class="sxs-lookup"><span data-stu-id="720a2-180">The `MasterCacheKeyArray`, which holds the string ProductsCache, is also used by the `AddCacheItem(key, value)` method, as we'll see momentarily.</span></span>

<span data-ttu-id="720a2-181">從 ASP.NET 網頁的程式碼後置類別中，您可以使用 `Page` 類別[`Cache` 屬性](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx)來存取資料快取，並允許如步驟2中所述的語法，如 `Cache("key") = value`。</span><span class="sxs-lookup"><span data-stu-id="720a2-181">From an ASP.NET page s code-behind class, the data cache can be accessed using the `Page` class s [`Cache` property](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx), and allows for syntax like `Cache("key") = value`, as discussed in Step 2.</span></span> <span data-ttu-id="720a2-182">從架構中的類別，您可以使用 `HttpRuntime.Cache` 或 `HttpContext.Current.Cache`來存取資料快取。</span><span class="sxs-lookup"><span data-stu-id="720a2-182">From a class within the architecture, the data cache can be accessed using either `HttpRuntime.Cache` or `HttpContext.Current.Cache`.</span></span> <span data-ttu-id="720a2-183">[Peter Johnson](https://weblogs.asp.net/pjohnson/default.aspx)的 Blog 專案[HttpRuntime. 快取與 HttpCoNtext](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache) 。快取注意使用 `HttpRuntime` 而不是 `HttpContext.Current`時的輕微效能優勢。因此，`ProductsCL` 會使用 `HttpRuntime`。</span><span class="sxs-lookup"><span data-stu-id="720a2-183">[Peter Johnson](https://weblogs.asp.net/pjohnson/default.aspx)'s blog entry [HttpRuntime.Cache vs. HttpContext.Current.Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache) notes the slight performance advantage in using `HttpRuntime` instead of `HttpContext.Current`; consequently, `ProductsCL` uses `HttpRuntime`.</span></span>

> [!NOTE]
> <span data-ttu-id="720a2-184">如果您的架構是使用類別庫專案來執行，則您將需要加入 `System.Web` 元件的參考，才能使用[`HttpRuntime`](https://msdn.microsoft.com/library/system.web.httpruntime.aspx)和[`HttpContext`](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)類別。</span><span class="sxs-lookup"><span data-stu-id="720a2-184">If your architecture is implemented using Class Library projects then you will need to add a reference to the `System.Web` assembly in order to use the [`HttpRuntime`](https://msdn.microsoft.com/library/system.web.httpruntime.aspx) and [`HttpContext`](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) classes.</span></span>

<span data-ttu-id="720a2-185">如果在快取中找不到此專案，則 `ProductsCL` 類別的方法會從 BLL 取得資料，並使用 `AddCacheItem(key, value)` 方法將其加入至快取。</span><span class="sxs-lookup"><span data-stu-id="720a2-185">If the item is not found in the cache, the `ProductsCL` class s methods get the data from the BLL and add it to the cache using the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="720a2-186">若要將*值*新增至快取，我們可以使用下列程式碼，其使用60秒的到期時間：</span><span class="sxs-lookup"><span data-stu-id="720a2-186">To add *value* to the cache we could use the following code, which uses a 60 second time expiry:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample7.vb)]

<span data-ttu-id="720a2-187">`DateTime.Now.AddSeconds(CacheDuration)` 會指定未來的以時間為基礎的到期60秒，而[`System.Web.Caching.Cache.NoSlidingExpiration`](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx)則表示沒有任何滑動到期日。</span><span class="sxs-lookup"><span data-stu-id="720a2-187">`DateTime.Now.AddSeconds(CacheDuration)` specifies the time-based expiry 60 seconds in the future while [`System.Web.Caching.Cache.NoSlidingExpiration`](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx) indicates that there s no sliding expiration.</span></span> <span data-ttu-id="720a2-188">雖然這個 `Insert` 方法多載具有絕對和滑動到期的輸入參數，但是您只能提供這兩個的其中一個。</span><span class="sxs-lookup"><span data-stu-id="720a2-188">While this `Insert` method overload has input parameters for both an absolute and sliding expiry, you can only provide one of the two.</span></span> <span data-ttu-id="720a2-189">如果您嘗試同時指定絕對時間和時間範圍，`Insert` 方法將會擲回 `ArgumentException` 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="720a2-189">If you attempt to specify both an absolute time and a time span, the `Insert` method will throw an `ArgumentException` exception.</span></span>

> [!NOTE]
> <span data-ttu-id="720a2-190">這項 `AddCacheItem(key, value)` 方法的執行目前有一些缺點。</span><span class="sxs-lookup"><span data-stu-id="720a2-190">This implementation of the `AddCacheItem(key, value)` method currently has some shortcomings.</span></span> <span data-ttu-id="720a2-191">我們會在步驟4中解決這些問題，並加以解決。</span><span class="sxs-lookup"><span data-stu-id="720a2-191">We'll address and overcome these issues in Step 4.</span></span>

## <a name="step-4-invalidating-the-cache-when-the-data-is-modified-through-the-architecture"></a><span data-ttu-id="720a2-192">步驟4：透過架構修改資料時，將快取失效</span><span class="sxs-lookup"><span data-stu-id="720a2-192">Step 4: Invalidating the Cache When the Data is Modified Through the Architecture</span></span>

<span data-ttu-id="720a2-193">除了資料抓取方法，快取層也必須提供與 BLL 相關的方法，以插入、更新和刪除資料。</span><span class="sxs-lookup"><span data-stu-id="720a2-193">Along with data retrieval methods, the Caching Layer needs to provide the same methods as the BLL for inserting, updating, and deleting data.</span></span> <span data-ttu-id="720a2-194">CL s 資料修改方法不會修改快取的資料，而是會呼叫 BLL 的對應資料修改方法，然後讓快取失效。</span><span class="sxs-lookup"><span data-stu-id="720a2-194">The CL s data modification methods do not modify the cached data, but rather call the BLL s corresponding data modification method and then invalidate the cache.</span></span> <span data-ttu-id="720a2-195">如我們在先前的教學課程中所見，這與 ObjectDataSource 在啟用快取功能並叫用其 `Insert`、`Update`或 `Delete` 方法時所套用的行為相同。</span><span class="sxs-lookup"><span data-stu-id="720a2-195">As we saw in the preceding tutorial, this is the same behavior that the ObjectDataSource applies when its caching features are enabled and its `Insert`, `Update`, or `Delete` methods are invoked.</span></span>

<span data-ttu-id="720a2-196">下列 `UpdateProduct` 多載說明如何在 CL 中執行資料修改方法：</span><span class="sxs-lookup"><span data-stu-id="720a2-196">The following `UpdateProduct` overload illustrates how to implement the data modification methods in the CL:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample8.vb)]

<span data-ttu-id="720a2-197">會叫用適當的資料修改商務邏輯層方法，但在傳回其回應之前，我們需要讓快取失效。</span><span class="sxs-lookup"><span data-stu-id="720a2-197">The appropriate data modification Business Logic Layer method is invoked, but before its response is returned we need to invalidate the cache.</span></span> <span data-ttu-id="720a2-198">可惜的是，將快取設為無效，因為 `ProductsCL` 類別 `GetProducts()` 和 `GetProductsByCategoryID(categoryID)` 方法都會使用不同的索引鍵將專案新增至快取，而 `GetProductsByCategoryID(categoryID)` 方法會為每個唯一的*類別*類型新增不同的快取專案。</span><span class="sxs-lookup"><span data-stu-id="720a2-198">Unfortunately, invalidating the cache is not straightforward because the `ProductsCL` class s `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods each add items to the cache with different keys, and the `GetProductsByCategoryID(categoryID)` method adds a different cache item for each unique *categoryID*.</span></span>

<span data-ttu-id="720a2-199">當您使快取失效時，我們必須移除 `ProductsCL` 類別可能已加入的*所有*專案。</span><span class="sxs-lookup"><span data-stu-id="720a2-199">When invalidating the cache, we need to remove *all* of the items that may have been added by the `ProductsCL` class.</span></span> <span data-ttu-id="720a2-200">這可以藉由將快取相依性與在 `AddCacheItem(key, value)` 方法中新增至快取的每個專案產生*關聯，來*完成這項作業。</span><span class="sxs-lookup"><span data-stu-id="720a2-200">This can be accomplished by associating a *cache dependency* with the each item added to the cache in the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="720a2-201">一般而言，快取相依性可以是快取中的另一個專案、檔案系統上的檔案，或是來自 Microsoft SQL Server 資料庫的資料。</span><span class="sxs-lookup"><span data-stu-id="720a2-201">In general, a cache dependency can be another item in the cache, a file on the file system, or data from a Microsoft SQL Server database.</span></span> <span data-ttu-id="720a2-202">當相依性變更或從快取中移除時，與它相關聯的快取專案會自動從快取中收回。</span><span class="sxs-lookup"><span data-stu-id="720a2-202">When the dependency changes or is removed from the cache, the cache items it is associated with are automatically evicted from the cache.</span></span> <span data-ttu-id="720a2-203">在本教學課程中，我們想要在快取中建立額外的專案，做為透過 `ProductsCL` 類別新增之所有專案的快取相依性。</span><span class="sxs-lookup"><span data-stu-id="720a2-203">For this tutorial, we want to create an additional item in the cache that serves as a cache dependency for all items added through the `ProductsCL` class.</span></span> <span data-ttu-id="720a2-204">如此一來，只要移除快取相依性，就可以從快取中移除所有這些專案。</span><span class="sxs-lookup"><span data-stu-id="720a2-204">That way, all of these items can be removed from the cache by simply removing the cache dependency.</span></span>

<span data-ttu-id="720a2-205">讓 s 更新 `AddCacheItem(key, value)` 方法，讓透過這個方法新增至快取的每個專案都與單一快取相依性相關聯：</span><span class="sxs-lookup"><span data-stu-id="720a2-205">Let s update the `AddCacheItem(key, value)` method so that each item added to the cache through this method is associated with a single cache dependency:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample9.vb)]

<span data-ttu-id="720a2-206">`MasterCacheKeyArray` 是保存單一值（ProductsCache）的字串陣列。</span><span class="sxs-lookup"><span data-stu-id="720a2-206">`MasterCacheKeyArray` is a string array that holds a single value, ProductsCache.</span></span> <span data-ttu-id="720a2-207">首先，快取專案會新增至快取，並指派目前的日期和時間。</span><span class="sxs-lookup"><span data-stu-id="720a2-207">First, a cache item is added to the cache and assigned the current date and time.</span></span> <span data-ttu-id="720a2-208">如果快取專案已經存在，就會更新。</span><span class="sxs-lookup"><span data-stu-id="720a2-208">If the cache item already exists, it is updated.</span></span> <span data-ttu-id="720a2-209">接下來，會建立快取相依性。</span><span class="sxs-lookup"><span data-stu-id="720a2-209">Next, a cache dependency is created.</span></span> <span data-ttu-id="720a2-210">[`CacheDependency` 類別](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx)的函式有許多多載，但此處使用的多載需要兩個 `String` 陣列輸入。</span><span class="sxs-lookup"><span data-stu-id="720a2-210">The [`CacheDependency` class](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx) s constructor has a number of overloads, but the one being used in here expects two `String` array inputs.</span></span> <span data-ttu-id="720a2-211">第一個會指定要當做相依性使用的一組檔案。</span><span class="sxs-lookup"><span data-stu-id="720a2-211">The first one specifies the set of files to be used as dependencies.</span></span> <span data-ttu-id="720a2-212">由於我們不想要使用任何檔案型相依性，因此第一個輸入參數會使用 `Nothing` 的值。</span><span class="sxs-lookup"><span data-stu-id="720a2-212">Since we don t want to use any file-based dependencies, a value of `Nothing` is used for the first input parameter.</span></span> <span data-ttu-id="720a2-213">第二個輸入參數會指定要當做相依性使用的一組快取索引鍵。</span><span class="sxs-lookup"><span data-stu-id="720a2-213">The second input parameter specifies the set of cache keys to use as dependencies.</span></span> <span data-ttu-id="720a2-214">在這裡，我們會指定單一相依性，`MasterCacheKeyArray`。</span><span class="sxs-lookup"><span data-stu-id="720a2-214">Here we specify our single dependency, `MasterCacheKeyArray`.</span></span> <span data-ttu-id="720a2-215">然後，`CacheDependency` 會傳遞至 `Insert` 方法。</span><span class="sxs-lookup"><span data-stu-id="720a2-215">The `CacheDependency` is then passed into the `Insert` method.</span></span>

<span data-ttu-id="720a2-216">透過這項修改來 `AddCacheItem(key, value)`，invaliding 快取就像移除相依性一樣簡單。</span><span class="sxs-lookup"><span data-stu-id="720a2-216">With this modification to `AddCacheItem(key, value)`, invaliding the cache is as simple as removing the dependency.</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample10.vb)]

## <a name="step-5-calling-the-caching-layer-from-the-presentation-layer"></a><span data-ttu-id="720a2-217">步驟5：從展示層呼叫快取層</span><span class="sxs-lookup"><span data-stu-id="720a2-217">Step 5: Calling the Caching Layer from the Presentation Layer</span></span>

<span data-ttu-id="720a2-218">快取層級的類別和方法可以使用我們在這些教學課程中所檢查的技術來處理資料。</span><span class="sxs-lookup"><span data-stu-id="720a2-218">The Caching Layer s classes and methods can be used to work with data using the techniques we ve examined throughout these tutorials.</span></span> <span data-ttu-id="720a2-219">若要說明如何使用快取的資料，請將變更儲存至 `ProductsCL` 類別，然後在 [`Caching`] 資料夾中開啟 [`FromTheArchitecture.aspx`] 頁面，並加入 GridView。</span><span class="sxs-lookup"><span data-stu-id="720a2-219">To illustrate working with cached data, save your changes to the `ProductsCL` class and then open the `FromTheArchitecture.aspx` page in the `Caching` folder and add a GridView.</span></span> <span data-ttu-id="720a2-220">從 GridView 的智慧標籤，建立新的 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="720a2-220">From the GridView s smart tag, create a new ObjectDataSource.</span></span> <span data-ttu-id="720a2-221">在 wizard 的第一個步驟中，您應該會看到 `ProductsCL` 類別，做為下拉式清單中的其中一個選項。</span><span class="sxs-lookup"><span data-stu-id="720a2-221">In the wizard s first step you should see the `ProductsCL` class as one of the options from the drop-down list.</span></span>

<span data-ttu-id="720a2-222">[![ProductsCL 類別包含在 [商務物件] 下拉式清單中](caching-data-in-the-architecture-vb/_static/image5.png)](caching-data-in-the-architecture-vb/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="720a2-222">[![The ProductsCL Class is Included in the Business Object Drop-Down List](caching-data-in-the-architecture-vb/_static/image5.png)](caching-data-in-the-architecture-vb/_static/image4.png)</span></span>

<span data-ttu-id="720a2-223">**圖 4**： [`ProductsCL`] 類別包含在 [商務物件] 下拉式清單中（[按一下以查看完整大小的影像](caching-data-in-the-architecture-vb/_static/image6.png)）</span><span class="sxs-lookup"><span data-stu-id="720a2-223">**Figure 4**: The `ProductsCL` Class is Included in the Business Object Drop-Down List ([Click to view full-size image](caching-data-in-the-architecture-vb/_static/image6.png))</span></span>

<span data-ttu-id="720a2-224">選取 `ProductsCL`之後，按 [下一步]。</span><span class="sxs-lookup"><span data-stu-id="720a2-224">After selecting `ProductsCL`, click Next.</span></span> <span data-ttu-id="720a2-225">[選取] 索引標籤中的下拉式清單有兩個專案-`GetProducts()` 和 `GetProductsByCategoryID(categoryID)` 而且 [更新] 索引標籤具有唯一的 `UpdateProduct` 多載。</span><span class="sxs-lookup"><span data-stu-id="720a2-225">The drop-down list in the SELECT tab has two items - `GetProducts()` and `GetProductsByCategoryID(categoryID)` and the UPDATE tab has the sole `UpdateProduct` overload.</span></span> <span data-ttu-id="720a2-226">從 更新 索引標籤的 選取 索引標籤和 `UpdateProducts` 方法選擇 `GetProducts()` 方法，然後按一下 完成</span><span class="sxs-lookup"><span data-stu-id="720a2-226">Choose the `GetProducts()` method from the SELECT tab and the `UpdateProducts` method from the UPDATE tab and click Finish.</span></span>

<span data-ttu-id="720a2-227">[![ProductsCL 類別 s 方法列于下拉式清單中](caching-data-in-the-architecture-vb/_static/image8.png)](caching-data-in-the-architecture-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="720a2-227">[![The ProductsCL Class s Methods are Listed in the Drop-Down Lists](caching-data-in-the-architecture-vb/_static/image8.png)](caching-data-in-the-architecture-vb/_static/image7.png)</span></span>

<span data-ttu-id="720a2-228">**圖 5**： `ProductsCL` 類別 s 的方法會列在下拉式清單中（[按一下以查看完整大小的影像](caching-data-in-the-architecture-vb/_static/image9.png)）</span><span class="sxs-lookup"><span data-stu-id="720a2-228">**Figure 5**: The `ProductsCL` Class s Methods are Listed in the Drop-Down Lists ([Click to view full-size image](caching-data-in-the-architecture-vb/_static/image9.png))</span></span>

<span data-ttu-id="720a2-229">完成 wizard 之後，Visual Studio 會將 ObjectDataSource 的 `OldValuesParameterFormatString` 屬性設定為 `original_{0}`，並將適當的欄位新增至 GridView。</span><span class="sxs-lookup"><span data-stu-id="720a2-229">After completing the wizard, Visual Studio will set the ObjectDataSource s `OldValuesParameterFormatString` property to `original_{0}` and add the appropriate fields to the GridView.</span></span> <span data-ttu-id="720a2-230">將 `OldValuesParameterFormatString` 屬性變更回其預設值 `{0}`，然後將 GridView 設定為支援分頁、排序和編輯。</span><span class="sxs-lookup"><span data-stu-id="720a2-230">Change the `OldValuesParameterFormatString` property back to its default value, `{0}`, and configure the GridView to support paging, sorting, and editing.</span></span> <span data-ttu-id="720a2-231">由於 CL 使用的 `UploadProducts` 多載只會接受已編輯的產品名稱和價格，因此限制 GridView 只能編輯這些欄位。</span><span class="sxs-lookup"><span data-stu-id="720a2-231">Since the `UploadProducts` overload used by the CL accepts only the edited product s name and price, limit the GridView so that only these fields are editable.</span></span>

<span data-ttu-id="720a2-232">在先前的教學課程中，我們定義了 GridView 以包含 `ProductName`、`CategoryName`和 `UnitPrice` 欄位的欄位。</span><span class="sxs-lookup"><span data-stu-id="720a2-232">In the preceding tutorial we defined a GridView to include fields for the `ProductName`, `CategoryName`, and `UnitPrice` fields.</span></span> <span data-ttu-id="720a2-233">您可以隨意複寫此格式和結構，在這種情況下，GridView 和 ObjectDataSource 的宣告式標記看起來應該如下所示：</span><span class="sxs-lookup"><span data-stu-id="720a2-233">Feel free to replicate this formatting and structure, in which case your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](caching-data-in-the-architecture-vb/samples/sample11.aspx)]

<span data-ttu-id="720a2-234">此時，我們有一個使用快取層的頁面。</span><span class="sxs-lookup"><span data-stu-id="720a2-234">At this point we have a page that uses the Caching Layer.</span></span> <span data-ttu-id="720a2-235">若要查看作用中的快取，請在 `ProductsCL` 類別 s `GetProducts()` 和 `UpdateProduct` 方法中設定中斷點。</span><span class="sxs-lookup"><span data-stu-id="720a2-235">To see the cache in action, set breakpoints in the `ProductsCL` class s `GetProducts()` and `UpdateProduct` methods.</span></span> <span data-ttu-id="720a2-236">請造訪瀏覽器中的頁面，並在排序和分頁時逐步執行程式碼，以便查看從快取中提取的資料。</span><span class="sxs-lookup"><span data-stu-id="720a2-236">Visit the page in a browser and step through the code when sorting and paging in order to see the data pulled from the cache.</span></span> <span data-ttu-id="720a2-237">然後更新記錄，並記下快取已失效，因此當資料重新系結至 GridView 時，就會從 BLL 抓取該快取。</span><span class="sxs-lookup"><span data-stu-id="720a2-237">Then update a record and note that the cache is invalidated and, consequently, it is retrieved from the BLL when the data is rebound to the GridView.</span></span>

> [!NOTE]
> <span data-ttu-id="720a2-238">本文隨附的下載中所提供的快取層並未完成。</span><span class="sxs-lookup"><span data-stu-id="720a2-238">The Caching Layer provided in the download accompanying this article is not complete.</span></span> <span data-ttu-id="720a2-239">它只包含一個類別，`ProductsCL`，只運動幾個方法。</span><span class="sxs-lookup"><span data-stu-id="720a2-239">It contains only one class, `ProductsCL`, which only sports a handful of methods.</span></span> <span data-ttu-id="720a2-240">此外，只有單一的 ASP.NET 網頁會使用 CL （`~/Caching/FromTheArchitecture.aspx`），其他人仍會直接參考 BLL。</span><span class="sxs-lookup"><span data-stu-id="720a2-240">Moreover, only a single ASP.NET page uses the CL (`~/Caching/FromTheArchitecture.aspx`) all others still reference the BLL directly.</span></span> <span data-ttu-id="720a2-241">如果您打算在應用程式中使用 CL，展示層的所有呼叫都應該移至 CL，這會要求 CL 類別和方法涵蓋展示層目前所使用之 BLL 中的類別和方法。</span><span class="sxs-lookup"><span data-stu-id="720a2-241">If you plan on using a CL in your application, all calls from the Presentation Layer should go to the CL, which would require that the CL s classes and methods covered those classes and methods in the BLL currently used by the Presentation Layer.</span></span>

## <a name="summary"></a><span data-ttu-id="720a2-242">總結</span><span class="sxs-lookup"><span data-stu-id="720a2-242">Summary</span></span>

<span data-ttu-id="720a2-243">雖然可以使用 ASP.NET 2.0 s SqlDataSource 和 ObjectDataSource 控制項在展示層套用快取，但最好的快取責任會委派給架構中的個別層。</span><span class="sxs-lookup"><span data-stu-id="720a2-243">While caching can be applied at the Presentation Layer with ASP.NET 2.0 s SqlDataSource and ObjectDataSource controls, ideally caching responsibilities would be delegated to a separate layer in the architecture.</span></span> <span data-ttu-id="720a2-244">在本教學課程中，我們建立了位於展示層和商務邏輯層之間的快取層。</span><span class="sxs-lookup"><span data-stu-id="720a2-244">In this tutorial we created a Caching Layer that resides between the Presentation Layer and the Business Logic Layer.</span></span> <span data-ttu-id="720a2-245">快取層必須提供存在於 BLL 中的一組相同類別和方法，並從展示層呼叫。</span><span class="sxs-lookup"><span data-stu-id="720a2-245">The Caching Layer needs to provide the same set of classes and methods that exist in the BLL and are called from the Presentation Layer.</span></span>

<span data-ttu-id="720a2-246">我們在此探討的快取層範例，而先前的教學課程呈現了*被動的載入*。</span><span class="sxs-lookup"><span data-stu-id="720a2-246">The Caching Layer examples we explored in this and the preceding tutorials exhibited *reactive loading*.</span></span> <span data-ttu-id="720a2-247">使用被動式載入時，只有在提出資料的要求，且快取中遺漏資料時，才會將資料載入快取中。</span><span class="sxs-lookup"><span data-stu-id="720a2-247">With reactive loading, the data is loaded into the cache only when a request for the data is made and that data is missing from the cache.</span></span> <span data-ttu-id="720a2-248">資料也可以*主動載入*至快取中，這是在實際需要資料之前，將資料載入快取的技術。</span><span class="sxs-lookup"><span data-stu-id="720a2-248">Data can also be *proactively loaded* into the cache, a technique that loads the data into the cache before it is actually needed.</span></span> <span data-ttu-id="720a2-249">在下一個教學課程中，我們會看到當我們查看如何在應用程式啟動時將靜態值儲存至快取中的主動式載入範例。</span><span class="sxs-lookup"><span data-stu-id="720a2-249">In the next tutorial we'll see an example of proactive loading when we look at how to store static values into the cache at application startup.</span></span>

<span data-ttu-id="720a2-250">快樂的程式設計！</span><span class="sxs-lookup"><span data-stu-id="720a2-250">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="720a2-251">關於作者</span><span class="sxs-lookup"><span data-stu-id="720a2-251">About the Author</span></span>

<span data-ttu-id="720a2-252">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，自1998起，有七個 ASP/ASP. NET 書籍和創辦人的[4GuysFromRolla.com](http://www.4guysfromrolla.com)。</span><span class="sxs-lookup"><span data-stu-id="720a2-252">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="720a2-253">Scott 以獨立的顧問、訓練員和作者的身分運作。</span><span class="sxs-lookup"><span data-stu-id="720a2-253">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="720a2-254">他的最新著作是[*在24小時內讓自己的 ASP.NET 2.0*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="720a2-254">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="720a2-255">他可以在mitchell@4GuysFromRolla.com觸達[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="720a2-255">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="720a2-256">或者透過他的 blog，可以在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)找到。</span><span class="sxs-lookup"><span data-stu-id="720a2-256">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="720a2-257">特別感謝</span><span class="sxs-lookup"><span data-stu-id="720a2-257">Special Thanks To</span></span>

<span data-ttu-id="720a2-258">本教學課程系列已由許多有用的審核者所審查。</span><span class="sxs-lookup"><span data-stu-id="720a2-258">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="720a2-259">本教學課程的領導審查者為 Teresa Murphy。</span><span class="sxs-lookup"><span data-stu-id="720a2-259">Lead reviewer for this tutorial was Teresa Murphy.</span></span> <span data-ttu-id="720a2-260">有興趣複習我即將發行的 MSDN 文章嗎？</span><span class="sxs-lookup"><span data-stu-id="720a2-260">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="720a2-261">若是如此，請在mitchell@4GuysFromRolla.com的那一行下拉式[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="720a2-261">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="720a2-262">[上一頁](caching-data-with-the-objectdatasource-vb.md)
> [下一頁](caching-data-at-application-startup-vb.md)</span><span class="sxs-lookup"><span data-stu-id="720a2-262">[Previous](caching-data-with-the-objectdatasource-vb.md)
[Next](caching-data-at-application-startup-vb.md)</span></span>
