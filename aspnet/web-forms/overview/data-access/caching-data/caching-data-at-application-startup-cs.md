---
uid: web-forms/overview/data-access/caching-data/caching-data-at-application-startup-cs
title: 在應用程式啟動時快C#取資料（） |Microsoft Docs
author: rick-anderson
description: 在任何 Web 應用程式中，會經常使用某些資料，而某些資料則不常使用。 我們可以改善 ASP.NET 應用程式 b 的效能 。
ms.author: riande
ms.date: 05/30/2007
ms.assetid: 22ca8efa-7cd1-45a7-b9ce-ce6eb3b3ff95
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-at-application-startup-cs
msc.type: authoredcontent
ms.openlocfilehash: a0b55b0df1b7843120de284891e16178df23fabe
ms.sourcegitcommit: fe5c7512383a9b0a05d321ff10d3cca1611556f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/05/2019
ms.locfileid: "70386487"
---
# <a name="caching-data-at-application-startup-c"></a><span data-ttu-id="23bd8-104">在應用程式啟動時快取資料 (C#)</span><span class="sxs-lookup"><span data-stu-id="23bd8-104">Caching Data at Application Startup (C#)</span></span>

<span data-ttu-id="23bd8-105">由[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="23bd8-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

[<span data-ttu-id="23bd8-106">下載 PDF</span><span class="sxs-lookup"><span data-stu-id="23bd8-106">Download PDF</span></span>](caching-data-at-application-startup-cs/_static/datatutorial60cs1.pdf)

> <span data-ttu-id="23bd8-107">在任何 Web 應用程式中，會經常使用某些資料，而某些資料則不常使用。</span><span class="sxs-lookup"><span data-stu-id="23bd8-107">In any Web application some data will be frequently used and some data will be infrequently used.</span></span> <span data-ttu-id="23bd8-108">我們可以預先載入經常使用的資料（稱為快取的技術），藉此改善 ASP.NET 應用程式的效能。</span><span class="sxs-lookup"><span data-stu-id="23bd8-108">We can improve the performance of our ASP.NET application by loading in advance the frequently-used data, a technique known as Caching.</span></span> <span data-ttu-id="23bd8-109">本教學課程示範主動式載入的其中一個方法，也就是在應用程式啟動時將資料載入快取中。</span><span class="sxs-lookup"><span data-stu-id="23bd8-109">This tutorial demonstrates one approach to proactive loading, which is to load data into the cache at application startup.</span></span>

## <a name="introduction"></a><span data-ttu-id="23bd8-110">簡介</span><span class="sxs-lookup"><span data-stu-id="23bd8-110">Introduction</span></span>

<span data-ttu-id="23bd8-111">先前的兩個教學課程探討了如何在簡報和快取層中快取資料。</span><span class="sxs-lookup"><span data-stu-id="23bd8-111">The two previous tutorials looked at caching data in the Presentation and Caching Layers.</span></span> <span data-ttu-id="23bd8-112">在[使用 objectdatasource](caching-data-with-the-objectdatasource-cs.md)快取資料時，我們探討了如何使用 objectdatasource 的快取功能來快取展示層中的資料。</span><span class="sxs-lookup"><span data-stu-id="23bd8-112">In [Caching Data with the ObjectDataSource](caching-data-with-the-objectdatasource-cs.md), we looked at using the ObjectDataSource's caching features to cache data in the Presentation Layer.</span></span> <span data-ttu-id="23bd8-113">在[架構中](caching-data-in-the-architecture-cs.md)快取資料會在新的個別快取層中檢查快取。</span><span class="sxs-lookup"><span data-stu-id="23bd8-113">[Caching Data in the Architecture](caching-data-in-the-architecture-cs.md) examined caching in a new, separate Caching Layer.</span></span> <span data-ttu-id="23bd8-114">這兩個教學課程都在使用資料快取時使用了*被動式載入*。</span><span class="sxs-lookup"><span data-stu-id="23bd8-114">Both of these tutorials used *reactive loading* in working with the data cache.</span></span> <span data-ttu-id="23bd8-115">使用被動式載入時，每次要求資料時，系統會先檢查它是否在快取中。</span><span class="sxs-lookup"><span data-stu-id="23bd8-115">With reactive loading, each time the data is requested, the system first checks if it's in the cache.</span></span> <span data-ttu-id="23bd8-116">如果不是，它會從原始來源抓取資料，例如資料庫，然後將它儲存在快取中。</span><span class="sxs-lookup"><span data-stu-id="23bd8-116">If not, it grabs the data from the originating source, such as the database, and then stores it in the cache.</span></span> <span data-ttu-id="23bd8-117">被動式載入的主要優點是它的輕鬆執行。</span><span class="sxs-lookup"><span data-stu-id="23bd8-117">The main advantage to reactive loading is its ease of implementation.</span></span> <span data-ttu-id="23bd8-118">其中一個缺點是它在要求之間的效能不平均。</span><span class="sxs-lookup"><span data-stu-id="23bd8-118">One of its disadvantages is its uneven performance across requests.</span></span> <span data-ttu-id="23bd8-119">假設有一個頁面使用上一個教學課程中的快取層來顯示產品資訊。</span><span class="sxs-lookup"><span data-stu-id="23bd8-119">Imagine a page that uses the Caching Layer from the preceding tutorial to display product information.</span></span> <span data-ttu-id="23bd8-120">第一次造訪此頁面時，或在快取資料因為記憶體限制而收回或已達到指定的到期後第一次流覽時，必須從資料庫中取出資料。</span><span class="sxs-lookup"><span data-stu-id="23bd8-120">When this page is visited for the first time, or visited for the first time after the cached data has been evicted due to memory constraints or the specified expiry having been reached, the data must be retrieved from the database.</span></span> <span data-ttu-id="23bd8-121">因此，這些使用者的要求將會比快取所能提供的使用者要求更長的時間。</span><span class="sxs-lookup"><span data-stu-id="23bd8-121">Therefore, these users requests will take longer than users requests that can be served by the cache.</span></span>

<span data-ttu-id="23bd8-122">*主動式載入*提供替代的快取管理原則，藉由在需要時載入快取的資料，在要求之間平滑效能。</span><span class="sxs-lookup"><span data-stu-id="23bd8-122">*Proactive loading* provides an alternative cache management strategy that smoothes out the performance across requests by loading the cached data before it's needed.</span></span> <span data-ttu-id="23bd8-123">一般來說，主動式載入會使用一些進程，定期檢查或在更新基礎資料時收到通知。</span><span class="sxs-lookup"><span data-stu-id="23bd8-123">Typically, proactive loading uses some process that either periodically checks or is notified when there has been an update to the underlying data.</span></span> <span data-ttu-id="23bd8-124">然後，此程式會更新快取，使其保持在最新的。</span><span class="sxs-lookup"><span data-stu-id="23bd8-124">This process then updates the cache to keep it fresh.</span></span> <span data-ttu-id="23bd8-125">如果基礎資料來自緩慢的資料庫連接、Web 服務或其他一些特別緩慢的資料來源，主動式載入就特別有用。</span><span class="sxs-lookup"><span data-stu-id="23bd8-125">Proactive loading is especially useful if the underlying data comes from a slow database connection, a Web service, or some other particularly sluggish data source.</span></span> <span data-ttu-id="23bd8-126">但這種主動式載入方法比較難以實現，因為它需要建立、管理和部署處理常式以檢查變更並更新快取。</span><span class="sxs-lookup"><span data-stu-id="23bd8-126">But this approach to proactive loading is more difficult to implement, as it requires creating, managing, and deploying a process to check for changes and update the cache.</span></span>

<span data-ttu-id="23bd8-127">在應用程式啟動時將資料載入快取中的另一種主動式載入類別，以及我們將在本教學課程中探索的類型。</span><span class="sxs-lookup"><span data-stu-id="23bd8-127">Another flavor of proactive loading, and the type we'll be exploring in this tutorial, is loading data into the cache at application startup.</span></span> <span data-ttu-id="23bd8-128">這種方法特別適用于快取靜態資料，例如資料庫查閱資料表中的記錄。</span><span class="sxs-lookup"><span data-stu-id="23bd8-128">This approach is especially useful for caching static data, such as the records in database lookup tables.</span></span>

> [!NOTE]
> <span data-ttu-id="23bd8-129">如需深入瞭解主動式和被動式載入之間的差異，以及優缺點的詳細資訊，請參閱適用于 .NET 的快取架構指南的管理快取的[內容](https://msdn.microsoft.com/library/ms978503.aspx)一節[。架構應用程式](https://msdn.microsoft.com/library/ms978498.aspx)。</span><span class="sxs-lookup"><span data-stu-id="23bd8-129">For a more in-depth look at the differences between proactive and reactive loading, as well as lists of pros, cons, and implementation recommendations, refer to the [Managing the Contents of a Cache](https://msdn.microsoft.com/library/ms978503.aspx) section of the [Caching Architecture Guide for .NET Framework Applications](https://msdn.microsoft.com/library/ms978498.aspx).</span></span>

## <a name="step-1-determining-what-data-to-cache-at-application-startup"></a><span data-ttu-id="23bd8-130">步驟 1：判斷要在應用程式啟動時快取哪些資料</span><span class="sxs-lookup"><span data-stu-id="23bd8-130">Step 1: Determining What Data to Cache at Application Startup</span></span>

<span data-ttu-id="23bd8-131">使用在前兩個教學課程中所檢查的「回應式載入」的快取範例，適用于可能定期變更且不會花費 exorbitantly 長時間產生的資料。</span><span class="sxs-lookup"><span data-stu-id="23bd8-131">The caching examples using reactive loading that we examined in the previous two tutorials work well with data that may periodically change and does not take exorbitantly long to generate.</span></span> <span data-ttu-id="23bd8-132">但是，如果快取的資料永遠不會變更，則被動式載入所使用的過期就是多餘的。</span><span class="sxs-lookup"><span data-stu-id="23bd8-132">But if the cached data never changes, the expiry used by reactive loading is superfluous.</span></span> <span data-ttu-id="23bd8-133">同樣地，如果要快取的資料花很長的時間來產生，則在抓取基礎資料時，要求將快取設為空白的使用者就必須忍受冗長的等候。</span><span class="sxs-lookup"><span data-stu-id="23bd8-133">Likewise, if the data being cached takes an exceedingly long time to generate, then those users whose requests find the cache empty will have to endure a lengthy wait while the underlying data is retrieved.</span></span> <span data-ttu-id="23bd8-134">請考慮快取在應用程式啟動時，需要很長時間才會產生的靜態資料和資料。</span><span class="sxs-lookup"><span data-stu-id="23bd8-134">Consider caching static data and data that takes an exceptionally long time to generate at application startup.</span></span>

<span data-ttu-id="23bd8-135">雖然資料庫有許多動態且經常變更的值，但大部分也有相當大量的靜態資料。</span><span class="sxs-lookup"><span data-stu-id="23bd8-135">While databases have many dynamic, frequently-changing values, most also have a fair amount of static data.</span></span> <span data-ttu-id="23bd8-136">例如，幾乎所有的資料模型都有一或多個資料行，其中包含一組固定選擇的特定值。</span><span class="sxs-lookup"><span data-stu-id="23bd8-136">For example, virtually all data models have one or more columns that contain a particular value from a fixed set of choices.</span></span> <span data-ttu-id="23bd8-137">資料庫資料表可能`PrimaryLanguage`有資料行，其值的集合可以是英文、西班牙文、法文、俄文、日文等等。 `Patients`</span><span class="sxs-lookup"><span data-stu-id="23bd8-137">A `Patients` database table might have a `PrimaryLanguage` column, whose set of values could be English, Spanish, French, Russian, Japanese, and so on.</span></span> <span data-ttu-id="23bd8-138">這些類型的資料行經常使用*查閱資料表*來執行。</span><span class="sxs-lookup"><span data-stu-id="23bd8-138">Oftentimes, these types of columns are implemented using *lookup tables*.</span></span> <span data-ttu-id="23bd8-139">並不是在`Patients`資料表中儲存字串英文或法文，而是建立第二個數據表，其中通常會有兩個數據行-唯一識別碼和字串描述-具有每個可能值的記錄。</span><span class="sxs-lookup"><span data-stu-id="23bd8-139">Rather than storing the string English or French in the `Patients` table, a second table is created that has, commonly, two columns - a unique identifier and a string description - with a record for each possible value.</span></span> <span data-ttu-id="23bd8-140">資料表中的`PrimaryLanguage`資料行會將對應的唯一識別碼儲存在查閱資料表中。 `Patients`</span><span class="sxs-lookup"><span data-stu-id="23bd8-140">The `PrimaryLanguage` column in the `Patients` table stores the corresponding unique identifier in the lookup table.</span></span> <span data-ttu-id="23bd8-141">在 [圖 1] 中，患者 John Doe 的主要語言是英文，而 Ed Johnson 是俄文。</span><span class="sxs-lookup"><span data-stu-id="23bd8-141">In Figure 1, patient John Doe's primary language is English, while Ed Johnson's is Russian.</span></span>

![[語言] 資料表是病人資料表所使用的查閱資料表](caching-data-at-application-startup-cs/_static/image1.png)

<span data-ttu-id="23bd8-143">**圖 1**：資料表是`Patients`資料表所使用的查閱資料表`Languages`</span><span class="sxs-lookup"><span data-stu-id="23bd8-143">**Figure 1**: The `Languages` Table is a Lookup Table Used by the `Patients` Table</span></span>

<span data-ttu-id="23bd8-144">編輯或建立新患者的使用者介面，會包含`Languages`資料表中的記錄所填入的允許語言下拉式清單。</span><span class="sxs-lookup"><span data-stu-id="23bd8-144">The user interface for editing or creating a new patient would include a drop-down list of allowable languages populated by the records in the `Languages` table.</span></span> <span data-ttu-id="23bd8-145">在沒有快取的情況下，每次造訪此介面時`Languages` ，系統都必須查詢資料表。</span><span class="sxs-lookup"><span data-stu-id="23bd8-145">Without caching, each time this interface is visited the system must query the `Languages` table.</span></span> <span data-ttu-id="23bd8-146">這很浪費和不必要，因為如果有的話，查閱資料表值不常變更。</span><span class="sxs-lookup"><span data-stu-id="23bd8-146">This is wasteful and unnecessary since lookup table values change very infrequently, if ever.</span></span>

<span data-ttu-id="23bd8-147">我們可以`Languages`使用先前教學課程中所檢查的相同「回應式載入」技術來快取資料。</span><span class="sxs-lookup"><span data-stu-id="23bd8-147">We could cache the `Languages` data using the same reactive loading techniques examined in the previous tutorials.</span></span> <span data-ttu-id="23bd8-148">不過，被動式載入會使用以時間為基礎的到期日，這不是靜態查閱資料表資料所需的。</span><span class="sxs-lookup"><span data-stu-id="23bd8-148">Reactive loading, however, uses a time-based expiry, which is not needed for static lookup table data.</span></span> <span data-ttu-id="23bd8-149">雖然使用「被動」載入的快取比完全沒有 caching，但最好的方法是在應用程式啟動時主動將查閱資料表資料載入快取中。</span><span class="sxs-lookup"><span data-stu-id="23bd8-149">While caching using reactive loading would be better than no caching at all, the best approach would be to proactively load the lookup table data into the cache at application startup.</span></span>

<span data-ttu-id="23bd8-150">在本教學課程中，我們將探討如何快取查閱資料表資料和其他靜態資訊。</span><span class="sxs-lookup"><span data-stu-id="23bd8-150">In this tutorial we will look at how to cache lookup table data and other static information.</span></span>

## <a name="step-2-examining-the-different-ways-to-cache-data"></a><span data-ttu-id="23bd8-151">步驟 2：檢查快取資料的不同方式</span><span class="sxs-lookup"><span data-stu-id="23bd8-151">Step 2: Examining the Different Ways to Cache Data</span></span>

<span data-ttu-id="23bd8-152">您可以使用各種方法，以程式設計方式在 ASP.NET 應用程式中快取資訊。</span><span class="sxs-lookup"><span data-stu-id="23bd8-152">Information can be programmatically cached in an ASP.NET application using a variety of approaches.</span></span> <span data-ttu-id="23bd8-153">我們已瞭解如何在先前的教學課程中使用資料快取。</span><span class="sxs-lookup"><span data-stu-id="23bd8-153">We ve already seen how to use the data cache in previous tutorials.</span></span> <span data-ttu-id="23bd8-154">或者，可以使用*靜態成員*或*應用程式狀態*，以程式設計方式快取物件。</span><span class="sxs-lookup"><span data-stu-id="23bd8-154">Alternatively, objects can be programmatically cached using *static members* or *application state*.</span></span>

<span data-ttu-id="23bd8-155">使用類別時，通常必須先將類別具現化，才能存取其成員。</span><span class="sxs-lookup"><span data-stu-id="23bd8-155">When working with a class, typically the class must first be instantiated before its members can be accessed.</span></span> <span data-ttu-id="23bd8-156">例如，若要從我們的商務邏輯層中的其中一個類別叫用方法，我們必須先建立類別的實例：</span><span class="sxs-lookup"><span data-stu-id="23bd8-156">For example, in order to invoke a method from one of the classes in our Business Logic Layer, we must first create an instance of the class:</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample1.cs)]

<span data-ttu-id="23bd8-157">在我們可以叫用*SomeMethod*或使用*SomeProperty*之前，我們必須先使用`new`關鍵字來建立類別的實例。</span><span class="sxs-lookup"><span data-stu-id="23bd8-157">Before we can invoke *SomeMethod* or work with *SomeProperty*, we must first create an instance of the class using the `new` keyword.</span></span> <span data-ttu-id="23bd8-158">*SomeMethod*和*SomeProperty*會與特定實例相關聯。</span><span class="sxs-lookup"><span data-stu-id="23bd8-158">*SomeMethod* and *SomeProperty* are associated with a particular instance.</span></span> <span data-ttu-id="23bd8-159">這些成員的存留期會系結至其相關聯物件的存留期。</span><span class="sxs-lookup"><span data-stu-id="23bd8-159">The lifetime of these members is tied to the lifetime of their associated object.</span></span> <span data-ttu-id="23bd8-160">另一方面，*靜態成員*是在類別的*所有*實例之間共用的變數、屬性和方法，因此，其存留期會與類別相同。</span><span class="sxs-lookup"><span data-stu-id="23bd8-160">*Static members*, on the other hand, are variables, properties, and methods that are shared among *all* instances of the class and, consequently, have a lifetime as long as the class.</span></span> <span data-ttu-id="23bd8-161">靜態成員是以關鍵字`static`表示。</span><span class="sxs-lookup"><span data-stu-id="23bd8-161">Static members are denoted by the keyword `static`.</span></span>

<span data-ttu-id="23bd8-162">除了靜態成員之外，還可以使用應用程式狀態來快取資料。</span><span class="sxs-lookup"><span data-stu-id="23bd8-162">In addition to static members, data can be cached using application state.</span></span> <span data-ttu-id="23bd8-163">每個 ASP.NET 應用程式都會維護一個在應用程式的所有使用者和頁面之間共用的名稱/值集合。</span><span class="sxs-lookup"><span data-stu-id="23bd8-163">Each ASP.NET application maintains a name/value collection that's shared across all users and pages of the application.</span></span> <span data-ttu-id="23bd8-164">您可以使用[ `HttpContext`類別](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)的[ `Application`屬性](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx)來存取這個集合，並從 ASP.NET 網頁的程式碼後置類別中使用，如下所示：</span><span class="sxs-lookup"><span data-stu-id="23bd8-164">This collection can be accessed using the [`HttpContext` class](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)'s [`Application` property](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx), and used from an ASP.NET page's code-behind class like so:</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample2.cs)]

<span data-ttu-id="23bd8-165">資料快取可提供更豐富的 API 來快取資料、提供時間和相依性 expiries 的機制、快取專案優先順序等等。</span><span class="sxs-lookup"><span data-stu-id="23bd8-165">The data cache provides a much richer API for caching data, providing mechanisms for time- and dependency-based expiries, cache item priorities, and so forth.</span></span> <span data-ttu-id="23bd8-166">使用靜態成員和應用程式狀態時，網頁開發人員必須手動加入這類功能。</span><span class="sxs-lookup"><span data-stu-id="23bd8-166">With static members and application state, such features must be manually added by the page developer.</span></span> <span data-ttu-id="23bd8-167">不過，在應用程式啟動時快取資料以在應用程式的存留期間，資料快取的優點是想法。</span><span class="sxs-lookup"><span data-stu-id="23bd8-167">When caching data at application startup for the lifetime of the application, however, the data cache's advantages are moot.</span></span> <span data-ttu-id="23bd8-168">在本教學課程中，我們將探討使用這三種方法來快取靜態資料的程式碼。</span><span class="sxs-lookup"><span data-stu-id="23bd8-168">In this tutorial we'll look at code that uses all three techniques for caching static data.</span></span>

## <a name="step-3-caching-thesupplierstable-data"></a><span data-ttu-id="23bd8-169">步驟 3：快取`Suppliers`資料表資料</span><span class="sxs-lookup"><span data-stu-id="23bd8-169">Step 3: Caching the`Suppliers`Table Data</span></span>

<span data-ttu-id="23bd8-170">我們已實作為日期的 Northwind 資料庫資料表不包含任何傳統查閱資料表。</span><span class="sxs-lookup"><span data-stu-id="23bd8-170">The Northwind database tables we ve implemented to date do not include any traditional lookup tables.</span></span> <span data-ttu-id="23bd8-171">這四個 Datatable 在 DAL 中實作為所有模型資料表，其值為非靜態。</span><span class="sxs-lookup"><span data-stu-id="23bd8-171">The four DataTables implemented in our DAL all model tables whose values are non-static.</span></span> <span data-ttu-id="23bd8-172">本教學課程只是假設`Suppliers`資料表的資料是靜態的，而不花時間將新的 DataTable 加入 DAL，然後將新的類別和方法新增到 BLL。</span><span class="sxs-lookup"><span data-stu-id="23bd8-172">Rather than spending the time to add a new DataTable to the DAL and then a new class and methods to the BLL, for this tutorial let's just pretend that the `Suppliers` table's data is static.</span></span> <span data-ttu-id="23bd8-173">因此，我們可以在應用程式啟動時快取此資料。</span><span class="sxs-lookup"><span data-stu-id="23bd8-173">Therefore, we could cache this data at application startup.</span></span>

<span data-ttu-id="23bd8-174">若要開始，請`StaticCache.cs` `CL`在資料夾中建立名為的新類別。</span><span class="sxs-lookup"><span data-stu-id="23bd8-174">To start, create a new class named `StaticCache.cs` in the `CL` folder.</span></span>

![在 CL 資料夾中建立 StaticCache.cs 類別](caching-data-at-application-startup-cs/_static/image2.png)

<span data-ttu-id="23bd8-176">**圖 2**：在資料夾中建立類別`StaticCache.cs` `CL`</span><span class="sxs-lookup"><span data-stu-id="23bd8-176">**Figure 2**: Create the `StaticCache.cs` Class in the `CL` Folder</span></span>

<span data-ttu-id="23bd8-177">我們需要新增方法，將啟動時的資料載入至適當的快取存放區，以及從這個快取傳回資料的方法。</span><span class="sxs-lookup"><span data-stu-id="23bd8-177">We need to add a method that loads the data at startup into the appropriate cache store, as well as methods that return data from this cache.</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample3.cs)]

<span data-ttu-id="23bd8-178">上述程式碼會使用靜態成員變數， `suppliers`來保存`SuppliersBLL`類別的`GetSuppliers()`方法的結果，而這會從`LoadStaticCache()`方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="23bd8-178">The above code uses a static member variable, `suppliers`, to hold the results from the `SuppliersBLL` class's `GetSuppliers()` method, which is called from the `LoadStaticCache()` method.</span></span> <span data-ttu-id="23bd8-179">`LoadStaticCache()`方法的目的是要在應用程式啟動期間呼叫。</span><span class="sxs-lookup"><span data-stu-id="23bd8-179">The `LoadStaticCache()` method is meant to be called during the application's start.</span></span> <span data-ttu-id="23bd8-180">一旦在應用程式啟動時載入此資料，任何需要使用供應商資料的頁面都可以呼叫`StaticCache`類別的`GetSuppliers()`方法。</span><span class="sxs-lookup"><span data-stu-id="23bd8-180">Once this data has been loaded at application startup, any page that needs to work with supplier data can call the `StaticCache` class's `GetSuppliers()` method.</span></span> <span data-ttu-id="23bd8-181">因此，在應用程式啟動時，對資料庫的呼叫只會出現一次。</span><span class="sxs-lookup"><span data-stu-id="23bd8-181">Therefore, the call to the database to get the suppliers only happens once, at application start.</span></span>

<span data-ttu-id="23bd8-182">我們不會使用靜態成員變數做為快取存放區，而是也可以使用應用程式狀態或資料快取。</span><span class="sxs-lookup"><span data-stu-id="23bd8-182">Rather than using a static member variable as the cache store, we could have alternatively used application state or the data cache.</span></span> <span data-ttu-id="23bd8-183">下列程式碼顯示類別改良以使用應用程式狀態：</span><span class="sxs-lookup"><span data-stu-id="23bd8-183">The following code shows the class retooled to use application state:</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample4.cs)]

<span data-ttu-id="23bd8-184">在`LoadStaticCache()`中，供應商資訊會儲存至應用程式變數索引*鍵*。</span><span class="sxs-lookup"><span data-stu-id="23bd8-184">In `LoadStaticCache()`, the supplier information is stored to the application variable *key*.</span></span> <span data-ttu-id="23bd8-185">它會從`GetSuppliers()`傳回為適當的類型`Northwind.SuppliersDataTable`（）。</span><span class="sxs-lookup"><span data-stu-id="23bd8-185">It's returned as the appropriate type (`Northwind.SuppliersDataTable`) from `GetSuppliers()`.</span></span> <span data-ttu-id="23bd8-186">雖然可以使用`Application["key"]`在 ASP.NET 網頁的程式碼後置類別中存取應用程式狀態，但在架構中， `HttpContext.Current.Application["key"]`我們必須使用，才能取得`HttpContext`目前的。</span><span class="sxs-lookup"><span data-stu-id="23bd8-186">While application state can be accessed in the code-behind classes of ASP.NET pages using `Application["key"]`, in the architecture we must use `HttpContext.Current.Application["key"]` in order to get the current `HttpContext`.</span></span>

<span data-ttu-id="23bd8-187">同樣地，資料快取也可以當做快取存放區使用，如下列程式碼所示：</span><span class="sxs-lookup"><span data-stu-id="23bd8-187">Likewise, the data cache can be used as a cache store, as the following code shows:</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample5.cs)]

<span data-ttu-id="23bd8-188">若要將專案新增至資料快取，但沒有以時間為基礎的`System.Web.Caching.Cache.NoAbsoluteExpiration`到期`System.Web.Caching.Cache.NoSlidingExpiration`日，請使用和值做為輸入參數。</span><span class="sxs-lookup"><span data-stu-id="23bd8-188">To add an item to the data cache with no time-based expiry, use the `System.Web.Caching.Cache.NoAbsoluteExpiration` and `System.Web.Caching.Cache.NoSlidingExpiration` values as input parameters.</span></span> <span data-ttu-id="23bd8-189">已選取此資料`Insert`快取方法的特定多載，以便我們可以指定快取專案的*優先順序*。</span><span class="sxs-lookup"><span data-stu-id="23bd8-189">This particular overload of the data cache's `Insert` method was selected so that we could specify the *priority* of the cache item.</span></span> <span data-ttu-id="23bd8-190">優先順序是用來決定可用記憶體不足時，要從快取中清除哪些專案。</span><span class="sxs-lookup"><span data-stu-id="23bd8-190">The priority is used to determine what items to scavenge from the cache when available memory runs low.</span></span> <span data-ttu-id="23bd8-191">在此我們會使用`NotRemovable`優先順序，以確保不會清除此快取專案。</span><span class="sxs-lookup"><span data-stu-id="23bd8-191">Here we use the priority `NotRemovable`, which ensures that this cache item won't be scavenged.</span></span>

> [!NOTE]
> <span data-ttu-id="23bd8-192">本教學`StaticCache`課程的下載會使用靜態成員變數方法來執行類別。</span><span class="sxs-lookup"><span data-stu-id="23bd8-192">This tutorial's download implements the `StaticCache` class using the static member variable approach.</span></span> <span data-ttu-id="23bd8-193">應用程式狀態和資料快取技術的程式碼可在類別檔案的批註中取得。</span><span class="sxs-lookup"><span data-stu-id="23bd8-193">The code for the application state and data cache techniques is available in the comments in the class file.</span></span>

## <a name="step-4-executing-code-at-application-startup"></a><span data-ttu-id="23bd8-194">步驟 4：在應用程式啟動時執行程式碼</span><span class="sxs-lookup"><span data-stu-id="23bd8-194">Step 4: Executing Code at Application Startup</span></span>

<span data-ttu-id="23bd8-195">若要在 web 應用程式第一次啟動時執行程式碼，我們必須建立`Global.asax`名為的特殊檔案。</span><span class="sxs-lookup"><span data-stu-id="23bd8-195">To execute code when a web application first starts, we need to create a special file named `Global.asax`.</span></span> <span data-ttu-id="23bd8-196">這個檔案可以包含應用程式、會話和要求層級事件的事件處理常式，而且可以在這裡新增應用程式啟動時所要執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="23bd8-196">This file can contain event handlers for application-, session-, and request-level events, and it is here where we can add code that will be executed whenever the application starts.</span></span>

<span data-ttu-id="23bd8-197">`Global.asax`以滑鼠右鍵按一下 Visual Studio 的方案總管中的網站專案名稱，然後選擇 [加入新專案]，將檔案新增至 web 應用程式的根目錄。</span><span class="sxs-lookup"><span data-stu-id="23bd8-197">Add the `Global.asax` file to your web application's root directory by right-clicking on the website project name in Visual Studio's Solution Explorer and choosing Add New Item.</span></span> <span data-ttu-id="23bd8-198">從 [加入新專案] 對話方塊中，選取 [全域應用程式類別] 專案類型，然後按一下 [加入] 按鈕。</span><span class="sxs-lookup"><span data-stu-id="23bd8-198">From the Add New Item dialog box, select the Global Application Class item type and then click the Add button.</span></span>

> [!NOTE]
> <span data-ttu-id="23bd8-199">如果您的專案中`Global.asax`已經有檔案，全域應用程式類別專案類型將不會列在 [加入新專案] 對話方塊中。</span><span class="sxs-lookup"><span data-stu-id="23bd8-199">If you already have a `Global.asax` file in your project, the Global Application Class item type will not be listed in the Add New Item dialog box.</span></span>

<span data-ttu-id="23bd8-200">[![將 global.asax 檔案新增至 Web 應用程式的根目錄](caching-data-at-application-startup-cs/_static/image4.png)](caching-data-at-application-startup-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="23bd8-200">[![Add the Global.asax File to Your Web Application's Root Directory](caching-data-at-application-startup-cs/_static/image4.png)](caching-data-at-application-startup-cs/_static/image3.png)</span></span>

<span data-ttu-id="23bd8-201">**圖 3**:將檔案新增至 Web 應用程式的根目錄（[按一下以查看完整大小的影像）](caching-data-at-application-startup-cs/_static/image5.png) `Global.asax`</span><span class="sxs-lookup"><span data-stu-id="23bd8-201">**Figure 3**: Add the `Global.asax` File to Your Web Application's Root Directory ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image5.png))</span></span>

<span data-ttu-id="23bd8-202">預設`Global.asax`檔案範本包含伺服器端`<script>`標記內的五個方法：</span><span class="sxs-lookup"><span data-stu-id="23bd8-202">The default `Global.asax` file template includes five methods within a server-side `<script>` tag:</span></span>

- <span data-ttu-id="23bd8-203">**`Application_Start`** 在 web 應用程式第一次啟動時執行</span><span class="sxs-lookup"><span data-stu-id="23bd8-203">**`Application_Start`** executes when the web application first starts</span></span>
- <span data-ttu-id="23bd8-204">**`Application_End`** 在應用程式關閉時執行</span><span class="sxs-lookup"><span data-stu-id="23bd8-204">**`Application_End`** runs when the application is shutting down</span></span>
- <span data-ttu-id="23bd8-205">**`Application_Error`** 當未處理的例外狀況到達應用程式時執行</span><span class="sxs-lookup"><span data-stu-id="23bd8-205">**`Application_Error`** executes whenever an unhandled exception reaches the application</span></span>
- <span data-ttu-id="23bd8-206">**`Session_Start`** 在建立新的會話時執行</span><span class="sxs-lookup"><span data-stu-id="23bd8-206">**`Session_Start`** executes when a new session is created</span></span>
- <span data-ttu-id="23bd8-207">**`Session_End`** 當會話已過期或已放棄時執行</span><span class="sxs-lookup"><span data-stu-id="23bd8-207">**`Session_End`** runs when a session is expired or abandoned</span></span>

<span data-ttu-id="23bd8-208">`Application_Start`事件處理常式只會在應用程式的生命週期中呼叫一次。</span><span class="sxs-lookup"><span data-stu-id="23bd8-208">The `Application_Start` event handler is called only once during an application's life cycle.</span></span> <span data-ttu-id="23bd8-209">應用程式會在第一次從應用程式要求 ASP.NET 資源時啟動，並繼續執行直到重新開機應用程式為止，這可能是因為修改`/Bin`資料夾的內容、修改`Global.asax`、修改資料夾中的`App_Code`內容，或`Web.config`修改檔案，還有其他原因。</span><span class="sxs-lookup"><span data-stu-id="23bd8-209">The application starts the first time an ASP.NET resource is requested from the application and continues to run until the application is restarted, which can happen by modifying the contents of the `/Bin` folder, modifying `Global.asax`, modifying the contents in the `App_Code` folder, or modifying the `Web.config` file, among other causes.</span></span> <span data-ttu-id="23bd8-210">如需應用程式生命週期的詳細討論，請參閱[ASP.NET 應用程式生命週期總覽](https://msdn.microsoft.com/library/ms178473.aspx)。</span><span class="sxs-lookup"><span data-stu-id="23bd8-210">Refer to [ASP.NET Application Life Cycle Overview](https://msdn.microsoft.com/library/ms178473.aspx) for a more detailed discussion on the application life cycle.</span></span>

<span data-ttu-id="23bd8-211">在`Application_Start`這些教學課程中，我們只需要將程式碼新增至方法，因此您可以自由移除其他專案。</span><span class="sxs-lookup"><span data-stu-id="23bd8-211">For these tutorials we only need to add code to the `Application_Start` method, so feel free to remove the others.</span></span> <span data-ttu-id="23bd8-212">在`Application_Start`中，只要`StaticCache`呼叫類別的`LoadStaticCache()`方法，它就會載入並快取供應商資訊：</span><span class="sxs-lookup"><span data-stu-id="23bd8-212">In `Application_Start`, simply call the `StaticCache` class's `LoadStaticCache()` method, which will load and cache the supplier information:</span></span>

[!code-aspx[Main](caching-data-at-application-startup-cs/samples/sample6.aspx)]

<span data-ttu-id="23bd8-213">這樣就全部完成了！</span><span class="sxs-lookup"><span data-stu-id="23bd8-213">That's all there is to it!</span></span> <span data-ttu-id="23bd8-214">在應用程式啟動時`LoadStaticCache()` ，方法會從 BLL 抓取供應商資訊，並將其儲存在靜態成員變數中（或您`StaticCache`在類別中最後使用的任何快取存放區）。</span><span class="sxs-lookup"><span data-stu-id="23bd8-214">At application startup, the `LoadStaticCache()` method will grab the supplier information from the BLL, and store it in a static member variable (or whatever cache store you ended up using in the `StaticCache` class).</span></span> <span data-ttu-id="23bd8-215">若要確認此行為，請在方法中`Application_Start`設定中斷點，並執行您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="23bd8-215">To verify this behavior, set a breakpoint in the `Application_Start` method and run your application.</span></span> <span data-ttu-id="23bd8-216">請注意，啟動應用程式時，會叫用中斷點。</span><span class="sxs-lookup"><span data-stu-id="23bd8-216">Note that the breakpoint is hit upon the application starting.</span></span> <span data-ttu-id="23bd8-217">不過，後續要求並不會使`Application_Start`方法執行。</span><span class="sxs-lookup"><span data-stu-id="23bd8-217">Subsequent requests, however, do not cause the `Application_Start` method to execute.</span></span>

<span data-ttu-id="23bd8-218">[![使用中斷點來確認正在執行 Application_Start 事件處理常式](caching-data-at-application-startup-cs/_static/image7.png)](caching-data-at-application-startup-cs/_static/image6.png)</span><span class="sxs-lookup"><span data-stu-id="23bd8-218">[![Use a Breakpoint to Verify that the Application_Start Event Handler is Being Executed](caching-data-at-application-startup-cs/_static/image7.png)](caching-data-at-application-startup-cs/_static/image6.png)</span></span>

<span data-ttu-id="23bd8-219">**圖 4**：使用中斷點來確認`Application_Start`正在執行事件處理常式（[按一下以查看完整大小的影像](caching-data-at-application-startup-cs/_static/image8.png)）</span><span class="sxs-lookup"><span data-stu-id="23bd8-219">**Figure 4**: Use a Breakpoint to Verify that the `Application_Start` Event Handler is Being Executed ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image8.png))</span></span>

> [!NOTE]
> <span data-ttu-id="23bd8-220">如果您在第一次`Application_Start`啟動偵錯工具時未叫用中斷點，這是因為您的應用程式已啟動。</span><span class="sxs-lookup"><span data-stu-id="23bd8-220">If you do not hit the `Application_Start` breakpoint when you first start debugging, it is because your application has already started.</span></span> <span data-ttu-id="23bd8-221">藉由修改`Global.asax`或`Web.config`檔案來強制重新開機應用程式，然後再試一次。</span><span class="sxs-lookup"><span data-stu-id="23bd8-221">Force the application to restart by modifying your `Global.asax` or `Web.config` files and then try again.</span></span> <span data-ttu-id="23bd8-222">您可以直接在上述其中一個檔案的結尾加入（或移除）空白行，以快速重新開機應用程式。</span><span class="sxs-lookup"><span data-stu-id="23bd8-222">You can simply add (or remove) a blank line at the end of one of these files to quickly restart the application.</span></span>

## <a name="step-5-displaying-the-cached-data"></a><span data-ttu-id="23bd8-223">步驟 5：顯示快取的資料</span><span class="sxs-lookup"><span data-stu-id="23bd8-223">Step 5: Displaying the Cached Data</span></span>

<span data-ttu-id="23bd8-224">此時， `StaticCache`類別會有在應用程式啟動時快取的供應商資料版本，可以透過其`GetSuppliers()`方法來存取。</span><span class="sxs-lookup"><span data-stu-id="23bd8-224">At this point the `StaticCache` class has a version of the supplier data cached at application startup that can be accessed through its `GetSuppliers()` method.</span></span> <span data-ttu-id="23bd8-225">若要從展示層使用此資料，我們可以使用 ObjectDataSource，或從 ASP.NET 網頁的`StaticCache`程式碼`GetSuppliers()`後置類別中，以程式設計方式叫用類別的方法。</span><span class="sxs-lookup"><span data-stu-id="23bd8-225">To work with this data from the Presentation Layer, we can use an ObjectDataSource or programmatically invoke the `StaticCache` class's `GetSuppliers()` method from an ASP.NET page's code-behind class.</span></span> <span data-ttu-id="23bd8-226">讓我們看看如何使用 ObjectDataSource 和 GridView 控制項來顯示快取的供應商資訊。</span><span class="sxs-lookup"><span data-stu-id="23bd8-226">Let's look at using the ObjectDataSource and GridView controls to display the cached supplier information.</span></span>

<span data-ttu-id="23bd8-227">從開啟`Caching`資料夾中`AtApplicationStartup.aspx`的頁面開始。</span><span class="sxs-lookup"><span data-stu-id="23bd8-227">Start by opening the `AtApplicationStartup.aspx` page in the `Caching` folder.</span></span> <span data-ttu-id="23bd8-228">將 GridView 從 [工具箱] 拖曳至設計工具，將`ID`其屬性`Suppliers`設定為。</span><span class="sxs-lookup"><span data-stu-id="23bd8-228">Drag a GridView from the Toolbox onto the designer, setting its `ID` property to `Suppliers`.</span></span> <span data-ttu-id="23bd8-229">接下來，從 GridView 的智慧標籤選擇建立名為`SuppliersCachedDataSource`的新 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="23bd8-229">Next, from the GridView's smart tag choose to create a new ObjectDataSource named `SuppliersCachedDataSource`.</span></span> <span data-ttu-id="23bd8-230">將 ObjectDataSource 設定為使用`StaticCache`類別的`GetSuppliers()`方法。</span><span class="sxs-lookup"><span data-stu-id="23bd8-230">Configure the ObjectDataSource to use the `StaticCache` class's `GetSuppliers()` method.</span></span>

<span data-ttu-id="23bd8-231">[![將 ObjectDataSource 設定為使用 StaticCache 類別](caching-data-at-application-startup-cs/_static/image10.png)](caching-data-at-application-startup-cs/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="23bd8-231">[![Configure the ObjectDataSource to use the StaticCache Class](caching-data-at-application-startup-cs/_static/image10.png)](caching-data-at-application-startup-cs/_static/image9.png)</span></span>

<span data-ttu-id="23bd8-232">**圖 5**：設定 ObjectDataSource 使用`StaticCache`類別（[按一下以查看完整大小的影像](caching-data-at-application-startup-cs/_static/image11.png)）</span><span class="sxs-lookup"><span data-stu-id="23bd8-232">**Figure 5**: Configure the ObjectDataSource to use the `StaticCache` Class ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image11.png))</span></span>

<span data-ttu-id="23bd8-233">[![使用 GetSuppliers （）方法來取出快取的供應商資料](caching-data-at-application-startup-cs/_static/image13.png)](caching-data-at-application-startup-cs/_static/image12.png)</span><span class="sxs-lookup"><span data-stu-id="23bd8-233">[![Use the GetSuppliers() Method to Retrieve the Cached Supplier Data](caching-data-at-application-startup-cs/_static/image13.png)](caching-data-at-application-startup-cs/_static/image12.png)</span></span>

<span data-ttu-id="23bd8-234">**圖 6**:使用方法來抓取快取的供應商資料（[按一下以查看完整大小的影像）](caching-data-at-application-startup-cs/_static/image14.png) `GetSuppliers()`</span><span class="sxs-lookup"><span data-stu-id="23bd8-234">**Figure 6**: Use the `GetSuppliers()` Method to Retrieve the Cached Supplier Data ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image14.png))</span></span>

<span data-ttu-id="23bd8-235">完成 wizard 之後，Visual Studio 會自動為中`SuppliersDataTable`的每個資料欄位加入 BoundFields。</span><span class="sxs-lookup"><span data-stu-id="23bd8-235">After completing the wizard, Visual Studio will automatically add BoundFields for each of the data fields in `SuppliersDataTable`.</span></span> <span data-ttu-id="23bd8-236">您的 GridView 和 ObjectDataSource 的宣告式標記看起來應該如下所示：</span><span class="sxs-lookup"><span data-stu-id="23bd8-236">Your GridView and ObjectDataSource's declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](caching-data-at-application-startup-cs/samples/sample7.aspx)]

<span data-ttu-id="23bd8-237">[圖 7] 顯示透過瀏覽器觀看的頁面。</span><span class="sxs-lookup"><span data-stu-id="23bd8-237">Figure 7 shows the page when viewed through a browser.</span></span> <span data-ttu-id="23bd8-238">輸出與我們從 BLL 的`SuppliersBLL`類別提取資料的方式相同，但`StaticCache`使用類別會傳回供應商資料，如在應用程式啟動時快取。</span><span class="sxs-lookup"><span data-stu-id="23bd8-238">The output is the same had we pulled the data from the BLL's `SuppliersBLL` class, but using the `StaticCache` class returns the supplier data as cached at application startup.</span></span> <span data-ttu-id="23bd8-239">您可以在`StaticCache`類別的`GetSuppliers()`方法中設定中斷點，以驗證此行為。</span><span class="sxs-lookup"><span data-stu-id="23bd8-239">You can set breakpoints in the `StaticCache` class's `GetSuppliers()` method to verify this behavior.</span></span>

<span data-ttu-id="23bd8-240">[![已快取的供應商資料會顯示在 GridView 中](caching-data-at-application-startup-cs/_static/image16.png)](caching-data-at-application-startup-cs/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="23bd8-240">[![The Cached Supplier Data is Displayed in a GridView](caching-data-at-application-startup-cs/_static/image16.png)](caching-data-at-application-startup-cs/_static/image15.png)</span></span>

<span data-ttu-id="23bd8-241">**圖 7**：快取的供應商資料會顯示在 GridView 中（[按一下以查看完整大小的影像](caching-data-at-application-startup-cs/_static/image17.png)）</span><span class="sxs-lookup"><span data-stu-id="23bd8-241">**Figure 7**: The Cached Supplier Data is Displayed in a GridView ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image17.png))</span></span>

## <a name="summary"></a><span data-ttu-id="23bd8-242">總結</span><span class="sxs-lookup"><span data-stu-id="23bd8-242">Summary</span></span>

<span data-ttu-id="23bd8-243">大部分的資料模型都包含相當大量的靜態資料，通常是以查閱資料表的形式來執行。</span><span class="sxs-lookup"><span data-stu-id="23bd8-243">Most every data model contains a fair amount of static data, usually implemented in the form of lookup tables.</span></span> <span data-ttu-id="23bd8-244">由於這項資訊是靜態的，因此在每次需要顯示此資訊時，都無法持續存取資料庫。</span><span class="sxs-lookup"><span data-stu-id="23bd8-244">Since this information is static, there's no reason to continually access the database each time this information needs to be displayed.</span></span> <span data-ttu-id="23bd8-245">此外，由於其靜態本質，當快取資料時，不需要到期。</span><span class="sxs-lookup"><span data-stu-id="23bd8-245">Furthermore, due to its static nature, when caching the data there's no need for an expiry.</span></span> <span data-ttu-id="23bd8-246">在本教學課程中，我們已瞭解如何採用這類資料，並將它快取到資料快取、應用程式狀態，以及透過靜態成員變數。</span><span class="sxs-lookup"><span data-stu-id="23bd8-246">In this tutorial we saw how to take such data and cache it in the data cache, application state, and through a static member variable.</span></span> <span data-ttu-id="23bd8-247">這項資訊會在應用程式啟動時快取，並在整個應用程式的存留期間保留在快取中。</span><span class="sxs-lookup"><span data-stu-id="23bd8-247">This information is cached at application startup and remains in the cache throughout the application's lifetime.</span></span>

<span data-ttu-id="23bd8-248">在本教學課程和過去的兩個中，我們已探討在應用程式存留期間的快取資料，以及使用以時間為基礎的 expiries。</span><span class="sxs-lookup"><span data-stu-id="23bd8-248">In this tutorial and the past two, we ve looked at caching data for the duration of the application's lifetime as well as using time-based expiries.</span></span> <span data-ttu-id="23bd8-249">不過，當快取資料庫資料時，以時間為基礎的到期可能會小於理想的。</span><span class="sxs-lookup"><span data-stu-id="23bd8-249">When caching database data, though, a time-based expiry may be less than ideal.</span></span> <span data-ttu-id="23bd8-250">並不會定期清除快取，因此只有在修改基礎資料庫資料時才收回快取的專案是最佳做法。</span><span class="sxs-lookup"><span data-stu-id="23bd8-250">Rather than periodically flushing the cache, it would be optimal to only evict the cached item when the underlying database data is modified.</span></span> <span data-ttu-id="23bd8-251">這是使用 SQL 快取相依性的理想選擇，我們將在下一個教學課程中進行檢查。</span><span class="sxs-lookup"><span data-stu-id="23bd8-251">This ideal is possible through the use of SQL cache dependencies, which we'll examine in our next tutorial.</span></span>

<span data-ttu-id="23bd8-252">快樂的程式設計！</span><span class="sxs-lookup"><span data-stu-id="23bd8-252">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="23bd8-253">關於作者</span><span class="sxs-lookup"><span data-stu-id="23bd8-253">About the Author</span></span>

<span data-ttu-id="23bd8-254">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，自1998起，有七個 ASP/ASP. NET 書籍和創辦人的[4GuysFromRolla.com](http://www.4guysfromrolla.com)。</span><span class="sxs-lookup"><span data-stu-id="23bd8-254">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="23bd8-255">Scott 以獨立的顧問、訓練員和作者的身分運作。</span><span class="sxs-lookup"><span data-stu-id="23bd8-255">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="23bd8-256">他的最新著作是[*在24小時內讓自己的 ASP.NET 2.0*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="23bd8-256">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="23bd8-257">他可以到達[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="23bd8-257">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="23bd8-258">或透過他的部落格，這位於 [http://ScottOnWriting.NET](http://ScottOnWriting.NET)。</span><span class="sxs-lookup"><span data-stu-id="23bd8-258">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="23bd8-259">特別感謝</span><span class="sxs-lookup"><span data-stu-id="23bd8-259">Special Thanks To</span></span>

<span data-ttu-id="23bd8-260">本教學課程系列已由許多有用的審核者所審查。</span><span class="sxs-lookup"><span data-stu-id="23bd8-260">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="23bd8-261">本教學課程的潛在客戶審核者為 Teresa Murphy 和 Zack。</span><span class="sxs-lookup"><span data-stu-id="23bd8-261">Lead reviewers for this tutorial were Teresa Murphy and Zack Jones.</span></span> <span data-ttu-id="23bd8-262">有興趣複習我即將發行的 MSDN 文章嗎？</span><span class="sxs-lookup"><span data-stu-id="23bd8-262">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="23bd8-263">若是如此，請在上[ mitchell@4GuysFromRolla.com放一行。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="23bd8-263">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="23bd8-264">[上一頁](caching-data-in-the-architecture-cs.md)
> [下一頁](using-sql-cache-dependencies-cs.md)</span><span class="sxs-lookup"><span data-stu-id="23bd8-264">[Previous](caching-data-in-the-architecture-cs.md)
[Next](using-sql-cache-dependencies-cs.md)</span></span>
