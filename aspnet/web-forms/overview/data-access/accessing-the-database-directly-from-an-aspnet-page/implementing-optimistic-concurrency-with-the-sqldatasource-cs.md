---
uid: web-forms/overview/data-access/accessing-the-database-directly-from-an-aspnet-page/implementing-optimistic-concurrency-with-the-sqldatasource-cs
title: 使用 SqlDataSource （C#）來執行開放式平行存取 |Microsoft Docs
author: rick-anderson
description: 在本教學課程中，我們將探討開放式並行存取控制的基本概念，然後探索如何使用 SqlDataSource 控制項來執行它。
ms.author: riande
ms.date: 02/20/2007
ms.assetid: df999966-ac48-460e-b82b-4877a57d6ab9
msc.legacyurl: /web-forms/overview/data-access/accessing-the-database-directly-from-an-aspnet-page/implementing-optimistic-concurrency-with-the-sqldatasource-cs
msc.type: authoredcontent
ms.openlocfilehash: 87fca52e2e8be844411b2fff8382c6002eccbe09
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/06/2020
ms.locfileid: "78553232"
---
# <a name="implementing-optimistic-concurrency-with-the-sqldatasource-c"></a><span data-ttu-id="219c3-103">使用 SqlDataSource 實作開放式同步存取 (C#)</span><span class="sxs-lookup"><span data-stu-id="219c3-103">Implementing Optimistic Concurrency with the SqlDataSource (C#)</span></span>

<span data-ttu-id="219c3-104">由[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="219c3-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="219c3-105">[下載範例應用程式](https://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_50_CS.exe)或[下載 PDF](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/datatutorial50cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="219c3-105">[Download Sample App](https://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_50_CS.exe) or [Download PDF](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/datatutorial50cs1.pdf)</span></span>

> <span data-ttu-id="219c3-106">在本教學課程中，我們將探討開放式並行存取控制的基本概念，然後探索如何使用 SqlDataSource 控制項來執行它。</span><span class="sxs-lookup"><span data-stu-id="219c3-106">In this tutorial we review the essentials of optimistic concurrency control and then explore how to implement it using the SqlDataSource control.</span></span>

## <a name="introduction"></a><span data-ttu-id="219c3-107">簡介</span><span class="sxs-lookup"><span data-stu-id="219c3-107">Introduction</span></span>

<span data-ttu-id="219c3-108">在先前的教學課程中，我們探討了如何將插入、更新和刪除功能新增至 SqlDataSource 控制項。</span><span class="sxs-lookup"><span data-stu-id="219c3-108">In the preceding tutorial we examined how to add inserting, updating, and deleting capabilities to the SqlDataSource control.</span></span> <span data-ttu-id="219c3-109">簡言之，若要提供這些功能，我們需要在控制項 s `InsertCommand`、`UpdateCommand`或 `DeleteCommand` 屬性中指定對應的 `INSERT`、`UPDATE`或 `DELETE` SQL 語句，以及 `InsertParameters`、`UpdateParameters`和 `DeleteParameters` 集合中的適當參數。</span><span class="sxs-lookup"><span data-stu-id="219c3-109">In short, to provide these features we needed to specify the corresponding `INSERT`, `UPDATE`, or `DELETE` SQL statement in the control s `InsertCommand`, `UpdateCommand`, or `DeleteCommand` properties, along with the appropriate parameters in the `InsertParameters`, `UpdateParameters`, and `DeleteParameters` collections.</span></span> <span data-ttu-id="219c3-110">雖然可以手動指定這些屬性和集合，但是 [設定資料來源嚮導] 的 [建立 `INSERT`]、[`UPDATE`] 和 [`DELETE` 語句] 核取方塊會根據 `SELECT` 語句，自動建立這些語句。</span><span class="sxs-lookup"><span data-stu-id="219c3-110">While these properties and collections can be specified manually, the Configure Data Source wizard s Advanced button offers a Generate `INSERT`, `UPDATE`, and `DELETE` statements checkbox that will auto-create these statements based on the `SELECT` statement.</span></span>

<span data-ttu-id="219c3-111">除了 [產生 `INSERT`]、[`UPDATE`] 和 [`DELETE` 語句] 核取方塊，[Advanced SQL 產生選項] 對話方塊還包含 [使用開放式平行存取] 選項（請參閱 [圖 1]）。</span><span class="sxs-lookup"><span data-stu-id="219c3-111">Along with the Generate `INSERT`, `UPDATE`, and `DELETE` statements checkbox, the Advanced SQL Generation Options dialog box includes a Use optimistic concurrency option (see Figure 1).</span></span> <span data-ttu-id="219c3-112">若有選取時，自動產生的 `UPDATE` 和 `DELETE` 語句中的 `WHERE` 子句會修改成隻在使用者上次將資料載入方格後未修改基礎資料庫資料時，才執行更新或刪除。</span><span class="sxs-lookup"><span data-stu-id="219c3-112">When checked, the `WHERE` clauses in the autogenerated `UPDATE` and `DELETE` statements are modified to only perform the update or delete if the underlying database data hasn't been modified since the user last loaded the data into the grid.</span></span>

![您可以從 [Advanced SQL 產生選項] 對話方塊新增開放式平行存取支援](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image1.gif)

<span data-ttu-id="219c3-114">**圖 1**：您可以從 [Advanced SQL 產生選項] 對話方塊加入開放式平行存取支援</span><span class="sxs-lookup"><span data-stu-id="219c3-114">**Figure 1**: You Can Add Optimistic Concurrency Support from the Advanced SQL Generation Options Dialog Box</span></span>

<span data-ttu-id="219c3-115">回到[執行開放式並行](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-cs.md)存取教學課程，我們檢查了開放式並行存取控制的基本概念，以及如何將它加入至 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="219c3-115">Back in the [Implementing Optimistic Concurrency](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-cs.md) tutorial we examined the fundamentals of optimistic concurrency control and how to add it to the ObjectDataSource.</span></span> <span data-ttu-id="219c3-116">在本教學課程中，我們將針對開放式並行存取控制的基本概念進行潤色，然後探索如何使用 SqlDataSource 來執行。</span><span class="sxs-lookup"><span data-stu-id="219c3-116">In this tutorial we'll retouch on the essentials of optimistic concurrency control and then explore how to implement it using the SqlDataSource.</span></span>

## <a name="a-recap-of-optimistic-concurrency"></a><span data-ttu-id="219c3-117">開放式平行存取的回顧</span><span class="sxs-lookup"><span data-stu-id="219c3-117">A Recap of Optimistic Concurrency</span></span>

<span data-ttu-id="219c3-118">對於允許多個同時使用者編輯或刪除相同資料的 web 應用程式，有可能有一位使用者意外覆寫另一項變更。</span><span class="sxs-lookup"><span data-stu-id="219c3-118">For web applications that allow multiple, simultaneous users to edit or delete the same data, there exists a possibility that one user may accidentally overwrite another s changes.</span></span> <span data-ttu-id="219c3-119">在[執行開放式並行](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-cs.md)存取教學課程中，我提供了下列範例：</span><span class="sxs-lookup"><span data-stu-id="219c3-119">In the [Implementing Optimistic Concurrency](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-cs.md) tutorial I provided the following example:</span></span>

<span data-ttu-id="219c3-120">假設有兩位使用者（Jisun 和 Sam）同時造訪應用程式中的網頁，讓訪客能夠透過 GridView 控制項來更新和刪除產品。</span><span class="sxs-lookup"><span data-stu-id="219c3-120">Imagine that two users, Jisun and Sam, were both visiting a page in an application that allowed visitors to update and delete products through a GridView control.</span></span> <span data-ttu-id="219c3-121">同時按一下 [Chai] 的 [編輯] 按鈕，以在同一時間前後進行。</span><span class="sxs-lookup"><span data-stu-id="219c3-121">Both click the Edit button for Chai around the same time.</span></span> <span data-ttu-id="219c3-122">Jisun 會將產品名稱變更為 Chai 茶，並按一下 [更新] 按鈕。</span><span class="sxs-lookup"><span data-stu-id="219c3-122">Jisun changes the product name to Chai Tea and clicks the Update button.</span></span> <span data-ttu-id="219c3-123">最終結果是傳送至資料庫的 `UPDATE` 語句，它會設定*所有*產品的可更新欄位（即使 Jisun 只更新一個欄位，`ProductName`）。</span><span class="sxs-lookup"><span data-stu-id="219c3-123">The net result is an `UPDATE` statement that is sent to the database, which sets *all* of the product s updateable fields (even though Jisun only updated one field, `ProductName`).</span></span> <span data-ttu-id="219c3-124">在此時間點，資料庫的值為 Chai 茶、類別飲料、供應商外來液體等等。</span><span class="sxs-lookup"><span data-stu-id="219c3-124">At this point in time, the database has the values Chai Tea, the category Beverages, the supplier Exotic Liquids, and so on for this particular product.</span></span> <span data-ttu-id="219c3-125">不過，Sam s 畫面上的 GridView 仍然會在可編輯的 GridView 資料列中，將產品名稱顯示為 Chai。</span><span class="sxs-lookup"><span data-stu-id="219c3-125">However, the GridView on Sam s screen still shows the product name in the editable GridView row as Chai.</span></span> <span data-ttu-id="219c3-126">在 Jisun s 變更之後的幾秒後，Sam 會將類別更新為 Condiments，然後按一下 [更新]。</span><span class="sxs-lookup"><span data-stu-id="219c3-126">A few seconds after Jisun s changes have been committed, Sam updates the category to Condiments and clicks Update.</span></span> <span data-ttu-id="219c3-127">這會導致 `UPDATE` 語句傳送到資料庫，將產品名稱設定為 Chai，`CategoryID` 對應的 Condiments 分類識別碼等等。</span><span class="sxs-lookup"><span data-stu-id="219c3-127">This results in an `UPDATE` statement sent to the database that sets the product name to Chai, the `CategoryID` to the corresponding Condiments category ID, and so on.</span></span> <span data-ttu-id="219c3-128">已覆寫對產品名稱所做的 Jisun 變更。</span><span class="sxs-lookup"><span data-stu-id="219c3-128">Jisun s changes to the product name have been overwritten.</span></span>

<span data-ttu-id="219c3-129">[圖 2] 說明這種互動。</span><span class="sxs-lookup"><span data-stu-id="219c3-129">Figure 2 illustrates this interaction.</span></span>

<span data-ttu-id="219c3-130">[![當兩個使用者同時更新記錄時，有一位使用者變更可能會覆寫其他的](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image2.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="219c3-130">[![When Two Users Simultaneously Update a Record There s Potential for One User s Changes to Overwrite the Other s](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image2.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image1.png)</span></span>

<span data-ttu-id="219c3-131">**圖 2**：當兩個使用者同時更新記錄時，有一位使用者變更的可能性可能會覆寫其他的（[按一下以觀看完整大小的影像](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image2.png)）</span><span class="sxs-lookup"><span data-stu-id="219c3-131">**Figure 2**: When Two Users Simultaneously Update a Record There s Potential for One User s Changes to Overwrite the Other s ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image2.png))</span></span>

<span data-ttu-id="219c3-132">若要防止展開此案例，必須實作為[並行存取控制](http://en.wikipedia.org/wiki/Concurrency_control)的形式。</span><span class="sxs-lookup"><span data-stu-id="219c3-132">To prevent this scenario from unfolding, a form of [concurrency control](http://en.wikipedia.org/wiki/Concurrency_control) must be implemented.</span></span> <span data-ttu-id="219c3-133">[開放式並行](http://en.wikipedia.org/wiki/Optimistic_concurrency_control)存取：本教學課程的重點在於假設，雖然每個階段可能會發生並行衝突，但大部分的情況下都不會發生這類衝突。</span><span class="sxs-lookup"><span data-stu-id="219c3-133">[Optimistic concurrency](http://en.wikipedia.org/wiki/Optimistic_concurrency_control) the focus of this tutorial works on the assumption that while there may be concurrency conflicts every now and then, the vast majority of the time such conflicts won't arise.</span></span> <span data-ttu-id="219c3-134">因此，如果發生衝突，開放式並行存取控制只會通知使用者其變更無法儲存，因為另一個使用者已修改相同的資料。</span><span class="sxs-lookup"><span data-stu-id="219c3-134">Therefore, if a conflict does arise, optimistic concurrency control simply informs the user that their changes can t be saved because another user has modified the same data.</span></span>

> [!NOTE]
> <span data-ttu-id="219c3-135">對於假設會有許多並行衝突或無法容忍這類衝突的應用程式，則可以改用封閉式並行存取控制。</span><span class="sxs-lookup"><span data-stu-id="219c3-135">For applications where it is assumed that there will be many concurrency conflicts or if such conflicts are not tolerable, then pessimistic concurrency control can be used instead.</span></span> <span data-ttu-id="219c3-136">請回頭[執行開放式並行](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-cs.md)存取教學課程，以深入瞭解封閉式並行存取控制。</span><span class="sxs-lookup"><span data-stu-id="219c3-136">Refer back to the [Implementing Optimistic Concurrency](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-cs.md) tutorial for a more thorough discussion on pessimistic concurrency control.</span></span>

<span data-ttu-id="219c3-137">開放式並行存取控制的運作方式是確保更新或刪除的記錄具有與更新或刪除進程啟動時相同的值。</span><span class="sxs-lookup"><span data-stu-id="219c3-137">Optimistic concurrency control works by ensuring that the record being updated or deleted has the same values as it did when the updating or deleting process started.</span></span> <span data-ttu-id="219c3-138">例如，當您在可編輯的 GridView 中按一下 [編輯] 按鈕時，會從資料庫讀取記錄的值，並顯示在文字方塊和其他 Web 控制項中。</span><span class="sxs-lookup"><span data-stu-id="219c3-138">For example, when clicking the Edit button in an editable GridView, the record s values are read from the database and displayed in TextBoxes and other Web controls.</span></span> <span data-ttu-id="219c3-139">這些原始值是由 GridView 儲存。</span><span class="sxs-lookup"><span data-stu-id="219c3-139">These original values are saved by the GridView.</span></span> <span data-ttu-id="219c3-140">之後，當使用者進行變更並按一下 [更新] 按鈕之後，所使用的 `UPDATE` 語句就必須考慮原始值加上新的值，而且只有在使用者開始編輯的原始值與資料庫中仍有的值相同時，才更新基礎資料庫記錄。</span><span class="sxs-lookup"><span data-stu-id="219c3-140">Later, after the user makes her changes and clicks the Update button, the `UPDATE` statement used must take into account the original values plus the new values and only update the underlying database record if the original values that the user started editing are identical to the values still in the database.</span></span> <span data-ttu-id="219c3-141">[圖 3] 描繪了這一系列的事件。</span><span class="sxs-lookup"><span data-stu-id="219c3-141">Figure 3 depicts this sequence of events.</span></span>

<span data-ttu-id="219c3-142">[若要成功更新或刪除 ![，原始值必須等於目前的資料庫值](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image3.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="219c3-142">[![For the Update or Delete to Succeed, the Original Values Must Be Equal to the Current Database Values](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image3.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image3.png)</span></span>

<span data-ttu-id="219c3-143">**圖 3**：若要讓 Update 或 Delete 成功，原始值必須等於目前的資料庫值（[按一下以查看完整大小的影像](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image4.png)）</span><span class="sxs-lookup"><span data-stu-id="219c3-143">**Figure 3**: For the Update or Delete to Succeed, the Original Values Must Be Equal to the Current Database Values ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image4.png))</span></span>

<span data-ttu-id="219c3-144">有各種方法可以執行開放式平行存取（請參閱[Peter A. Bromberg](http://www.eggheadcafe.com/articles/pbrombergresume.asp)的[開放式平行存取邏輯](http://www.eggheadcafe.com/articles/20050719.asp)，以瞭解一些選項）。</span><span class="sxs-lookup"><span data-stu-id="219c3-144">There are various approaches to implementing optimistic concurrency (see [Peter A. Bromberg](http://www.eggheadcafe.com/articles/pbrombergresume.asp)'s [Optimistic Concurrency Updating Logic](http://www.eggheadcafe.com/articles/20050719.asp) for a brief look at a number of options).</span></span> <span data-ttu-id="219c3-145">SqlDataSource 所使用的技術（以及資料存取層中所使用的 ADO.NET 具類型資料集）會增強 `WHERE` 子句，以包含所有原始值的比較。</span><span class="sxs-lookup"><span data-stu-id="219c3-145">The technique used by the SqlDataSource (as well as by the ADO.NET Typed DataSets used in our Data Access Layer) augments the `WHERE` clause to include a comparison of all of the original values.</span></span> <span data-ttu-id="219c3-146">例如，如果目前的資料庫值等於在 GridView 中更新記錄時原先抓取的值，則下列 `UPDATE` 語句會更新產品的名稱和價格。</span><span class="sxs-lookup"><span data-stu-id="219c3-146">The following `UPDATE` statement, for example, updates the name and price of a product only if the current database values are equal to the values that were originally retrieved when updating the record in the GridView.</span></span> <span data-ttu-id="219c3-147">`@ProductName` 和 `@UnitPrice` 參數包含使用者輸入的新值，而 `@original_ProductName` 和 `@original_UnitPrice` 包含在按下 [編輯] 按鈕時，原先載入至 GridView 的值：</span><span class="sxs-lookup"><span data-stu-id="219c3-147">The `@ProductName` and `@UnitPrice` parameters contain the new values entered by the user, whereas `@original_ProductName` and `@original_UnitPrice` contain the values that were originally loaded into the GridView when the Edit button was clicked:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-cs/samples/sample1.sql)]

<span data-ttu-id="219c3-148">如我們在本教學課程中所見，使用 SqlDataSource 來啟用開放式並行存取控制，就像勾選核取方塊一樣簡單。</span><span class="sxs-lookup"><span data-stu-id="219c3-148">As we'll see in this tutorial, enabling optimistic concurrency control with the SqlDataSource is as simple as checking a checkbox.</span></span>

## <a name="step-1-creating-a-sqldatasource-that-supports-optimistic-concurrency"></a><span data-ttu-id="219c3-149">步驟1：建立支援開放式平行存取的 SqlDataSource</span><span class="sxs-lookup"><span data-stu-id="219c3-149">Step 1: Creating a SqlDataSource that Supports Optimistic Concurrency</span></span>

<span data-ttu-id="219c3-150">從 [`SqlDataSource`] 資料夾開啟 [`OptimisticConcurrency.aspx`] 頁面開始。</span><span class="sxs-lookup"><span data-stu-id="219c3-150">Start by opening the `OptimisticConcurrency.aspx` page from the `SqlDataSource` folder.</span></span> <span data-ttu-id="219c3-151">從 [工具箱] 將 [SqlDataSource] 控制項拖曳至設計工具，將其 `ID` 屬性設定為 [`ProductsDataSourceWithOptimisticConcurrency`]。</span><span class="sxs-lookup"><span data-stu-id="219c3-151">Drag a SqlDataSource control from the Toolbox onto the Designer, settings its `ID` property to `ProductsDataSourceWithOptimisticConcurrency`.</span></span> <span data-ttu-id="219c3-152">接下來，按一下控制項 s 智慧標籤中的 [設定資料來源] 連結。</span><span class="sxs-lookup"><span data-stu-id="219c3-152">Next, click on the Configure Data Source link from the control s smart tag.</span></span> <span data-ttu-id="219c3-153">從嚮導的第一個畫面中，選擇使用 `NORTHWINDConnectionString`，然後按 [下一步]。</span><span class="sxs-lookup"><span data-stu-id="219c3-153">From the first screen in the wizard, choose to work with the `NORTHWINDConnectionString` and click Next.</span></span>

<span data-ttu-id="219c3-154">[![選擇使用 NORTHWINDConnectionString](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image4.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image5.png)</span><span class="sxs-lookup"><span data-stu-id="219c3-154">[![Choose to Work with the NORTHWINDConnectionString](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image4.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image5.png)</span></span>

<span data-ttu-id="219c3-155">**圖 4**：選擇使用 `NORTHWINDConnectionString` （[按一下以觀看完整大小的影像](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image6.png)）</span><span class="sxs-lookup"><span data-stu-id="219c3-155">**Figure 4**: Choose to Work with the `NORTHWINDConnectionString` ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image6.png))</span></span>

<span data-ttu-id="219c3-156">在此範例中，我們將新增 GridView，讓使用者編輯 `Products` 資料表。</span><span class="sxs-lookup"><span data-stu-id="219c3-156">For this example we'll be adding a GridView that enables users to edit the `Products` table.</span></span> <span data-ttu-id="219c3-157">因此，從 [設定 Select 語句] 畫面中，選擇下拉式清單中的 [`Products`] 資料表，然後選取 [`ProductID`]、[`ProductName`]、[`UnitPrice`] 和 [`Discontinued`] 資料行，如 [圖 5] 所示。</span><span class="sxs-lookup"><span data-stu-id="219c3-157">Therefore, from the Configure the Select Statement screen, choose the `Products` table from the drop-down list and select the `ProductID`, `ProductName`, `UnitPrice`, and `Discontinued` columns, as shown in Figure 5.</span></span>

<span data-ttu-id="219c3-158">[從 Products 資料表 ![，傳回 ProductID、ProductName、單價和已停止的資料行](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image5.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="219c3-158">[![From the Products Table, Return the ProductID, ProductName, UnitPrice, and Discontinued Columns](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image5.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image7.png)</span></span>

<span data-ttu-id="219c3-159">**圖 5**：從 [`Products`] 資料表中，傳回 [`ProductID`]、[`ProductName`]、[`UnitPrice`] 和 [`Discontinued`] 資料行（[按一下以查看完整大小的影像](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image8.png)）</span><span class="sxs-lookup"><span data-stu-id="219c3-159">**Figure 5**: From the `Products` Table, Return the `ProductID`, `ProductName`, `UnitPrice`, and `Discontinued` Columns ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image8.png))</span></span>

<span data-ttu-id="219c3-160">挑選資料行之後，請按一下 [Advanced] 按鈕以顯示 [Advanced SQL 產生選項] 對話方塊。</span><span class="sxs-lookup"><span data-stu-id="219c3-160">After picking the columns, click the Advanced button to bring up the Advanced SQL Generation Options dialog box.</span></span> <span data-ttu-id="219c3-161">核取 [產生 `INSERT`]、[`UPDATE`] 和 [`DELETE` 語句，並使用開放式平行存取] 核取方塊，然後按一下 [確定] （如需螢幕擷取畫面，請參閱 [圖 1]</span><span class="sxs-lookup"><span data-stu-id="219c3-161">Check the Generate `INSERT`, `UPDATE`, and `DELETE` statements and Use optimistic concurrency checkboxes and click OK (refer back to Figure 1 for a screenshot).</span></span> <span data-ttu-id="219c3-162">按 [下一步]，然後按一下 [完成]，以完成嚮導。</span><span class="sxs-lookup"><span data-stu-id="219c3-162">Complete the wizard by clicking Next, then Finish.</span></span>

<span data-ttu-id="219c3-163">完成 [設定資料來源] 嚮導之後，請花點時間檢查產生的 `DeleteCommand` 並 `UpdateCommand` 屬性和 `DeleteParameters` 和 `UpdateParameters` 集合。</span><span class="sxs-lookup"><span data-stu-id="219c3-163">After completing the Configure Data Source wizard, take a moment to examine the resulting `DeleteCommand` and `UpdateCommand` properties and the `DeleteParameters` and `UpdateParameters` collections.</span></span> <span data-ttu-id="219c3-164">若要這麼做，最簡單的方法是按一下左下角的 [來源] 索引標籤，以查看頁面的宣告式語法。</span><span class="sxs-lookup"><span data-stu-id="219c3-164">The easiest way to do this is to click on the Source tab in the lower left corner to see the page s declarative syntax.</span></span> <span data-ttu-id="219c3-165">您會在這裡找到 `UpdateCommand` 值：</span><span class="sxs-lookup"><span data-stu-id="219c3-165">There you will find an `UpdateCommand` value of:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-cs/samples/sample2.sql)]

<span data-ttu-id="219c3-166">`UpdateParameters` 集合中有七個參數：</span><span class="sxs-lookup"><span data-stu-id="219c3-166">With seven parameters in the `UpdateParameters` collection:</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-with-the-sqldatasource-cs/samples/sample3.aspx)]

<span data-ttu-id="219c3-167">同樣地，`DeleteCommand` 屬性和 `DeleteParameters` 集合看起來應該如下所示：</span><span class="sxs-lookup"><span data-stu-id="219c3-167">Similarly, the `DeleteCommand` property and `DeleteParameters` collection should look like the following:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-cs/samples/sample4.sql)]

[!code-aspx[Main](implementing-optimistic-concurrency-with-the-sqldatasource-cs/samples/sample5.aspx)]

<span data-ttu-id="219c3-168">除了擴充 `UpdateCommand` 的 `WHERE` 子句和 `DeleteCommand` 屬性（以及將額外的參數新增至個別的參數集合）之外，選取 [使用開放式平行存取] 選項也會調整其他兩個屬性：</span><span class="sxs-lookup"><span data-stu-id="219c3-168">In addition to augmenting the `WHERE` clauses of the `UpdateCommand` and `DeleteCommand` properties (and adding the additional parameters to the respective parameter collections), selecting the Use optimistic concurrency option adjusts two other properties:</span></span>

- <span data-ttu-id="219c3-169">將[`ConflictDetection` 屬性](https://msdn.microsoft.com/library/system.web.ui.webcontrols.sqldatasource.conflictdetection.aspx)從 `OverwriteChanges` （預設值）變更為 `CompareAllValues`</span><span class="sxs-lookup"><span data-stu-id="219c3-169">Changes the [`ConflictDetection` property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.sqldatasource.conflictdetection.aspx) from `OverwriteChanges` (the default) to `CompareAllValues`</span></span>
- <span data-ttu-id="219c3-170">將[`OldValuesParameterFormatString` 屬性](https://msdn.microsoft.com/library/system.web.ui.webcontrols.sqldatasource.oldvaluesparameterformatstring.aspx)從 {0} （預設值）變更為原始\_{0}。</span><span class="sxs-lookup"><span data-stu-id="219c3-170">Changes the [`OldValuesParameterFormatString` property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.sqldatasource.oldvaluesparameterformatstring.aspx) from {0} (the default) to original\_{0} .</span></span>

<span data-ttu-id="219c3-171">當資料 Web 控制項叫用 SqlDataSource s `Update()` 或 `Delete()` 方法時，它會傳入原始值。</span><span class="sxs-lookup"><span data-stu-id="219c3-171">When the data Web control invokes the SqlDataSource s `Update()` or `Delete()` method, it passes in the original values.</span></span> <span data-ttu-id="219c3-172">如果 [SqlDataSource s `ConflictDetection`] 屬性設為 [`CompareAllValues`]，則會將這些原始值新增至命令。</span><span class="sxs-lookup"><span data-stu-id="219c3-172">If the SqlDataSource s `ConflictDetection` property is set to `CompareAllValues`, these original values are added to the command.</span></span> <span data-ttu-id="219c3-173">`OldValuesParameterFormatString` 屬性提供用於這些原始值參數的命名模式。</span><span class="sxs-lookup"><span data-stu-id="219c3-173">The `OldValuesParameterFormatString` property provides the naming pattern used for these original value parameters.</span></span> <span data-ttu-id="219c3-174">[設定資料來源] 嚮導會使用原始\_{0} 並在 `DeleteCommand` `UpdateCommand` 中命名每個原始參數，並據以 `UpdateParameters` 和 `DeleteParameters` 集合。</span><span class="sxs-lookup"><span data-stu-id="219c3-174">The Configure Data Source wizard uses original\_{0} and names each original parameter in the `UpdateCommand` and `DeleteCommand` properties and `UpdateParameters` and `DeleteParameters` collections accordingly.</span></span>

> [!NOTE]
> <span data-ttu-id="219c3-175">由於我們不會使用 SqlDataSource 控制項的插入功能，因此請隨意移除 `InsertCommand` 屬性及其 `InsertParameters` 集合。</span><span class="sxs-lookup"><span data-stu-id="219c3-175">Since we re not using the SqlDataSource control s inserting capabilities, feel free to remove the `InsertCommand` property and its `InsertParameters` collection.</span></span>

## <a name="correctly-handlingnullvalues"></a><span data-ttu-id="219c3-176">正確處理`NULL`值</span><span class="sxs-lookup"><span data-stu-id="219c3-176">Correctly Handling`NULL`Values</span></span>

<span data-ttu-id="219c3-177">可惜的是，使用開放式平行存取時，[設定資料來源] wizard 自動產生的增強型 `UPDATE` 和 `DELETE` 語句*不會*使用包含 `NULL` 值的記錄。</span><span class="sxs-lookup"><span data-stu-id="219c3-177">Unfortunately, the augmented `UPDATE` and `DELETE` statements autogenerated by the Configure Data Source wizard when using optimistic concurrency do *not* work with records that contain `NULL` values.</span></span> <span data-ttu-id="219c3-178">若要瞭解原因，請考慮我們的 SqlDataSource `UpdateCommand`：</span><span class="sxs-lookup"><span data-stu-id="219c3-178">To see why, consider our SqlDataSource s `UpdateCommand`:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-cs/samples/sample6.sql)]

<span data-ttu-id="219c3-179">`Products` 資料表中的 `UnitPrice` 資料行可以有 `NULL` 值。</span><span class="sxs-lookup"><span data-stu-id="219c3-179">The `UnitPrice` column in the `Products` table can have `NULL` values.</span></span> <span data-ttu-id="219c3-180">如果特定記錄具有 `UnitPrice`的 `NULL` 值，則 `WHERE` 子句部分 `[UnitPrice] = @original_UnitPrice`*一律*會評估為 false，因為 `NULL = NULL` 一律會傳回 false。</span><span class="sxs-lookup"><span data-stu-id="219c3-180">If a particular record has a `NULL` value for `UnitPrice`, the `WHERE` clause portion `[UnitPrice] = @original_UnitPrice` will *always* evaluate to False because `NULL = NULL` always returns False.</span></span> <span data-ttu-id="219c3-181">因此，包含 `NULL` 值的記錄無法編輯或刪除，因為 `UPDATE` 和 `DELETE` 語句 `WHERE` 子句不會傳回任何要更新或刪除的資料列。</span><span class="sxs-lookup"><span data-stu-id="219c3-181">Therefore, records that contain `NULL` values cannot be edited or deleted, as the `UPDATE` and `DELETE` statements `WHERE` clauses won't return any rows to update or delete.</span></span>

> [!NOTE]
> <span data-ttu-id="219c3-182">此錯誤在2004年6月首次向 Microsoft 回報， [SqlDataSource 會產生不正確的 SQL 語句](https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=93937)，而且據傳排定在下一版的 ASP.NET 中修正。</span><span class="sxs-lookup"><span data-stu-id="219c3-182">This bug was first reported to Microsoft in June of 2004 in [SqlDataSource Generates Incorrect SQL Statements](https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=93937) and is reportedly scheduled to be fixed in the next version of ASP.NET.</span></span>

<span data-ttu-id="219c3-183">若要修正此問題，我們必須針對可以有 `NULL` 值的**所有**資料行，以手動方式更新 `UpdateCommand` 和 `DeleteCommand` 屬性中的 `WHERE` 子句。</span><span class="sxs-lookup"><span data-stu-id="219c3-183">To fix this, we have to manually update the `WHERE` clauses in both the `UpdateCommand` and `DeleteCommand` properties for **all** columns that can have `NULL` values.</span></span> <span data-ttu-id="219c3-184">在 [一般] 中，將 `[ColumnName] = @original_ColumnName` 變更為：</span><span class="sxs-lookup"><span data-stu-id="219c3-184">In general, change `[ColumnName] = @original_ColumnName` to:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-cs/samples/sample7.sql)]

<span data-ttu-id="219c3-185">這項修改可以直接透過宣告式標記、屬性視窗的 UpdateQuery 或 DeleteQuery 選項，或是透過 [設定資料] 中 [指定自訂 SQL 語句或預存程式] 選項的 [更新] 和 [刪除] 索引標籤來進行。來源 wizard。</span><span class="sxs-lookup"><span data-stu-id="219c3-185">This modification can be made directly through the declarative markup, via the UpdateQuery or DeleteQuery options from the Properties window, or through the UPDATE and DELETE tabs in the Specify a custom SQL statement or stored procedure option in the Configure Data Source wizard.</span></span> <span data-ttu-id="219c3-186">同樣地，您必須針對 `UpdateCommand` 和 `DeleteCommand` s `WHERE` 子句中可包含 `NULL` 值的*每個*資料行進行這項修改。</span><span class="sxs-lookup"><span data-stu-id="219c3-186">Again, this modification must be made for *every* column in the `UpdateCommand` and `DeleteCommand` s `WHERE` clause that can contain `NULL` values.</span></span>

<span data-ttu-id="219c3-187">將此套用到我們的範例會產生下列已修改的 `UpdateCommand` 和 `DeleteCommand` 值：</span><span class="sxs-lookup"><span data-stu-id="219c3-187">Applying this to our example results in the following modified `UpdateCommand` and `DeleteCommand` values:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-cs/samples/sample8.sql)]

## <a name="step-2-adding-a-gridview-with-edit-and-delete-options"></a><span data-ttu-id="219c3-188">步驟2：使用 [編輯] 和 [刪除] 選項加入 GridView</span><span class="sxs-lookup"><span data-stu-id="219c3-188">Step 2: Adding a GridView with Edit and Delete Options</span></span>

<span data-ttu-id="219c3-189">當 SqlDataSource 設定為支援開放式平行存取時，剩下的工作就是將資料 Web 控制項加入至利用此並行存取控制的頁面。</span><span class="sxs-lookup"><span data-stu-id="219c3-189">With the SqlDataSource configured to support optimistic concurrency, all that remains is to add a data Web control to the page that utilizes this concurrency control.</span></span> <span data-ttu-id="219c3-190">在本教學課程中，我們將新增可同時提供編輯和刪除功能的 GridView。</span><span class="sxs-lookup"><span data-stu-id="219c3-190">For this tutorial, let s add a GridView that provides both edit and delete functionality.</span></span> <span data-ttu-id="219c3-191">若要完成此動作，請將 GridView 從 [工具箱] 拖曳至設計工具，並將其 `ID` 設定為 [`Products`]。</span><span class="sxs-lookup"><span data-stu-id="219c3-191">To accomplish this, drag a GridView from the Toolbox onto the Designer and set its `ID` to `Products`.</span></span> <span data-ttu-id="219c3-192">從 GridView 的智慧標籤，將它系結至步驟1中新增的 `ProductsDataSourceWithOptimisticConcurrency` SqlDataSource 控制項。</span><span class="sxs-lookup"><span data-stu-id="219c3-192">From the GridView s smart tag, bind it to the `ProductsDataSourceWithOptimisticConcurrency` SqlDataSource control added in Step 1.</span></span> <span data-ttu-id="219c3-193">最後，請核取 [啟用編輯] 和 [啟用刪除] 選項（從智慧標籤）。</span><span class="sxs-lookup"><span data-stu-id="219c3-193">Finally, check the Enable Editing and Enable Deleting options from the smart tag.</span></span>

<span data-ttu-id="219c3-194">[![將 GridView 系結至 SqlDataSource，並啟用編輯和刪除](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image6.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="219c3-194">[![Bind the GridView to the SqlDataSource and Enable Editing and Deleting](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image6.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image9.png)</span></span>

<span data-ttu-id="219c3-195">**圖 6**：將 GridView 系結至 SqlDataSource，並啟用編輯和刪除（[按一下以觀看完整大小的影像](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image10.png)）</span><span class="sxs-lookup"><span data-stu-id="219c3-195">**Figure 6**: Bind the GridView to the SqlDataSource and Enable Editing and Deleting ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image10.png))</span></span>

<span data-ttu-id="219c3-196">加入 GridView 之後，請移除 `ProductID` BoundField、將 `ProductName` BoundField s `HeaderText` 屬性變更為 [Product]，然後更新 `UnitPrice` BoundField，使其 [`HeaderText`] 屬性只是價格，以設定其外觀。</span><span class="sxs-lookup"><span data-stu-id="219c3-196">After adding the GridView, configure its appearance by removing the `ProductID` BoundField, changing the `ProductName` BoundField s `HeaderText` property to Product, and updating the `UnitPrice` BoundField so that its `HeaderText` property is simply Price.</span></span> <span data-ttu-id="219c3-197">在理想的情況下，我們會增強編輯介面，以包含 `ProductName` 值的 RequiredFieldValidator 和 `UnitPrice` 值的 CompareValidator （以確保其格式正確的數值）。</span><span class="sxs-lookup"><span data-stu-id="219c3-197">Ideally, we d enhance the editing interface to include a RequiredFieldValidator for the `ProductName` value and a CompareValidator for the `UnitPrice` value (to ensure it s a properly formatted numeric value).</span></span> <span data-ttu-id="219c3-198">請參閱[自訂資料修改介面](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-cs.md)教學課程，以深入瞭解自訂 GridView 的編輯介面。</span><span class="sxs-lookup"><span data-stu-id="219c3-198">Refer to the [Customizing the Data Modification Interface](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-cs.md) tutorial for a more in-depth look at customizing the GridView s editing interface.</span></span>

> [!NOTE]
> <span data-ttu-id="219c3-199">必須啟用 GridView s view 狀態，因為從 GridView 傳遞至 SqlDataSource 的原始值會以檢視狀態儲存。</span><span class="sxs-lookup"><span data-stu-id="219c3-199">The GridView s view state must be enabled since the original values passed from the GridView to the SqlDataSource are stored in view state.</span></span>

<span data-ttu-id="219c3-200">對 GridView 進行這些修改之後，GridView 和 SqlDataSource 宣告式標記看起來應該如下所示：</span><span class="sxs-lookup"><span data-stu-id="219c3-200">After making these modifications to the GridView, the GridView and SqlDataSource declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-with-the-sqldatasource-cs/samples/sample9.aspx)]

<span data-ttu-id="219c3-201">若要查看作用中的開放式並行存取控制，請開啟兩個瀏覽器視窗，並在兩者中載入 [`OptimisticConcurrency.aspx`] 頁面。</span><span class="sxs-lookup"><span data-stu-id="219c3-201">To see the optimistic concurrency control in action, open two browser windows and load the `OptimisticConcurrency.aspx` page in both.</span></span> <span data-ttu-id="219c3-202">在兩個瀏覽器中，按一下第一個產品的 [編輯] 按鈕。</span><span class="sxs-lookup"><span data-stu-id="219c3-202">Click on the Edit buttons for the first product in both browsers.</span></span> <span data-ttu-id="219c3-203">在一個瀏覽器中，變更產品名稱，然後按一下 [更新]。</span><span class="sxs-lookup"><span data-stu-id="219c3-203">In one browser, change the product name and click Update.</span></span> <span data-ttu-id="219c3-204">瀏覽器將回傳，而 GridView 會回到其預先編輯模式，顯示剛編輯之記錄的新產品名稱。</span><span class="sxs-lookup"><span data-stu-id="219c3-204">The browser will postback and the GridView will return to its pre-editing mode, showing the new product name for the record just edited.</span></span>

<span data-ttu-id="219c3-205">在第二個瀏覽器視窗中，變更價格（但保留產品名稱作為其原始值），然後按一下 [更新]。</span><span class="sxs-lookup"><span data-stu-id="219c3-205">In the second browser window, change the price (but leave the product name as its original value) and click Update.</span></span> <span data-ttu-id="219c3-206">在回傳時，方格會回到其預先編輯模式，但不會記錄價格的變更。</span><span class="sxs-lookup"><span data-stu-id="219c3-206">On postback, the grid returns to its pre-editing mode, but the change to the price is not recorded.</span></span> <span data-ttu-id="219c3-207">第二個瀏覽器顯示的值與具有舊價格的新產品名稱的第一個相同。</span><span class="sxs-lookup"><span data-stu-id="219c3-207">The second browser shows the same value as the first one the new product name with the old price.</span></span> <span data-ttu-id="219c3-208">在第二個瀏覽器視窗中所做的變更已遺失。</span><span class="sxs-lookup"><span data-stu-id="219c3-208">The changes made in the second browser window were lost.</span></span> <span data-ttu-id="219c3-209">此外，由於沒有任何例外狀況或訊息指出發生的平行存取違規，因此變更已遺失，而不是安靜。</span><span class="sxs-lookup"><span data-stu-id="219c3-209">Moreover, the changes were lost rather quietly, as there was no exception or message indicating that a concurrency violation just occurred.</span></span>

<span data-ttu-id="219c3-210">[![第二個瀏覽器視窗中的變更不會以無訊息方式遺失](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image7.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image11.png)</span><span class="sxs-lookup"><span data-stu-id="219c3-210">[![The Changes in the Second Browser Window Were Silently Lost](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image7.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image11.png)</span></span>

<span data-ttu-id="219c3-211">**圖 7**：第二個瀏覽器視窗中的變更以無訊息方式遺失（[按一下以觀看完整大小的影像](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image12.png)）</span><span class="sxs-lookup"><span data-stu-id="219c3-211">**Figure 7**: The Changes in the Second Browser Window Were Silently Lost ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image12.png))</span></span>

<span data-ttu-id="219c3-212">未認可第二個瀏覽器變更的原因是因為 `UPDATE` 語句 s `WHERE` 子句已篩選掉所有記錄，因此不會影響任何資料列。</span><span class="sxs-lookup"><span data-stu-id="219c3-212">The reason why the second browser s changes were not committed was because the `UPDATE` statement s `WHERE` clause filtered out all records and therefore did not affect any rows.</span></span> <span data-ttu-id="219c3-213">讓我們再看一次 `UPDATE` 語句：</span><span class="sxs-lookup"><span data-stu-id="219c3-213">Let s look at the `UPDATE` statement again:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-cs/samples/sample10.sql)]

<span data-ttu-id="219c3-214">當第二個瀏覽器視窗更新記錄時，`WHERE` 子句中指定的原始產品名稱不會與現有的產品名稱相符（因為第一個瀏覽器已變更）。</span><span class="sxs-lookup"><span data-stu-id="219c3-214">When the second browser window updates the record, the original product name specified in the `WHERE` clause doesn t match up with the existing product name (since it was changed by the first browser).</span></span> <span data-ttu-id="219c3-215">因此，語句 `[ProductName] = @original_ProductName` 會傳回 False，而 `UPDATE` 不會影響任何記錄。</span><span class="sxs-lookup"><span data-stu-id="219c3-215">Therefore, the statement `[ProductName] = @original_ProductName` returns False, and the `UPDATE` does not affect any records.</span></span>

> [!NOTE]
> <span data-ttu-id="219c3-216">Delete 的運作方式相同。</span><span class="sxs-lookup"><span data-stu-id="219c3-216">Delete works in the same manner.</span></span> <span data-ttu-id="219c3-217">在開啟兩個瀏覽器視窗的情況下，一開始先編輯指定的產品，然後再儲存其變更。</span><span class="sxs-lookup"><span data-stu-id="219c3-217">With two browser windows open, start by editing a given product with one, and then saving its changes.</span></span> <span data-ttu-id="219c3-218">在單一瀏覽器中儲存變更之後，請按一下另一個中相同產品的 [刪除] 按鈕。</span><span class="sxs-lookup"><span data-stu-id="219c3-218">After saving the changes in the one browser, click the Delete button for the same product in the other.</span></span> <span data-ttu-id="219c3-219">因為原始值不會在 `DELETE` 語句 s `WHERE` 子句中相符，所以刪除會以無訊息模式失敗。</span><span class="sxs-lookup"><span data-stu-id="219c3-219">Since the original values don t match up in the `DELETE` statement s `WHERE` clause, the delete silently fails.</span></span>

<span data-ttu-id="219c3-220">從使用者在第二個瀏覽器視窗中的觀點來看，按一下 [更新] 按鈕之後，方格會回到預先編輯模式，但其變更已遺失。</span><span class="sxs-lookup"><span data-stu-id="219c3-220">From the end user s perspective in the second browser window, after clicking the Update button the grid returns to the pre-editing mode, but their changes were lost.</span></span> <span data-ttu-id="219c3-221">不過，沒有視覺效果的意見反應，他們的變更不會改變。</span><span class="sxs-lookup"><span data-stu-id="219c3-221">However, there s no visual feedback that their changes didn't stick.</span></span> <span data-ttu-id="219c3-222">在理想的情況下，如果使用者的變更會遺失並行違規，我們會通知他們，而且可能會將方格保持在編輯模式。</span><span class="sxs-lookup"><span data-stu-id="219c3-222">Ideally, if a user s changes are lost to a concurrency violation, we d notify them and, perhaps, keep the grid in edit mode.</span></span> <span data-ttu-id="219c3-223">讓我們看看如何完成此動作。</span><span class="sxs-lookup"><span data-stu-id="219c3-223">Let s look at how to accomplish this.</span></span>

## <a name="step-3-determining-when-a-concurrency-violation-has-occurred"></a><span data-ttu-id="219c3-224">步驟3：判斷是否發生並行違規</span><span class="sxs-lookup"><span data-stu-id="219c3-224">Step 3: Determining When a Concurrency Violation Has Occurred</span></span>

<span data-ttu-id="219c3-225">由於並行違規會拒絕所做的變更，因此在發生並行違規時，會很有可能會對使用者發出警示。</span><span class="sxs-lookup"><span data-stu-id="219c3-225">Since a concurrency violation rejects the changes one has made, it would be nice to alert the user when a concurrency violation has occurred.</span></span> <span data-ttu-id="219c3-226">若要警示使用者，請將標籤 Web 控制項新增至名為 `ConcurrencyViolationMessage` 的頁面頂端，其 `Text` 屬性會顯示下列訊息：您已嘗試更新或刪除另一位使用者同時更新的記錄。</span><span class="sxs-lookup"><span data-stu-id="219c3-226">To alert the user, let s add a Label Web control to the top of the page named `ConcurrencyViolationMessage` whose `Text` property displays the following message: You have attempted to update or delete a record that was simultaneously updated by another user.</span></span> <span data-ttu-id="219c3-227">請檢查其他使用者的變更，然後重做您的更新或刪除。</span><span class="sxs-lookup"><span data-stu-id="219c3-227">Please review the other user's changes and then redo your update or delete.</span></span> <span data-ttu-id="219c3-228">將 [標籤控制項] `CssClass` 屬性設定為 [警告]，這是在 `Styles.css` 中定義的 CSS 類別，會以紅色、斜體、粗體和大字型顯示文字。</span><span class="sxs-lookup"><span data-stu-id="219c3-228">Set the Label control s `CssClass` property to Warning, which is a CSS class defined in `Styles.css` that displays text in a red, italic, bold, and large font.</span></span> <span data-ttu-id="219c3-229">最後，將標籤的 `Visible` 和 `EnableViewState` 屬性設定為 [`false`]。</span><span class="sxs-lookup"><span data-stu-id="219c3-229">Finally, set the Label s `Visible` and `EnableViewState` properties to `false`.</span></span> <span data-ttu-id="219c3-230">這會隱藏標籤，但只有那些回傳會明確將其 `Visible` 屬性設為 `true`。</span><span class="sxs-lookup"><span data-stu-id="219c3-230">This will hide the Label except for only those postbacks where we explicitly set its `Visible` property to `true`.</span></span>

<span data-ttu-id="219c3-231">[![將標籤控制項新增至頁面以顯示警告](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image8.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="219c3-231">[![Add a Label Control to the Page to Display the Warning](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image8.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image13.png)</span></span>

<span data-ttu-id="219c3-232">**圖 8**：將標籤控制項新增至頁面以顯示警告（[按一下以查看完整大小的影像](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image14.png)）</span><span class="sxs-lookup"><span data-stu-id="219c3-232">**Figure 8**: Add a Label Control to the Page to Display the Warning ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image14.png))</span></span>

<span data-ttu-id="219c3-233">執行更新或刪除時，GridView 的 `RowUpdated` 和 `RowDeleted` 事件處理常式會在其資料來源控制執行要求的更新或刪除之後引發。</span><span class="sxs-lookup"><span data-stu-id="219c3-233">When performing an update or delete, the GridView s `RowUpdated` and `RowDeleted` event handlers fire after its data source control has performed the requested update or delete.</span></span> <span data-ttu-id="219c3-234">我們可以從這些事件處理常式判斷作業所影響的資料列數目。</span><span class="sxs-lookup"><span data-stu-id="219c3-234">We can determine how many rows were affected by the operation from these event handlers.</span></span> <span data-ttu-id="219c3-235">如果零個數據列受到影響，我們想要顯示 [`ConcurrencyViolationMessage`] 標籤。</span><span class="sxs-lookup"><span data-stu-id="219c3-235">If zero rows were affected, we want to display the `ConcurrencyViolationMessage` Label.</span></span>

<span data-ttu-id="219c3-236">建立 `RowUpdated` 和 `RowDeleted` 事件的事件處理常式，並新增下列程式碼：</span><span class="sxs-lookup"><span data-stu-id="219c3-236">Create an event handler for both the `RowUpdated` and `RowDeleted` events and add the following code:</span></span>

[!code-csharp[Main](implementing-optimistic-concurrency-with-the-sqldatasource-cs/samples/sample11.cs)]

<span data-ttu-id="219c3-237">在這兩個事件處理常式中，我們會檢查 `e.AffectedRows` 屬性，如果它等於0，請將 `ConcurrencyViolationMessage` Label s `Visible` 屬性設定為 `true`。</span><span class="sxs-lookup"><span data-stu-id="219c3-237">In both event handlers we check the `e.AffectedRows` property and, if it equals 0, set the `ConcurrencyViolationMessage` Label s `Visible` property to `true`.</span></span> <span data-ttu-id="219c3-238">在 `RowUpdated` 事件處理常式中，我們也會藉由將 `KeepInEditMode` 屬性設定為 true，指示 GridView 保持編輯模式。</span><span class="sxs-lookup"><span data-stu-id="219c3-238">In the `RowUpdated` event handler, we also instruct the GridView to stay in edit mode by setting the `KeepInEditMode` property to true.</span></span> <span data-ttu-id="219c3-239">在這種情況下，我們需要將資料重新系結到方格，讓其他使用者的資料載入編輯介面中。</span><span class="sxs-lookup"><span data-stu-id="219c3-239">In doing so, we need to rebind the data to the grid so that the other user s data is loaded into the editing interface.</span></span> <span data-ttu-id="219c3-240">這是藉由呼叫 GridView s `DataBind()` 方法來完成。</span><span class="sxs-lookup"><span data-stu-id="219c3-240">This is accomplished by calling the GridView s `DataBind()` method.</span></span>

<span data-ttu-id="219c3-241">如 [圖 9] 所示，在這兩個事件處理常式中，每當發生並行違規時，就會顯示非常明顯的訊息。</span><span class="sxs-lookup"><span data-stu-id="219c3-241">As Figure 9 shows, with these two event handlers, a very noticeable message is displayed whenever a concurrency violation occurs.</span></span>

<span data-ttu-id="219c3-242">[![訊息會在面臨並行違規時顯示](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image9.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="219c3-242">[![A Message is Displayed in the Face of a Concurrency Violation](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image9.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image15.png)</span></span>

<span data-ttu-id="219c3-243">**圖 9**：發生並行違規時，會顯示訊息（[按一下以觀看完整大小的影像](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image16.png)）</span><span class="sxs-lookup"><span data-stu-id="219c3-243">**Figure 9**: A Message is Displayed in the Face of a Concurrency Violation ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-cs/_static/image16.png))</span></span>

## <a name="summary"></a><span data-ttu-id="219c3-244">總結</span><span class="sxs-lookup"><span data-stu-id="219c3-244">Summary</span></span>

<span data-ttu-id="219c3-245">建立多個並行使用者可能會編輯相同資料的 web 應用程式時，請務必考慮並行控制選項。</span><span class="sxs-lookup"><span data-stu-id="219c3-245">When creating a web application where multiple, concurrent users may be editing the same data, it is important to consider concurrency control options.</span></span> <span data-ttu-id="219c3-246">根據預設，ASP.NET 資料 Web 控制項和資料來源控制項不會採用任何並行存取控制。</span><span class="sxs-lookup"><span data-stu-id="219c3-246">By default, the ASP.NET data Web controls and data source controls do not employ any concurrency control.</span></span> <span data-ttu-id="219c3-247">如我們在本教學課程中所見，使用 SqlDataSource 來執行開放式並行存取控制的速度相當快速且簡單。</span><span class="sxs-lookup"><span data-stu-id="219c3-247">As we saw in this tutorial, implementing optimistic concurrency control with the SqlDataSource is relatively quick and easy.</span></span> <span data-ttu-id="219c3-248">SqlDataSource 會處理您將擴充的 `WHERE` 子句加入至自動產生的 `UPDATE` 和 `DELETE` 語句的大部分跑腿活兒，但在處理 `NULL` 值資料行時，有幾個微妙差異，如正確處理 `NULL` 值一節中所述。</span><span class="sxs-lookup"><span data-stu-id="219c3-248">The SqlDataSource handles most of the legwork for your adding augmented `WHERE` clauses to the autogenerated `UPDATE` and `DELETE` statements but there are a few subtleties in handling `NULL` value columns, as discussed in the Correctly Handling `NULL` Values section.</span></span>

<span data-ttu-id="219c3-249">本教學課程將結束我們的 SqlDataSource 檢查。</span><span class="sxs-lookup"><span data-stu-id="219c3-249">This tutorial concludes our examination of the SqlDataSource.</span></span> <span data-ttu-id="219c3-250">其餘的教學課程將會回到使用 ObjectDataSource 和分層架構來處理資料。</span><span class="sxs-lookup"><span data-stu-id="219c3-250">Our remaining tutorials will return to working with data using the ObjectDataSource and tiered architecture.</span></span>

<span data-ttu-id="219c3-251">快樂的程式設計！</span><span class="sxs-lookup"><span data-stu-id="219c3-251">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="219c3-252">關於作者</span><span class="sxs-lookup"><span data-stu-id="219c3-252">About the Author</span></span>

<span data-ttu-id="219c3-253">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，自1998起，有七個 ASP/ASP. NET 書籍和創辦人的[4GuysFromRolla.com](http://www.4guysfromrolla.com)。</span><span class="sxs-lookup"><span data-stu-id="219c3-253">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="219c3-254">Scott 以獨立的顧問、訓練員和作者的身分運作。</span><span class="sxs-lookup"><span data-stu-id="219c3-254">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="219c3-255">他的最新著作是[*在24小時內讓自己的 ASP.NET 2.0*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="219c3-255">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="219c3-256">他可以在mitchell@4GuysFromRolla.com觸達[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="219c3-256">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="219c3-257">或者透過他的 blog，可以在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)找到。</span><span class="sxs-lookup"><span data-stu-id="219c3-257">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="219c3-258">[上一頁](inserting-updating-and-deleting-data-with-the-sqldatasource-cs.md)
> [下一頁](querying-data-with-the-sqldatasource-control-vb.md)</span><span class="sxs-lookup"><span data-stu-id="219c3-258">[Previous](inserting-updating-and-deleting-data-with-the-sqldatasource-cs.md)
[Next](querying-data-with-the-sqldatasource-control-vb.md)</span></span>
