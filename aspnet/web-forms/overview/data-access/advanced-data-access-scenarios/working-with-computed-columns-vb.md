---
uid: web-forms/overview/data-access/advanced-data-access-scenarios/working-with-computed-columns-vb
title: 使用計算資料行（VB） |Microsoft Docs
author: rick-anderson
description: 建立資料庫資料表時，Microsoft SQL Server 可讓您定義計算資料行，其值是從通常 referen 的運算式計算而來。
ms.author: riande
ms.date: 08/03/2007
ms.assetid: 5811b8ff-ed56-40fc-9397-6b69ae09a8f6
msc.legacyurl: /web-forms/overview/data-access/advanced-data-access-scenarios/working-with-computed-columns-vb
msc.type: authoredcontent
ms.openlocfilehash: e425d7363c2cdea6efb0ba51f3fc2b6a5330bf2a
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/28/2019
ms.locfileid: "74603122"
---
# <a name="working-with-computed-columns-vb"></a><span data-ttu-id="f1d31-103">使用計算資料行 (VB)</span><span class="sxs-lookup"><span data-stu-id="f1d31-103">Working with Computed Columns (VB)</span></span>

<span data-ttu-id="f1d31-104">由[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="f1d31-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="f1d31-105">[下載程式代碼](https://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_71_VB.zip)或[下載 PDF](working-with-computed-columns-vb/_static/datatutorial71vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="f1d31-105">[Download Code](https://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_71_VB.zip) or [Download PDF](working-with-computed-columns-vb/_static/datatutorial71vb1.pdf)</span></span>

> <span data-ttu-id="f1d31-106">建立資料庫資料表時，Microsoft SQL Server 可讓您定義計算資料行，其值是從通常參考相同資料庫記錄中其他值的運算式計算而來。</span><span class="sxs-lookup"><span data-stu-id="f1d31-106">When creating a database table, Microsoft SQL Server allows you to define a computed column whose value is calculated from an expression that usually references other values in the same database record.</span></span> <span data-ttu-id="f1d31-107">這類值在資料庫中是唯讀的，這在使用 Tableadapter 時需要特殊的考慮。</span><span class="sxs-lookup"><span data-stu-id="f1d31-107">Such values are read-only at the database, which requires special considerations when working with TableAdapters.</span></span> <span data-ttu-id="f1d31-108">在本教學課程中，我們將學習如何滿足計算資料行所帶來的挑戰。</span><span class="sxs-lookup"><span data-stu-id="f1d31-108">In this tutorial we learn how to meet the challenges posed by computed columns.</span></span>

## <a name="introduction"></a><span data-ttu-id="f1d31-109">簡介</span><span class="sxs-lookup"><span data-stu-id="f1d31-109">Introduction</span></span>

<span data-ttu-id="f1d31-110">Microsoft SQL Server 允許 *[計算資料行](https://msdn.microsoft.com/library/ms191250.aspx)* ，這是其值是從運算式計算而來，且通常會從相同資料表中的其他資料行參考值的資料行。</span><span class="sxs-lookup"><span data-stu-id="f1d31-110">Microsoft SQL Server allows for *[computed columns](https://msdn.microsoft.com/library/ms191250.aspx)*, which are columns whose values are calculated from an expression that usually references the values from other columns in the same table.</span></span> <span data-ttu-id="f1d31-111">例如，時間追蹤資料模型可能會有一個名為 `ServiceLog` 的資料表，其中包含資料行，包括 `ServicePerformed`、`EmployeeID`、`Rate`和 `Duration`等等。</span><span class="sxs-lookup"><span data-stu-id="f1d31-111">As an example, a time tracking data model might have a table named `ServiceLog` with columns including `ServicePerformed`, `EmployeeID`, `Rate`, and `Duration`, among others.</span></span> <span data-ttu-id="f1d31-112">雖然可以透過網頁或其他程式設計介面來計算每個服務專案的應付金額（速率乘以持續時間），但在報告這項資訊的 `ServiceLog` `AmountDue` 資料表中包含資料行，可能會很方便。</span><span class="sxs-lookup"><span data-stu-id="f1d31-112">While the amount due per service item (being the rate multiplied by the duration) could be calculated through a web page or other programmatic interface, it might be handy to include a column in the `ServiceLog` table named `AmountDue` that reported this information.</span></span> <span data-ttu-id="f1d31-113">此資料行可以建立為一般資料行，但每當 `Rate` 或 `Duration` 資料行值變更時，都必須更新。</span><span class="sxs-lookup"><span data-stu-id="f1d31-113">This column could be created as a normal column, but it would need to be updated anytime the `Rate` or `Duration` column values changed.</span></span> <span data-ttu-id="f1d31-114">較好的方法是使用運算式 `Rate * Duration`，讓 `AmountDue` 資料行成為計算資料行。</span><span class="sxs-lookup"><span data-stu-id="f1d31-114">A better approach would be to make the `AmountDue` column a computed column using the expression `Rate * Duration`.</span></span> <span data-ttu-id="f1d31-115">這麼做會導致 SQL Server 在查詢中參考 `AmountDue` 的資料行值時，自動計算該值。</span><span class="sxs-lookup"><span data-stu-id="f1d31-115">Doing so would cause SQL Server to automatically calculate the `AmountDue` column value whenever it was referenced in a query.</span></span>

<span data-ttu-id="f1d31-116">由於計算資料行的值是由運算式決定，因此這類資料行是唯讀的，因此不能在 `INSERT` 或 `UPDATE` 語句中指派值給它們。</span><span class="sxs-lookup"><span data-stu-id="f1d31-116">Since a computed column s value is determined by an expression, such columns are read-only and therefore cannot have values assigned to them in `INSERT` or `UPDATE` statements.</span></span> <span data-ttu-id="f1d31-117">不過，當計算資料行屬於使用臨機操作 SQL 語句之 TableAdapter 的主要查詢時，它們會自動包含在自動產生的 `INSERT` 和 `UPDATE` 語句中。</span><span class="sxs-lookup"><span data-stu-id="f1d31-117">However, when computed columns are part of the main query for a TableAdapter that uses ad-hoc SQL statements, they are automatically included in the auto-generated `INSERT` and `UPDATE` statements.</span></span> <span data-ttu-id="f1d31-118">因此，必須更新 TableAdapter s `INSERT` 和 `UPDATE` 查詢和 `InsertCommand` 和 `UpdateCommand` 屬性，才能移除任何計算資料行的參考。</span><span class="sxs-lookup"><span data-stu-id="f1d31-118">Consequently, the TableAdapter s `INSERT` and `UPDATE` queries and `InsertCommand` and `UpdateCommand` properties must be updated to remove references to any computed columns.</span></span>

<span data-ttu-id="f1d31-119">使用計算資料行搭配使用臨機操作 SQL 語句的 TableAdapter 的一項挑戰，就是在完成 TableAdapter 設定向導時，會自動重新產生 TableAdapter s `INSERT` 和 `UPDATE` 查詢。</span><span class="sxs-lookup"><span data-stu-id="f1d31-119">One challenge of using computed columns with a TableAdapter that uses ad-hoc SQL statements is that the TableAdapter s `INSERT` and `UPDATE` queries are automatically regenerated any time the TableAdapter Configuration wizard is completed.</span></span> <span data-ttu-id="f1d31-120">因此，手動從 `INSERT` 中移除的計算資料行，如果重新執行此嚮導，`UPDATE` 查詢就會再次出現。</span><span class="sxs-lookup"><span data-stu-id="f1d31-120">Therefore, the computed columns manually removed from the `INSERT` and `UPDATE` queries will reappear if the wizard is re-run.</span></span> <span data-ttu-id="f1d31-121">雖然使用預存程式的 Tableadapter 不會受到此肯定脆弱度的影響，但它們在步驟3中會有自己的疑慮。</span><span class="sxs-lookup"><span data-stu-id="f1d31-121">Although TableAdapters that use stored procedures don t suffer from this brittleness, they do have their own quirks that we will address in Step 3.</span></span>

<span data-ttu-id="f1d31-122">在本教學課程中，我們將在 Northwind 資料庫的 `Suppliers` 資料表中加入一個計算資料行，然後建立對應的 TableAdapter 來處理這個資料表及其計算資料行。</span><span class="sxs-lookup"><span data-stu-id="f1d31-122">In this tutorial we will add a computed column to the `Suppliers` table in the Northwind database and then create a corresponding TableAdapter to work with this table and its computed column.</span></span> <span data-ttu-id="f1d31-123">我們會將 TableAdapter 使用預存程式，而不是臨機操作 SQL 語句，因此在使用 TableAdapter 設定向導時，不會遺失我們的自訂專案。</span><span class="sxs-lookup"><span data-stu-id="f1d31-123">We will have our TableAdapter use stored procedures instead of ad-hoc SQL statements so that our customizations aren't lost when the TableAdapter Configuration wizard is used.</span></span>

<span data-ttu-id="f1d31-124">讓我們開始吧！</span><span class="sxs-lookup"><span data-stu-id="f1d31-124">Let s get started!</span></span>

## <a name="step-1-adding-a-computed-column-to-thesupplierstable"></a><span data-ttu-id="f1d31-125">步驟1：將計算資料行加入至`Suppliers`資料表</span><span class="sxs-lookup"><span data-stu-id="f1d31-125">Step 1: Adding a Computed Column to the`Suppliers`Table</span></span>

<span data-ttu-id="f1d31-126">Northwind 資料庫沒有任何計算資料行，因此我們需要自己加入一個。</span><span class="sxs-lookup"><span data-stu-id="f1d31-126">The Northwind database does not have any computed columns so we will need to add one ourselves.</span></span> <span data-ttu-id="f1d31-127">在本教學課程中，我們會將計算的資料行新增至稱為 `FullContactName` 的 `Suppliers` 資料表，以傳回連絡人的名稱、標題和其工作的公司，格式如下： `ContactName` （`ContactTitle`，`CompanyName`）。</span><span class="sxs-lookup"><span data-stu-id="f1d31-127">For this tutorial let s add a computed column to the `Suppliers` table called `FullContactName` that returns the contact s name, title, and the company they work for in the following format: `ContactName` (`ContactTitle`, `CompanyName`).</span></span> <span data-ttu-id="f1d31-128">當顯示供應商的相關資訊時，可能會在報表中使用這個計算資料行。</span><span class="sxs-lookup"><span data-stu-id="f1d31-128">This computed column might be used in reports when displaying information about suppliers.</span></span>

<span data-ttu-id="f1d31-129">一開始先開啟 `Suppliers` 資料表定義，方法是以滑鼠右鍵按一下 伺服器總管中的 `Suppliers` 資料表，然後從內容功能表中選擇 開啟資料表定義。</span><span class="sxs-lookup"><span data-stu-id="f1d31-129">Start by opening the `Suppliers` table definition by right-clicking on the `Suppliers` table in the Server Explorer and choosing Open Table Definition from the context-menu.</span></span> <span data-ttu-id="f1d31-130">這會顯示資料表及其屬性的資料行，例如其資料類型、是否允許 `NULL` s 等等。</span><span class="sxs-lookup"><span data-stu-id="f1d31-130">This will display the columns of the table and their properties, such as their data type, whether they allow `NULL` s, and so forth.</span></span> <span data-ttu-id="f1d31-131">若要加入計算資料行，請先在資料表定義中輸入資料行的名稱。</span><span class="sxs-lookup"><span data-stu-id="f1d31-131">To add a computed column, start by typing in the name of the column into the table definition.</span></span> <span data-ttu-id="f1d31-132">接下來，在資料行屬性視窗的 [計算資料行規格] 區段下，將其運算式輸入 [（公式）] 文字方塊中（請參閱 [圖 1]）。</span><span class="sxs-lookup"><span data-stu-id="f1d31-132">Next, enter its expression into the (Formula) textbox under the Computed Column Specification section in the Column Properties window (see Figure 1).</span></span> <span data-ttu-id="f1d31-133">將計算資料行命名為 `FullContactName` 並使用下列運算式：</span><span class="sxs-lookup"><span data-stu-id="f1d31-133">Name the computed column `FullContactName` and use the following expression:</span></span>

[!code-sql[Main](working-with-computed-columns-vb/samples/sample1.sql)]

<span data-ttu-id="f1d31-134">請注意，您可以使用 `+` 運算子，在 SQL 中串連字號串。</span><span class="sxs-lookup"><span data-stu-id="f1d31-134">Note that strings can be concatenated in SQL using the `+` operator.</span></span> <span data-ttu-id="f1d31-135">`CASE` 語句可以如同傳統程式設計語言中的條件來使用。</span><span class="sxs-lookup"><span data-stu-id="f1d31-135">The `CASE` statement can be used like a conditional in a traditional programming language.</span></span> <span data-ttu-id="f1d31-136">在上述運算式中，可以將 `CASE` 語句視為：如果 `ContactTitle` 不 `NULL`，則會輸出以逗號串連的 `ContactTitle` 值，否則不發出任何內容。</span><span class="sxs-lookup"><span data-stu-id="f1d31-136">In the above expression the `CASE` statement can be read as: If `ContactTitle` is not `NULL` then output the `ContactTitle` value concatenated with a comma, otherwise emit nothing.</span></span> <span data-ttu-id="f1d31-137">如需 `CASE` 語句之實用性的詳細資訊，請參閱[SQL `CASE` 語句的強大功能](http://www.4guysfromrolla.com/webtech/102704-1.shtml)。</span><span class="sxs-lookup"><span data-stu-id="f1d31-137">For more on the usefulness of the `CASE` statement, see [The Power of SQL `CASE` Statements](http://www.4guysfromrolla.com/webtech/102704-1.shtml).</span></span>

> [!NOTE]
> <span data-ttu-id="f1d31-138">我們不會在這裡使用 `CASE` 語句，而是也可以使用 `ISNULL(ContactTitle, '')`。</span><span class="sxs-lookup"><span data-stu-id="f1d31-138">Instead of using a `CASE` statement here, we could have alternatively used `ISNULL(ContactTitle, '')`.</span></span> <span data-ttu-id="f1d31-139">[`ISNULL(checkExpression, replacementValue)`](https://msdn.microsoft.com/library/ms184325.aspx)會傳回非 Null 的*checkExpression* ，否則會傳回*replacementValue*。</span><span class="sxs-lookup"><span data-stu-id="f1d31-139">[`ISNULL(checkExpression, replacementValue)`](https://msdn.microsoft.com/library/ms184325.aspx) returns *checkExpression* if it is non-NULL, otherwise it returns *replacementValue*.</span></span> <span data-ttu-id="f1d31-140">雖然 `ISNULL` 或 `CASE` 會在此實例中工作，但有更複雜的情況，也就是 `ISNULL`無法比對 `CASE` 語句的彈性。</span><span class="sxs-lookup"><span data-stu-id="f1d31-140">While either `ISNULL` or `CASE` will work in this instance, there are more intricate scenarios where the flexibility of the `CASE` statement cannot be matched by `ISNULL`.</span></span>

<span data-ttu-id="f1d31-141">加入這個計算資料行之後，您的畫面看起來應該像 [圖 1] 中的螢幕擷取畫面。</span><span class="sxs-lookup"><span data-stu-id="f1d31-141">After adding this computed column your screen should look like the screen shot in Figure 1.</span></span>

<span data-ttu-id="f1d31-142">[![將名為 FullContactName 的計算資料行新增至供應商資料表](working-with-computed-columns-vb/_static/image2.png)](working-with-computed-columns-vb/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="f1d31-142">[![Add a Computed Column Named FullContactName to the Suppliers Table](working-with-computed-columns-vb/_static/image2.png)](working-with-computed-columns-vb/_static/image1.png)</span></span>

<span data-ttu-id="f1d31-143">**圖 1**：將名為 `FullContactName` 的計算資料行加入至 `Suppliers` 資料表（[按一下以查看完整大小的影像](working-with-computed-columns-vb/_static/image3.png)）</span><span class="sxs-lookup"><span data-stu-id="f1d31-143">**Figure 1**: Add a Computed Column Named `FullContactName` to the `Suppliers` Table ([Click to view full-size image](working-with-computed-columns-vb/_static/image3.png))</span></span>

<span data-ttu-id="f1d31-144">在命名計算資料行並輸入其運算式之後，請按一下工具列中的 [儲存] 圖示、按下 Ctrl + S，或前往 [檔案] 功能表，然後選擇 [儲存 `Suppliers`]，將變更儲存至資料表。</span><span class="sxs-lookup"><span data-stu-id="f1d31-144">After naming the computed column and entering its expression, save the changes to the table by clicking the Save icon in the toolbar, by hitting Ctrl+S, or by going to the File menu and choosing Save `Suppliers`.</span></span>

<span data-ttu-id="f1d31-145">儲存資料表應該會重新整理伺服器總管，包括 `Suppliers` 資料表 s 資料行清單中剛加入的資料行。</span><span class="sxs-lookup"><span data-stu-id="f1d31-145">Saving the table should refresh the Server Explorer, including the just-added column in the `Suppliers` table s column list.</span></span> <span data-ttu-id="f1d31-146">此外，在 [（公式）] 文字方塊中輸入的運算式會自動調整為對等的運算式，以去除不必要的空白字元、將資料行名稱括在方括弧（`[]`），並包含括弧以更明確地顯示作業順序：</span><span class="sxs-lookup"><span data-stu-id="f1d31-146">Furthermore, the expression entered into the (Formula) textbox will automatically adjust to an equivalent expression that strips unnecessary whitespace, surrounds column names with brackets (`[]`), and includes parentheses to more explicitly show the order of operations:</span></span>

[!code-sql[Main](working-with-computed-columns-vb/samples/sample2.sql)]

<span data-ttu-id="f1d31-147">如需 Microsoft SQL Server 中計算資料行的詳細資訊，請參閱[技術檔](https://msdn.microsoft.com/library/ms191250.aspx)。</span><span class="sxs-lookup"><span data-stu-id="f1d31-147">For more information on computed columns in Microsoft SQL Server, refer to the [technical documentation](https://msdn.microsoft.com/library/ms191250.aspx).</span></span> <span data-ttu-id="f1d31-148">另請參閱[如何：指定計算資料行](https://msdn.microsoft.com/library/ms188300.aspx)，以取得建立計算資料行的逐步解說。</span><span class="sxs-lookup"><span data-stu-id="f1d31-148">Also check out the [How to: Specify Computed Columns](https://msdn.microsoft.com/library/ms188300.aspx) for a step-by-step walkthrough of creating computed columns.</span></span>

> [!NOTE]
> <span data-ttu-id="f1d31-149">根據預設，計算資料行不會實際儲存在資料表中，而是在每次查詢中參考它們時重新計算。</span><span class="sxs-lookup"><span data-stu-id="f1d31-149">By default, computed columns are not physically stored in the table but are instead recalculated each time they are referenced in a query.</span></span> <span data-ttu-id="f1d31-150">不過，藉由勾選 [已保存] 核取方塊，您可以指示 SQL Server 實際將計算資料行儲存在資料表中。</span><span class="sxs-lookup"><span data-stu-id="f1d31-150">By checking the Is Persisted checkbox, however, you can instruct SQL Server to physically store the computed column in the table.</span></span> <span data-ttu-id="f1d31-151">這麼做可讓您在計算資料行上建立索引，這樣可以改善在其 `WHERE` 子句中使用計算資料行值之查詢的效能。</span><span class="sxs-lookup"><span data-stu-id="f1d31-151">Doing so allows an index to be created on the computed column, which can improve the performance of queries that use the computed column value in their `WHERE` clauses.</span></span> <span data-ttu-id="f1d31-152">如需詳細資訊，請參閱[在計算資料行上建立索引](https://msdn.microsoft.com/library/ms189292.aspx)。</span><span class="sxs-lookup"><span data-stu-id="f1d31-152">See [Creating Indexes on Computed Columns](https://msdn.microsoft.com/library/ms189292.aspx) for more information.</span></span>

## <a name="step-2-viewing-the-computed-column-s-values"></a><span data-ttu-id="f1d31-153">步驟2：查看計算資料行的值</span><span class="sxs-lookup"><span data-stu-id="f1d31-153">Step 2: Viewing the Computed Column s Values</span></span>

<span data-ttu-id="f1d31-154">開始處理資料存取層之前，讓我們花一分鐘的時間來查看 `FullContactName` 的值。</span><span class="sxs-lookup"><span data-stu-id="f1d31-154">Before we start work on the Data Access Layer, let s take a minute to view the `FullContactName` values.</span></span> <span data-ttu-id="f1d31-155">從 伺服器總管中，以滑鼠右鍵按一下 `Suppliers` 資料表名稱，然後從內容功能表中選擇 新增查詢。</span><span class="sxs-lookup"><span data-stu-id="f1d31-155">From the Server Explorer, right-click on the `Suppliers` table name and choose New Query from the context-menu.</span></span> <span data-ttu-id="f1d31-156">這會顯示一個查詢視窗，提示我們選擇要包含在查詢中的資料表。</span><span class="sxs-lookup"><span data-stu-id="f1d31-156">This will bring up a Query window that prompts us to choose what tables to include in the query.</span></span> <span data-ttu-id="f1d31-157">新增 `Suppliers` 資料表，然後按一下 [關閉]。</span><span class="sxs-lookup"><span data-stu-id="f1d31-157">Add the `Suppliers` table and click Close.</span></span> <span data-ttu-id="f1d31-158">接下來，檢查 [供應商] 資料表中的 `CompanyName`、`ContactName`、`ContactTitle`和 `FullContactName` 資料行。</span><span class="sxs-lookup"><span data-stu-id="f1d31-158">Next, check the `CompanyName`, `ContactName`, `ContactTitle`, and `FullContactName` columns from the Suppliers table.</span></span> <span data-ttu-id="f1d31-159">最後，按一下工具列中的紅色驚嘆號圖示，以執行查詢並查看結果。</span><span class="sxs-lookup"><span data-stu-id="f1d31-159">Finally, click the red exclamation point icon in the Toolbar to execute the query and view the results.</span></span>

<span data-ttu-id="f1d31-160">如 [圖 2] 所示，結果包括 `FullContactName`，其中列出使用 `ContactName` （`ContactTitle`，`CompanyName`）格式的 `CompanyName`、`ContactName`和 `ContactTitle` 資料行。</span><span class="sxs-lookup"><span data-stu-id="f1d31-160">As Figure 2 shows, the results include `FullContactName`, which lists the `CompanyName`, `ContactName`, and `ContactTitle` columns using the format `ContactName` (`ContactTitle`, `CompanyName`) .</span></span>

<span data-ttu-id="f1d31-161">[![FullContactName 使用 [連絡人] 格式（ContactTitle，公司名稱）](working-with-computed-columns-vb/_static/image5.png)](working-with-computed-columns-vb/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="f1d31-161">[![The FullContactName Uses the Format ContactName (ContactTitle, CompanyName)](working-with-computed-columns-vb/_static/image5.png)](working-with-computed-columns-vb/_static/image4.png)</span></span>

<span data-ttu-id="f1d31-162">**圖 2**： `FullContactName` 使用格式 `ContactName` （`ContactTitle`，`CompanyName`）（[按一下以觀看完整大小的影像](working-with-computed-columns-vb/_static/image6.png)）</span><span class="sxs-lookup"><span data-stu-id="f1d31-162">**Figure 2**: The `FullContactName` Uses the Format `ContactName` (`ContactTitle`, `CompanyName`) ([Click to view full-size image](working-with-computed-columns-vb/_static/image6.png))</span></span>

## <a name="step-3-adding-thesupplierstableadapterto-the-data-access-layer"></a><span data-ttu-id="f1d31-163">步驟3：將`SuppliersTableAdapter`新增至資料存取層</span><span class="sxs-lookup"><span data-stu-id="f1d31-163">Step 3: Adding the`SuppliersTableAdapter`to the Data Access Layer</span></span>

<span data-ttu-id="f1d31-164">為了在我們的應用程式中使用供應商資訊，我們必須先在 DAL 中建立 TableAdapter 和 DataTable。</span><span class="sxs-lookup"><span data-stu-id="f1d31-164">In order to work with the supplier information in our application we need to first create a TableAdapter and DataTable in our DAL.</span></span> <span data-ttu-id="f1d31-165">在理想的情況下，您可以使用先前教學課程中所檢查的相同直接步驟來完成這項作業。</span><span class="sxs-lookup"><span data-stu-id="f1d31-165">Ideally, this would be accomplished using the same straightforward steps examined in earlier tutorials.</span></span> <span data-ttu-id="f1d31-166">不過，使用計算資料行引進了一些 wrinkles，可提供討論。</span><span class="sxs-lookup"><span data-stu-id="f1d31-166">However, working with computed columns introduces a few wrinkles that merit discussion.</span></span>

<span data-ttu-id="f1d31-167">如果您使用的 TableAdapter 使用臨機操作 SQL 語句，您可以透過 [TableAdapter 設定向導]，直接在 TableAdapter s 查詢中包含計算資料行。</span><span class="sxs-lookup"><span data-stu-id="f1d31-167">If you are using a TableAdapter that uses ad-hoc SQL statements, you can simply include the computed column in the TableAdapter s main query via the TableAdapter Configuration wizard.</span></span> <span data-ttu-id="f1d31-168">不過，這會自動產生包含計算資料行的 `INSERT` 和 `UPDATE` 語句。</span><span class="sxs-lookup"><span data-stu-id="f1d31-168">This, however, will auto-generate `INSERT` and `UPDATE` statements that include the computed column.</span></span> <span data-ttu-id="f1d31-169">如果您嘗試執行其中一種方法，就無法修改具有訊息的資料行*ColumnName*的 `SqlException`，因為它是計算資料行，或是會擲回 UNION 運算子的結果。</span><span class="sxs-lookup"><span data-stu-id="f1d31-169">If you attempt to execute one of these methods, a `SqlException` with the message The column *ColumnName* cannot be modified because it is either a computed column or is the result of a UNION operator will be thrown.</span></span> <span data-ttu-id="f1d31-170">雖然 `INSERT` 和 `UPDATE` 語句可以透過 TableAdapter s `InsertCommand` 和 `UpdateCommand` 屬性來手動調整，但是每當重新執行 TableAdapter 設定向導時，這些自訂都會遺失。</span><span class="sxs-lookup"><span data-stu-id="f1d31-170">While the `INSERT` and `UPDATE` statement can be manually adjusted through the TableAdapter s `InsertCommand` and `UpdateCommand` properties, these customizations will be lost whenever the TableAdapter Configuration wizard is re-run.</span></span>

<span data-ttu-id="f1d31-171">由於使用臨機操作 SQL 語句的 Tableadapter 肯定脆弱度，因此建議在使用計算資料行時使用預存程式。</span><span class="sxs-lookup"><span data-stu-id="f1d31-171">Due to the brittleness of TableAdapters that use ad-hoc SQL statements, it is recommended that we use stored procedures when working with computed columns.</span></span> <span data-ttu-id="f1d31-172">如果您使用現有的預存程式，只要[針對具類型的資料集 tableadapter 教學課程使用現有的預存程式來](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-vb.md)設定 TableAdapter 即可。</span><span class="sxs-lookup"><span data-stu-id="f1d31-172">If you are using existing stored procedures, simply configure the TableAdapter as discussed in the [Using Existing Stored Procedures for the Typed DataSet s TableAdapters](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-vb.md) tutorial.</span></span> <span data-ttu-id="f1d31-173">不過，如果您有 TableAdapter wizard 為您建立預存程式，則一開始請先從主查詢中省略任何計算資料行，這是很重要的。</span><span class="sxs-lookup"><span data-stu-id="f1d31-173">If you have the TableAdapter wizard create the stored procedures for you, however, it is important to initially omit any computed columns from the main query.</span></span> <span data-ttu-id="f1d31-174">如果您在主要查詢中包含計算資料行，TableAdapter 設定 wizard 會在完成時通知您，它無法建立對應的預存程式。</span><span class="sxs-lookup"><span data-stu-id="f1d31-174">If you include a computed column in the main query, the TableAdapter Configuration wizard will inform you, upon completion, that it cannot create the corresponding stored procedures.</span></span> <span data-ttu-id="f1d31-175">簡言之，我們必須一開始使用計算資料行免費的主要查詢來設定 TableAdapter，然後手動更新對應的預存程式和 TableAdapter `SelectCommand` 以包含計算資料行。</span><span class="sxs-lookup"><span data-stu-id="f1d31-175">In short, we need to initially configure the TableAdapter using a computed column-free main query and then manually update the corresponding stored procedure and the TableAdapter s `SelectCommand` to include the computed column.</span></span> <span data-ttu-id="f1d31-176">此方法類似于將[TableAdapter 更新為使用](updating-the-tableadapter-to-use-joins-vb.md)`JOIN`*s*教學課程中所使用的方法。</span><span class="sxs-lookup"><span data-stu-id="f1d31-176">This approach is similar to the one used in the [Updating the TableAdapter to Use](updating-the-tableadapter-to-use-joins-vb.md)`JOIN`*s* tutorial.</span></span>

<span data-ttu-id="f1d31-177">在本教學課程中，讓我們新增新的 TableAdapter，並讓它自動為我們建立預存程式。</span><span class="sxs-lookup"><span data-stu-id="f1d31-177">For this tutorial, let s add a new TableAdapter and have it automatically create the stored procedures for us.</span></span> <span data-ttu-id="f1d31-178">因此，我們必須一開始就從主查詢中省略 `FullContactName` 計算資料行。</span><span class="sxs-lookup"><span data-stu-id="f1d31-178">Consequently, we will need to initially omit the `FullContactName` computed column from the main query.</span></span>

<span data-ttu-id="f1d31-179">從開啟 `~/App_Code/DAL` 資料夾中的 `NorthwindWithSprocs` 資料集開始。</span><span class="sxs-lookup"><span data-stu-id="f1d31-179">Start by opening the `NorthwindWithSprocs` DataSet in the `~/App_Code/DAL` folder.</span></span> <span data-ttu-id="f1d31-180">在設計工具中按一下滑鼠右鍵，然後從內容功能表中，加入宣告新的 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="f1d31-180">Right-click in the Designer and, from the context-menu, choose to add a new TableAdapter.</span></span> <span data-ttu-id="f1d31-181">這會啟動 [TableAdapter 設定向導]。</span><span class="sxs-lookup"><span data-stu-id="f1d31-181">This will launch the TableAdapter Configuration wizard.</span></span> <span data-ttu-id="f1d31-182">指定要從中查詢資料的資料庫（從 `Web.config``NORTHWNDConnectionString`），然後按 [下一步]。</span><span class="sxs-lookup"><span data-stu-id="f1d31-182">Specify the database to query data from (`NORTHWNDConnectionString` from `Web.config`) and click Next.</span></span> <span data-ttu-id="f1d31-183">由於我們尚未建立任何用來查詢或修改 `Suppliers` 資料表的預存程式，因此請選取 [建立新的預存程式] 選項，讓 wizard 為我們建立，然後按 [下一步]。</span><span class="sxs-lookup"><span data-stu-id="f1d31-183">Since we have not yet created any stored procedures for querying or modifying the `Suppliers` table, select the Create new stored procedures option so that the wizard will create them for us and click Next.</span></span>

<span data-ttu-id="f1d31-184">[![選擇 [建立新的預存程式] 選項](working-with-computed-columns-vb/_static/image8.png)](working-with-computed-columns-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="f1d31-184">[![Choose the Create new stored procedures Option](working-with-computed-columns-vb/_static/image8.png)](working-with-computed-columns-vb/_static/image7.png)</span></span>

<span data-ttu-id="f1d31-185">**圖 3**：選擇 [建立新的預存程式] 選項（[按一下以查看完整大小的影像](working-with-computed-columns-vb/_static/image9.png)）</span><span class="sxs-lookup"><span data-stu-id="f1d31-185">**Figure 3**: Choose the Create new stored procedures Option ([Click to view full-size image](working-with-computed-columns-vb/_static/image9.png))</span></span>

<span data-ttu-id="f1d31-186">後續步驟會提示我們進行主查詢。</span><span class="sxs-lookup"><span data-stu-id="f1d31-186">The subsequent step prompts us for the main query.</span></span> <span data-ttu-id="f1d31-187">輸入下列查詢，以傳回每個供應商的 `SupplierID`、`CompanyName`、`ContactName`和 `ContactTitle` 資料行。</span><span class="sxs-lookup"><span data-stu-id="f1d31-187">Enter the following query, which returns the `SupplierID`, `CompanyName`, `ContactName`, and `ContactTitle` columns for each supplier.</span></span> <span data-ttu-id="f1d31-188">請注意，此查詢特意省略了計算資料行（`FullContactName`）;我們將會更新對應的預存程式，以便在步驟4中包含此資料行。</span><span class="sxs-lookup"><span data-stu-id="f1d31-188">Note that this query purposefully omits the computed column (`FullContactName`); we will update the corresponding stored procedure to include this column in Step 4.</span></span>

[!code-sql[Main](working-with-computed-columns-vb/samples/sample3.sql)]

<span data-ttu-id="f1d31-189">輸入主要查詢並按 [下一步] 之後，嚮導可讓我們命名所要產生的四個預存程式。</span><span class="sxs-lookup"><span data-stu-id="f1d31-189">After entering the main query and clicking Next, the wizard allows us to name the four stored procedures it will generate.</span></span> <span data-ttu-id="f1d31-190">將這些預存程式命名 `Suppliers_Select`、`Suppliers_Insert`、`Suppliers_Update`和 `Suppliers_Delete`，如 [圖 4] 所示。</span><span class="sxs-lookup"><span data-stu-id="f1d31-190">Name these stored procedures `Suppliers_Select`, `Suppliers_Insert`, `Suppliers_Update`, and `Suppliers_Delete`, as Figure 4 illustrates.</span></span>

<span data-ttu-id="f1d31-191">[![自訂自動產生之預存程式的名稱](working-with-computed-columns-vb/_static/image11.png)](working-with-computed-columns-vb/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="f1d31-191">[![Customize the Names of the Auto-Generated Stored Procedures](working-with-computed-columns-vb/_static/image11.png)](working-with-computed-columns-vb/_static/image10.png)</span></span>

<span data-ttu-id="f1d31-192">**圖 4**：自訂自動產生的預存程式名稱（[按一下以查看完整大小的影像](working-with-computed-columns-vb/_static/image12.png)）</span><span class="sxs-lookup"><span data-stu-id="f1d31-192">**Figure 4**: Customize the Names of the Auto-Generated Stored Procedures ([Click to view full-size image](working-with-computed-columns-vb/_static/image12.png))</span></span>

<span data-ttu-id="f1d31-193">下一個 [wizard] 步驟可讓我們命名 TableAdapter s 方法，並指定用來存取和更新資料的模式。</span><span class="sxs-lookup"><span data-stu-id="f1d31-193">The next wizard step allows us to name the TableAdapter s methods and specify the patterns used to access and update data.</span></span> <span data-ttu-id="f1d31-194">將這三個核取方塊保持核取狀態，但將 `GetData` 方法重新命名為 `GetSuppliers`。</span><span class="sxs-lookup"><span data-stu-id="f1d31-194">Leave all three checkboxes checked, but rename the `GetData` method to `GetSuppliers`.</span></span> <span data-ttu-id="f1d31-195">按一下 [完成] 以完成精靈。</span><span class="sxs-lookup"><span data-stu-id="f1d31-195">Click Finish to complete the wizard.</span></span>

<span data-ttu-id="f1d31-196">[![將 GetSuppliers 方法重新命名為](working-with-computed-columns-vb/_static/image14.png)](working-with-computed-columns-vb/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="f1d31-196">[![Rename the GetData Method to GetSuppliers](working-with-computed-columns-vb/_static/image14.png)](working-with-computed-columns-vb/_static/image13.png)</span></span>

<span data-ttu-id="f1d31-197">**圖 5**：將 `GetData` 方法重新命名為 `GetSuppliers` （[按一下以查看完整大小的影像](working-with-computed-columns-vb/_static/image15.png)）</span><span class="sxs-lookup"><span data-stu-id="f1d31-197">**Figure 5**: Rename the `GetData` Method to `GetSuppliers` ([Click to view full-size image](working-with-computed-columns-vb/_static/image15.png))</span></span>

<span data-ttu-id="f1d31-198">按一下 [完成] 之後，嚮導會建立四個預存程式，並將 TableAdapter 和對應的 DataTable 加入至具類型的資料集。</span><span class="sxs-lookup"><span data-stu-id="f1d31-198">Upon clicking Finish, the wizard will create the four stored procedures and add the TableAdapter and corresponding DataTable to the Typed DataSet.</span></span>

## <a name="step-4-including-the-computed-column-in-the-tableadapter-s-main-query"></a><span data-ttu-id="f1d31-199">步驟4：在 TableAdapter s 主查詢中包含計算資料行</span><span class="sxs-lookup"><span data-stu-id="f1d31-199">Step 4: Including the Computed Column in the TableAdapter s Main Query</span></span>

<span data-ttu-id="f1d31-200">我們現在需要更新在步驟3中建立的 TableAdapter 和 DataTable，以包含 `FullContactName` 計算資料行。</span><span class="sxs-lookup"><span data-stu-id="f1d31-200">We now need to update the TableAdapter and DataTable created in Step 3 to include the `FullContactName` computed column.</span></span> <span data-ttu-id="f1d31-201">這包含兩個步驟：</span><span class="sxs-lookup"><span data-stu-id="f1d31-201">This involves two steps:</span></span>

1. <span data-ttu-id="f1d31-202">更新 `Suppliers_Select` 預存程式以傳回 `FullContactName` 的計算資料行，以及</span><span class="sxs-lookup"><span data-stu-id="f1d31-202">Updating the `Suppliers_Select` stored procedure to return the `FullContactName` computed column, and</span></span>
2. <span data-ttu-id="f1d31-203">更新 DataTable 以包含對應的 `FullContactName` 資料行。</span><span class="sxs-lookup"><span data-stu-id="f1d31-203">Updating the DataTable to include a corresponding `FullContactName` column.</span></span>

<span data-ttu-id="f1d31-204">首先，流覽至伺服器總管並向下切入至 [預存程式] 資料夾。</span><span class="sxs-lookup"><span data-stu-id="f1d31-204">Start by navigating to the Server Explorer and drilling down into the Stored Procedures folder.</span></span> <span data-ttu-id="f1d31-205">開啟 `Suppliers_Select` 預存程式，並更新 `SELECT` 查詢，以包含 `FullContactName` 計算資料行：</span><span class="sxs-lookup"><span data-stu-id="f1d31-205">Open the `Suppliers_Select` stored procedure and update the `SELECT` query to include the `FullContactName` computed column:</span></span>

[!code-sql[Main](working-with-computed-columns-vb/samples/sample4.sql)]

<span data-ttu-id="f1d31-206">按一下工具列中的 [儲存] 圖示、按下 Ctrl + S，或從 [檔案] 功能表選擇 [儲存 `Suppliers_Select`] 選項，將變更儲存至預存程式。</span><span class="sxs-lookup"><span data-stu-id="f1d31-206">Save the changes to the stored procedure by clicking the Save icon in the Toolbar, by hitting Ctrl+S, or by choosing the Save `Suppliers_Select` option from the File menu.</span></span>

<span data-ttu-id="f1d31-207">接下來，返回 DataSet 設計工具，以滑鼠右鍵按一下 `SuppliersTableAdapter`，然後從內容功能表中選擇 設定。</span><span class="sxs-lookup"><span data-stu-id="f1d31-207">Next, return to the DataSet Designer, right-click on the `SuppliersTableAdapter`, and choose Configure from the context-menu.</span></span> <span data-ttu-id="f1d31-208">請注意，[`Suppliers_Select`] 資料行現在會在其資料行集合中包含 [`FullContactName`] 資料行。</span><span class="sxs-lookup"><span data-stu-id="f1d31-208">Note that the `Suppliers_Select` column now includes the `FullContactName` column in its Data Columns collection.</span></span>

<span data-ttu-id="f1d31-209">[![執行 TableAdapter s 設定向導來更新 DataTable 的資料行](working-with-computed-columns-vb/_static/image17.png)](working-with-computed-columns-vb/_static/image16.png)</span><span class="sxs-lookup"><span data-stu-id="f1d31-209">[![Run the TableAdapter s Configuration Wizard to Update the DataTable s Columns](working-with-computed-columns-vb/_static/image17.png)](working-with-computed-columns-vb/_static/image16.png)</span></span>

<span data-ttu-id="f1d31-210">**圖 6**：執行 TableAdapter s 設定向導來更新 DataTable 的資料行（[按一下以查看完整大小的影像](working-with-computed-columns-vb/_static/image18.png)）</span><span class="sxs-lookup"><span data-stu-id="f1d31-210">**Figure 6**: Run the TableAdapter s Configuration Wizard to Update the DataTable s Columns ([Click to view full-size image](working-with-computed-columns-vb/_static/image18.png))</span></span>

<span data-ttu-id="f1d31-211">按一下 [完成] 以完成精靈。</span><span class="sxs-lookup"><span data-stu-id="f1d31-211">Click Finish to complete the wizard.</span></span> <span data-ttu-id="f1d31-212">這會自動將對應的資料行新增至 `SuppliersDataTable`。</span><span class="sxs-lookup"><span data-stu-id="f1d31-212">This will automatically add a corresponding column to the `SuppliersDataTable`.</span></span> <span data-ttu-id="f1d31-213">TableAdapter wizard 非常聰明，可以偵測 `FullContactName` 的資料行是計算資料行，因此是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="f1d31-213">The TableAdapter wizard is smart enough to detect that the `FullContactName` column is a computed column and therefore read-only.</span></span> <span data-ttu-id="f1d31-214">因此，它會將資料行的 `ReadOnly` 屬性設定為 `true`。</span><span class="sxs-lookup"><span data-stu-id="f1d31-214">Consequently, it sets the column s `ReadOnly` property to `true`.</span></span> <span data-ttu-id="f1d31-215">若要確認這一點，請從 `SuppliersDataTable` 中選取資料行，然後移至屬性視窗（請參閱 [圖 7]）。</span><span class="sxs-lookup"><span data-stu-id="f1d31-215">To verify this, select the column from the `SuppliersDataTable` and then go to the Properties window (see Figure 7).</span></span> <span data-ttu-id="f1d31-216">請注意，`FullContactName` 資料行 `DataType` 和 `MaxLength` 屬性也會據此進行設定。</span><span class="sxs-lookup"><span data-stu-id="f1d31-216">Note that the `FullContactName` column s `DataType` and `MaxLength` properties are also set accordingly.</span></span>

<span data-ttu-id="f1d31-217">[![FullContactName 資料行標示為唯讀](working-with-computed-columns-vb/_static/image20.png)](working-with-computed-columns-vb/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="f1d31-217">[![The FullContactName Column is Marked as Read-Only](working-with-computed-columns-vb/_static/image20.png)](working-with-computed-columns-vb/_static/image19.png)</span></span>

<span data-ttu-id="f1d31-218">**圖 7**： `FullContactName` 資料行標示為唯讀（[按一下以查看完整大小的影像](working-with-computed-columns-vb/_static/image21.png)）</span><span class="sxs-lookup"><span data-stu-id="f1d31-218">**Figure 7**: The `FullContactName` Column is Marked as Read-Only ([Click to view full-size image](working-with-computed-columns-vb/_static/image21.png))</span></span>

## <a name="step-5-adding-agetsupplierbysupplieridmethod-to-the-tableadapter"></a><span data-ttu-id="f1d31-219">步驟5：將`GetSupplierBySupplierID`方法加入至 TableAdapter</span><span class="sxs-lookup"><span data-stu-id="f1d31-219">Step 5: Adding a`GetSupplierBySupplierID`Method to the TableAdapter</span></span>

<span data-ttu-id="f1d31-220">在本教學課程中，我們將建立 ASP.NET 網頁，以在可更新的方格中顯示供應商。</span><span class="sxs-lookup"><span data-stu-id="f1d31-220">For this tutorial we will create an ASP.NET page that displays the suppliers in an updateable grid.</span></span> <span data-ttu-id="f1d31-221">在過去的教學課程中，我們已更新來自商務邏輯層的一筆記錄，方法是從 DAL 將該特定記錄抓取為強型別 DataTable，更新其屬性，然後將更新的 DataTable 傳送回 DAL 以將變更傳播至資料庫。</span><span class="sxs-lookup"><span data-stu-id="f1d31-221">In past tutorials we have updated a single record from the Business Logic Layer by retrieving that particular record from the DAL as a strongly-typed DataTable, updating its properties, and then sending the updated DataTable back to the DAL to propagate the changes to the database.</span></span> <span data-ttu-id="f1d31-222">若要完成第一個步驟-從 DAL 中抓取要更新的記錄，我們必須先將 `GetSupplierBySupplierID(supplierID)` 方法新增至 DAL。</span><span class="sxs-lookup"><span data-stu-id="f1d31-222">To accomplish this first step - retrieving the record being updated from the DAL - we need to first add a `GetSupplierBySupplierID(supplierID)` method to the DAL.</span></span>

<span data-ttu-id="f1d31-223">以滑鼠右鍵按一下資料集設計中的 `SuppliersTableAdapter`，然後從內容功能表中選擇 加入查詢 選項。</span><span class="sxs-lookup"><span data-stu-id="f1d31-223">Right-click on the `SuppliersTableAdapter` in the DataSet Design and choose the Add Query option from the context-menu.</span></span> <span data-ttu-id="f1d31-224">如同我們在步驟3中所做的，請選取 [建立新的預存程式] 選項，讓 wizard 為我們產生新的預存程式（請參閱 [圖 3]，以取得此 wizard 步驟的螢幕擷取畫面）。</span><span class="sxs-lookup"><span data-stu-id="f1d31-224">As we did in Step 3, let the wizard generate a new stored procedure for us by selecting the Create new stored procedure option (refer back to Figure 3 for a screenshot of this wizard step).</span></span> <span data-ttu-id="f1d31-225">由於這個方法會傳回具有多個資料行的記錄，因此，請指出我們想要使用 SQL 查詢，這是傳回資料列的 SELECT，然後按 [下一步]。</span><span class="sxs-lookup"><span data-stu-id="f1d31-225">Since this method will return a record with multiple columns, indicate that we want to use a SQL query that is a SELECT which returns rows and click Next.</span></span>

<span data-ttu-id="f1d31-226">[![選擇要傳回資料列的 SELECT 選項](working-with-computed-columns-vb/_static/image23.png)](working-with-computed-columns-vb/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="f1d31-226">[![Choose the SELECT which returns rows Option](working-with-computed-columns-vb/_static/image23.png)](working-with-computed-columns-vb/_static/image22.png)</span></span>

<span data-ttu-id="f1d31-227">**圖 8**：選擇 [選擇傳回資料列] 選項（[按一下以查看完整大小的影像](working-with-computed-columns-vb/_static/image24.png)）</span><span class="sxs-lookup"><span data-stu-id="f1d31-227">**Figure 8**: Choose the SELECT which returns rows Option ([Click to view full-size image](working-with-computed-columns-vb/_static/image24.png))</span></span>

<span data-ttu-id="f1d31-228">後續步驟會提示我們輸入此方法所使用的查詢。</span><span class="sxs-lookup"><span data-stu-id="f1d31-228">The subsequent step prompts us for the query to use for this method.</span></span> <span data-ttu-id="f1d31-229">輸入下列程式，這會傳回與主要查詢相同的資料欄位，但針對特定供應商。</span><span class="sxs-lookup"><span data-stu-id="f1d31-229">Enter the following, which returns the same data fields as the main query but for a particular supplier.</span></span>

[!code-sql[Main](working-with-computed-columns-vb/samples/sample5.sql)]

<span data-ttu-id="f1d31-230">下一個畫面會要求我們將自動產生的預存程式命名為。</span><span class="sxs-lookup"><span data-stu-id="f1d31-230">The next screen asks us to name the stored procedure that will be auto-generated.</span></span> <span data-ttu-id="f1d31-231">將此預存程式命名為 `Suppliers_SelectBySupplierID` 然後按 [下一步]。</span><span class="sxs-lookup"><span data-stu-id="f1d31-231">Name this stored procedure `Suppliers_SelectBySupplierID` and click Next.</span></span>

<span data-ttu-id="f1d31-232">[![為預存程式命名 Suppliers_SelectBySupplierID](working-with-computed-columns-vb/_static/image26.png)](working-with-computed-columns-vb/_static/image25.png)</span><span class="sxs-lookup"><span data-stu-id="f1d31-232">[![Name the Stored Procedure Suppliers_SelectBySupplierID](working-with-computed-columns-vb/_static/image26.png)](working-with-computed-columns-vb/_static/image25.png)</span></span>

<span data-ttu-id="f1d31-233">**圖 9**：將預存程式命名 `Suppliers_SelectBySupplierID` （[按一下以查看完整大小的影像](working-with-computed-columns-vb/_static/image27.png)）</span><span class="sxs-lookup"><span data-stu-id="f1d31-233">**Figure 9**: Name the Stored Procedure `Suppliers_SelectBySupplierID` ([Click to view full-size image](working-with-computed-columns-vb/_static/image27.png))</span></span>

<span data-ttu-id="f1d31-234">最後，嚮導會提示我們輸入要用於 TableAdapter 的資料存取模式和方法名稱。</span><span class="sxs-lookup"><span data-stu-id="f1d31-234">Lastly, the wizard prompts us for the data access patterns and method names to use for the TableAdapter.</span></span> <span data-ttu-id="f1d31-235">勾選這兩個核取方塊，但將 `FillBy` 和 `GetDataBy` 方法分別重新命名為 `FillBySupplierID` 和 `GetSupplierBySupplierID`。</span><span class="sxs-lookup"><span data-stu-id="f1d31-235">Leave both checkboxes checked, but rename the `FillBy` and `GetDataBy` methods to `FillBySupplierID` and `GetSupplierBySupplierID`, respectively.</span></span>

<span data-ttu-id="f1d31-236">[![命名 TableAdapter 方法 FillBySupplierID 和 GetSupplierBySupplierID](working-with-computed-columns-vb/_static/image29.png)](working-with-computed-columns-vb/_static/image28.png)</span><span class="sxs-lookup"><span data-stu-id="f1d31-236">[![Name the TableAdapter Methods FillBySupplierID and GetSupplierBySupplierID](working-with-computed-columns-vb/_static/image29.png)](working-with-computed-columns-vb/_static/image28.png)</span></span>

<span data-ttu-id="f1d31-237">**圖 10**：將 TableAdapter 方法命名 `FillBySupplierID` 並 `GetSupplierBySupplierID` （[按一下以查看完整大小的影像](working-with-computed-columns-vb/_static/image30.png)）</span><span class="sxs-lookup"><span data-stu-id="f1d31-237">**Figure 10**: Name the TableAdapter Methods `FillBySupplierID` and `GetSupplierBySupplierID` ([Click to view full-size image](working-with-computed-columns-vb/_static/image30.png))</span></span>

<span data-ttu-id="f1d31-238">按一下 [完成] 以完成精靈。</span><span class="sxs-lookup"><span data-stu-id="f1d31-238">Click Finish to complete the wizard.</span></span>

## <a name="step-6-creating-the-business-logic-layer"></a><span data-ttu-id="f1d31-239">步驟6：建立商務邏輯層</span><span class="sxs-lookup"><span data-stu-id="f1d31-239">Step 6: Creating the Business Logic Layer</span></span>

<span data-ttu-id="f1d31-240">在我們建立使用步驟1中所建立之計算資料行的 ASP.NET 網頁之前，我們必須先在 BLL 中新增對應的方法。</span><span class="sxs-lookup"><span data-stu-id="f1d31-240">Before we create an ASP.NET page that uses the computed column created in Step 1, we first need to add the corresponding methods in the BLL.</span></span> <span data-ttu-id="f1d31-241">我們將在步驟7中建立的 ASP.NET 網頁，可讓使用者查看和編輯供應商。</span><span class="sxs-lookup"><span data-stu-id="f1d31-241">Our ASP.NET page, which we will create in Step 7, will allow users to view and edit suppliers.</span></span> <span data-ttu-id="f1d31-242">因此，我們需要 BLL 至少提供一種方法來取得所有供應商，以及另一種方式來更新特定供應商。</span><span class="sxs-lookup"><span data-stu-id="f1d31-242">Therefore, we need our BLL to provide, at minimum, a method to get all of the suppliers and another to update a particular supplier.</span></span>

<span data-ttu-id="f1d31-243">在 `~/App_Code/BLL` 資料夾中建立名為 `SuppliersBLLWithSprocs` 的新類別檔案，並新增下列程式碼：</span><span class="sxs-lookup"><span data-stu-id="f1d31-243">Create a new class file named `SuppliersBLLWithSprocs` in the `~/App_Code/BLL` folder and add the following code:</span></span>

[!code-vb[Main](working-with-computed-columns-vb/samples/sample6.vb)]

<span data-ttu-id="f1d31-244">就像其他 BLL 類別一樣，`SuppliersBLLWithSprocs` 具有 `Protected` `Adapter` 屬性，它會傳回 `SuppliersTableAdapter` 類別的實例，以及兩個 `Public` 方法： `GetSuppliers` 和 `UpdateSupplier`。</span><span class="sxs-lookup"><span data-stu-id="f1d31-244">Like the other BLL classes, `SuppliersBLLWithSprocs` has a `Protected` `Adapter` property that returns an instance of the `SuppliersTableAdapter` class along with two `Public` methods: `GetSuppliers` and `UpdateSupplier`.</span></span> <span data-ttu-id="f1d31-245">`GetSuppliers` 方法會呼叫並傳回資料存取層中對應 `GetSupplier` 方法所傳回的 `SuppliersDataTable`。</span><span class="sxs-lookup"><span data-stu-id="f1d31-245">The `GetSuppliers` method calls and returns the `SuppliersDataTable` returned by the corresponding `GetSupplier` method in the Data Access Layer.</span></span> <span data-ttu-id="f1d31-246">`UpdateSupplier` 方法會透過呼叫 DAL 的 `GetSupplierBySupplierID(supplierID)` 方法，來抓取要更新之特定供應商的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="f1d31-246">The `UpdateSupplier` method retrieves information about the particular supplier being updated via a call to the DAL s `GetSupplierBySupplierID(supplierID)` method.</span></span> <span data-ttu-id="f1d31-247">然後，它會更新 `CategoryName`、`ContactName`和 `ContactTitle` 屬性，並藉由呼叫資料存取層的 `Update` 方法（傳入已修改的 `SuppliersRow` 物件）來認可資料庫的這些變更。</span><span class="sxs-lookup"><span data-stu-id="f1d31-247">It then updates the `CategoryName`, `ContactName`, and `ContactTitle` properties and commits these changes to the database by calling the Data Access Layer s `Update` method, passing in the modified `SuppliersRow` object.</span></span>

> [!NOTE]
> <span data-ttu-id="f1d31-248">除了 `SupplierID` 和 `CompanyName`以外，[供應商] 資料表中的所有資料行都允許 `NULL` 值。</span><span class="sxs-lookup"><span data-stu-id="f1d31-248">Except for `SupplierID` and `CompanyName`, all columns in the Suppliers table allow `NULL` values.</span></span> <span data-ttu-id="f1d31-249">因此，如果傳入的 `contactName` 或 `contactTitle` 參數 `Nothing` 我們必須分別使用 `ContactTitle` 和 `NULL` 方法，將對應的 `ContactName` 和 `SetContactNameNull` 屬性設定為 `SetContactTitleNull` 資料庫值。</span><span class="sxs-lookup"><span data-stu-id="f1d31-249">Therefore, if the passed-in `contactName` or `contactTitle` parameters are `Nothing` we need to set the corresponding `ContactName` and `ContactTitle` properties to a `NULL` database value using the `SetContactNameNull` and `SetContactTitleNull` methods, respectively.</span></span>

## <a name="step-7-working-with-the-computed-column-from-the-presentation-layer"></a><span data-ttu-id="f1d31-250">步驟7：使用展示層中的計算資料行</span><span class="sxs-lookup"><span data-stu-id="f1d31-250">Step 7: Working with the Computed Column from the Presentation Layer</span></span>

<span data-ttu-id="f1d31-251">將計算資料行新增至 `Suppliers` 資料表，並據以更新 DAL 和 BLL 之後，我們就可以建立可與 `FullContactName` 計算資料行搭配使用的 ASP.NET 網頁。</span><span class="sxs-lookup"><span data-stu-id="f1d31-251">With the computed column added to the `Suppliers` table and the DAL and BLL updated accordingly, we are ready to build an ASP.NET page that works with the `FullContactName` computed column.</span></span> <span data-ttu-id="f1d31-252">一開始先開啟 [`AdvancedDAL`] 資料夾中的 [`ComputedColumns.aspx`] 頁面，然後從 [工具箱] 將 [GridView] 拖曳至設計工具。</span><span class="sxs-lookup"><span data-stu-id="f1d31-252">Start by opening the `ComputedColumns.aspx` page in the `AdvancedDAL` folder and drag a GridView from the Toolbox onto the Designer.</span></span> <span data-ttu-id="f1d31-253">將 GridView 的 `ID` 屬性設定為 `Suppliers`，並將其從智慧標籤系結至名為 `SuppliersDataSource`的新 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="f1d31-253">Set the GridView s `ID` property to `Suppliers` and, from its smart tag, bind it to a new ObjectDataSource named `SuppliersDataSource`.</span></span> <span data-ttu-id="f1d31-254">設定 ObjectDataSource 使用我們在步驟6中新增的 `SuppliersBLLWithSprocs` 類別，然後按 [下一步]。</span><span class="sxs-lookup"><span data-stu-id="f1d31-254">Configure the ObjectDataSource to use the `SuppliersBLLWithSprocs` class we added back in Step 6 and click Next.</span></span>

<span data-ttu-id="f1d31-255">[![將 ObjectDataSource 設定為使用 SuppliersBLLWithSprocs 類別](working-with-computed-columns-vb/_static/image32.png)](working-with-computed-columns-vb/_static/image31.png)</span><span class="sxs-lookup"><span data-stu-id="f1d31-255">[![Configure the ObjectDataSource to Use the SuppliersBLLWithSprocs Class](working-with-computed-columns-vb/_static/image32.png)](working-with-computed-columns-vb/_static/image31.png)</span></span>

<span data-ttu-id="f1d31-256">**圖 11**：設定 ObjectDataSource 使用 `SuppliersBLLWithSprocs` 類別（[按一下以查看完整大小的影像](working-with-computed-columns-vb/_static/image33.png)）</span><span class="sxs-lookup"><span data-stu-id="f1d31-256">**Figure 11**: Configure the ObjectDataSource to Use the `SuppliersBLLWithSprocs` Class ([Click to view full-size image](working-with-computed-columns-vb/_static/image33.png))</span></span>

<span data-ttu-id="f1d31-257">`SuppliersBLLWithSprocs` 類別中只定義了兩個方法： `GetSuppliers` 和 `UpdateSupplier`。</span><span class="sxs-lookup"><span data-stu-id="f1d31-257">There are only two methods defined in the `SuppliersBLLWithSprocs` class: `GetSuppliers` and `UpdateSupplier`.</span></span> <span data-ttu-id="f1d31-258">請確定在 [選取和更新] 索引標籤中分別指定這兩個方法，然後按一下 [完成] 以完成 ObjectDataSource 的設定。</span><span class="sxs-lookup"><span data-stu-id="f1d31-258">Ensure that these two methods are specified in the SELECT and UPDATE tabs, respectively, and click Finish to complete the configuration of the ObjectDataSource.</span></span>

<span data-ttu-id="f1d31-259">完成資料來源設定 wizard 後，Visual Studio 將會針對每個傳回的資料欄位加入 BoundField。</span><span class="sxs-lookup"><span data-stu-id="f1d31-259">Upon completion of the Data Source Configuration wizard, Visual Studio will add a BoundField for each of the data fields returned.</span></span> <span data-ttu-id="f1d31-260">移除 `SupplierID` BoundField，並分別將 `CompanyName`、`ContactName`、`ContactTitle`和 `FullContactName` BoundFields 的 `HeaderText` 屬性變更為 [公司]、[連絡人姓名]、[標題] 和 [完整連絡人姓名]。</span><span class="sxs-lookup"><span data-stu-id="f1d31-260">Remove the `SupplierID` BoundField and change the `HeaderText` properties of the `CompanyName`, `ContactName`, `ContactTitle`, and `FullContactName` BoundFields to Company, Contact Name, Title, and Full Contact Name, respectively.</span></span> <span data-ttu-id="f1d31-261">從智慧標籤中，勾選 [啟用編輯] 核取方塊，以開啟 GridView 的內建編輯功能。</span><span class="sxs-lookup"><span data-stu-id="f1d31-261">From the smart tag, check the Enable Editing checkbox to turn on the GridView s built-in editing capabilities.</span></span>

<span data-ttu-id="f1d31-262">除了將 BoundFields 加入 GridView 之外，資料來源 Wizard 的完成也會導致 Visual Studio 將 ObjectDataSource s `OldValuesParameterFormatString` 屬性設定為原始\_{0}。</span><span class="sxs-lookup"><span data-stu-id="f1d31-262">In addition to adding BoundFields to the GridView, completion of the Data Source Wizard also causes Visual Studio to set the ObjectDataSource s `OldValuesParameterFormatString` property to original\_{0}.</span></span> <span data-ttu-id="f1d31-263">將此設定還原回其預設值 {0}。</span><span class="sxs-lookup"><span data-stu-id="f1d31-263">Revert this setting back to its default value, {0} .</span></span>

<span data-ttu-id="f1d31-264">對 GridView 和 ObjectDataSource 進行這些編輯之後，其宣告式標記看起來應該如下所示：</span><span class="sxs-lookup"><span data-stu-id="f1d31-264">After making these edits to the GridView and ObjectDataSource, their declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](working-with-computed-columns-vb/samples/sample7.aspx)]

<span data-ttu-id="f1d31-265">接下來，透過瀏覽器造訪此頁面。</span><span class="sxs-lookup"><span data-stu-id="f1d31-265">Next, visit this page through a browser.</span></span> <span data-ttu-id="f1d31-266">如 [圖 12] 所示，每個供應商都會列在包含 [`FullContactName`] 資料行的方格中，其值只是將其他三個數據行的串連設定為 `ContactName` （`ContactTitle`，`CompanyName`）。</span><span class="sxs-lookup"><span data-stu-id="f1d31-266">As Figure 12 shows, each supplier is listed in a grid that includes the `FullContactName` column, whose value is simply the concatenation of the other three columns formatted as `ContactName` (`ContactTitle`, `CompanyName`) .</span></span>

<span data-ttu-id="f1d31-267">[![方格中列出每個供應商](working-with-computed-columns-vb/_static/image35.png)](working-with-computed-columns-vb/_static/image34.png)</span><span class="sxs-lookup"><span data-stu-id="f1d31-267">[![Each Supplier is Listed in the Grid](working-with-computed-columns-vb/_static/image35.png)](working-with-computed-columns-vb/_static/image34.png)</span></span>

<span data-ttu-id="f1d31-268">**圖 12**：每個供應商都會列在方格中（[按一下以查看完整大小的影像](working-with-computed-columns-vb/_static/image36.png)）</span><span class="sxs-lookup"><span data-stu-id="f1d31-268">**Figure 12**: Each Supplier is Listed in the Grid ([Click to view full-size image](working-with-computed-columns-vb/_static/image36.png))</span></span>

<span data-ttu-id="f1d31-269">按一下特定供應商的 [編輯] 按鈕會導致回傳，而且該資料列會呈現在其編輯介面中（請參閱 [圖 13]）。</span><span class="sxs-lookup"><span data-stu-id="f1d31-269">Clicking the Edit button for a particular supplier causes a postback and has that row rendered in its editing interface (see Figure 13).</span></span> <span data-ttu-id="f1d31-270">前三個數據行在其預設的編輯介面中轉譯-TextBox 控制項，其 `Text` 屬性設定為資料欄位的值。</span><span class="sxs-lookup"><span data-stu-id="f1d31-270">The first three columns render in their default editing interface - a TextBox control whose `Text` property is set to the value of the data field.</span></span> <span data-ttu-id="f1d31-271">不過，`FullContactName` 資料行仍會保留為文字。</span><span class="sxs-lookup"><span data-stu-id="f1d31-271">The `FullContactName` column, however, remains as text.</span></span> <span data-ttu-id="f1d31-272">當 BoundFields 在資料來源設定 wizard 完成時加入至 GridView 時，`FullContactName` BoundField s `ReadOnly` 屬性會設定為 `True`，因為 `SuppliersDataTable` 中對應的 `FullContactName` 資料行將其 `ReadOnly` 屬性設定為 `True`。</span><span class="sxs-lookup"><span data-stu-id="f1d31-272">When the BoundFields were added to the GridView at the completion of the Data Source Configuration wizard, the `FullContactName` BoundField s `ReadOnly` property was set to `True` because the corresponding `FullContactName` column in the `SuppliersDataTable` has its `ReadOnly` property set to `True`.</span></span> <span data-ttu-id="f1d31-273">如步驟4所述，`FullContactName` s `ReadOnly` 屬性已設定為 `True`，因為 TableAdapter 偵測到資料行是計算資料行。</span><span class="sxs-lookup"><span data-stu-id="f1d31-273">As noted in Step 4, the `FullContactName` s `ReadOnly` property was set to `True` because the TableAdapter detected that the column was a computed column.</span></span>

<span data-ttu-id="f1d31-274">[![無法編輯 FullContactName 資料行](working-with-computed-columns-vb/_static/image38.png)](working-with-computed-columns-vb/_static/image37.png)</span><span class="sxs-lookup"><span data-stu-id="f1d31-274">[![The FullContactName Column is Not Editable](working-with-computed-columns-vb/_static/image38.png)](working-with-computed-columns-vb/_static/image37.png)</span></span>

<span data-ttu-id="f1d31-275">**圖 13**：無法編輯 `FullContactName` 資料行（[按一下以查看完整大小的影像](working-with-computed-columns-vb/_static/image39.png)）</span><span class="sxs-lookup"><span data-stu-id="f1d31-275">**Figure 13**: The `FullContactName` Column is Not Editable ([Click to view full-size image](working-with-computed-columns-vb/_static/image39.png))</span></span>

<span data-ttu-id="f1d31-276">請繼續並更新一個或多個可編輯資料行的值，然後按一下 [更新]。</span><span class="sxs-lookup"><span data-stu-id="f1d31-276">Go ahead and update the value of one or more of the editable columns and click Update.</span></span> <span data-ttu-id="f1d31-277">請注意，`FullContactName` s 值會自動更新以反映變更。</span><span class="sxs-lookup"><span data-stu-id="f1d31-277">Note how the `FullContactName` s value is automatically updated to reflect the change.</span></span>

> [!NOTE]
> <span data-ttu-id="f1d31-278">GridView 目前針對可編輯的欄位使用 BoundFields，因此會產生預設的編輯介面。</span><span class="sxs-lookup"><span data-stu-id="f1d31-278">The GridView currently uses BoundFields for the editable fields, resulting in the default editing interface.</span></span> <span data-ttu-id="f1d31-279">因為 [`CompanyName`] 欄位是必要的，所以應該轉換成包含 RequiredFieldValidator 的 TemplateField。</span><span class="sxs-lookup"><span data-stu-id="f1d31-279">Since the `CompanyName` field is required, it should be converted into a TemplateField that includes a RequiredFieldValidator.</span></span> <span data-ttu-id="f1d31-280">我將這個練習留給感興趣的讀者。</span><span class="sxs-lookup"><span data-stu-id="f1d31-280">I leave this as an exercise for the interested reader.</span></span> <span data-ttu-id="f1d31-281">如需將 BoundField 轉換為 TemplateField 和加入驗證控制項的逐步指示，請參閱將[驗證控制項新增至編輯和插入介面](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-vb.md)教學課程。</span><span class="sxs-lookup"><span data-stu-id="f1d31-281">Consult the [Adding Validation Controls to the Editing and Inserting Interfaces](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-vb.md) tutorial for step-by-step instructions on converting a BoundField to a TemplateField and adding validation controls.</span></span>

## <a name="summary"></a><span data-ttu-id="f1d31-282">總結</span><span class="sxs-lookup"><span data-stu-id="f1d31-282">Summary</span></span>

<span data-ttu-id="f1d31-283">定義資料表的架構時，Microsoft SQL Server 允許包含計算資料行。</span><span class="sxs-lookup"><span data-stu-id="f1d31-283">When defining the schema for a table, Microsoft SQL Server allows the inclusion of computed columns.</span></span> <span data-ttu-id="f1d31-284">這些資料行的值是從通常參考相同記錄中其他資料行值的運算式計算而來。</span><span class="sxs-lookup"><span data-stu-id="f1d31-284">These are columns whose values are calculated from an expression that usually references the values from other columns in the same record.</span></span> <span data-ttu-id="f1d31-285">由於計算資料行的值是以運算式為基礎，因此它們是唯讀的，而且無法在 `INSERT` 或 `UPDATE` 語句中指派值。</span><span class="sxs-lookup"><span data-stu-id="f1d31-285">Since the values for computed columns are based on an expression, they are read-only and cannot be assigned a value in an `INSERT` or `UPDATE` statement.</span></span> <span data-ttu-id="f1d31-286">在 TableAdapter 的主查詢中使用計算資料行時，如果嘗試自動產生對應的 `INSERT`、`UPDATE`和 `DELETE` 語句，這就會造成挑戰。</span><span class="sxs-lookup"><span data-stu-id="f1d31-286">This introduces challenges when using a computed column in the main query of a TableAdapter that tries to automatically generate corresponding `INSERT`, `UPDATE`, and `DELETE` statements.</span></span>

<span data-ttu-id="f1d31-287">在本教學課程中，我們已討論規避計算資料行所造成之挑戰的技術。</span><span class="sxs-lookup"><span data-stu-id="f1d31-287">In this tutorial we discussed techniques for circumventing the challenges posed by computed columns.</span></span> <span data-ttu-id="f1d31-288">特別是，我們使用 TableAdapter 中的預存程式，來克服使用臨機操作 SQL 語句之 Tableadapter 中的肯定脆弱度。</span><span class="sxs-lookup"><span data-stu-id="f1d31-288">In particular, we used stored procedures in our TableAdapter to overcome the brittleness inherent in TableAdapters that use ad-hoc SQL statements.</span></span> <span data-ttu-id="f1d31-289">當 [TableAdapter wizard] 建立新的預存程式時，請務必讓主查詢一開始省略任何計算資料行，因為它們的存在會防止產生資料修改預存程式。</span><span class="sxs-lookup"><span data-stu-id="f1d31-289">When having the TableAdapter wizard create new stored procedures, it is important that we have the main query initially omit any computed columns because their presence prevents the data modification stored procedures from being generated.</span></span> <span data-ttu-id="f1d31-290">一開始設定 TableAdapter 之後，可以改良其 `SelectCommand` 預存程式來包含任何計算資料行。</span><span class="sxs-lookup"><span data-stu-id="f1d31-290">After the TableAdapter has been initially configured, its `SelectCommand` stored procedure can be retooled to include any computed columns.</span></span>

<span data-ttu-id="f1d31-291">快樂的程式設計！</span><span class="sxs-lookup"><span data-stu-id="f1d31-291">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="f1d31-292">關於作者</span><span class="sxs-lookup"><span data-stu-id="f1d31-292">About the Author</span></span>

<span data-ttu-id="f1d31-293">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，自1998起，有七個 ASP/ASP. NET 書籍和創辦人的[4GuysFromRolla.com](http://www.4guysfromrolla.com)。</span><span class="sxs-lookup"><span data-stu-id="f1d31-293">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="f1d31-294">Scott 以獨立的顧問、訓練員和作者的身分運作。</span><span class="sxs-lookup"><span data-stu-id="f1d31-294">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="f1d31-295">他的最新著作是[*在24小時內讓自己的 ASP.NET 2.0*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="f1d31-295">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="f1d31-296">他可以在mitchell@4GuysFromRolla.com觸達[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="f1d31-296">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="f1d31-297">或者透過他的 blog，可以在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)找到。</span><span class="sxs-lookup"><span data-stu-id="f1d31-297">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="f1d31-298">特別感謝</span><span class="sxs-lookup"><span data-stu-id="f1d31-298">Special Thanks To</span></span>

<span data-ttu-id="f1d31-299">本教學課程系列已由許多有用的審核者所審查。</span><span class="sxs-lookup"><span data-stu-id="f1d31-299">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="f1d31-300">本教學課程的領導審查者為 Hilton Geisenow 和 Teresa Murphy。</span><span class="sxs-lookup"><span data-stu-id="f1d31-300">Lead reviewers for this tutorial were Hilton Geisenow and Teresa Murphy.</span></span> <span data-ttu-id="f1d31-301">有興趣複習我即將發行的 MSDN 文章嗎？</span><span class="sxs-lookup"><span data-stu-id="f1d31-301">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="f1d31-302">若是如此，請在mitchell@4GuysFromRolla.com的那一行下拉式[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="f1d31-302">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="f1d31-303">[上一頁](adding-additional-datatable-columns-vb.md)
> [下一頁](configuring-the-data-access-layer-s-connection-and-command-level-settings-vb.md)</span><span class="sxs-lookup"><span data-stu-id="f1d31-303">[Previous](adding-additional-datatable-columns-vb.md)
[Next](configuring-the-data-access-layer-s-connection-and-command-level-settings-vb.md)</span></span>
