---
uid: web-forms/overview/data-access/advanced-data-access-scenarios/updating-the-tableadapter-to-use-joins-cs
title: 更新 TableAdapter 以使用 Join （C#） |Microsoft Docs
author: rick-anderson
description: 使用資料庫時，通常會要求分散到多個資料表的資料。 若要從兩個不同的資料表取出資料，我們可以使用 。
ms.author: riande
ms.date: 07/18/2007
ms.assetid: 675531a7-cb54-4dd6-89ac-2636e4c285a5
msc.legacyurl: /web-forms/overview/data-access/advanced-data-access-scenarios/updating-the-tableadapter-to-use-joins-cs
msc.type: authoredcontent
ms.openlocfilehash: 24ff3645783dabfcdef5ac313a2d4833e4998efc
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/28/2019
ms.locfileid: "74608163"
---
# <a name="updating-the-tableadapter-to-use-joins-c"></a><span data-ttu-id="0eb64-104">更新 TableAdapter 以使用 JOIN (C#)</span><span class="sxs-lookup"><span data-stu-id="0eb64-104">Updating the TableAdapter to Use JOINs (C#)</span></span>

<span data-ttu-id="0eb64-105">由[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="0eb64-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="0eb64-106">[下載程式代碼](https://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_69_CS.zip)或[下載 PDF](updating-the-tableadapter-to-use-joins-cs/_static/datatutorial69cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="0eb64-106">[Download Code](https://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_69_CS.zip) or [Download PDF](updating-the-tableadapter-to-use-joins-cs/_static/datatutorial69cs1.pdf)</span></span>

> <span data-ttu-id="0eb64-107">使用資料庫時，通常會要求分散到多個資料表的資料。</span><span class="sxs-lookup"><span data-stu-id="0eb64-107">When working with a database it is common to request data that is spread across multiple tables.</span></span> <span data-ttu-id="0eb64-108">若要從兩個不同的資料表中取出資料，我們可以使用相互關聯的子查詢或聯結作業。</span><span class="sxs-lookup"><span data-stu-id="0eb64-108">To retrieve data from two different tables we can use either a correlated subquery or a JOIN operation.</span></span> <span data-ttu-id="0eb64-109">在本教學課程中，我們將比較相互關聯的子查詢和聯結語法，然後再查看如何建立在其主要查詢中包含聯結的 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="0eb64-109">In this tutorial we compare correlated subqueries and the JOIN syntax before looking at how to create a TableAdapter that includes a JOIN in its main query.</span></span>

## <a name="introduction"></a><span data-ttu-id="0eb64-110">簡介</span><span class="sxs-lookup"><span data-stu-id="0eb64-110">Introduction</span></span>

<span data-ttu-id="0eb64-111">使用關係資料庫時，我們想要使用的資料通常會分散到多個資料表。</span><span class="sxs-lookup"><span data-stu-id="0eb64-111">With relational databases the data we are interested in working with is often spread across multiple tables.</span></span> <span data-ttu-id="0eb64-112">例如，顯示產品資訊時，我們可能會想要列出每個產品的對應類別和供應商名稱。</span><span class="sxs-lookup"><span data-stu-id="0eb64-112">For example, when displaying product information we likely want to list each product s corresponding category and supplier s names.</span></span> <span data-ttu-id="0eb64-113">`Products` 資料表具有 `CategoryID` 和 `SupplierID` 值，但實際的分類和供應商名稱分別位於 `Categories` 和 `Suppliers` 資料表中。</span><span class="sxs-lookup"><span data-stu-id="0eb64-113">The `Products` table has `CategoryID` and `SupplierID` values, but the actual category and supplier names are in the `Categories` and `Suppliers` tables, respectively.</span></span>

<span data-ttu-id="0eb64-114">若要從另一個相關的資料表取出資訊，我們可以使用相互*關聯的子查詢*或 `JOIN`*s*。</span><span class="sxs-lookup"><span data-stu-id="0eb64-114">To retrieve information from another, related table, we can either use *correlated subqueries* or `JOIN`*s*.</span></span> <span data-ttu-id="0eb64-115">相互關聯的子查詢是參考外部查詢中資料行的嵌套 `SELECT` 查詢。</span><span class="sxs-lookup"><span data-stu-id="0eb64-115">A correlated subquery is a nested `SELECT` query that references columns in the outer query.</span></span> <span data-ttu-id="0eb64-116">例如，在[建立資料存取層](../introduction/creating-a-data-access-layer-cs.md)教學課程中，我們在 `ProductsTableAdapter` s 主查詢中使用了兩個相互關聯的子查詢，以傳回每個產品的類別目錄和供應商名稱。</span><span class="sxs-lookup"><span data-stu-id="0eb64-116">For example, in the [Creating a Data Access Layer](../introduction/creating-a-data-access-layer-cs.md) tutorial we used two correlated subqueries in the `ProductsTableAdapter` s main query to return the category and supplier names for each product.</span></span> <span data-ttu-id="0eb64-117">`JOIN` 是一種 SQL 結構，可合併兩個不同資料表的相關資料列。</span><span class="sxs-lookup"><span data-stu-id="0eb64-117">A `JOIN` is a SQL construct that merges related rows from two different tables.</span></span> <span data-ttu-id="0eb64-118">我們在使用[SqlDataSource 控制項來查詢資料](../accessing-the-database-directly-from-an-aspnet-page/querying-data-with-the-sqldatasource-control-cs.md)教學課程中使用了 `JOIN`，以便在每個產品旁顯示類別資訊。</span><span class="sxs-lookup"><span data-stu-id="0eb64-118">We used a `JOIN` in the [Querying Data with the SqlDataSource Control](../accessing-the-database-directly-from-an-aspnet-page/querying-data-with-the-sqldatasource-control-cs.md) tutorial to display category information alongside each product.</span></span>

<span data-ttu-id="0eb64-119">我們從使用 `JOIN` s 與 Tableadapter abstained 的原因，是因為 TableAdapter s wizard 中的限制會自動產生對應的 `INSERT`、`UPDATE`和 `DELETE` 語句。</span><span class="sxs-lookup"><span data-stu-id="0eb64-119">The reason we have abstained from using `JOIN` s with the TableAdapters is because of limitations in the TableAdapter s wizard to auto-generate corresponding `INSERT`, `UPDATE`, and `DELETE` statements.</span></span> <span data-ttu-id="0eb64-120">更明確地說，如果 TableAdapter 的主查詢包含任何 `JOIN` s，TableAdapter 就無法針對其 `InsertCommand`、`UpdateCommand`和 `DeleteCommand` 屬性，自動建立臨機操作 SQL 語句或預存程式。</span><span class="sxs-lookup"><span data-stu-id="0eb64-120">More specifically, if the TableAdapter s main query contains any `JOIN` s, the TableAdapter cannot auto-create the ad-hoc SQL statements or stored procedures for its `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties.</span></span>

<span data-ttu-id="0eb64-121">在本教學課程中，我們將簡短地比較和對比相互關聯的子查詢和 `JOIN`，然後再探索如何建立在其主要查詢中包含 `JOIN` 的 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="0eb64-121">In this tutorial we will briefly compare and contrast correlated subqueries and `JOIN` s before exploring how to create a TableAdapter that includes `JOIN` s in its main query.</span></span>

## <a name="comparing-and-contrasting-correlated-subqueries-andjoin-s"></a><span data-ttu-id="0eb64-122">比較和對比相互關聯的子查詢與`JOIN` s</span><span class="sxs-lookup"><span data-stu-id="0eb64-122">Comparing and Contrasting Correlated Subqueries and`JOIN` s</span></span>

<span data-ttu-id="0eb64-123">回想一下，在 `Northwind` 資料集的第一個教學課程中建立的 `ProductsTableAdapter` 會使用相互關聯的子查詢，以傳回每個產品的對應類別和供應商名稱。</span><span class="sxs-lookup"><span data-stu-id="0eb64-123">Recall that the `ProductsTableAdapter` created in the first tutorial in the `Northwind` DataSet uses correlated subqueries to bring back each product s corresponding category and supplier name.</span></span> <span data-ttu-id="0eb64-124">`ProductsTableAdapter` s 主要查詢如下所示。</span><span class="sxs-lookup"><span data-stu-id="0eb64-124">The `ProductsTableAdapter` s main query is shown below.</span></span>

[!code-sql[Main](updating-the-tableadapter-to-use-joins-cs/samples/sample1.sql)]

<span data-ttu-id="0eb64-125">兩個相互關聯的子查詢 `(SELECT CategoryName FROM Categories WHERE Categories.CategoryID = Products.CategoryID)` 和 `(SELECT CompanyName FROM Suppliers WHERE Suppliers.SupplierID = Products.SupplierID)` 是 `SELECT` 查詢，會傳回每個產品的單一值，做為外部 `SELECT` 語句 s 資料行清單中的額外資料行。</span><span class="sxs-lookup"><span data-stu-id="0eb64-125">The two correlated subqueries - `(SELECT CategoryName FROM Categories WHERE Categories.CategoryID = Products.CategoryID)` and `(SELECT CompanyName FROM Suppliers WHERE Suppliers.SupplierID = Products.SupplierID)` - are `SELECT` queries that return a single value per product as an additional column in the outer `SELECT` statement s column list.</span></span>

<span data-ttu-id="0eb64-126">或者，`JOIN` 可以用來傳回每個產品的供應商和類別目錄名稱。</span><span class="sxs-lookup"><span data-stu-id="0eb64-126">Alternatively, a `JOIN` can be used to return each product s supplier and category name.</span></span> <span data-ttu-id="0eb64-127">下列查詢會傳回與上述相同的輸出，但會使用 `JOIN` s 來取代子查詢：</span><span class="sxs-lookup"><span data-stu-id="0eb64-127">The following query returns the same output as the above one, but uses `JOIN` s in place of subqueries:</span></span>

[!code-sql[Main](updating-the-tableadapter-to-use-joins-cs/samples/sample2.sql)]

<span data-ttu-id="0eb64-128">`JOIN` 會根據某些準則，合併一個資料表中的記錄與另一個資料表中的記錄。</span><span class="sxs-lookup"><span data-stu-id="0eb64-128">A `JOIN` merges the records from one table with records from another table based on some criteria.</span></span> <span data-ttu-id="0eb64-129">例如，在上述查詢中，`LEFT JOIN Categories ON Categories.CategoryID = Products.CategoryID` 會指示 SQL Server 合併每個產品記錄與分類記錄，其 `CategoryID` 值符合產品的 `CategoryID` 值。</span><span class="sxs-lookup"><span data-stu-id="0eb64-129">In the above query, for example, the `LEFT JOIN Categories ON Categories.CategoryID = Products.CategoryID` instructs SQL Server to merge each product record with the category record whose `CategoryID` value matches the product s `CategoryID` value.</span></span> <span data-ttu-id="0eb64-130">合併的結果可讓我們處理每項產品的對應類別欄位（例如 `CategoryName`）。</span><span class="sxs-lookup"><span data-stu-id="0eb64-130">The merged result allows us to work with the corresponding category fields for each product (such as `CategoryName`).</span></span>

> [!NOTE]
> <span data-ttu-id="0eb64-131">在查詢關係資料庫中的資料時，通常會使用 `JOIN` s。</span><span class="sxs-lookup"><span data-stu-id="0eb64-131">`JOIN` s are commonly used when querying data from relational databases.</span></span> <span data-ttu-id="0eb64-132">如果您不熟悉 `JOIN` 語法，或需要在其使用方式上進行多筆處理，我建議您在[W3 學校](http://www.w3schools.com/)的[SQL 聯結教學](http://www.w3schools.com/sql/sql_join.asp)課程。</span><span class="sxs-lookup"><span data-stu-id="0eb64-132">If you are new to the `JOIN` syntax or need to brush up a bit on its usage, I d recommend the [SQL Join tutorial](http://www.w3schools.com/sql/sql_join.asp) at [W3 Schools](http://www.w3schools.com/).</span></span> <span data-ttu-id="0eb64-133">另請閱讀《 [SQL 線上叢書》](https://msdn.microsoft.com/library/ms130214.aspx)中的[`JOIN` 基本](https://msdn.microsoft.com/library/ms191517.aspx)概念和[子查詢基本](https://msdn.microsoft.com/library/ms189575.aspx)概念一節。</span><span class="sxs-lookup"><span data-stu-id="0eb64-133">Also worth reading are the [`JOIN` Fundamentals](https://msdn.microsoft.com/library/ms191517.aspx) and [Subquery Fundamentals](https://msdn.microsoft.com/library/ms189575.aspx) sections of the [SQL Books Online](https://msdn.microsoft.com/library/ms130214.aspx).</span></span>

<span data-ttu-id="0eb64-134">因為 `JOIN` s 和相互關聯的子查詢都可以用來從其他資料表中取出相關資料，所以許多開發人員會留下抓著自己的想法，並知道要使用哪種方法。</span><span class="sxs-lookup"><span data-stu-id="0eb64-134">Since `JOIN` s and correlated subqueries can both be used to retrieve related data from other tables, many developers are left scratching their heads and wondering which approach to use.</span></span> <span data-ttu-id="0eb64-135">我之前提到的所有 SQL 專家都說過大致相同的事，因為 SQL Server 會產生大致相同的執行計畫。</span><span class="sxs-lookup"><span data-stu-id="0eb64-135">All of the SQL gurus I ve talked to have said roughly the same thing, that it doesn t really matter performance-wise as SQL Server will produce roughly identical execution plans.</span></span> <span data-ttu-id="0eb64-136">我們的建議是使用您和您的小組最熟悉的技術。</span><span class="sxs-lookup"><span data-stu-id="0eb64-136">Their advice, then, is to use the technique that you and your team are most comfortable with.</span></span> <span data-ttu-id="0eb64-137">值得注意的是，在清楚告知這項建議之後，這些專家會立即透過相互關聯的子查詢來表達其 `JOIN` 的喜好設定。</span><span class="sxs-lookup"><span data-stu-id="0eb64-137">It merits noting that after imparting this advice these experts immediately express their preference of `JOIN` s over correlated subqueries.</span></span>

<span data-ttu-id="0eb64-138">使用具類型的資料集來建立資料存取層時，使用子查詢時，工具的效果較佳。</span><span class="sxs-lookup"><span data-stu-id="0eb64-138">When building a Data Access Layer using Typed DataSets, the tools work better when using subqueries.</span></span> <span data-ttu-id="0eb64-139">特別的是，如果主要查詢包含任何 `JOIN`，則 TableAdapter s wizard 不會自動產生對應的 `INSERT`、`UPDATE`和 `DELETE` 語句，但會在使用相互關聯的子查詢時自動產生這些語句。</span><span class="sxs-lookup"><span data-stu-id="0eb64-139">In particular, the TableAdapter s wizard will not auto-generate corresponding `INSERT`, `UPDATE`, and `DELETE` statements if the main query contains any `JOIN` s, but will auto-generate these statements when correlated subqueries are used.</span></span>

<span data-ttu-id="0eb64-140">若要探索此缺點，請在 `~/App_Code/DAL` 資料夾中建立臨時類型資料集。</span><span class="sxs-lookup"><span data-stu-id="0eb64-140">To explore this shortcoming, create a temporary Typed DataSet in the `~/App_Code/DAL` folder.</span></span> <span data-ttu-id="0eb64-141">在 [TableAdapter 設定向導] 中，選擇使用臨機操作 SQL 語句，並輸入下列 `SELECT` 查詢（請參閱 [圖 1]）：</span><span class="sxs-lookup"><span data-stu-id="0eb64-141">During the TableAdapter Configuration wizard, choose to use ad-hoc SQL statements and enter the following `SELECT` query (see Figure 1):</span></span>

[!code-sql[Main](updating-the-tableadapter-to-use-joins-cs/samples/sample3.sql)]

<span data-ttu-id="0eb64-142">[![輸入包含聯結的主要查詢](updating-the-tableadapter-to-use-joins-cs/_static/image2.png)](updating-the-tableadapter-to-use-joins-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="0eb64-142">[![Enter a Main Query that Contains JOINs](updating-the-tableadapter-to-use-joins-cs/_static/image2.png)](updating-the-tableadapter-to-use-joins-cs/_static/image1.png)</span></span>

<span data-ttu-id="0eb64-143">**圖 1**：輸入包含 `JOIN` s 的主要查詢（[按一下以查看完整大小的影像](updating-the-tableadapter-to-use-joins-cs/_static/image3.png)）</span><span class="sxs-lookup"><span data-stu-id="0eb64-143">**Figure 1**: Enter a Main Query that Contains `JOIN` s ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image3.png))</span></span>

<span data-ttu-id="0eb64-144">根據預設，TableAdapter 會依據主要查詢自動建立 `INSERT`、`UPDATE`和 `DELETE` 語句。</span><span class="sxs-lookup"><span data-stu-id="0eb64-144">By default, the TableAdapter will automatically create `INSERT`, `UPDATE`, and `DELETE` statements based on the main query.</span></span> <span data-ttu-id="0eb64-145">如果您按一下 [Advanced] 按鈕，就會看到此功能已啟用。</span><span class="sxs-lookup"><span data-stu-id="0eb64-145">If you click the Advanced button you can see that this feature is enabled.</span></span> <span data-ttu-id="0eb64-146">雖然此設定，但 TableAdapter 將無法建立 `INSERT`、`UPDATE`和 `DELETE` 語句，因為主要查詢包含 `JOIN`。</span><span class="sxs-lookup"><span data-stu-id="0eb64-146">Despite this setting, the TableAdapter will not be able to create the `INSERT`, `UPDATE`, and `DELETE` statements because the main query contains a `JOIN`.</span></span>

![輸入包含聯結的主要查詢](updating-the-tableadapter-to-use-joins-cs/_static/image4.png)

<span data-ttu-id="0eb64-148">**圖 2**：輸入包含 `JOIN` s 的主要查詢</span><span class="sxs-lookup"><span data-stu-id="0eb64-148">**Figure 2**: Enter a Main Query that Contains `JOIN` s</span></span>

<span data-ttu-id="0eb64-149">按一下 [完成] 以完成精靈。</span><span class="sxs-lookup"><span data-stu-id="0eb64-149">Click Finish to complete the wizard.</span></span> <span data-ttu-id="0eb64-150">此時，您的資料集的設計工具會包含一個具有 DataTable 的單一 TableAdapter，其中每個欄位在 `SELECT` query s 資料行清單中傳回。</span><span class="sxs-lookup"><span data-stu-id="0eb64-150">At this point your DataSet s Designer will include a single TableAdapter with a DataTable with columns for each of the fields returned in the `SELECT` query s column list.</span></span> <span data-ttu-id="0eb64-151">這包括 `CategoryName` 和 `SupplierName`，如 [圖 3] 所示。</span><span class="sxs-lookup"><span data-stu-id="0eb64-151">This includes the `CategoryName` and `SupplierName`, as Figure 3 shows.</span></span>

![DataTable 會針對資料行清單中傳回的每個欄位包含一個資料行。](updating-the-tableadapter-to-use-joins-cs/_static/image5.png)

<span data-ttu-id="0eb64-153">**圖 3**： DataTable 針對資料行清單中傳回的每個欄位包含一個資料行</span><span class="sxs-lookup"><span data-stu-id="0eb64-153">**Figure 3**: The DataTable Includes a Column for Each Field Returned in the Column List</span></span>

<span data-ttu-id="0eb64-154">雖然 DataTable 具有適當的資料行，但 TableAdapter 缺少其 `InsertCommand`、`UpdateCommand`和 `DeleteCommand` 屬性的值。</span><span class="sxs-lookup"><span data-stu-id="0eb64-154">While the DataTable has the appropriate columns, the TableAdapter lacks values for its `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties.</span></span> <span data-ttu-id="0eb64-155">若要確認這一點，請按一下設計工具中的 TableAdapter，然後移至 [屬性視窗]。</span><span class="sxs-lookup"><span data-stu-id="0eb64-155">To confirm this, click on the TableAdapter in the Designer and then go to the Properties window.</span></span> <span data-ttu-id="0eb64-156">在這裡，您會看到 [`InsertCommand`]、[`UpdateCommand`] 和 [`DeleteCommand`] 屬性設定為 [（無）]。</span><span class="sxs-lookup"><span data-stu-id="0eb64-156">There you will see that the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties are set to (None) .</span></span>

<span data-ttu-id="0eb64-157">[![[InsertCommand]、[UpdateCommand] 和 [DeleteCommand] 屬性設定為 [（無）]](updating-the-tableadapter-to-use-joins-cs/_static/image7.png)](updating-the-tableadapter-to-use-joins-cs/_static/image6.png)</span><span class="sxs-lookup"><span data-stu-id="0eb64-157">[![The InsertCommand, UpdateCommand, and DeleteCommand Properties are Set to (None)](updating-the-tableadapter-to-use-joins-cs/_static/image7.png)](updating-the-tableadapter-to-use-joins-cs/_static/image6.png)</span></span>

<span data-ttu-id="0eb64-158">**圖 4**： [`InsertCommand`]、[`UpdateCommand`] 和 [`DeleteCommand`] 屬性設定為 [（無）] （[按一下以查看完整大小的影像](updating-the-tableadapter-to-use-joins-cs/_static/image8.png)）</span><span class="sxs-lookup"><span data-stu-id="0eb64-158">**Figure 4**: The `InsertCommand`, `UpdateCommand`, and `DeleteCommand` Properties are Set to (None) ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image8.png))</span></span>

<span data-ttu-id="0eb64-159">為了解決這種缺點，我們可以透過屬性視窗，手動提供 `InsertCommand`、`UpdateCommand`和 `DeleteCommand` 屬性的 SQL 語句和參數。</span><span class="sxs-lookup"><span data-stu-id="0eb64-159">To work around this shortcoming, we can manually provide the SQL statements and parameters for the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties via the Properties window.</span></span> <span data-ttu-id="0eb64-160">或者，我們也可以開始設定 TableAdapter s 查詢，*不要*包含任何 `JOIN` s。</span><span class="sxs-lookup"><span data-stu-id="0eb64-160">Alternatively, we could start by configuring the TableAdapter s main query to *not* include any `JOIN` s.</span></span> <span data-ttu-id="0eb64-161">這將允許為我們自動產生 `INSERT`、`UPDATE`和 `DELETE` 語句。</span><span class="sxs-lookup"><span data-stu-id="0eb64-161">This will allow the `INSERT`, `UPDATE`, and `DELETE` statements to be auto-generated for us.</span></span> <span data-ttu-id="0eb64-162">完成 wizard 之後，我們就可以從屬性視窗手動更新 TableAdapter `SelectCommand`，使其包含 `JOIN` 語法。</span><span class="sxs-lookup"><span data-stu-id="0eb64-162">After completing the wizard, we could then manually update the TableAdapter s `SelectCommand` from the Properties window so that it includes the `JOIN` syntax.</span></span>

<span data-ttu-id="0eb64-163">雖然這種方法可行，但在使用臨機操作 SQL 查詢時非常脆弱，因為每當您透過 wizard 重新設定 TableAdapter 主查詢時，自動產生的 `INSERT`、`UPDATE`和 `DELETE` 語句都會重新建立。</span><span class="sxs-lookup"><span data-stu-id="0eb64-163">While this approach works, it is very brittle when using ad-hoc SQL queries because any time the TableAdapter s main query is re-configured through the wizard, the auto-generated `INSERT`, `UPDATE`, and `DELETE` statements are recreated.</span></span> <span data-ttu-id="0eb64-164">這表示，如果我們在 TableAdapter 上按一下滑鼠右鍵、從操作功能表中選擇 [設定]，然後再次完成嚮導，則我們之後所做的所有自訂都會遺失。</span><span class="sxs-lookup"><span data-stu-id="0eb64-164">That means all of the customizations we later made would be lost if we right-clicked on the TableAdapter, chose Configure from the context menu, and completed the wizard again.</span></span>

<span data-ttu-id="0eb64-165">TableAdapter s 自動產生的 `INSERT`、`UPDATE`和 `DELETE` 語句的肯定脆弱度，只是特定的 SQL 語句。</span><span class="sxs-lookup"><span data-stu-id="0eb64-165">The brittleness of the TableAdapter s auto-generated `INSERT`, `UPDATE`, and `DELETE` statements is, fortunately, limited to ad-hoc SQL statements.</span></span> <span data-ttu-id="0eb64-166">如果您的 TableAdapter 使用預存程式，您可以自訂 `SelectCommand`、`InsertCommand`、`UpdateCommand`或 `DeleteCommand` 預存程式，並重新執行 TableAdapter 設定 wizard，而不必擔心預存程式將會被修改。</span><span class="sxs-lookup"><span data-stu-id="0eb64-166">If your TableAdapter uses stored procedures, you can customize the `SelectCommand`, `InsertCommand`, `UpdateCommand`, or `DeleteCommand` stored procedures and re-run the TableAdapter Configuration wizard without having to fear that the stored procedures will be modified.</span></span>

<span data-ttu-id="0eb64-167">在接下來的幾個步驟中，我們將建立一個 TableAdapter，一開始會使用會省略任何 `JOIN` s 的主要查詢，以便自動產生對應的插入、更新和刪除預存程式。</span><span class="sxs-lookup"><span data-stu-id="0eb64-167">Over the next several steps we will create a TableAdapter that, initially, uses a main query that omits any `JOIN` s so that the corresponding insert, update, and delete stored procedures will be auto-generated.</span></span> <span data-ttu-id="0eb64-168">然後，我們會更新 `SelectCommand`，以便使用會從相關資料表傳回額外資料行的 `JOIN`。</span><span class="sxs-lookup"><span data-stu-id="0eb64-168">We will then update the `SelectCommand` so that uses a `JOIN` that returns additional columns from related tables.</span></span> <span data-ttu-id="0eb64-169">最後，我們將建立對應的商務邏輯層級類別，並示範如何在 ASP.NET 網頁中使用 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="0eb64-169">Finally, we'll create a corresponding Business Logic Layer class and demonstrate using the TableAdapter in an ASP.NET web page.</span></span>

## <a name="step-1-creating-the-tableadapter-using-a-simplified-main-query"></a><span data-ttu-id="0eb64-170">步驟1：使用簡化的主要查詢來建立 TableAdapter</span><span class="sxs-lookup"><span data-stu-id="0eb64-170">Step 1: Creating the TableAdapter Using a Simplified Main Query</span></span>

<span data-ttu-id="0eb64-171">在本教學課程中，我們將為 `NorthwindWithSprocs` 資料集中的 `Employees` 資料表加入 TableAdapter 和強型別 DataTable。</span><span class="sxs-lookup"><span data-stu-id="0eb64-171">For this tutorial we will add a TableAdapter and strongly-typed DataTable for the `Employees` table in the `NorthwindWithSprocs` DataSet.</span></span> <span data-ttu-id="0eb64-172">`Employees` 資料表包含一個 `ReportsTo` 欄位，其中指定了員工 s 經理的 `EmployeeID`。</span><span class="sxs-lookup"><span data-stu-id="0eb64-172">The `Employees` table contains a `ReportsTo` field that specified the `EmployeeID` of the employee s manager.</span></span> <span data-ttu-id="0eb64-173">例如，employee Anne 劉天具有5的 `ReportTo` 值，也就是 Steven 林丹的 `EmployeeID`。</span><span class="sxs-lookup"><span data-stu-id="0eb64-173">For example, employee Anne Dodsworth has a `ReportTo` value of 5, which is the `EmployeeID` of Steven Buchanan.</span></span> <span data-ttu-id="0eb64-174">因此，Anne 報告給 Steven，她的經理。</span><span class="sxs-lookup"><span data-stu-id="0eb64-174">Consequently, Anne reports to Steven, her manager.</span></span> <span data-ttu-id="0eb64-175">除了報告每個員工的 `ReportsTo` 值，我們也可能會想要取得其經理的名稱。</span><span class="sxs-lookup"><span data-stu-id="0eb64-175">Along with reporting each employee s `ReportsTo` value, we might also want to retrieve the name of their manager.</span></span> <span data-ttu-id="0eb64-176">您可以使用 `JOIN`來完成這項作業。</span><span class="sxs-lookup"><span data-stu-id="0eb64-176">This can be accomplished using a `JOIN`.</span></span> <span data-ttu-id="0eb64-177">但是在最初建立 TableAdapter 時使用 `JOIN`，會阻止嚮導自動產生對應的插入、更新和刪除功能。</span><span class="sxs-lookup"><span data-stu-id="0eb64-177">But using a `JOIN` when initially creating the TableAdapter precludes the wizard from automatically generating the corresponding insert, update, and delete capabilities.</span></span> <span data-ttu-id="0eb64-178">因此，我們一開始會建立一個 TableAdapter，其主要查詢不包含任何 `JOIN` s。</span><span class="sxs-lookup"><span data-stu-id="0eb64-178">Therefore, we will start by creating a TableAdapter whose main query does not contain any `JOIN` s.</span></span> <span data-ttu-id="0eb64-179">然後，在步驟2中，我們將更新主要查詢預存程式，以透過 `JOIN`來抓取管理員的名稱。</span><span class="sxs-lookup"><span data-stu-id="0eb64-179">Then, in Step 2, we will update the main query stored procedure to retrieve the manager s name via a `JOIN`.</span></span>

<span data-ttu-id="0eb64-180">從開啟 `~/App_Code/DAL` 資料夾中的 `NorthwindWithSprocs` 資料集開始。</span><span class="sxs-lookup"><span data-stu-id="0eb64-180">Start by opening the `NorthwindWithSprocs` DataSet in the `~/App_Code/DAL` folder.</span></span> <span data-ttu-id="0eb64-181">以滑鼠右鍵按一下設計工具，從內容功能表中選取 [新增] 選項，然後挑選 [TableAdapter] 功能表項目。</span><span class="sxs-lookup"><span data-stu-id="0eb64-181">Right-click on the Designer, select the Add option from the context menu, and pick the TableAdapter menu item.</span></span> <span data-ttu-id="0eb64-182">這會啟動 [TableAdapter 設定向導]。</span><span class="sxs-lookup"><span data-stu-id="0eb64-182">This will launch the TableAdapter Configuration wizard.</span></span> <span data-ttu-id="0eb64-183">如 [圖 5] 所示，讓 wizard 建立新的預存程式，然後按 [下一步]。</span><span class="sxs-lookup"><span data-stu-id="0eb64-183">As Figure 5 depicts, have the wizard create new stored procedures and click Next.</span></span> <span data-ttu-id="0eb64-184">如需從 TableAdapter s wizard 建立新預存程式的重新整理程式，請參閱</span><span class="sxs-lookup"><span data-stu-id="0eb64-184">For a refresher on creating new stored procedures from the TableAdapter s wizard, consult the [Creating New Stored Procedures for the Typed DataSet s TableAdapters](creating-new-stored-procedures-for-the-typed-dataset-s-tableadapters-cs.md) tutorial.</span></span>

<span data-ttu-id="0eb64-185">[![選取 [建立新的預存程式] 選項](updating-the-tableadapter-to-use-joins-cs/_static/image10.png)](updating-the-tableadapter-to-use-joins-cs/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="0eb64-185">[![Select the Create new stored procedures Option](updating-the-tableadapter-to-use-joins-cs/_static/image10.png)](updating-the-tableadapter-to-use-joins-cs/_static/image9.png)</span></span>

<span data-ttu-id="0eb64-186">**圖 5**：選取 [建立新的預存程式] 選項（[按一下以查看完整大小的影像](updating-the-tableadapter-to-use-joins-cs/_static/image11.png)）</span><span class="sxs-lookup"><span data-stu-id="0eb64-186">**Figure 5**: Select the Create new stored procedures Option ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image11.png))</span></span>

<span data-ttu-id="0eb64-187">針對 TableAdapter s 主要查詢使用下列 `SELECT` 語句：</span><span class="sxs-lookup"><span data-stu-id="0eb64-187">Use the following `SELECT` statement for the TableAdapter s main query:</span></span>

[!code-sql[Main](updating-the-tableadapter-to-use-joins-cs/samples/sample4.sql)]

<span data-ttu-id="0eb64-188">因為此查詢不包含任何 `JOIN`，所以 TableAdapter wizard 會自動使用對應的 `INSERT`、`UPDATE`和 `DELETE` 語句來建立預存程式，以及執行主要查詢的預存程式。</span><span class="sxs-lookup"><span data-stu-id="0eb64-188">Since this query does not include any `JOIN` s, the TableAdapter wizard will automatically create stored procedures with corresponding `INSERT`, `UPDATE`, and `DELETE` statements, as well as a stored procedure for executing the main query.</span></span>

<span data-ttu-id="0eb64-189">下列步驟可讓我們命名 TableAdapter s 預存程式。</span><span class="sxs-lookup"><span data-stu-id="0eb64-189">The following step allows us to name the TableAdapter s stored procedures.</span></span> <span data-ttu-id="0eb64-190">使用 `Employees_Select`、`Employees_Insert`、`Employees_Update`和 `Employees_Delete`的名稱，如 [圖 6] 所示。</span><span class="sxs-lookup"><span data-stu-id="0eb64-190">Use the names `Employees_Select`, `Employees_Insert`, `Employees_Update`, and `Employees_Delete`, as shown in Figure 6.</span></span>

<span data-ttu-id="0eb64-191">[![命名 TableAdapter s 預存程式](updating-the-tableadapter-to-use-joins-cs/_static/image13.png)](updating-the-tableadapter-to-use-joins-cs/_static/image12.png)</span><span class="sxs-lookup"><span data-stu-id="0eb64-191">[![Name the TableAdapter s Stored Procedures](updating-the-tableadapter-to-use-joins-cs/_static/image13.png)](updating-the-tableadapter-to-use-joins-cs/_static/image12.png)</span></span>

<span data-ttu-id="0eb64-192">**圖 6**：命名 TableAdapter s 預存程式（[按一下以查看完整大小的影像](updating-the-tableadapter-to-use-joins-cs/_static/image14.png)）</span><span class="sxs-lookup"><span data-stu-id="0eb64-192">**Figure 6**: Name the TableAdapter s Stored Procedures ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image14.png))</span></span>

<span data-ttu-id="0eb64-193">最後一個步驟會提示我們命名 TableAdapter s 方法。</span><span class="sxs-lookup"><span data-stu-id="0eb64-193">The final step prompts us to name the TableAdapter s methods.</span></span> <span data-ttu-id="0eb64-194">使用 `Fill`，並 `GetEmployees` 做為方法名稱。</span><span class="sxs-lookup"><span data-stu-id="0eb64-194">Use `Fill` and `GetEmployees` as the method names.</span></span> <span data-ttu-id="0eb64-195">另請務必勾選 [建立方法，直接將更新傳送至資料庫（GenerateDBDirectMethods）] 核取方塊。</span><span class="sxs-lookup"><span data-stu-id="0eb64-195">Also be sure to leave the Create methods to send updates directly to the database (GenerateDBDirectMethods) checkbox checked.</span></span>

<span data-ttu-id="0eb64-196">[![命名 TableAdapter s 方法填滿和 GetEmployees](updating-the-tableadapter-to-use-joins-cs/_static/image16.png)](updating-the-tableadapter-to-use-joins-cs/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="0eb64-196">[![Name the TableAdapter s Methods Fill and GetEmployees](updating-the-tableadapter-to-use-joins-cs/_static/image16.png)](updating-the-tableadapter-to-use-joins-cs/_static/image15.png)</span></span>

<span data-ttu-id="0eb64-197">**圖 7**：將 TableAdapter 的方法命名為 `Fill` 和 `GetEmployees` （[按一下以查看完整大小的影像](updating-the-tableadapter-to-use-joins-cs/_static/image17.png)）</span><span class="sxs-lookup"><span data-stu-id="0eb64-197">**Figure 7**: Name the TableAdapter s Methods `Fill` and `GetEmployees` ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image17.png))</span></span>

<span data-ttu-id="0eb64-198">完成 wizard 之後，請花點時間檢查資料庫中的預存程式。</span><span class="sxs-lookup"><span data-stu-id="0eb64-198">After completing the wizard, take a moment to examine the stored procedures in the database.</span></span> <span data-ttu-id="0eb64-199">您應該會看到四個新的： `Employees_Select`、`Employees_Insert`、`Employees_Update`和 `Employees_Delete`。</span><span class="sxs-lookup"><span data-stu-id="0eb64-199">You should see four new ones: `Employees_Select`, `Employees_Insert`, `Employees_Update`, and `Employees_Delete`.</span></span> <span data-ttu-id="0eb64-200">接下來，檢查 `EmployeesDataTable`，並 `EmployeesTableAdapter` 剛建立的。</span><span class="sxs-lookup"><span data-stu-id="0eb64-200">Next, inspect the `EmployeesDataTable` and `EmployeesTableAdapter` just created.</span></span> <span data-ttu-id="0eb64-201">DataTable 包含主要查詢所傳回之每個欄位的資料行。</span><span class="sxs-lookup"><span data-stu-id="0eb64-201">The DataTable contains a column for each field returned by the main query.</span></span> <span data-ttu-id="0eb64-202">按一下 [TableAdapter]，然後移至 [屬性視窗]。</span><span class="sxs-lookup"><span data-stu-id="0eb64-202">Click on the TableAdapter and then go to the Properties window.</span></span> <span data-ttu-id="0eb64-203">您會看到 [`InsertCommand`]、[`UpdateCommand`] 和 [`DeleteCommand`] 屬性已正確設定，以呼叫對應的預存程式。</span><span class="sxs-lookup"><span data-stu-id="0eb64-203">There you will see that the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties are correctly configured to call the corresponding stored procedures.</span></span>

<span data-ttu-id="0eb64-204">[![TableAdapter 包含插入、更新和刪除功能](updating-the-tableadapter-to-use-joins-cs/_static/image19.png)](updating-the-tableadapter-to-use-joins-cs/_static/image18.png)</span><span class="sxs-lookup"><span data-stu-id="0eb64-204">[![The TableAdapter Includes Insert, Update, and Delete Capabilities](updating-the-tableadapter-to-use-joins-cs/_static/image19.png)](updating-the-tableadapter-to-use-joins-cs/_static/image18.png)</span></span>

<span data-ttu-id="0eb64-205">**圖 8**： TableAdapter 包含插入、更新和刪除功能（[按一下以查看完整大小的影像](updating-the-tableadapter-to-use-joins-cs/_static/image20.png)）</span><span class="sxs-lookup"><span data-stu-id="0eb64-205">**Figure 8**: The TableAdapter Includes Insert, Update, and Delete Capabilities ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image20.png))</span></span>

<span data-ttu-id="0eb64-206">當自動建立 insert、update 和 delete 預存程式，且已正確設定 `InsertCommand`、`UpdateCommand`和 `DeleteCommand` 屬性後，我們就可以自訂 `SelectCommand` 的預存程式，以傳回每個員工經理的其他相關資訊。</span><span class="sxs-lookup"><span data-stu-id="0eb64-206">With the insert, update, and delete stored procedures automatically created and the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties correctly configured, we are ready to customize the `SelectCommand` s stored procedure to return additional information about each employee s manager.</span></span> <span data-ttu-id="0eb64-207">具體而言，我們必須更新 `Employees_Select` 預存程式，才能使用 `JOIN` 並傳回 manager s `FirstName` 和 `LastName` 值。</span><span class="sxs-lookup"><span data-stu-id="0eb64-207">Specifically, we need to update the `Employees_Select` stored procedure to use a `JOIN` and return the manager s `FirstName` and `LastName` values.</span></span> <span data-ttu-id="0eb64-208">在更新預存程式之後，我們必須更新 DataTable，使其包含這些額外的資料行。</span><span class="sxs-lookup"><span data-stu-id="0eb64-208">After the stored procedure has been updated, we will need to update the DataTable so that it includes these additional columns.</span></span> <span data-ttu-id="0eb64-209">我們將在步驟2和3中解決這兩項工作。</span><span class="sxs-lookup"><span data-stu-id="0eb64-209">We'll tackle these two tasks in Steps 2 and 3.</span></span>

## <a name="step-2-customizing-the-stored-procedure-to-include-ajoin"></a><span data-ttu-id="0eb64-210">步驟2：自訂預存程式以包含`JOIN`</span><span class="sxs-lookup"><span data-stu-id="0eb64-210">Step 2: Customizing the Stored Procedure to Include a`JOIN`</span></span>

<span data-ttu-id="0eb64-211">一開始先前往伺服器總管，向下切入 Northwind 資料庫的 [預存程式] 資料夾，然後開啟 `Employees_Select` 預存程式。</span><span class="sxs-lookup"><span data-stu-id="0eb64-211">Start by going to the Server Explorer, drilling down into the Northwind database s Stored Procedures folder, and opening the `Employees_Select` stored procedure.</span></span> <span data-ttu-id="0eb64-212">如果您看不到此預存程式，請以滑鼠右鍵按一下 [預存程式] 資料夾，然後選擇 [重新整理]。</span><span class="sxs-lookup"><span data-stu-id="0eb64-212">If you do not see this stored procedure, right-click on the Stored Procedures folder and choose Refresh.</span></span> <span data-ttu-id="0eb64-213">更新預存程式，讓它使用 `LEFT JOIN` 來傳回管理員的名字和姓氏：</span><span class="sxs-lookup"><span data-stu-id="0eb64-213">Update the stored procedure so that it uses a `LEFT JOIN` to return the manager s first and last name:</span></span>

[!code-sql[Main](updating-the-tableadapter-to-use-joins-cs/samples/sample5.sql)]

<span data-ttu-id="0eb64-214">更新 `SELECT` 語句之後，請前往 [檔案] 功能表，然後選擇 [儲存 `Employees_Select`]，以儲存變更。</span><span class="sxs-lookup"><span data-stu-id="0eb64-214">After updating the `SELECT` statement, save the changes by going to the File menu and choosing Save `Employees_Select`.</span></span> <span data-ttu-id="0eb64-215">或者，您也可以按一下工具列中的 [儲存] 圖示，或按 Ctrl + S。</span><span class="sxs-lookup"><span data-stu-id="0eb64-215">Alternatively, you can click the Save icon in the toolbar or hit Ctrl+S.</span></span> <span data-ttu-id="0eb64-216">儲存變更之後，以滑鼠右鍵按一下伺服器總管中的 `Employees_Select` 預存程式，然後選擇 [執行]。</span><span class="sxs-lookup"><span data-stu-id="0eb64-216">After saving your changes, right-click on the `Employees_Select` stored procedure in the Server Explorer and choose Execute.</span></span> <span data-ttu-id="0eb64-217">這會執行預存程式，並在 [輸出] 視窗中顯示其結果（請參閱 [圖 9]）。</span><span class="sxs-lookup"><span data-stu-id="0eb64-217">This will run the stored procedure and show its results in the Output window (see Figure 9).</span></span>

<span data-ttu-id="0eb64-218">[![預存程式結果會顯示在輸出視窗](updating-the-tableadapter-to-use-joins-cs/_static/image22.png)](updating-the-tableadapter-to-use-joins-cs/_static/image21.png)</span><span class="sxs-lookup"><span data-stu-id="0eb64-218">[![The Stored Procedures Results are Displayed in the Output Window](updating-the-tableadapter-to-use-joins-cs/_static/image22.png)](updating-the-tableadapter-to-use-joins-cs/_static/image21.png)</span></span>

<span data-ttu-id="0eb64-219">**圖 9**：預存程式結果會顯示在輸出視窗中（[按一下以查看完整大小的影像](updating-the-tableadapter-to-use-joins-cs/_static/image23.png)）</span><span class="sxs-lookup"><span data-stu-id="0eb64-219">**Figure 9**: The Stored Procedures Results are Displayed in the Output Window ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image23.png))</span></span>

## <a name="step-3-updating-the-datatable-s-columns"></a><span data-ttu-id="0eb64-220">步驟3：更新 DataTable 的資料行</span><span class="sxs-lookup"><span data-stu-id="0eb64-220">Step 3: Updating the DataTable s Columns</span></span>

<span data-ttu-id="0eb64-221">此時，`Employees_Select` 預存程式會傳回 `ManagerFirstName` 和 `ManagerLastName` 值，但 `EmployeesDataTable` 遺漏了這些資料行。</span><span class="sxs-lookup"><span data-stu-id="0eb64-221">At this point, the `Employees_Select` stored procedure returns `ManagerFirstName` and `ManagerLastName` values, but the `EmployeesDataTable` is missing these columns.</span></span> <span data-ttu-id="0eb64-222">這些遺漏的資料行可以透過下列兩種方式的其中一種來加入至 DataTable：</span><span class="sxs-lookup"><span data-stu-id="0eb64-222">These missing columns can be added to the DataTable in one of two ways:</span></span>

- <span data-ttu-id="0eb64-223">以**手動**方式在 DataSet 設計工具中，以滑鼠右鍵按一下 DataTable，然後從 [加入] 功能表選擇 [資料行]。</span><span class="sxs-lookup"><span data-stu-id="0eb64-223">**Manually** - right-click on the DataTable in the DataSet Designer and, from the Add menu, choose Column.</span></span> <span data-ttu-id="0eb64-224">接著，您可以將資料行命名，並據以設定其屬性。</span><span class="sxs-lookup"><span data-stu-id="0eb64-224">You can then name the column and set its properties accordingly.</span></span>
- <span data-ttu-id="0eb64-225">**自動**-TableAdapter 設定 wizard 會更新 DataTable s 資料行，以反映 `SelectCommand` 預存程式所傳回的欄位。</span><span class="sxs-lookup"><span data-stu-id="0eb64-225">**Automatically** - the TableAdapter Configuration wizard will update the DataTable s columns to reflect the fields returned by the `SelectCommand` stored procedure.</span></span> <span data-ttu-id="0eb64-226">使用臨機操作 SQL 語句時，此 wizard 也會移除 `InsertCommand`、`UpdateCommand`和 `DeleteCommand` 屬性，因為 `SelectCommand` 現在包含 `JOIN`。</span><span class="sxs-lookup"><span data-stu-id="0eb64-226">When using ad-hoc SQL statements, the wizard will also remove the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties since the `SelectCommand` now contains a `JOIN`.</span></span> <span data-ttu-id="0eb64-227">但是在使用預存程式時，這些命令屬性會維持不變。</span><span class="sxs-lookup"><span data-stu-id="0eb64-227">But when using stored procedures, these command properties remain intact.</span></span>

<span data-ttu-id="0eb64-228">我們已在先前的教學課程中探索手動新增 DataTable 資料行，包括[主要/詳細資料，使用具有詳細資料 DataList](../filtering-scenarios-with-the-datalist-and-repeater/master-detail-using-a-bulleted-list-of-master-records-with-a-details-datalist-cs.md)和[上傳](../working-with-binary-files/uploading-files-cs.md)檔案的主要記錄項目符號清單，我們將在下一個教學課程中更詳細地查看此程式。</span><span class="sxs-lookup"><span data-stu-id="0eb64-228">We have explored manually adding DataTable columns in previous tutorials, including [Master/Detail Using a Bulleted List of Master Records with a Details DataList](../filtering-scenarios-with-the-datalist-and-repeater/master-detail-using-a-bulleted-list-of-master-records-with-a-details-datalist-cs.md) and [Uploading Files](../working-with-binary-files/uploading-files-cs.md), and we will look at this process again in more detail in our next tutorial.</span></span> <span data-ttu-id="0eb64-229">不過，在本教學課程中，我們會透過 TableAdapter 設定 wizard 來使用自動方法。</span><span class="sxs-lookup"><span data-stu-id="0eb64-229">For this tutorial, however, let s use the automatic approach via the TableAdapter Configuration wizard.</span></span>

<span data-ttu-id="0eb64-230">首先，以滑鼠右鍵按一下 `EmployeesTableAdapter`，然後從內容功能表中選取 [設定]。</span><span class="sxs-lookup"><span data-stu-id="0eb64-230">Start by right-clicking on the `EmployeesTableAdapter` and selecting Configure from the context menu.</span></span> <span data-ttu-id="0eb64-231">這會顯示 [TableAdapter 設定向導]，其中列出用來選取、插入、更新和刪除的預存程式，以及其傳回值和參數（如果有的話）。</span><span class="sxs-lookup"><span data-stu-id="0eb64-231">This brings up the TableAdapter Configuration wizard, which lists the stored procedures used for selecting, inserting, updating, and deleting, along with their return values and parameters (if any).</span></span> <span data-ttu-id="0eb64-232">[圖 10] 顯示此嚮導。</span><span class="sxs-lookup"><span data-stu-id="0eb64-232">Figure 10 shows this wizard.</span></span> <span data-ttu-id="0eb64-233">在這裡，我們可以看到 `Employees_Select` 預存程式現在會傳回 `ManagerFirstName` 和 `ManagerLastName` 欄位。</span><span class="sxs-lookup"><span data-stu-id="0eb64-233">Here we can see that the `Employees_Select` stored procedure now returns the `ManagerFirstName` and `ManagerLastName` fields.</span></span>

<span data-ttu-id="0eb64-234">[![嚮導會顯示 Employees_Select 預存程式的已更新資料行清單](updating-the-tableadapter-to-use-joins-cs/_static/image25.png)](updating-the-tableadapter-to-use-joins-cs/_static/image24.png)</span><span class="sxs-lookup"><span data-stu-id="0eb64-234">[![The Wizard Shows the Updated Column List for the Employees_Select Stored Procedure](updating-the-tableadapter-to-use-joins-cs/_static/image25.png)](updating-the-tableadapter-to-use-joins-cs/_static/image24.png)</span></span>

<span data-ttu-id="0eb64-235">**圖 10**：此 Wizard 會顯示 `Employees_Select` 預存程式的已更新資料行清單（[按一下以查看完整大小的影像](updating-the-tableadapter-to-use-joins-cs/_static/image26.png)）</span><span class="sxs-lookup"><span data-stu-id="0eb64-235">**Figure 10**: The Wizard Shows the Updated Column List for the `Employees_Select` Stored Procedure ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image26.png))</span></span>

<span data-ttu-id="0eb64-236">按一下 [完成] 以完成嚮導。</span><span class="sxs-lookup"><span data-stu-id="0eb64-236">Complete the wizard by clicking Finish.</span></span> <span data-ttu-id="0eb64-237">回到 DataSet 設計工具時，`EmployeesDataTable` 包含兩個額外的資料行： `ManagerFirstName` 和 `ManagerLastName`。</span><span class="sxs-lookup"><span data-stu-id="0eb64-237">Upon returning to the DataSet Designer, the `EmployeesDataTable` includes two additional columns: `ManagerFirstName` and `ManagerLastName`.</span></span>

<span data-ttu-id="0eb64-238">[![EmployeesDataTable 包含兩個新的資料行](updating-the-tableadapter-to-use-joins-cs/_static/image28.png)](updating-the-tableadapter-to-use-joins-cs/_static/image27.png)</span><span class="sxs-lookup"><span data-stu-id="0eb64-238">[![The EmployeesDataTable Contains Two New Columns](updating-the-tableadapter-to-use-joins-cs/_static/image28.png)](updating-the-tableadapter-to-use-joins-cs/_static/image27.png)</span></span>

<span data-ttu-id="0eb64-239">**圖 11**： `EmployeesDataTable` 包含兩個新的資料行（[按一下以查看完整大小的影像](updating-the-tableadapter-to-use-joins-cs/_static/image29.png)）</span><span class="sxs-lookup"><span data-stu-id="0eb64-239">**Figure 11**: The `EmployeesDataTable` Contains Two New Columns ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image29.png))</span></span>

<span data-ttu-id="0eb64-240">為了說明已更新的 `Employees_Select` 預存程式已生效，而且 TableAdapter 的插入、更新和刪除功能仍可正常運作，請建立可讓使用者查看及刪除員工的網頁。</span><span class="sxs-lookup"><span data-stu-id="0eb64-240">To illustrate that the updated `Employees_Select` stored procedure is in effect and that the insert, update, and delete capabilities of the TableAdapter are still functional, let s create a web page that allows users to view and delete employees.</span></span> <span data-ttu-id="0eb64-241">不過，在建立這類頁面之前，我們必須先在商務邏輯層中建立新的類別，以便與 `NorthwindWithSprocs` 資料集中的員工合作。</span><span class="sxs-lookup"><span data-stu-id="0eb64-241">Before we create such a page, however, we need to first create a new class in the Business Logic Layer for working with employees from the `NorthwindWithSprocs` DataSet.</span></span> <span data-ttu-id="0eb64-242">在步驟4中，我們將建立 `EmployeesBLLWithSprocs` 類別。</span><span class="sxs-lookup"><span data-stu-id="0eb64-242">In Step 4, we will create an `EmployeesBLLWithSprocs` class.</span></span> <span data-ttu-id="0eb64-243">在步驟5中，我們將從 ASP.NET 網頁使用這個類別。</span><span class="sxs-lookup"><span data-stu-id="0eb64-243">In Step 5, we will use this class from an ASP.NET page.</span></span>

## <a name="step-4-implementing-the-business-logic-layer"></a><span data-ttu-id="0eb64-244">步驟4：執行商務邏輯層</span><span class="sxs-lookup"><span data-stu-id="0eb64-244">Step 4: Implementing the Business Logic Layer</span></span>

<span data-ttu-id="0eb64-245">在名為 `EmployeesBLLWithSprocs.cs`的 `~/App_Code/BLL` 資料夾中建立新的類別檔案。</span><span class="sxs-lookup"><span data-stu-id="0eb64-245">Create a new class file in the `~/App_Code/BLL` folder named `EmployeesBLLWithSprocs.cs`.</span></span> <span data-ttu-id="0eb64-246">這個類別會模擬現有 `EmployeesBLL` 類別的語義，只有這個新的方法會提供較少的方法，並使用 `NorthwindWithSprocs` 的資料集（而不是 `Northwind` 的資料集）。</span><span class="sxs-lookup"><span data-stu-id="0eb64-246">This class mimics the semantics of the existing `EmployeesBLL` class, only this new one provides fewer methods and uses the `NorthwindWithSprocs` DataSet (instead of the `Northwind` DataSet).</span></span> <span data-ttu-id="0eb64-247">將下列程式碼加入 `EmployeesBLLWithSprocs` 類別。</span><span class="sxs-lookup"><span data-stu-id="0eb64-247">Add the following code to the `EmployeesBLLWithSprocs` class.</span></span>

[!code-csharp[Main](updating-the-tableadapter-to-use-joins-cs/samples/sample6.cs)]

<span data-ttu-id="0eb64-248">`EmployeesBLLWithSprocs` class s `Adapter` 屬性會傳回 `NorthwindWithSprocs` 資料集 `EmployeesTableAdapter`的實例。</span><span class="sxs-lookup"><span data-stu-id="0eb64-248">The `EmployeesBLLWithSprocs` class s `Adapter` property returns an instance of the `NorthwindWithSprocs` DataSet s `EmployeesTableAdapter`.</span></span> <span data-ttu-id="0eb64-249">這是由類別的 `GetEmployees` 和 `DeleteEmployee` 方法所使用。</span><span class="sxs-lookup"><span data-stu-id="0eb64-249">This is used by the class s `GetEmployees` and `DeleteEmployee` methods.</span></span> <span data-ttu-id="0eb64-250">`GetEmployees` 方法會呼叫對應 `GetEmployees` 方法的 `EmployeesTableAdapter`，它會叫用 `Employees_Select` 預存程式，並在 `EmployeeDataTable`中填入其結果。</span><span class="sxs-lookup"><span data-stu-id="0eb64-250">The `GetEmployees` method calls the `EmployeesTableAdapter` s corresponding `GetEmployees` method, which invokes the `Employees_Select` stored procedure and populates its results in an `EmployeeDataTable`.</span></span> <span data-ttu-id="0eb64-251">`DeleteEmployee` 方法同樣會呼叫 `EmployeesTableAdapter` s `Delete` 方法，這會叫用 `Employees_Delete` 預存程式。</span><span class="sxs-lookup"><span data-stu-id="0eb64-251">The `DeleteEmployee` method similarly calls the `EmployeesTableAdapter` s `Delete` method, which invokes the `Employees_Delete` stored procedure.</span></span>

## <a name="step-5-working-with-the-data-in-the-presentation-layer"></a><span data-ttu-id="0eb64-252">步驟5：使用展示層中的資料</span><span class="sxs-lookup"><span data-stu-id="0eb64-252">Step 5: Working with the Data in the Presentation Layer</span></span>

<span data-ttu-id="0eb64-253">完成 `EmployeesBLLWithSprocs` 類別之後，我們就可以透過 ASP.NET 網頁來準備使用員工資料。</span><span class="sxs-lookup"><span data-stu-id="0eb64-253">With the `EmployeesBLLWithSprocs` class complete, we re ready to work with employee data through an ASP.NET page.</span></span> <span data-ttu-id="0eb64-254">開啟 [`AdvancedDAL`] 資料夾中的 [`JOINs.aspx`] 頁面，並將 GridView 從 [工具箱] 拖曳至設計工具，將其 `ID` 屬性設定為 [`Employees`]。</span><span class="sxs-lookup"><span data-stu-id="0eb64-254">Open the `JOINs.aspx` page in the `AdvancedDAL` folder and drag a GridView from the Toolbox onto the Designer, setting its `ID` property to `Employees`.</span></span> <span data-ttu-id="0eb64-255">接下來，從 GridView 的智慧標籤，將方格系結至名為 `EmployeesDataSource`的新 ObjectDataSource 控制項。</span><span class="sxs-lookup"><span data-stu-id="0eb64-255">Next, from the GridView s smart tag, bind the grid to a new ObjectDataSource control named `EmployeesDataSource`.</span></span>

<span data-ttu-id="0eb64-256">將 ObjectDataSource 設定為使用 `EmployeesBLLWithSprocs` 類別，並從 [選取] 和 [刪除] 索引標籤，確定已從下拉式清單中選取 [`GetEmployees`] 和 [`DeleteEmployee`] 方法。</span><span class="sxs-lookup"><span data-stu-id="0eb64-256">Configure the ObjectDataSource to use the `EmployeesBLLWithSprocs` class and, from the SELECT and DELETE tabs, ensure that the `GetEmployees` and `DeleteEmployee` methods are selected from the drop-down lists.</span></span> <span data-ttu-id="0eb64-257">按一下 [完成] 以完成 ObjectDataSource s 設定。</span><span class="sxs-lookup"><span data-stu-id="0eb64-257">Click Finish to complete the ObjectDataSource s configuration.</span></span>

<span data-ttu-id="0eb64-258">[![將 ObjectDataSource 設定為使用 EmployeesBLLWithSprocs 類別](updating-the-tableadapter-to-use-joins-cs/_static/image31.png)](updating-the-tableadapter-to-use-joins-cs/_static/image30.png)</span><span class="sxs-lookup"><span data-stu-id="0eb64-258">[![Configure the ObjectDataSource to Use the EmployeesBLLWithSprocs Class](updating-the-tableadapter-to-use-joins-cs/_static/image31.png)](updating-the-tableadapter-to-use-joins-cs/_static/image30.png)</span></span>

<span data-ttu-id="0eb64-259">**圖 12**：設定 ObjectDataSource 使用 `EmployeesBLLWithSprocs` 類別（[按一下以觀看完整大小的影像](updating-the-tableadapter-to-use-joins-cs/_static/image32.png)）</span><span class="sxs-lookup"><span data-stu-id="0eb64-259">**Figure 12**: Configure the ObjectDataSource to Use the `EmployeesBLLWithSprocs` Class ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image32.png))</span></span>

<span data-ttu-id="0eb64-260">[![具有 ObjectDataSource，請使用 GetEmployees 和 DeleteEmployee 方法](updating-the-tableadapter-to-use-joins-cs/_static/image34.png)](updating-the-tableadapter-to-use-joins-cs/_static/image33.png)</span><span class="sxs-lookup"><span data-stu-id="0eb64-260">[![Have the ObjectDataSource Use the GetEmployees and DeleteEmployee Methods](updating-the-tableadapter-to-use-joins-cs/_static/image34.png)](updating-the-tableadapter-to-use-joins-cs/_static/image33.png)</span></span>

<span data-ttu-id="0eb64-261">**圖 13**：讓 ObjectDataSource 使用 `GetEmployees` 和 `DeleteEmployee` 方法（[按一下以查看完整大小的影像](updating-the-tableadapter-to-use-joins-cs/_static/image35.png)）</span><span class="sxs-lookup"><span data-stu-id="0eb64-261">**Figure 13**: Have the ObjectDataSource Use the `GetEmployees` and `DeleteEmployee` Methods ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image35.png))</span></span>

<span data-ttu-id="0eb64-262">Visual Studio 會針對每個 `EmployeesDataTable` s 資料行，將 BoundField 加入至 GridView。</span><span class="sxs-lookup"><span data-stu-id="0eb64-262">Visual Studio will add a BoundField to the GridView for each of the `EmployeesDataTable` s columns.</span></span> <span data-ttu-id="0eb64-263">除了 `Title`、`LastName`、`FirstName`、`ManagerFirstName`和 `ManagerLastName` 以外，移除所有這些 BoundFields，並將最後四個 BoundFields 的 `HeaderText` 屬性分別重新命名為 last name、First name、Manager s First Name 和 Manager s 姓。</span><span class="sxs-lookup"><span data-stu-id="0eb64-263">Remove all of these BoundFields except for `Title`, `LastName`, `FirstName`, `ManagerFirstName`, and `ManagerLastName` and rename the `HeaderText` properties for the last four BoundFields to Last Name, First Name, Manager s First Name, and Manager s Last Name, respectively.</span></span>

<span data-ttu-id="0eb64-264">若要讓使用者能夠從這個頁面刪除員工，我們必須做兩件事。</span><span class="sxs-lookup"><span data-stu-id="0eb64-264">To allow users to delete employees from this page we need to do two things.</span></span> <span data-ttu-id="0eb64-265">首先，請檢查 GridView 以提供刪除功能，方法是從其智慧標籤中核取 [啟用刪除] 選項。</span><span class="sxs-lookup"><span data-stu-id="0eb64-265">First, instruct the GridView to provide deleting capabilities by checking the Enable Deleting option from its smart tag.</span></span> <span data-ttu-id="0eb64-266">第二，將 objectdatasource s `OldValuesParameterFormatString` 屬性從 ObjectDataSource wizard （`original_{0}`）所設定的值變更為其預設值（`{0}`）。</span><span class="sxs-lookup"><span data-stu-id="0eb64-266">Second, change the ObjectDataSource s `OldValuesParameterFormatString` property from the value set by the ObjectDataSource wizard (`original_{0}`) to its default value (`{0}`).</span></span> <span data-ttu-id="0eb64-267">進行這些變更之後，GridView 和 ObjectDataSource 的宣告式標記看起來應該如下所示：</span><span class="sxs-lookup"><span data-stu-id="0eb64-267">After making these changes, your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](updating-the-tableadapter-to-use-joins-cs/samples/sample7.aspx)]

<span data-ttu-id="0eb64-268">透過瀏覽器造訪來測試頁面。</span><span class="sxs-lookup"><span data-stu-id="0eb64-268">Test out the page by visiting it through a browser.</span></span> <span data-ttu-id="0eb64-269">如 [圖 14] 所示，此頁面會列出每位員工和他的經理名稱（假設他們有一個）。</span><span class="sxs-lookup"><span data-stu-id="0eb64-269">As Figure 14 shows, the page will list each employee and his or her manager s name (assuming they have one).</span></span>

<span data-ttu-id="0eb64-270">[![Employees_Select 預存程式中的聯結會傳回管理員的名稱](updating-the-tableadapter-to-use-joins-cs/_static/image37.png)](updating-the-tableadapter-to-use-joins-cs/_static/image36.png)</span><span class="sxs-lookup"><span data-stu-id="0eb64-270">[![The JOIN in the Employees_Select Stored Procedure Returns the Manager s Name](updating-the-tableadapter-to-use-joins-cs/_static/image37.png)](updating-the-tableadapter-to-use-joins-cs/_static/image36.png)</span></span>

<span data-ttu-id="0eb64-271">**圖 14**： `Employees_Select` 預存程式中的 `JOIN` 會傳回管理員的名稱（[按一下以查看完整大小的影像](updating-the-tableadapter-to-use-joins-cs/_static/image38.png)）</span><span class="sxs-lookup"><span data-stu-id="0eb64-271">**Figure 14**: The `JOIN` in the `Employees_Select` Stored Procedure Returns the Manager s Name ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image38.png))</span></span>

<span data-ttu-id="0eb64-272">按一下 [刪除] 按鈕會啟動刪除工作流程，這會在 `Employees_Delete` 預存程式的執行中最後。</span><span class="sxs-lookup"><span data-stu-id="0eb64-272">Clicking the Delete button starts the deleting workflow, which culminates in the execution of the `Employees_Delete` stored procedure.</span></span> <span data-ttu-id="0eb64-273">不過，在預存程式中嘗試的 `DELETE` 語句會因為外鍵條件約束違規而失敗（請參閱 [圖 15]）。</span><span class="sxs-lookup"><span data-stu-id="0eb64-273">However, the attempted `DELETE` statement in the stored procedure fails because of a foreign key constraint violation (see Figure 15).</span></span> <span data-ttu-id="0eb64-274">具體而言，每個員工在 `Orders` 資料表中都有一筆或多筆記錄，導致刪除失敗。</span><span class="sxs-lookup"><span data-stu-id="0eb64-274">Specifically, each employee has one or more records in the `Orders` table, causing the delete to fail.</span></span>

<span data-ttu-id="0eb64-275">[![刪除具有對應訂單的員工會導致 Foreign Key 條件約束違規](updating-the-tableadapter-to-use-joins-cs/_static/image40.png)](updating-the-tableadapter-to-use-joins-cs/_static/image39.png)</span><span class="sxs-lookup"><span data-stu-id="0eb64-275">[![Deleting an Employee That has Corresponding Orders Results in a Foreign Key Constraint Violation](updating-the-tableadapter-to-use-joins-cs/_static/image40.png)](updating-the-tableadapter-to-use-joins-cs/_static/image39.png)</span></span>

<span data-ttu-id="0eb64-276">**圖 15**：刪除具有對應訂單的員工會導致外鍵條件約束違規（[按一下以查看完整大小的影像](updating-the-tableadapter-to-use-joins-cs/_static/image41.png)）</span><span class="sxs-lookup"><span data-stu-id="0eb64-276">**Figure 15**: Deleting an Employee That has Corresponding Orders Results in a Foreign Key Constraint Violation ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image41.png))</span></span>

<span data-ttu-id="0eb64-277">若要允許刪除員工，您可以：</span><span class="sxs-lookup"><span data-stu-id="0eb64-277">To allow an employee to be deleted you could:</span></span>

- <span data-ttu-id="0eb64-278">將 foreign key 條件約束更新為 cascade delete，</span><span class="sxs-lookup"><span data-stu-id="0eb64-278">Update the foreign key constraint to cascade deletes,</span></span>
- <span data-ttu-id="0eb64-279">針對您想要刪除的員工，手動刪除 `Orders` 資料表中的記錄，或</span><span class="sxs-lookup"><span data-stu-id="0eb64-279">Manually delete the records from the `Orders` table for the employee(s) you want to delete, or</span></span>
- <span data-ttu-id="0eb64-280">更新 `Employees_Delete` 預存程式，先刪除 `Orders` 資料表中的相關記錄，再刪除 `Employees` 記錄。</span><span class="sxs-lookup"><span data-stu-id="0eb64-280">Update the `Employees_Delete` stored procedure to first delete the related records from the `Orders` table before deleting the `Employees` record.</span></span> <span data-ttu-id="0eb64-281">我們已在[使用具類型資料集的現有預存程式 tableadapter](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-cs.md)教學課程中討論過這項技術。</span><span class="sxs-lookup"><span data-stu-id="0eb64-281">We discussed this technique in the [Using Existing Stored Procedures for the Typed DataSet s TableAdapters](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-cs.md) tutorial.</span></span>

<span data-ttu-id="0eb64-282">我將此做為讀者的練習。</span><span class="sxs-lookup"><span data-stu-id="0eb64-282">I leave this as an exercise for the reader.</span></span>

## <a name="summary"></a><span data-ttu-id="0eb64-283">總結</span><span class="sxs-lookup"><span data-stu-id="0eb64-283">Summary</span></span>

<span data-ttu-id="0eb64-284">使用關係資料庫時，查詢通常會從多個相關的資料表提取其資料。</span><span class="sxs-lookup"><span data-stu-id="0eb64-284">When working with relational databases, it is common for queries to pull their data from multiple, related tables.</span></span> <span data-ttu-id="0eb64-285">相互關聯的子查詢和 `JOIN` 會提供兩種不同的技術，以從查詢中的相關資料表存取資料。</span><span class="sxs-lookup"><span data-stu-id="0eb64-285">Correlated subqueries and `JOIN` s provide two different techniques for accessing data from related tables in a query.</span></span> <span data-ttu-id="0eb64-286">在先前的教學課程中，我們最常使用相互關聯的子查詢，因為 TableAdapter 無法針對涉及 `JOIN` 的查詢自動產生 `INSERT`、`UPDATE`和 `DELETE` 語句。</span><span class="sxs-lookup"><span data-stu-id="0eb64-286">In previous tutorials we most commonly made use of correlated subqueries because the TableAdapter cannot auto-generate `INSERT`, `UPDATE`, and `DELETE` statements for queries involving `JOIN` s.</span></span> <span data-ttu-id="0eb64-287">雖然可以手動提供這些值，但使用臨機操作 SQL 語句時，當 TableAdapter 設定 wizard 完成時，將會覆寫任何自訂。</span><span class="sxs-lookup"><span data-stu-id="0eb64-287">While these values can be provided manually, when using ad-hoc SQL statements any customizations will be overwritten when the TableAdapter Configuration wizard is completed.</span></span>

<span data-ttu-id="0eb64-288">幸運的是，使用預存程式所建立的 Tableadapter 不會與使用臨機操作 SQL 語句所建立的肯定脆弱度相同。</span><span class="sxs-lookup"><span data-stu-id="0eb64-288">Fortunately, TableAdapters created using stored procedures do not suffer from the same brittleness as those created using ad-hoc SQL statements.</span></span> <span data-ttu-id="0eb64-289">因此，在使用預存程式時，建立主要查詢使用 `JOIN` 的 TableAdapter 是可行的。</span><span class="sxs-lookup"><span data-stu-id="0eb64-289">Therefore, it is feasible to create a TableAdapter whose main query uses a `JOIN` when using stored procedures.</span></span> <span data-ttu-id="0eb64-290">在本教學課程中，我們已瞭解如何建立這類 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="0eb64-290">In this tutorial we saw how to create such a TableAdapter.</span></span> <span data-ttu-id="0eb64-291">我們開始使用適用于 TableAdapter s 主查詢的不 `JOIN``SELECT` 查詢，以便自動建立對應的插入、更新和刪除預存程式。</span><span class="sxs-lookup"><span data-stu-id="0eb64-291">We started by using a `JOIN`-less `SELECT` query for the TableAdapter s main query so that the corresponding insert, update, and delete stored procedures would be auto-created.</span></span> <span data-ttu-id="0eb64-292">當 TableAdapter 的初始設定完成時，我們增強了 `SelectCommand` 預存程式來使用 `JOIN` 並重新執行 [TableAdapter 設定]，以更新 `EmployeesDataTable` 的資料行。</span><span class="sxs-lookup"><span data-stu-id="0eb64-292">With the TableAdapter s initial configuration complete, we augmented the `SelectCommand` stored procedure to use a `JOIN` and re-ran the TableAdapter Configuration wizard to update the `EmployeesDataTable` s columns.</span></span>

<span data-ttu-id="0eb64-293">重新執行 TableAdapter 設定向導會自動更新 `EmployeesDataTable` 資料行，以反映 `Employees_Select` 預存程式所傳回的資料欄位。</span><span class="sxs-lookup"><span data-stu-id="0eb64-293">Re-running the TableAdapter Configuration wizard automatically updated the `EmployeesDataTable` columns to reflect the data fields returned by the `Employees_Select` stored procedure.</span></span> <span data-ttu-id="0eb64-294">或者，我們也可以將這些資料行手動新增至 DataTable。</span><span class="sxs-lookup"><span data-stu-id="0eb64-294">Alternatively, we could have added these columns manually to the DataTable.</span></span> <span data-ttu-id="0eb64-295">在下一個教學課程中，我們將探索手動將資料行加入至 DataTable。</span><span class="sxs-lookup"><span data-stu-id="0eb64-295">We will explore manually adding columns to the DataTable in the next tutorial.</span></span>

<span data-ttu-id="0eb64-296">快樂的程式設計！</span><span class="sxs-lookup"><span data-stu-id="0eb64-296">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="0eb64-297">關於作者</span><span class="sxs-lookup"><span data-stu-id="0eb64-297">About the Author</span></span>

<span data-ttu-id="0eb64-298">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，自1998起，有七個 ASP/ASP. NET 書籍和創辦人的[4GuysFromRolla.com](http://www.4guysfromrolla.com)。</span><span class="sxs-lookup"><span data-stu-id="0eb64-298">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="0eb64-299">Scott 以獨立的顧問、訓練員和作者的身分運作。</span><span class="sxs-lookup"><span data-stu-id="0eb64-299">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="0eb64-300">他的最新著作是[*在24小時內讓自己的 ASP.NET 2.0*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="0eb64-300">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="0eb64-301">他可以在mitchell@4GuysFromRolla.com觸達[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="0eb64-301">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="0eb64-302">或者透過他的 blog，可以在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)找到。</span><span class="sxs-lookup"><span data-stu-id="0eb64-302">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="0eb64-303">特別感謝</span><span class="sxs-lookup"><span data-stu-id="0eb64-303">Special Thanks To</span></span>

<span data-ttu-id="0eb64-304">本教學課程系列已由許多有用的審核者所審查。</span><span class="sxs-lookup"><span data-stu-id="0eb64-304">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="0eb64-305">本教學課程的領導審查者為 Hilton Geisenow、David Suru 和 Teresa Murphy。</span><span class="sxs-lookup"><span data-stu-id="0eb64-305">Lead reviewers for this tutorial were Hilton Geisenow, David Suru, and Teresa Murphy.</span></span> <span data-ttu-id="0eb64-306">有興趣複習我即將發行的 MSDN 文章嗎？</span><span class="sxs-lookup"><span data-stu-id="0eb64-306">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="0eb64-307">若是如此，請在mitchell@4GuysFromRolla.com的那一行下拉式[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="0eb64-307">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="0eb64-308">[上一頁](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-cs.md)
> [下一頁](adding-additional-datatable-columns-cs.md)</span><span class="sxs-lookup"><span data-stu-id="0eb64-308">[Previous](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-cs.md)
[Next](adding-additional-datatable-columns-cs.md)</span></span>
