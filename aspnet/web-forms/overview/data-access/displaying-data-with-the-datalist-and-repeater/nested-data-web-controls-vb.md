---
uid: web-forms/overview/data-access/displaying-data-with-the-datalist-and-repeater/nested-data-web-controls-vb
title: 嵌套的資料 Web 控制項（VB） |Microsoft Docs
author: rick-anderson
description: 在本教學課程中，我們將探討如何使用嵌套在另一個中繼器內的中繼器。 這些範例將說明如何將內部中繼器全部填入 d 。
ms.author: riande
ms.date: 09/13/2006
ms.assetid: 8b7fcf7b-722b-498d-a4e4-7c93701e0c95
msc.legacyurl: /web-forms/overview/data-access/displaying-data-with-the-datalist-and-repeater/nested-data-web-controls-vb
msc.type: authoredcontent
ms.openlocfilehash: c3c62ce4293498d3b325031ac9817f8935b183b2
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/28/2019
ms.locfileid: "74629674"
---
# <a name="nested-data-web-controls-vb"></a><span data-ttu-id="78ab3-104">巢狀資料 Web 控制項 (VB)</span><span class="sxs-lookup"><span data-stu-id="78ab3-104">Nested Data Web Controls (VB)</span></span>

<span data-ttu-id="78ab3-105">由[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="78ab3-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="78ab3-106">[下載範例應用程式](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_32_VB.exe)或[下載 PDF](nested-data-web-controls-vb/_static/datatutorial32vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="78ab3-106">[Download Sample App](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_32_VB.exe) or [Download PDF](nested-data-web-controls-vb/_static/datatutorial32vb1.pdf)</span></span>

> <span data-ttu-id="78ab3-107">在本教學課程中，我們將探討如何使用嵌套在另一個中繼器內的中繼器。</span><span class="sxs-lookup"><span data-stu-id="78ab3-107">In this tutorial we will explore how to use a Repeater nested inside another Repeater.</span></span> <span data-ttu-id="78ab3-108">這些範例將說明如何以宣告方式和程式設計方式填入內部中繼器。</span><span class="sxs-lookup"><span data-stu-id="78ab3-108">The examples will illustrate how to populate the inner Repeater both declaratively and programmatically.</span></span>

## <a name="introduction"></a><span data-ttu-id="78ab3-109">簡介</span><span class="sxs-lookup"><span data-stu-id="78ab3-109">Introduction</span></span>

<span data-ttu-id="78ab3-110">除了靜態 HTML 和資料系結語法，範本也可以包含 Web 控制項和使用者控制項。</span><span class="sxs-lookup"><span data-stu-id="78ab3-110">In addition to static HTML and databinding syntax, templates can also include Web controls and User Controls.</span></span> <span data-ttu-id="78ab3-111">這些 Web 控制項可以透過宣告式、資料系結語法來指派其屬性，或可在適當的伺服器端事件處理常式中以程式設計方式存取。</span><span class="sxs-lookup"><span data-stu-id="78ab3-111">These Web controls can have their properties assigned via declarative, databinding syntax, or can be accessed programmatically in the appropriate server-side event handlers.</span></span>

<span data-ttu-id="78ab3-112">藉由在範本中內嵌控制項，可以自訂和改善外觀和使用者體驗。</span><span class="sxs-lookup"><span data-stu-id="78ab3-112">By embedding controls within a template, the appearance and user experience can be customized and improved upon.</span></span> <span data-ttu-id="78ab3-113">例如，在 GridView 控制項教學課程的[使用 TemplateFields](../custom-formatting/using-templatefields-in-the-gridview-control-vb.md)中，我們已瞭解如何在 TemplateField 中加入行事曆控制項來自訂 GridView 的顯示，以顯示員工的雇用日期;在將[驗證控制項新增至編輯和插入介面](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-vb.md)和[自訂資料修改介面](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-vb.md)教學課程中，我們已瞭解如何藉由加入驗證控制項、文字方塊、dropdownlist 進行和其他 Web 控制項來自訂編輯和插入介面。</span><span class="sxs-lookup"><span data-stu-id="78ab3-113">For example, in the [Using TemplateFields in the GridView Control](../custom-formatting/using-templatefields-in-the-gridview-control-vb.md) tutorial, we saw how to customize the GridView s display by adding a Calendar control in a TemplateField to show an employee s hire date; in the [Adding Validation Controls to the Editing and Inserting Interfaces](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-vb.md) and [Customizing the Data Modification Interface](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-vb.md) tutorials, we saw how to customize the editing and inserting interfaces by adding validation controls, TextBoxes, DropDownLists, and other Web controls.</span></span>

<span data-ttu-id="78ab3-114">範本也可以包含其他資料 Web 控制項。</span><span class="sxs-lookup"><span data-stu-id="78ab3-114">Templates can also contain other data Web controls.</span></span> <span data-ttu-id="78ab3-115">也就是說，在其範本中，我們可以有一個 DataList，其中包含另一個 DataList （或重複項或 GridView 或 DetailsView 等等）。</span><span class="sxs-lookup"><span data-stu-id="78ab3-115">That is, we can have a DataList that contains another DataList (or Repeater or GridView or DetailsView, and so on) within its templates.</span></span> <span data-ttu-id="78ab3-116">這類介面的挑戰，就是將適當的資料系結至內部資料 Web 控制項。</span><span class="sxs-lookup"><span data-stu-id="78ab3-116">The challenge with such an interface is binding the appropriate data to the inner data Web control.</span></span> <span data-ttu-id="78ab3-117">有幾種不同的方法可用，範圍從使用 ObjectDataSource 的宣告式選項到程式設計方式。</span><span class="sxs-lookup"><span data-stu-id="78ab3-117">There are a few different approaches available, ranging from declarative options using the ObjectDataSource to programmatic ones.</span></span>

<span data-ttu-id="78ab3-118">在本教學課程中，我們將探討如何使用嵌套在另一個中繼器內的中繼器。</span><span class="sxs-lookup"><span data-stu-id="78ab3-118">In this tutorial we will explore how to use a Repeater nested inside another Repeater.</span></span> <span data-ttu-id="78ab3-119">外部中繼器會針對資料庫中的每個類別目錄包含一個專案，並顯示類別目錄的名稱和描述。</span><span class="sxs-lookup"><span data-stu-id="78ab3-119">The outer Repeater will contain an item for each category in the database, displaying the category s name and description.</span></span> <span data-ttu-id="78ab3-120">每個類別目錄專案的內部中繼器都會在項目符號清單中顯示屬於該類別的每個產品的資訊（請參閱 [圖 1]）。</span><span class="sxs-lookup"><span data-stu-id="78ab3-120">Each category item s inner Repeater will display information for each product belonging to that category (see Figure 1) in a bulleted list.</span></span> <span data-ttu-id="78ab3-121">我們的範例將說明如何以宣告方式和程式設計方式填入內部中繼器。</span><span class="sxs-lookup"><span data-stu-id="78ab3-121">Our examples will illustrate how to populate the inner Repeater both declaratively and programmatically.</span></span>

<span data-ttu-id="78ab3-122">[列出每個類別及其產品的 ![](nested-data-web-controls-vb/_static/image2.png)](nested-data-web-controls-vb/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="78ab3-122">[![Each Category, Along with its Products, are Listed](nested-data-web-controls-vb/_static/image2.png)](nested-data-web-controls-vb/_static/image1.png)</span></span>

<span data-ttu-id="78ab3-123">**圖 1**：會列出每個類別及其產品（[按一下以觀看完整大小的影像](nested-data-web-controls-vb/_static/image3.png)）</span><span class="sxs-lookup"><span data-stu-id="78ab3-123">**Figure 1**: Each Category, Along with its Products, are Listed ([Click to view full-size image](nested-data-web-controls-vb/_static/image3.png))</span></span>

## <a name="step-1-creating-the-category-listing"></a><span data-ttu-id="78ab3-124">步驟1：建立類別目錄清單</span><span class="sxs-lookup"><span data-stu-id="78ab3-124">Step 1: Creating the Category Listing</span></span>

<span data-ttu-id="78ab3-125">在建立使用嵌套資料 Web 控制項的網頁時，我發現，最好先設計、建立和測試最外層的資料 Web 控制項，而不必擔心內部的嵌套控制項。</span><span class="sxs-lookup"><span data-stu-id="78ab3-125">When building a page that uses nested data Web controls, I find it helpful to design, create, and test the outermost data Web control first, without even worrying about the inner nested control.</span></span> <span data-ttu-id="78ab3-126">因此，讓我們先逐步完成在列出每個類別的名稱和描述的情況下，將中繼器新增至頁面的必要步驟。</span><span class="sxs-lookup"><span data-stu-id="78ab3-126">Therefore, let s start by walking through the steps necessary to add a Repeater to the page that lists the name and description for each category.</span></span>

<span data-ttu-id="78ab3-127">一開始先開啟 [`DataListRepeaterBasics`] 資料夾中的 [`NestedControls.aspx`] 頁面，並將 [中繼器] 控制項新增至頁面，將其 `ID` 屬性設定為 [`CategoryList`]。</span><span class="sxs-lookup"><span data-stu-id="78ab3-127">Start by opening the `NestedControls.aspx` page in the `DataListRepeaterBasics` folder and add a Repeater control to the page, setting its `ID` property to `CategoryList`.</span></span> <span data-ttu-id="78ab3-128">從 [中繼器] 智慧標籤中，選擇建立名為 `CategoriesDataSource`的新 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="78ab3-128">From the Repeater s smart tag, choose to create a new ObjectDataSource named `CategoriesDataSource`.</span></span>

<span data-ttu-id="78ab3-129">[![命名新的 ObjectDataSource CategoriesDataSource](nested-data-web-controls-vb/_static/image5.png)](nested-data-web-controls-vb/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="78ab3-129">[![Name the New ObjectDataSource CategoriesDataSource](nested-data-web-controls-vb/_static/image5.png)](nested-data-web-controls-vb/_static/image4.png)</span></span>

<span data-ttu-id="78ab3-130">**圖 2**：為新的 ObjectDataSource `CategoriesDataSource` 命名（[按一下以查看完整大小的影像](nested-data-web-controls-vb/_static/image6.png)）</span><span class="sxs-lookup"><span data-stu-id="78ab3-130">**Figure 2**: Name the New ObjectDataSource `CategoriesDataSource` ([Click to view full-size image](nested-data-web-controls-vb/_static/image6.png))</span></span>

<span data-ttu-id="78ab3-131">設定 ObjectDataSource，使其從 `CategoriesBLL` 類別的 `GetCategories` 方法提取其資料。</span><span class="sxs-lookup"><span data-stu-id="78ab3-131">Configure the ObjectDataSource so that it pulls its data from the `CategoriesBLL` class s `GetCategories` method.</span></span>

<span data-ttu-id="78ab3-132">[![將 ObjectDataSource 設定為使用 CategoriesBLL 類別的 GetCategories 方法](nested-data-web-controls-vb/_static/image8.png)](nested-data-web-controls-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="78ab3-132">[![Configure the ObjectDataSource to Use the CategoriesBLL Class s GetCategories Method](nested-data-web-controls-vb/_static/image8.png)](nested-data-web-controls-vb/_static/image7.png)</span></span>

<span data-ttu-id="78ab3-133">**圖 3**：設定 ObjectDataSource 使用 `CategoriesBLL` 類別的 `GetCategories` 方法（[按一下以查看完整大小的影像](nested-data-web-controls-vb/_static/image9.png)）</span><span class="sxs-lookup"><span data-stu-id="78ab3-133">**Figure 3**: Configure the ObjectDataSource to Use the `CategoriesBLL` Class s `GetCategories` Method ([Click to view full-size image](nested-data-web-controls-vb/_static/image9.png))</span></span>

<span data-ttu-id="78ab3-134">若要指定中繼器的範本內容，我們需要移至來源視圖，然後手動輸入宣告式語法。</span><span class="sxs-lookup"><span data-stu-id="78ab3-134">To specify the Repeater s template content we need to go to the Source view and manually enter the declarative syntax.</span></span> <span data-ttu-id="78ab3-135">新增 `ItemTemplate`，在 `<h4>` 專案中顯示類別目錄名稱，並在段落元素（`<p>`）中加入 category s 描述。</span><span class="sxs-lookup"><span data-stu-id="78ab3-135">Add an `ItemTemplate` that displays the category s name in an `<h4>` element and the category s description in a paragraph element (`<p>`).</span></span> <span data-ttu-id="78ab3-136">此外，讓我們使用水準規則（`<hr>`）來分隔每個類別目錄。</span><span class="sxs-lookup"><span data-stu-id="78ab3-136">Furthermore, let s separate each category with a horizontal rule (`<hr>`).</span></span> <span data-ttu-id="78ab3-137">進行這些變更之後，您的頁面應該會包含如下所示之中繼器和 ObjectDataSource 的宣告式語法：</span><span class="sxs-lookup"><span data-stu-id="78ab3-137">After making these changes your page should contain declarative syntax for the Repeater and ObjectDataSource that is similar to the following:</span></span>

[!code-aspx[Main](nested-data-web-controls-vb/samples/sample1.aspx)]

<span data-ttu-id="78ab3-138">[圖 4] 顯示透過瀏覽器觀看的進度。</span><span class="sxs-lookup"><span data-stu-id="78ab3-138">Figure 4 shows our progress when viewed through a browser.</span></span>

<span data-ttu-id="78ab3-139">[![列出每個分類的名稱和描述，並以水準規則分隔](nested-data-web-controls-vb/_static/image11.png)](nested-data-web-controls-vb/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="78ab3-139">[![Each Category s Name and Description is Listed, Separated by a Horizontal Rule](nested-data-web-controls-vb/_static/image11.png)](nested-data-web-controls-vb/_static/image10.png)</span></span>

<span data-ttu-id="78ab3-140">**圖 4**：每個分類的名稱和描述都會列出，並以水準規則分隔（[按一下以查看完整大小的影像](nested-data-web-controls-vb/_static/image12.png)）</span><span class="sxs-lookup"><span data-stu-id="78ab3-140">**Figure 4**: Each Category s Name and Description is Listed, Separated by a Horizontal Rule ([Click to view full-size image](nested-data-web-controls-vb/_static/image12.png))</span></span>

## <a name="step-2-adding-the-nested-product-repeater"></a><span data-ttu-id="78ab3-141">步驟2：新增嵌套的產品中繼器</span><span class="sxs-lookup"><span data-stu-id="78ab3-141">Step 2: Adding the Nested Product Repeater</span></span>

<span data-ttu-id="78ab3-142">類別清單完成後，下一個工作是將「中繼器」新增至 `CategoryList` s `ItemTemplate`，以顯示屬於適當類別的產品相關資訊。</span><span class="sxs-lookup"><span data-stu-id="78ab3-142">With the category listing complete, our next task is to add a Repeater to the `CategoryList` s `ItemTemplate` that displays information about those products belonging to the appropriate category.</span></span> <span data-ttu-id="78ab3-143">有幾種方法可以抓取此內部中繼器的資料，我們很快就會探索其中兩個。</span><span class="sxs-lookup"><span data-stu-id="78ab3-143">There are a number of ways we can retrieve the data for this inner Repeater, two of which we'll explore shortly.</span></span> <span data-ttu-id="78ab3-144">現在，讓我們只在 `CategoryList` 中繼器 `ItemTemplate`內建立產品中繼器。</span><span class="sxs-lookup"><span data-stu-id="78ab3-144">For now, let s just create the products Repeater within the `CategoryList` Repeater s `ItemTemplate`.</span></span> <span data-ttu-id="78ab3-145">具體來說，讓產品中繼器在項目符號清單中顯示每個產品，其中每個清單專案都包含產品的名稱和價格。</span><span class="sxs-lookup"><span data-stu-id="78ab3-145">Specifically, let s have the product Repeater display each product in a bulleted list with each list item including the product s name and price.</span></span>

<span data-ttu-id="78ab3-146">若要建立此中繼器，我們必須以手動方式將內部中繼器的宣告式語法和範本輸入 `CategoryList` 的 `ItemTemplate`中。</span><span class="sxs-lookup"><span data-stu-id="78ab3-146">To create this Repeater we need to manually enter the inner Repeater s declarative syntax and templates into the `CategoryList` s `ItemTemplate`.</span></span> <span data-ttu-id="78ab3-147">在 `CategoryList` 中繼器 `ItemTemplate`內新增下列標記：</span><span class="sxs-lookup"><span data-stu-id="78ab3-147">Add the following markup within the `CategoryList` Repeater s `ItemTemplate`:</span></span>

[!code-aspx[Main](nested-data-web-controls-vb/samples/sample2.aspx)]

## <a name="step-3-binding-the-category-specific-products-to-the-productsbycategorylist-repeater"></a><span data-ttu-id="78ab3-148">步驟3：將類別特定的產品系結至 ProductsByCategoryList 中繼器</span><span class="sxs-lookup"><span data-stu-id="78ab3-148">Step 3: Binding the Category-Specific Products to the ProductsByCategoryList Repeater</span></span>

<span data-ttu-id="78ab3-149">如果您在此時透過瀏覽器造訪網頁，您的畫面看起來會像 [圖 4] 所示，因為我們尚未將任何資料系結至中繼器。</span><span class="sxs-lookup"><span data-stu-id="78ab3-149">If you visit the page through a browser at this point, your screen will look the same as in Figure 4 because we ve yet to bind any data to the Repeater.</span></span> <span data-ttu-id="78ab3-150">有幾種方式可以取得適當的產品記錄，並將它們系結至重複項，比其他專案更有效率。</span><span class="sxs-lookup"><span data-stu-id="78ab3-150">There are a few ways that we can grab the appropriate product records and bind them to the Repeater, some more efficient than others.</span></span> <span data-ttu-id="78ab3-151">這裡的主要挑戰是針對指定的類別，取回適當的產品。</span><span class="sxs-lookup"><span data-stu-id="78ab3-151">The main challenge here is getting back the appropriate products for the specified category.</span></span>

<span data-ttu-id="78ab3-152">要系結至內部重複項控制項的資料，可以透過 `CategoryList` 中繼器 s `ItemTemplate`中的 ObjectDataSource 或以程式設計方式，從 ASP.NET 網頁的程式碼後置頁面進行存取。</span><span class="sxs-lookup"><span data-stu-id="78ab3-152">The data to bind to the inner Repeater control can either be accessed declaratively, through an ObjectDataSource in the `CategoryList` Repeater s `ItemTemplate`, or programmatically, from the ASP.NET page s code-behind page.</span></span> <span data-ttu-id="78ab3-153">同樣地，這項資料可以透過宣告方式，系結至內部中繼器 `DataSourceID` 屬性，或透過宣告式資料系結語法或以程式設計方式系結至內部的 Repeater，方法是在 `CategoryList` 中繼器 s `ItemDataBound` 事件處理常式中參考內部中繼器，以程式設計方式設定其 `DataSource` 屬性，並呼叫其 `DataBind()` 方法。</span><span class="sxs-lookup"><span data-stu-id="78ab3-153">Similarly, this data can be bound to the inner Repeater either declaratively - through the inner Repeater s `DataSourceID` property or through declarative databinding syntax or programmatically by referencing the inner Repeater in the `CategoryList` Repeater s `ItemDataBound` event handler, programmatically setting its `DataSource` property, and calling its `DataBind()` method.</span></span> <span data-ttu-id="78ab3-154">讓我們來探索每一種方法。</span><span class="sxs-lookup"><span data-stu-id="78ab3-154">Let s explore each of these approaches.</span></span>

## <a name="accessing-the-data-declaratively-with-an-objectdatasource-control-and-theitemdataboundevent-handler"></a><span data-ttu-id="78ab3-155">使用 ObjectDataSource 控制項和`ItemDataBound`事件處理常式以宣告方式存取資料</span><span class="sxs-lookup"><span data-stu-id="78ab3-155">Accessing the Data Declaratively with an ObjectDataSource Control and the`ItemDataBound`Event Handler</span></span>

<span data-ttu-id="78ab3-156">由於我們已在整個教學課程系列中廣泛使用 ObjectDataSource，因此在此範例中，存取資料最自然的選擇是要堅持 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="78ab3-156">Since we ve used the ObjectDataSource extensively throughout this tutorial series, the most natural choice for accessing data for this example is to stick with the ObjectDataSource.</span></span> <span data-ttu-id="78ab3-157">`ProductsBLL` 類別具有 `GetProductsByCategoryID(categoryID)` 方法，會傳回屬於指定 *`categoryID`* 之產品的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="78ab3-157">The `ProductsBLL` class has a `GetProductsByCategoryID(categoryID)` method that returns information about those products that belong to the specified *`categoryID`*.</span></span> <span data-ttu-id="78ab3-158">因此，我們可以將 ObjectDataSource 新增至 `CategoryList` 的中繼器 `ItemTemplate`，並將其設定為從這個類別的方法存取其資料。</span><span class="sxs-lookup"><span data-stu-id="78ab3-158">Therefore, we can add an ObjectDataSource to the `CategoryList` Repeater s `ItemTemplate` and configure it to access its data from this class s method.</span></span>

<span data-ttu-id="78ab3-159">可惜的是，中繼器不允許透過設計檢視編輯其範本，因此我們需要手動新增這個 ObjectDataSource 控制項的宣告式語法。</span><span class="sxs-lookup"><span data-stu-id="78ab3-159">Unfortunately, the Repeater doesn t allow its templates to be edited through the Design view so we need to add the declarative syntax for this ObjectDataSource control by hand.</span></span> <span data-ttu-id="78ab3-160">下列語法顯示在新增這個新的 ObjectDataSource （`ProductsByCategoryDataSource`）之後，`CategoryList` 中繼器 `ItemTemplate`：</span><span class="sxs-lookup"><span data-stu-id="78ab3-160">The following syntax shows the `CategoryList` Repeater s `ItemTemplate` after adding this new ObjectDataSource (`ProductsByCategoryDataSource`):</span></span>

[!code-aspx[Main](nested-data-web-controls-vb/samples/sample3.aspx)]

<span data-ttu-id="78ab3-161">使用 ObjectDataSource 方法時，我們需要將 `ProductsByCategoryList` 中繼器 s `DataSourceID` 屬性設定為 ObjectDataSource 的 `ID` （`ProductsByCategoryDataSource`）。</span><span class="sxs-lookup"><span data-stu-id="78ab3-161">When using the ObjectDataSource approach we need to set the `ProductsByCategoryList` Repeater s `DataSourceID` property to the `ID` of the ObjectDataSource (`ProductsByCategoryDataSource`).</span></span> <span data-ttu-id="78ab3-162">此外，請注意，我們的 ObjectDataSource 有一個 `<asp:Parameter>` 元素，指定將傳遞至 `GetProductsByCategoryID(categoryID)` 方法的 *`categoryID`* 值。</span><span class="sxs-lookup"><span data-stu-id="78ab3-162">Also, notice that our ObjectDataSource has an `<asp:Parameter>` element that specifies the *`categoryID`* value that will be passed into the `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="78ab3-163">但是，我們要如何指定這個值呢？</span><span class="sxs-lookup"><span data-stu-id="78ab3-163">But how do we specify this value?</span></span> <span data-ttu-id="78ab3-164">在理想的情況下，我們可以使用資料系結語法來設定 `<asp:Parameter>` 元素的 `DefaultValue` 屬性，如下所示：</span><span class="sxs-lookup"><span data-stu-id="78ab3-164">Ideally, we d be able to just set the `DefaultValue` property of the `<asp:Parameter>` element using databinding syntax, like so:</span></span>

[!code-aspx[Main](nested-data-web-controls-vb/samples/sample4.aspx)]

<span data-ttu-id="78ab3-165">可惜的是，資料系結語法只有在具有 `DataBinding` 事件的控制項中才有效。</span><span class="sxs-lookup"><span data-stu-id="78ab3-165">Unfortunately, databinding syntax is only valid in controls that have a `DataBinding` event.</span></span> <span data-ttu-id="78ab3-166">`Parameter` 類別缺少這類事件，因此上述語法不合法，而且會導致執行階段錯誤。</span><span class="sxs-lookup"><span data-stu-id="78ab3-166">The `Parameter` class lacks such an event and therefore the above syntax is illegal and will result in a runtime error.</span></span>

<span data-ttu-id="78ab3-167">若要設定這個值，我們需要為 `CategoryList` 中繼器 `ItemDataBound` 事件建立事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="78ab3-167">To set this value, we need to create an event handler for the `CategoryList` Repeater s `ItemDataBound` event.</span></span> <span data-ttu-id="78ab3-168">回想一下，`ItemDataBound` 事件會針對系結至中繼器的每個專案引發一次。</span><span class="sxs-lookup"><span data-stu-id="78ab3-168">Recall that the `ItemDataBound` event fires once for each item bound to the Repeater.</span></span> <span data-ttu-id="78ab3-169">因此，每次針對外部中繼器引發此事件時，我們可以將目前的 `CategoryID` 值指派給 `ProductsByCategoryDataSource` ObjectDataSource s `CategoryID` 參數。</span><span class="sxs-lookup"><span data-stu-id="78ab3-169">Therefore, each time this event fires for the outer Repeater we can assign the current `CategoryID` value to the `ProductsByCategoryDataSource` ObjectDataSource s `CategoryID` parameter.</span></span>

<span data-ttu-id="78ab3-170">使用下列程式碼，為 `CategoryList` 中繼器 s `ItemDataBound` 事件建立事件處理常式：</span><span class="sxs-lookup"><span data-stu-id="78ab3-170">Create an event handler for the `CategoryList` Repeater s `ItemDataBound` event with the following code:</span></span>

[!code-vb[Main](nested-data-web-controls-vb/samples/sample5.vb)]

<span data-ttu-id="78ab3-171">這個事件處理常式一開始會確保我們會處理資料項目，而不是標頭、頁尾或分隔符號專案。</span><span class="sxs-lookup"><span data-stu-id="78ab3-171">This event handler starts by ensuring that we re dealing with a data item rather than the header, footer, or separator item.</span></span> <span data-ttu-id="78ab3-172">接下來，我們會參考剛系結至目前 `RepeaterItem`的實際 `CategoriesRow` 實例。</span><span class="sxs-lookup"><span data-stu-id="78ab3-172">Next, we reference the actual `CategoriesRow` instance that has just been bound to the current `RepeaterItem`.</span></span> <span data-ttu-id="78ab3-173">最後，我們會參考 `ItemTemplate` 中的 ObjectDataSource，並將其 `CategoryID` 參數值指派給目前 `RepeaterItem`的 `CategoryID`。</span><span class="sxs-lookup"><span data-stu-id="78ab3-173">Finally, we reference the ObjectDataSource in the `ItemTemplate` and assign its `CategoryID` parameter value to the `CategoryID` of the current `RepeaterItem`.</span></span>

<span data-ttu-id="78ab3-174">使用此事件處理常式，每個 `RepeaterItem` 中的 `ProductsByCategoryList` 中繼器都會系結至 `RepeaterItem` s 類別目錄中的產品。</span><span class="sxs-lookup"><span data-stu-id="78ab3-174">With this event handler, the `ProductsByCategoryList` Repeater in each `RepeaterItem` is bound to those products in the `RepeaterItem` s category.</span></span> <span data-ttu-id="78ab3-175">[圖 5] 顯示結果輸出的螢幕擷取畫面。</span><span class="sxs-lookup"><span data-stu-id="78ab3-175">Figure 5 shows a screen shot of the resulting output.</span></span>

<span data-ttu-id="78ab3-176">[![外部中繼器會列出每個類別;內部程式會列出該類別的產品](nested-data-web-controls-vb/_static/image14.png)](nested-data-web-controls-vb/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="78ab3-176">[![The Outer Repeater Lists Each Category; the Inner One Lists the Products for that Category](nested-data-web-controls-vb/_static/image14.png)](nested-data-web-controls-vb/_static/image13.png)</span></span>

<span data-ttu-id="78ab3-177">**圖 5**：外部中繼器會列出每個類別目錄;內部程式會列出該類別的產品（[按一下以查看完整大小的影像](nested-data-web-controls-vb/_static/image15.png)）</span><span class="sxs-lookup"><span data-stu-id="78ab3-177">**Figure 5**: The Outer Repeater Lists Each Category; the Inner One Lists the Products for that Category ([Click to view full-size image](nested-data-web-controls-vb/_static/image15.png))</span></span>

## <a name="accessing-the-products-by-category-data-programmatically"></a><span data-ttu-id="78ab3-178">以程式設計方式存取依類別目錄資料的產品</span><span class="sxs-lookup"><span data-stu-id="78ab3-178">Accessing the Products by Category Data Programmatically</span></span>

<span data-ttu-id="78ab3-179">我們不使用 ObjectDataSource 來抓取目前類別的產品，而是在 ASP.NET 網頁的程式碼後置類別中（或在 [`App_Code`] 資料夾或個別的類別庫專案中）建立方法，以在 `CategoryID`傳入時傳回適當的一組產品。</span><span class="sxs-lookup"><span data-stu-id="78ab3-179">Instead of using an ObjectDataSource to retrieve the products for the current category, we could create a method in our ASP.NET page s code-behind class (or in the `App_Code` folder or in a separate Class Library project) that returns the appropriate set of products when passed in a `CategoryID`.</span></span> <span data-ttu-id="78ab3-180">假設我們的 ASP.NET page s 程式碼後置類別中有這種方法，而且它的名稱為 `GetProductsInCategory(categoryID)`。</span><span class="sxs-lookup"><span data-stu-id="78ab3-180">Imagine that we had such a method in our ASP.NET page s code-behind class and that it was named `GetProductsInCategory(categoryID)`.</span></span> <span data-ttu-id="78ab3-181">有了這個方法，我們就可以使用下列宣告式語法，將目前類別目錄的產品系結至內部中繼器：</span><span class="sxs-lookup"><span data-stu-id="78ab3-181">With this method in place we could bind the products for the current category to the inner Repeater using the following declarative syntax:</span></span>

[!code-aspx[Main](nested-data-web-controls-vb/samples/sample6.aspx)]

<span data-ttu-id="78ab3-182">[中繼器] `DataSource` 屬性會使用資料系結語法來表示其資料來自 `GetProductsInCategory(categoryID)` 方法。</span><span class="sxs-lookup"><span data-stu-id="78ab3-182">The Repeater s `DataSource` property uses the databinding syntax to indicate that its data comes from the `GetProductsInCategory(categoryID)` method.</span></span> <span data-ttu-id="78ab3-183">由於 `Eval("CategoryID")` 會傳回 `Object`類型的值，因此我們會先將物件轉換成 `Integer`，再將它傳遞至 `GetProductsInCategory(categoryID)` 方法。</span><span class="sxs-lookup"><span data-stu-id="78ab3-183">Since `Eval("CategoryID")` returns a value of type `Object`, we cast the object to an `Integer` before passing it into the `GetProductsInCategory(categoryID)` method.</span></span> <span data-ttu-id="78ab3-184">請注意，透過資料系結語法存取的 `CategoryID` 是*外部*中繼器（`CategoryList`）中的 `CategoryID`，系結至 `Categories` 資料表中的記錄。</span><span class="sxs-lookup"><span data-stu-id="78ab3-184">Note that the `CategoryID` accessed here via the databinding syntax is the `CategoryID` in the *outer* Repeater (`CategoryList`), the one that s bound to the records in the `Categories` table.</span></span> <span data-ttu-id="78ab3-185">因此，我們知道 `CategoryID` 不可以是資料庫 `NULL` 值，這就是為什麼我們可以盲目地轉換 `Eval` 方法，而不需要檢查是否有 `DBNull`的處理。</span><span class="sxs-lookup"><span data-stu-id="78ab3-185">Therefore, we know that `CategoryID` cannot be a database `NULL` value, which is why we can blindly cast the `Eval` method without checking if we re dealing with a `DBNull`.</span></span>

<span data-ttu-id="78ab3-186">使用此方法時，我們必須建立 `GetProductsInCategory(categoryID)` 方法，並讓它根據提供的 *`categoryID`* 來抓取一組適當的產品。</span><span class="sxs-lookup"><span data-stu-id="78ab3-186">With this approach, we need to create the `GetProductsInCategory(categoryID)` method and have it retrieve the appropriate set of products given the supplied *`categoryID`*.</span></span> <span data-ttu-id="78ab3-187">我們可以藉由直接傳回 `ProductsBLL` class s `GetProductsByCategoryID(categoryID)` 方法所傳回的 `ProductsDataTable` 來完成這項操作。</span><span class="sxs-lookup"><span data-stu-id="78ab3-187">We can do this by simply returning the `ProductsDataTable` returned by the `ProductsBLL` class s `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="78ab3-188">讓 s 在 `NestedControls.aspx` 頁面的程式碼後置類別中建立 `GetProductsInCategory(categoryID)` 方法。</span><span class="sxs-lookup"><span data-stu-id="78ab3-188">Let s create the `GetProductsInCategory(categoryID)` method in the code-behind class for our `NestedControls.aspx` page.</span></span> <span data-ttu-id="78ab3-189">請使用下列程式碼來執行此動作：</span><span class="sxs-lookup"><span data-stu-id="78ab3-189">Do so using the following code:</span></span>

[!code-vb[Main](nested-data-web-controls-vb/samples/sample7.vb)]

<span data-ttu-id="78ab3-190">這個方法只會建立 `ProductsBLL` 方法的實例，並傳回 `GetProductsByCategoryID(categoryID)` 方法的結果。</span><span class="sxs-lookup"><span data-stu-id="78ab3-190">This method simply creates an instance of the `ProductsBLL` method and returns the results of the `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="78ab3-191">請注意，此方法必須標記 `Public` 或 `Protected`;如果方法標記為 `Private`，就無法從 ASP.NET 網頁的宣告式標記存取。</span><span class="sxs-lookup"><span data-stu-id="78ab3-191">Note that the method must be marked `Public` or `Protected`; if the method is marked `Private`, it will not be accessible from the ASP.NET page s declarative markup.</span></span>

<span data-ttu-id="78ab3-192">進行這些變更以使用這項新技術之後，請花一點時間透過瀏覽器來觀看頁面。</span><span class="sxs-lookup"><span data-stu-id="78ab3-192">After making these changes to use this new technique, take a moment to view the page through a browser.</span></span> <span data-ttu-id="78ab3-193">使用 ObjectDataSource 和 `ItemDataBound` 事件處理常式方法時，輸出應該與輸出相同（請參閱 [圖 5] 以查看螢幕擷取畫面）。</span><span class="sxs-lookup"><span data-stu-id="78ab3-193">The output should be identical to the output when using the ObjectDataSource and `ItemDataBound` event handler approach (refer back to Figure 5 to see a screen shot).</span></span>

> [!NOTE]
> <span data-ttu-id="78ab3-194">在 ASP.NET page s 程式碼後置類別中，可能看起來像 busywork 來建立 `GetProductsInCategory(categoryID)` 方法。</span><span class="sxs-lookup"><span data-stu-id="78ab3-194">It may seem like busywork to create the `GetProductsInCategory(categoryID)` method in the ASP.NET page s code-behind class.</span></span> <span data-ttu-id="78ab3-195">畢竟，這個方法只會建立 `ProductsBLL` 類別的實例，並傳回其 `GetProductsByCategoryID(categoryID)` 方法的結果。</span><span class="sxs-lookup"><span data-stu-id="78ab3-195">After all, this method simply creates an instance of the `ProductsBLL` class and returns the results of its `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="78ab3-196">為什麼不直接從內部中繼器中的資料系結語法呼叫這個方法，像是： `DataSource='<%# ProductsBLL.GetProductsByCategoryID(CType(Eval("CategoryID"), Integer)) %>'`？</span><span class="sxs-lookup"><span data-stu-id="78ab3-196">Why not just call this method directly from the databinding syntax in the inner Repeater, like: `DataSource='<%# ProductsBLL.GetProductsByCategoryID(CType(Eval("CategoryID"), Integer)) %>'`?</span></span> <span data-ttu-id="78ab3-197">雖然這個語法不適用於目前的 `ProductsBLL` 類別的執行（因為 `GetProductsByCategoryID(categoryID)` 方法是實例方法），您可以修改 `ProductsBLL` 以包含靜態 `GetProductsByCategoryID(categoryID)` 方法，或讓類別包含靜態 `Instance()` 方法，以傳回 `ProductsBLL` 類別的新實例。</span><span class="sxs-lookup"><span data-stu-id="78ab3-197">Although this syntax won't work with our current implementation of the `ProductsBLL` class (since the `GetProductsByCategoryID(categoryID)` method is an instance method), you could modify `ProductsBLL` to include a static `GetProductsByCategoryID(categoryID)` method or have the class include a static `Instance()` method to return a new instance of the `ProductsBLL` class.</span></span>

<span data-ttu-id="78ab3-198">雖然這類修改不需要 ASP.NET 網頁的程式碼後置類別中的 `GetProductsInCategory(categoryID)` 方法，但程式碼後置類別方法可讓我們更有彈性地使用所抓取的資料，如我們稍後所見。</span><span class="sxs-lookup"><span data-stu-id="78ab3-198">While such modifications would eliminate the need for the `GetProductsInCategory(categoryID)` method in the ASP.NET page s code-behind class, the code-behind class method gives us more flexibility in working with the data retrieved, as we'll see shortly.</span></span>

## <a name="retrieving-all-of-the-product-information-at-once"></a><span data-ttu-id="78ab3-199">一次取出所有產品資訊</span><span class="sxs-lookup"><span data-stu-id="78ab3-199">Retrieving All of the Product Information at Once</span></span>

<span data-ttu-id="78ab3-200">我們所檢查的兩個舊技術會藉由呼叫 `ProductsBLL` 類別的 `GetProductsByCategoryID(categoryID)` 方法（第一個方法是透過 ObjectDataSource 執行，第二個是透過程式碼後置類別中的 `GetProductsInCategory(categoryID)` 方法），來取得目前類別的產品。</span><span class="sxs-lookup"><span data-stu-id="78ab3-200">The two pervious techniques we ve examined grab those products for the current category by making a call to the `ProductsBLL` class s `GetProductsByCategoryID(categoryID)` method (the first approach did so through an ObjectDataSource, the second through the `GetProductsInCategory(categoryID)` method in the code-behind class).</span></span> <span data-ttu-id="78ab3-201">每次叫用此方法時，商務邏輯層會向下呼叫資料存取層，這會使用 SQL 語句來查詢資料庫，而此語句會從 `Products` 資料表中傳回資料列，而該資料表的 `CategoryID` 欄位符合提供的輸入參數。</span><span class="sxs-lookup"><span data-stu-id="78ab3-201">Each time this method is invoked, the Business Logic Layer calls down to the Data Access Layer, which queries the database with a SQL statement that returns rows from the `Products` table whose `CategoryID` field matches the supplied input parameter.</span></span>

<span data-ttu-id="78ab3-202">在系統中指定*n*個類別時，此方法會神經網路*n* + 1 呼叫資料庫一個資料庫查詢來取得所有類別，然後按*n*次呼叫取得每個類別的特定產品。</span><span class="sxs-lookup"><span data-stu-id="78ab3-202">Given *N* categories in the system, this approach nets *N* + 1 calls to the database one database query to get all of the categories and then *N* calls to get the products specific to each category.</span></span> <span data-ttu-id="78ab3-203">不過，我們可以只在兩個資料庫呼叫中取出所有需要的資料，以取得所有類別，另一個呼叫來取得所有的產品。</span><span class="sxs-lookup"><span data-stu-id="78ab3-203">We can, however, retrieve all the needed data in just two database calls one call to get all of the categories and another to get all of the products.</span></span> <span data-ttu-id="78ab3-204">一旦有了所有產品之後，我們就可以篩選這些產品，只有符合目前 `CategoryID` 的產品才會系結到該類別的內部中繼器。</span><span class="sxs-lookup"><span data-stu-id="78ab3-204">Once we have all of the products, we can filter those products so that only the products matching the current `CategoryID` are bound to that category s inner Repeater.</span></span>

<span data-ttu-id="78ab3-205">為了提供這項功能，我們只需要稍微修改 ASP.NET page s 程式碼後置類別中的 `GetProductsInCategory(categoryID)` 方法。</span><span class="sxs-lookup"><span data-stu-id="78ab3-205">To provide this functionality, we only need to make a slight modification to the `GetProductsInCategory(categoryID)` method in our ASP.NET page s code-behind class.</span></span> <span data-ttu-id="78ab3-206">我們可以改為先存取*所有*的產品（如果尚未存取），然後根據傳入的 `CategoryID`只傳回產品的篩選視圖，而不是盲目地傳回 `ProductsBLL` 類別的 `GetProductsByCategoryID(categoryID)` 方法的結果。</span><span class="sxs-lookup"><span data-stu-id="78ab3-206">Rather than blindly returning the results of the `ProductsBLL` class s `GetProductsByCategoryID(categoryID)` method, we can instead first access *all* of the products (if they haven't been accessed already) and then return just the filtered view of the products based on the passed-in `CategoryID`.</span></span>

[!code-vb[Main](nested-data-web-controls-vb/samples/sample8.vb)]

<span data-ttu-id="78ab3-207">請注意頁面層級變數的加入，`allProducts`。</span><span class="sxs-lookup"><span data-stu-id="78ab3-207">Note the addition of the page-level variable, `allProducts`.</span></span> <span data-ttu-id="78ab3-208">這會保留所有產品的相關資訊，並在第一次叫用 `GetProductsInCategory(categoryID)` 方法時填入。</span><span class="sxs-lookup"><span data-stu-id="78ab3-208">This holds information about all of the products and is populated the first time the `GetProductsInCategory(categoryID)` method is invoked.</span></span> <span data-ttu-id="78ab3-209">確定已建立並填入 `allProducts` 物件之後，方法會篩選 DataTable 的結果，使只有 `CategoryID` 符合指定 `CategoryID` 的資料列可以存取。</span><span class="sxs-lookup"><span data-stu-id="78ab3-209">After ensuring that the `allProducts` object has been created and populated, the method filters the DataTable s results such that only those rows whose `CategoryID` matches the specified `CategoryID` are accessible.</span></span> <span data-ttu-id="78ab3-210">這種方法可減少從*N* + 1 到2的資料庫存取次數。</span><span class="sxs-lookup"><span data-stu-id="78ab3-210">This approach reduces the number of times the database is accessed from *N* + 1 down to two.</span></span>

<span data-ttu-id="78ab3-211">這項增強功能並不會對頁面轉譯的標記引進任何變更，也不會傳回比其他方法更少的記錄。</span><span class="sxs-lookup"><span data-stu-id="78ab3-211">This enhancement does not introduce any change to the rendered markup of the page, nor does it bring back fewer records than the other approach.</span></span> <span data-ttu-id="78ab3-212">它只會減少對資料庫的呼叫次數。</span><span class="sxs-lookup"><span data-stu-id="78ab3-212">It simply reduces the number of calls to the database.</span></span>

> [!NOTE]
> <span data-ttu-id="78ab3-213">其中一個可能會直覺地減少資料庫存取的數目，確實改善效能。</span><span class="sxs-lookup"><span data-stu-id="78ab3-213">One might intuitively reason that reducing the number of database accesses would assuredly improve performance.</span></span> <span data-ttu-id="78ab3-214">不過，這可能不是這種情況。</span><span class="sxs-lookup"><span data-stu-id="78ab3-214">However, this might not be the case.</span></span> <span data-ttu-id="78ab3-215">例如，如果您有大量的產品，而其 `CategoryID` `NULL`，則呼叫 `GetProducts` 方法會傳回永遠不會顯示的產品數目。</span><span class="sxs-lookup"><span data-stu-id="78ab3-215">If you have a large number of products whose `CategoryID` is `NULL`, for example, then the call to the `GetProducts` method returns a number of products that are never displayed.</span></span> <span data-ttu-id="78ab3-216">此外，如果您只顯示類別的子集，則傳回所有產品可能會很浪費，如果您已經實頁，可能就會發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="78ab3-216">Moreover, returning all of the products can be wasteful if you re only showing a subset of the categories, which might be the case if you have implemented paging.</span></span>

<span data-ttu-id="78ab3-217">一如往常，在分析兩項技術的效能時，唯一的笑話量值是執行針對您的應用程式的常見案例所量身打造的受控制測試。</span><span class="sxs-lookup"><span data-stu-id="78ab3-217">As always, when it comes to analyzing the performance of two techniques, the only surefire measure is to run controlled tests tailored for your application s common case scenarios.</span></span>

## <a name="summary"></a><span data-ttu-id="78ab3-218">總結</span><span class="sxs-lookup"><span data-stu-id="78ab3-218">Summary</span></span>

<span data-ttu-id="78ab3-219">在本教學課程中，我們已瞭解如何將一個資料 Web 控制項放在另一個中，特別是檢查如何讓外部的重複項顯示每個類別的專案，並使用內部的重複項來列出項目符號清單中每個類別目錄的產品。</span><span class="sxs-lookup"><span data-stu-id="78ab3-219">In this tutorial we saw how to nest one data Web control within another, specifically examining how to have an outer Repeater display an item for each category with an inner Repeater listing the products for each category in a bulleted list.</span></span> <span data-ttu-id="78ab3-220">建立嵌套使用者介面的主要挑戰在於存取並將正確的資料系結至內部資料 Web 控制項。</span><span class="sxs-lookup"><span data-stu-id="78ab3-220">The main challenge in building a nested user interface lies in accessing and binding the correct data to the inner data Web control.</span></span> <span data-ttu-id="78ab3-221">有各種不同的技術，我們在本教學課程中探討了其中兩種。</span><span class="sxs-lookup"><span data-stu-id="78ab3-221">There are a variety of techniques available, two of which we examined in this tutorial.</span></span> <span data-ttu-id="78ab3-222">第一種方法是使用外部資料 Web 控制項中的 ObjectDataSource，`ItemTemplate` 透過其 `DataSourceID` 屬性系結至內部資料 Web 控制項。</span><span class="sxs-lookup"><span data-stu-id="78ab3-222">The first approach examined used an ObjectDataSource in the outer data Web control s `ItemTemplate` that was bound to the inner data Web control through its `DataSourceID` property.</span></span> <span data-ttu-id="78ab3-223">第二個技巧是透過 ASP.NET page s 程式碼後置類別中的方法來存取資料。</span><span class="sxs-lookup"><span data-stu-id="78ab3-223">The second technique accessed the data via a method in the ASP.NET page s code-behind class.</span></span> <span data-ttu-id="78ab3-224">然後，這個方法就可以透過資料系結語法，系結至內部資料 Web 控制項的 `DataSource` 屬性。</span><span class="sxs-lookup"><span data-stu-id="78ab3-224">This method can then be bound to the inner data Web control s `DataSource` property through databinding syntax.</span></span>

<span data-ttu-id="78ab3-225">雖然在本教學課程中檢查的嵌套使用者介面使用了在重複項中嵌套的重複項，但這些技術可以擴充至其他資料 Web 控制項。</span><span class="sxs-lookup"><span data-stu-id="78ab3-225">While the nested user interface examined in this tutorial used a Repeater nested within a Repeater, these techniques can be extended to the other data Web controls.</span></span> <span data-ttu-id="78ab3-226">您可以在 GridView 內或在 DataList 內的 GridView 中嵌套重複項，依此類推。</span><span class="sxs-lookup"><span data-stu-id="78ab3-226">You can nest a Repeater within a GridView, or a GridView within a DataList, and so on.</span></span>

<span data-ttu-id="78ab3-227">快樂的程式設計！</span><span class="sxs-lookup"><span data-stu-id="78ab3-227">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="78ab3-228">關於作者</span><span class="sxs-lookup"><span data-stu-id="78ab3-228">About the Author</span></span>

<span data-ttu-id="78ab3-229">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，自1998起，有七個 ASP/ASP. NET 書籍和創辦人的[4GuysFromRolla.com](http://www.4guysfromrolla.com)。</span><span class="sxs-lookup"><span data-stu-id="78ab3-229">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="78ab3-230">Scott 以獨立的顧問、訓練員和作者的身分運作。</span><span class="sxs-lookup"><span data-stu-id="78ab3-230">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="78ab3-231">他的最新著作是[*在24小時內讓自己的 ASP.NET 2.0*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="78ab3-231">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="78ab3-232">他可以在mitchell@4GuysFromRolla.com觸達[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="78ab3-232">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="78ab3-233">或者透過他的 blog，可以在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)找到。</span><span class="sxs-lookup"><span data-stu-id="78ab3-233">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="78ab3-234">特別感謝</span><span class="sxs-lookup"><span data-stu-id="78ab3-234">Special Thanks To</span></span>

<span data-ttu-id="78ab3-235">本教學課程系列已由許多有用的審核者所審查。</span><span class="sxs-lookup"><span data-stu-id="78ab3-235">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="78ab3-236">本教學課程的領導審查者為 Zack，Liz Shulok。</span><span class="sxs-lookup"><span data-stu-id="78ab3-236">Lead reviewers for this tutorial were Zack Jones and Liz Shulok.</span></span> <span data-ttu-id="78ab3-237">有興趣複習我即將發行的 MSDN 文章嗎？</span><span class="sxs-lookup"><span data-stu-id="78ab3-237">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="78ab3-238">若是如此，請在mitchell@4GuysFromRolla.com的那一行下拉式[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="78ab3-238">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> [<span data-ttu-id="78ab3-239">上一篇</span><span class="sxs-lookup"><span data-stu-id="78ab3-239">Previous</span></span>](showing-multiple-records-per-row-with-the-datalist-control-vb.md)
