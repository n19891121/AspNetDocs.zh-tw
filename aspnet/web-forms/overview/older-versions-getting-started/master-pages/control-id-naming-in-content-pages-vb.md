---
uid: web-forms/overview/older-versions-getting-started/master-pages/control-id-naming-in-content-pages-vb
title: 內容頁中的控制項識別碼命名（VB） |Microsoft Docs
author: rick-anderson
description: 說明 ContentPlaceHolder 控制項如何作為命名容器，並因此以程式設計方式使用控制項，而不容易（透過 FindControl） 。
ms.author: riande
ms.date: 06/10/2008
ms.assetid: dbb024a6-f043-4fc5-ad66-56556711875b
msc.legacyurl: /web-forms/overview/older-versions-getting-started/master-pages/control-id-naming-in-content-pages-vb
msc.type: authoredcontent
ms.openlocfilehash: 3cb8dec47040bc65f1a024325c91590729ffbdb7
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/28/2019
ms.locfileid: "74586637"
---
# <a name="control-id-naming-in-content-pages-vb"></a><span data-ttu-id="7fe20-103">內容頁中的控制項識別碼命名 (VB)</span><span class="sxs-lookup"><span data-stu-id="7fe20-103">Control ID Naming in Content Pages (VB)</span></span>

<span data-ttu-id="7fe20-104">由[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="7fe20-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="7fe20-105">[下載程式代碼](https://download.microsoft.com/download/e/e/f/eef369f5-743a-4a52-908f-b6532c4ce0a4/ASPNET_MasterPages_Tutorial_05_VB.zip)或[下載 PDF](https://download.microsoft.com/download/8/f/6/8f6349e4-6554-405a-bcd7-9b094ba5089a/ASPNET_MasterPages_Tutorial_05_VB.pdf)</span><span class="sxs-lookup"><span data-stu-id="7fe20-105">[Download Code](https://download.microsoft.com/download/e/e/f/eef369f5-743a-4a52-908f-b6532c4ce0a4/ASPNET_MasterPages_Tutorial_05_VB.zip) or [Download PDF](https://download.microsoft.com/download/8/f/6/8f6349e4-6554-405a-bcd7-9b094ba5089a/ASPNET_MasterPages_Tutorial_05_VB.pdf)</span></span>

> <span data-ttu-id="7fe20-106">說明 ContentPlaceHolder 控制項如何作為命名容器，並因此以程式設計方式使用控制項，而不容易（透過 FindControl）。</span><span class="sxs-lookup"><span data-stu-id="7fe20-106">Illustrates how ContentPlaceHolder controls serve as a naming container and therefore make programmatically working with a control difficult (via FindControl).</span></span> <span data-ttu-id="7fe20-107">查看這個問題和因應措施。</span><span class="sxs-lookup"><span data-stu-id="7fe20-107">Looks at this issue and workarounds.</span></span> <span data-ttu-id="7fe20-108">同時討論如何以程式設計方式存取產生的 ClientID 值。</span><span class="sxs-lookup"><span data-stu-id="7fe20-108">Also discusses how to programmatically access the resulting ClientID value.</span></span>

## <a name="introduction"></a><span data-ttu-id="7fe20-109">簡介</span><span class="sxs-lookup"><span data-stu-id="7fe20-109">Introduction</span></span>

<span data-ttu-id="7fe20-110">所有的 ASP.NET 伺服器控制項都包含可唯一識別控制項的 `ID` 屬性，而這是控制項在程式碼後置類別中以程式設計方式存取的方法。</span><span class="sxs-lookup"><span data-stu-id="7fe20-110">All ASP.NET server controls include an `ID` property that uniquely identifies the control and is the means by which the control is programmatically accessed in the code-behind class.</span></span> <span data-ttu-id="7fe20-111">同樣地，HTML 檔案中的元素可能會包含可唯一識別專案的 `id` 屬性;這些 `id` 值通常會在用戶端腳本中用來以程式設計方式參考特定的 HTML 專案。</span><span class="sxs-lookup"><span data-stu-id="7fe20-111">Similarly, the elements in an HTML document may include an `id` attribute that uniquely identifies the element; these `id` values are often used in client-side script to programmatically reference a particular HTML element.</span></span> <span data-ttu-id="7fe20-112">在此情況下，您可能會假設當 ASP.NET 伺服器控制項轉譯為 HTML 時，它的 `ID` 值會當做轉譯 HTML 專案的 `id` 值使用。</span><span class="sxs-lookup"><span data-stu-id="7fe20-112">Given this, you may assume that when an ASP.NET server control is rendered into HTML, its `ID` value is used as the `id` value of the rendered HTML element.</span></span> <span data-ttu-id="7fe20-113">這不一定是這樣的情況，因為在某些情況下，具有單一 `ID` 值的單一控制項可能會出現在轉譯的標記中多次。</span><span class="sxs-lookup"><span data-stu-id="7fe20-113">This is not necessarily the case because in certain circumstances a single control with a single `ID` value may appear multiple times in the rendered markup.</span></span> <span data-ttu-id="7fe20-114">假設有一個 GridView 控制項，其中包含具有 `ID` 值 `ProductName`之標籤 Web 控制項的 TemplateField。</span><span class="sxs-lookup"><span data-stu-id="7fe20-114">Consider a GridView control that includes a TemplateField with a Label Web control with an `ID` value of `ProductName`.</span></span> <span data-ttu-id="7fe20-115">當 GridView 在執行時間系結至其資料來源時，此標籤會針對每個 GridView 資料列重複一次。</span><span class="sxs-lookup"><span data-stu-id="7fe20-115">When the GridView is bound to its data source at runtime, this Label is repeated once for every GridView row.</span></span> <span data-ttu-id="7fe20-116">每個呈現的標籤都需要唯一的 `id` 值。</span><span class="sxs-lookup"><span data-stu-id="7fe20-116">Each rendered Label needs a unique `id` value.</span></span>

<span data-ttu-id="7fe20-117">為了處理這類案例，ASP.NET 允許將特定控制項表示為命名容器。</span><span class="sxs-lookup"><span data-stu-id="7fe20-117">To handle such scenarios, ASP.NET allows certain controls to be denoted as naming containers.</span></span> <span data-ttu-id="7fe20-118">命名容器可作為新的 `ID` 命名空間。</span><span class="sxs-lookup"><span data-stu-id="7fe20-118">A naming container serves as a new `ID` namespace.</span></span> <span data-ttu-id="7fe20-119">出現在命名容器中的任何伺服器控制項，其轉譯的 `id` 值前面會加上命名容器控制項的 `ID`。</span><span class="sxs-lookup"><span data-stu-id="7fe20-119">Any server controls that appear within the naming container have their rendered `id` value prefixed with the `ID` of the naming container control.</span></span> <span data-ttu-id="7fe20-120">例如，`GridView` 和 `GridViewRow` 類別都是命名容器。</span><span class="sxs-lookup"><span data-stu-id="7fe20-120">For example, the `GridView` and `GridViewRow` classes are both naming containers.</span></span> <span data-ttu-id="7fe20-121">因此，在 GridView TemplateField 中使用 `ID` `ProductName` 所定義的標籤控制項，會得到 `GridViewID_GridViewRowID_ProductName`的轉譯 `id` 值。</span><span class="sxs-lookup"><span data-stu-id="7fe20-121">Consequently, a Label control defined in a GridView TemplateField with `ID` `ProductName` is given a rendered `id` value of `GridViewID_GridViewRowID_ProductName`.</span></span> <span data-ttu-id="7fe20-122">由於*GridViewRowID*對於每個 GridView 資料列都是唯一的，因此產生的 `id` 值是唯一的。</span><span class="sxs-lookup"><span data-stu-id="7fe20-122">Because *GridViewRowID* is unique for each GridView row, the resulting `id` values are unique.</span></span>

> [!NOTE]
> <span data-ttu-id="7fe20-123">[`INamingContainer` 介面](https://msdn.microsoft.com/library/system.web.ui.inamingcontainer.aspx)是用來指出特定的 ASP.NET 伺服器控制項應該當做命名容器來運作。</span><span class="sxs-lookup"><span data-stu-id="7fe20-123">The [`INamingContainer` interface](https://msdn.microsoft.com/library/system.web.ui.inamingcontainer.aspx) is used to indicate that a particular ASP.NET server control should function as a naming container.</span></span> <span data-ttu-id="7fe20-124">`INamingContainer` 介面不會將伺服器控制項必須執行的任何方法拼出來;相反地，它是用來做為標記。</span><span class="sxs-lookup"><span data-stu-id="7fe20-124">The `INamingContainer` interface does not spell out any methods that the server control must implement; rather, it's used as a marker.</span></span> <span data-ttu-id="7fe20-125">在產生轉譯的標記時，如果控制項會執行此介面，則 ASP.NET 引擎會自動將其 `ID` 值前置到其呈現 `id` 屬性值的子代。</span><span class="sxs-lookup"><span data-stu-id="7fe20-125">In generating the rendered markup, if a control implements this interface then the ASP.NET engine automatically prefixes its `ID` value to its descendents' rendered `id` attribute values.</span></span> <span data-ttu-id="7fe20-126">在步驟2中，將會更詳細地討論此程式。</span><span class="sxs-lookup"><span data-stu-id="7fe20-126">This process is discussed in more detail in Step 2.</span></span>

<span data-ttu-id="7fe20-127">命名容器不僅會變更轉譯的 `id` 屬性值，也會影響控制項在 ASP.NET 網頁的程式碼後置類別中，如何以程式設計方式參考。</span><span class="sxs-lookup"><span data-stu-id="7fe20-127">Naming containers not only change the rendered `id` attribute value, but also affect how the control may be programmatically referenced from the ASP.NET page's code-behind class.</span></span> <span data-ttu-id="7fe20-128">`FindControl("controlID")` 方法通常用來以程式設計方式參考 Web 控制項。</span><span class="sxs-lookup"><span data-stu-id="7fe20-128">The `FindControl("controlID")` method is commonly used to programmatically reference a Web control.</span></span> <span data-ttu-id="7fe20-129">不過，`FindControl` 不會透過命名容器來進行。</span><span class="sxs-lookup"><span data-stu-id="7fe20-129">However, `FindControl` does not penetrate through naming containers.</span></span> <span data-ttu-id="7fe20-130">因此，您無法直接使用 `Page.FindControl` 方法來參考 GridView 或其他命名容器中的控制項。</span><span class="sxs-lookup"><span data-stu-id="7fe20-130">Consequently, you cannot directly use the `Page.FindControl` method to reference controls within a GridView or other naming container.</span></span>

<span data-ttu-id="7fe20-131">您可能有猜得到，主版頁面和 ContentPlaceHolders 都實作為命名容器。</span><span class="sxs-lookup"><span data-stu-id="7fe20-131">As you may have surmised, master pages and ContentPlaceHolders are both implemented as naming containers.</span></span> <span data-ttu-id="7fe20-132">在本教學課程中，我們將探討主版頁面如何影響 HTML 專案的 `id` 值，以及如何使用 `FindControl`以程式設計方式參考內容頁面中的 Web 控制項。</span><span class="sxs-lookup"><span data-stu-id="7fe20-132">In this tutorial we examine how master pages affect HTML element `id` values and ways to programmatically reference Web controls within a content page using `FindControl`.</span></span>

## <a name="step-1-adding-a-new-aspnet-page"></a><span data-ttu-id="7fe20-133">步驟1：加入新的 ASP.NET 網頁</span><span class="sxs-lookup"><span data-stu-id="7fe20-133">Step 1: Adding a New ASP.NET Page</span></span>

<span data-ttu-id="7fe20-134">為了示範本教學課程中所討論的概念，讓我們將新的 ASP.NET 網頁新增至我們的網站。</span><span class="sxs-lookup"><span data-stu-id="7fe20-134">To demonstrate the concepts discussed in this tutorial, let's add a new ASP.NET page to our website.</span></span> <span data-ttu-id="7fe20-135">在根資料夾中建立名為 `IDIssues.aspx` 的新內容頁面，並將其系結至 `Site.master` 主版頁面。</span><span class="sxs-lookup"><span data-stu-id="7fe20-135">Create a new content page named `IDIssues.aspx` in the root folder, binding it to the `Site.master` master page.</span></span>

![將內容頁 IDIssues 新增至根資料夾](control-id-naming-in-content-pages-vb/_static/image1.png)

<span data-ttu-id="7fe20-137">**圖 01**：將內容頁面 `IDIssues.aspx` 新增至根資料夾</span><span class="sxs-lookup"><span data-stu-id="7fe20-137">**Figure 01**: Add the Content Page `IDIssues.aspx` to the Root Folder</span></span>

<span data-ttu-id="7fe20-138">Visual Studio 會自動為每個主版頁面的四個 ContentPlaceHolders 建立內容控制項。</span><span class="sxs-lookup"><span data-stu-id="7fe20-138">Visual Studio automatically creates a Content control for each of the master page's four ContentPlaceHolders.</span></span> <span data-ttu-id="7fe20-139">如[*多 ContentPlaceHolders 和預設內容*](multiple-contentplaceholders-and-default-content-vb.md)教學課程中所述，如果內容控制項不存在，則會改為發出主版頁面的預設 ContentPlaceHolder 內容。</span><span class="sxs-lookup"><span data-stu-id="7fe20-139">As noted in the [*Multiple ContentPlaceHolders and Default Content*](multiple-contentplaceholders-and-default-content-vb.md) tutorial, if a Content control is not present the master page's default ContentPlaceHolder content is emitted instead.</span></span> <span data-ttu-id="7fe20-140">因為 `QuickLoginUI` 和 `LeftColumnContent` ContentPlaceHolders 包含適用于此頁面的適當預設標記，所以請繼續進行，並從 `IDIssues.aspx`移除其對應的內容控制項。</span><span class="sxs-lookup"><span data-stu-id="7fe20-140">Because the `QuickLoginUI` and `LeftColumnContent` ContentPlaceHolders contain suitable default markup for this page, go ahead and remove their corresponding Content controls from `IDIssues.aspx`.</span></span> <span data-ttu-id="7fe20-141">此時，內容頁面的宣告式標記看起來應該如下所示：</span><span class="sxs-lookup"><span data-stu-id="7fe20-141">At this point, the content page's declarative markup should look like the following:</span></span>

[!code-aspx[Main](control-id-naming-in-content-pages-vb/samples/sample1.aspx)]

<span data-ttu-id="7fe20-142">在[*主版頁面教學課程中指定標題、中繼標記和其他 HTML 標頭*](specifying-the-title-meta-tags-and-other-html-headers-in-the-master-page-vb.md)中，我們建立了自訂的基底頁面類別（`BasePage`），它會自動設定頁面的標題（如果未明確設定）。</span><span class="sxs-lookup"><span data-stu-id="7fe20-142">In the [*Specifying the Title, Meta Tags, and Other HTML Headers in the Master Page*](specifying-the-title-meta-tags-and-other-html-headers-in-the-master-page-vb.md) tutorial we created a custom base page class (`BasePage`) that automatically configures the page's title if it is not explicitly set.</span></span> <span data-ttu-id="7fe20-143">若要讓 `IDIssues.aspx` 頁面採用這項功能，頁面的程式碼後置類別必須衍生自 `BasePage` 類別（而不是 `System.Web.UI.Page`）。</span><span class="sxs-lookup"><span data-stu-id="7fe20-143">For the `IDIssues.aspx` page to employ this functionality, the page's code-behind class must derive from the `BasePage` class (instead of `System.Web.UI.Page`).</span></span> <span data-ttu-id="7fe20-144">修改程式碼後置類別的定義，使其看起來如下所示：</span><span class="sxs-lookup"><span data-stu-id="7fe20-144">Modify the code-behind class's definition so that it looks like the following:</span></span>

[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample2.vb)]

<span data-ttu-id="7fe20-145">最後，更新 `Web.sitemap` 檔案以包含此新課程的專案。</span><span class="sxs-lookup"><span data-stu-id="7fe20-145">Finally, update the `Web.sitemap` file to include an entry for this new lesson.</span></span> <span data-ttu-id="7fe20-146">新增 `<siteMapNode>` 專案，並將其 `title` 和 `url` 屬性分別設定為 [控制識別碼命名問題] 和 [`~/IDIssues.aspx`]。</span><span class="sxs-lookup"><span data-stu-id="7fe20-146">Add a `<siteMapNode>` element and set its `title` and `url` attributes to "Control ID Naming Issues" and `~/IDIssues.aspx`, respectively.</span></span> <span data-ttu-id="7fe20-147">進行這項新增之後，您的 `Web.sitemap` 檔案的標記看起來應該如下所示：</span><span class="sxs-lookup"><span data-stu-id="7fe20-147">After making this addition your `Web.sitemap` file's markup should look similar to the following:</span></span>

[!code-xml[Main](control-id-naming-in-content-pages-vb/samples/sample3.xml)]

<span data-ttu-id="7fe20-148">如 [圖 2] 所示，`Web.sitemap` 中的新網站地圖專案會立即反映在左欄的 [課程] 區段中。</span><span class="sxs-lookup"><span data-stu-id="7fe20-148">As Figure 2 illustrates, the new site map entry in `Web.sitemap` is immediately reflected in the Lessons section in the left column.</span></span>

![[課程] 區段現在包含 &quot;控制項 ID 命名問題的連結&quot;](control-id-naming-in-content-pages-vb/_static/image2.png)

<span data-ttu-id="7fe20-150">**圖 02**： [課程] 區段現在包含「控制項 ID 命名問題」的連結</span><span class="sxs-lookup"><span data-stu-id="7fe20-150">**Figure 02**: The Lessons Section Now Includes a Link to "Control ID Naming Issues"</span></span>

## <a name="step-2-examining-the-renderedidchanges"></a><span data-ttu-id="7fe20-151">步驟2：檢查呈現的`ID`變更</span><span class="sxs-lookup"><span data-stu-id="7fe20-151">Step 2: Examining the Rendered`ID`Changes</span></span>

<span data-ttu-id="7fe20-152">為了進一步瞭解 ASP.NET 引擎對伺服器控制項轉譯的 `id` 值所做的修改，讓我們將幾個 Web 控制項新增至 [`IDIssues.aspx`] 頁面，然後再查看傳送至瀏覽器的轉譯標記。</span><span class="sxs-lookup"><span data-stu-id="7fe20-152">To better understand the modifications the ASP.NET engine makes to the rendered `id` values of server controls, let's add a few Web controls to the `IDIssues.aspx` page and then view the rendered markup sent to the browser.</span></span> <span data-ttu-id="7fe20-153">具體來說，請輸入「請輸入您的年齡：」文字，後面接著 TextBox Web 控制項。</span><span class="sxs-lookup"><span data-stu-id="7fe20-153">Specifically, type in the text "Please enter your age:" followed by a TextBox Web control.</span></span> <span data-ttu-id="7fe20-154">在頁面上進一步向下新增按鈕 Web 控制項和標籤 Web 控制項。</span><span class="sxs-lookup"><span data-stu-id="7fe20-154">Further down on the page add a Button Web control and a Label Web control.</span></span> <span data-ttu-id="7fe20-155">將 TextBox 的 `ID` 和 `Columns` 屬性分別設定為 [`Age`] 和 [3]。</span><span class="sxs-lookup"><span data-stu-id="7fe20-155">Set the TextBox's `ID` and `Columns` properties to `Age` and 3, respectively.</span></span> <span data-ttu-id="7fe20-156">將按鈕的 [`Text`] 和 [`ID` 屬性] 設定為 [提交] 和 [`SubmitButton`]。</span><span class="sxs-lookup"><span data-stu-id="7fe20-156">Set the Button's `Text` and `ID` properties to "Submit" and `SubmitButton`.</span></span> <span data-ttu-id="7fe20-157">清除標籤的 [`Text`] 屬性，並將其 `ID` 設定為 [`Results`]。</span><span class="sxs-lookup"><span data-stu-id="7fe20-157">Clear out the Label's `Text` property and set its `ID` to `Results`.</span></span>

<span data-ttu-id="7fe20-158">此時，內容控制項的宣告式標記看起來應該如下所示：</span><span class="sxs-lookup"><span data-stu-id="7fe20-158">At this point your Content control's declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](control-id-naming-in-content-pages-vb/samples/sample4.aspx)]

<span data-ttu-id="7fe20-159">[圖 3] 顯示透過 Visual Studio 的設計工具觀看的頁面。</span><span class="sxs-lookup"><span data-stu-id="7fe20-159">Figure 3 shows the page when viewed through Visual Studio's designer.</span></span>

<span data-ttu-id="7fe20-160">[![頁面包含三個 Web 控制項：文字方塊、按鈕和標籤](control-id-naming-in-content-pages-vb/_static/image4.png)](control-id-naming-in-content-pages-vb/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="7fe20-160">[![The Page Includes Three Web Controls: a TextBox, Button, and Label](control-id-naming-in-content-pages-vb/_static/image4.png)](control-id-naming-in-content-pages-vb/_static/image3.png)</span></span>

<span data-ttu-id="7fe20-161">**圖 03**：此頁面包含三個 Web 控制項： [TextBox]、[Button] 和 [標籤] （[按一下以查看完整大小的影像](control-id-naming-in-content-pages-vb/_static/image5.png)）</span><span class="sxs-lookup"><span data-stu-id="7fe20-161">**Figure 03**: The Page Includes Three Web Controls: a TextBox, Button, and Label  ([Click to view full-size image](control-id-naming-in-content-pages-vb/_static/image5.png))</span></span>

<span data-ttu-id="7fe20-162">透過瀏覽器造訪頁面，然後觀看 HTML 原始檔。</span><span class="sxs-lookup"><span data-stu-id="7fe20-162">Visit the page through a browser and then view the HTML source.</span></span> <span data-ttu-id="7fe20-163">如下列標記所示，TextBox、Button 和 Label Web 控制項之 HTML 專案的 `id` 值是 Web 控制項 `ID` 值的組合，以及頁面中命名容器的 `ID` 值。</span><span class="sxs-lookup"><span data-stu-id="7fe20-163">As the markup below shows, the `id` values of the HTML elements for the TextBox, Button, and Label Web controls are a combination of the `ID` values of the Web controls and the `ID` values of the naming containers in the page.</span></span>

[!code-html[Main](control-id-naming-in-content-pages-vb/samples/sample5.html)]

<span data-ttu-id="7fe20-164">如本教學課程稍早所述，主版頁面和其 ContentPlaceHolders 都作為命名容器。</span><span class="sxs-lookup"><span data-stu-id="7fe20-164">As noted earlier in this tutorial, both the master page and its ContentPlaceHolders serve as naming containers.</span></span> <span data-ttu-id="7fe20-165">因此，兩者都會提供其嵌套控制項的呈現 `ID` 值。</span><span class="sxs-lookup"><span data-stu-id="7fe20-165">Consequently, both contribute the rendered `ID` values of their nested controls.</span></span> <span data-ttu-id="7fe20-166">採用 TextBox 的 `id` 屬性，例如： `ctl00_MainContent_Age`。</span><span class="sxs-lookup"><span data-stu-id="7fe20-166">Take the TextBox's `id` attribute, for instance: `ctl00_MainContent_Age`.</span></span> <span data-ttu-id="7fe20-167">回想一下 TextBox 控制項的 `ID` 值是 `Age`。</span><span class="sxs-lookup"><span data-stu-id="7fe20-167">Recall that the TextBox control's `ID` value was `Age`.</span></span> <span data-ttu-id="7fe20-168">其前面會加上其 ContentPlaceHolder 控制項的 `ID` 值，`MainContent`。</span><span class="sxs-lookup"><span data-stu-id="7fe20-168">This is prefixed with its ContentPlaceHolder control's `ID` value, `MainContent`.</span></span> <span data-ttu-id="7fe20-169">此外，此值的前面會加上主版頁面的 `ID` 值，`ctl00`。</span><span class="sxs-lookup"><span data-stu-id="7fe20-169">Furthermore, this value is prefixed with the master page's `ID` value, `ctl00`.</span></span> <span data-ttu-id="7fe20-170">淨效果是由主版頁面、ContentPlaceHolder 控制項和 TextBox 本身的 `ID` 值所組成的 `id` 屬性值。</span><span class="sxs-lookup"><span data-stu-id="7fe20-170">The net effect is an `id` attribute value consisting of the `ID` values of the master page, the ContentPlaceHolder control, and the TextBox itself.</span></span>

<span data-ttu-id="7fe20-171">[圖 4] 說明此行為。</span><span class="sxs-lookup"><span data-stu-id="7fe20-171">Figure 4 illustrates this behavior.</span></span> <span data-ttu-id="7fe20-172">若要判斷 `Age` 文字方塊的轉譯 `id`，請從 TextBox 控制項的 `ID` 值開始，`Age`。</span><span class="sxs-lookup"><span data-stu-id="7fe20-172">To determine the rendered `id` of the `Age` TextBox, start with the `ID` value of the TextBox control, `Age`.</span></span> <span data-ttu-id="7fe20-173">接下來，在控制項階層中往上一步。</span><span class="sxs-lookup"><span data-stu-id="7fe20-173">Next, work your way up the control hierarchy.</span></span> <span data-ttu-id="7fe20-174">在每個命名容器（具有 peach 色彩的節點）上，使用命名容器的 `id`在目前轉譯的 `id` 前面加上前置詞。</span><span class="sxs-lookup"><span data-stu-id="7fe20-174">At each naming container (those nodes with a peach color), prefix the current rendered `id` with the naming container's `id`.</span></span>

![呈現的 id 屬性是以命名容器的識別碼值為基礎](control-id-naming-in-content-pages-vb/_static/image6.png)

<span data-ttu-id="7fe20-176">**圖 04**：呈現的 `id` 屬性是以命名容器的 `ID` 值為基礎</span><span class="sxs-lookup"><span data-stu-id="7fe20-176">**Figure 04**: The Rendered `id` Attributes are Based On the `ID` Values of the Naming Containers</span></span>

> [!NOTE]
> <span data-ttu-id="7fe20-177">如我們所討論，轉譯 `id` 屬性的 `ctl00` 部分會構成主版頁面的 `ID` 值，但您可能會想知道此 `ID` 值的呈現方式。</span><span class="sxs-lookup"><span data-stu-id="7fe20-177">As we discussed, the `ctl00` portion of the rendered `id` attribute constitutes the `ID` value of the master page, but you may be wondering how this `ID` value came about.</span></span> <span data-ttu-id="7fe20-178">我們並未在主要或內容頁面中的任何位置指定它。</span><span class="sxs-lookup"><span data-stu-id="7fe20-178">We did not specify it anywhere in our master or content page.</span></span> <span data-ttu-id="7fe20-179">ASP.NET 網頁中的大部分伺服器控制項都是透過頁面的宣告式標記明確加入。</span><span class="sxs-lookup"><span data-stu-id="7fe20-179">Most server controls in an ASP.NET page are added explicitly through the page's declarative markup.</span></span> <span data-ttu-id="7fe20-180">`MainContent` ContentPlaceHolder 控制項已在 `Site.master`的標記中明確指定;`IDIssues.aspx`的標記已定義 [`Age`] 文字方塊。</span><span class="sxs-lookup"><span data-stu-id="7fe20-180">The `MainContent` ContentPlaceHolder control was explicitly specified in the markup of `Site.master`; the `Age` TextBox was defined `IDIssues.aspx`'s markup.</span></span> <span data-ttu-id="7fe20-181">我們可以透過屬性視窗或從宣告式語法，指定這些控制項類型的 `ID` 值。</span><span class="sxs-lookup"><span data-stu-id="7fe20-181">We can specify the `ID` values for these types of controls through the Properties window or from the declarative syntax.</span></span> <span data-ttu-id="7fe20-182">其他控制項（例如主版頁面本身）並未定義于宣告式標記中。</span><span class="sxs-lookup"><span data-stu-id="7fe20-182">Other controls, like the master page itself, are not defined in the declarative markup.</span></span> <span data-ttu-id="7fe20-183">因此，必須為我們自動產生其 `ID` 值。</span><span class="sxs-lookup"><span data-stu-id="7fe20-183">Consequently, their `ID` values must be automatically generated for us.</span></span> <span data-ttu-id="7fe20-184">ASP.NET 引擎會在執行時間為尚未明確設定其識別碼的控制項設定 `ID` 值。</span><span class="sxs-lookup"><span data-stu-id="7fe20-184">The ASP.NET engine sets the `ID` values at runtime for those controls whose IDs have not been explicitly set.</span></span> <span data-ttu-id="7fe20-185">它會使用命名模式 `ctlXX`，其中*XX*是連續增加的整數值。</span><span class="sxs-lookup"><span data-stu-id="7fe20-185">It uses the naming pattern `ctlXX`, where *XX* is a sequentially increasing integer value.</span></span>

<span data-ttu-id="7fe20-186">因為主版頁面本身會當做命名容器，所以主頁面中定義的 Web 控制項也已改變 `id` 屬性值轉譯。</span><span class="sxs-lookup"><span data-stu-id="7fe20-186">Because the master page itself serves as a naming container, the Web controls defined in the master page also have altered rendered `id` attribute values.</span></span> <span data-ttu-id="7fe20-187">例如，在[*使用主版頁面建立全網站版面*](creating-a-site-wide-layout-using-master-pages-vb.md)配置教學課程中，我們新增至主版頁面的 `DisplayDate` 標籤具有下列轉譯的標記：</span><span class="sxs-lookup"><span data-stu-id="7fe20-187">For example, the `DisplayDate` Label we added to the master page in the [*Creating a Site-Wide Layout with Master Pages*](creating-a-site-wide-layout-using-master-pages-vb.md) tutorial has the following rendered markup:</span></span>

[!code-html[Main](control-id-naming-in-content-pages-vb/samples/sample6.html)]

<span data-ttu-id="7fe20-188">請注意，`id` 屬性同時包含主版頁面的 `ID` 值（`ctl00`），以及標籤 Web 控制項（`DateDisplay`）的 `ID` 值。</span><span class="sxs-lookup"><span data-stu-id="7fe20-188">Note that the `id` attribute includes both the master page's `ID` value (`ctl00`) and the `ID` value of the Label Web control (`DateDisplay`).</span></span>

## <a name="step-3-programmatically-referencing-web-controls-viafindcontrol"></a><span data-ttu-id="7fe20-189">步驟3：透過`FindControl` 以程式設計方式參考 Web 控制項</span><span class="sxs-lookup"><span data-stu-id="7fe20-189">Step 3: Programmatically Referencing Web Controls via`FindControl`</span></span>

<span data-ttu-id="7fe20-190">每個 ASP.NET 伺服器控制項都包含一個 `FindControl("controlID")` 方法，可在控制項的子代中搜尋名為*controlID*的控制項。</span><span class="sxs-lookup"><span data-stu-id="7fe20-190">Every ASP.NET server control includes a `FindControl("controlID")` method that searches the control's descendents for a control named *controlID*.</span></span> <span data-ttu-id="7fe20-191">如果找到這類控制項，則會傳回;如果找不到相符的控制項，`FindControl` 會傳回 `Nothing`。</span><span class="sxs-lookup"><span data-stu-id="7fe20-191">If such a control is found, it is returned; if no matching control is found, `FindControl` returns `Nothing`.</span></span>

<span data-ttu-id="7fe20-192">`FindControl` 在需要存取控制項但沒有直接參考的情況下很有用。</span><span class="sxs-lookup"><span data-stu-id="7fe20-192">`FindControl` is useful in scenarios where you need to access a control but you don't have a direct reference to it.</span></span> <span data-ttu-id="7fe20-193">例如，當使用像是 GridView 的資料 Web 控制項時，GridView 的欄位內的控制項會在宣告式語法中定義一次，但在執行時間，會針對每個 GridView 資料列建立控制項的實例。</span><span class="sxs-lookup"><span data-stu-id="7fe20-193">When working with data Web controls like the GridView, for example, the controls within the GridView's fields are defined once in the declarative syntax, but at runtime an instance of the control is created for each GridView row.</span></span> <span data-ttu-id="7fe20-194">因此，在執行時間產生的控制項會存在，但我們沒有從程式碼後置類別提供的直接參考。</span><span class="sxs-lookup"><span data-stu-id="7fe20-194">Consequently, the controls generated at runtime exist, but we do not have a direct reference available from the code-behind class.</span></span> <span data-ttu-id="7fe20-195">因此，我們需要使用 `FindControl`，以程式設計方式處理 GridView 欄位內的特定控制項。</span><span class="sxs-lookup"><span data-stu-id="7fe20-195">As a result we need to use `FindControl` to programmatically work with a specific control within the GridView's fields.</span></span> <span data-ttu-id="7fe20-196">（如需使用 `FindControl` 來存取資料 Web 控制項範本內之控制項的詳細資訊，請參閱以[資料為基礎的自訂格式](../../data-access/custom-formatting/custom-formatting-based-upon-data-vb.md)）。當您以動態方式將 Web 控制項新增至 Web 表單時，就會發生這種情況，這是[建立動態資料輸入使用者介面](https://msdn.microsoft.com/library/aa479330.aspx)中所討論的主題。</span><span class="sxs-lookup"><span data-stu-id="7fe20-196">(For more information on using `FindControl` to access the controls within a data Web control's templates, see [Custom Formatting Based Upon Data](../../data-access/custom-formatting/custom-formatting-based-upon-data-vb.md).) This same scenario occurs when dynamically adding Web controls to a Web Form, a topic discussed in [Creating Dynamic Data Entry User Interfaces](https://msdn.microsoft.com/library/aa479330.aspx).</span></span>

<span data-ttu-id="7fe20-197">為了說明如何使用 `FindControl` 方法來搜尋內容頁面中的控制項，請為 `SubmitButton`的 `Click` 事件建立事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="7fe20-197">To illustrate using the `FindControl` method to search for controls within a content page, create an event handler for the `SubmitButton`'s `Click` event.</span></span> <span data-ttu-id="7fe20-198">在事件處理常式中，加入下列程式碼，以程式設計方式參考 [`Age`] 文字方塊，並使用 `FindControl` 方法來 `Results` 標籤，然後根據使用者的輸入，在 `Results` 中顯示訊息。</span><span class="sxs-lookup"><span data-stu-id="7fe20-198">In the event handler, add the following code, which programmatically references the `Age` TextBox and `Results` Label using the `FindControl` method and then displays a message in `Results` based on the user's input.</span></span>

> [!NOTE]
> <span data-ttu-id="7fe20-199">當然，我們不需要使用 `FindControl` 來參考此範例的標籤和 TextBox 控制項。</span><span class="sxs-lookup"><span data-stu-id="7fe20-199">Of course, we don't need to use `FindControl` to reference the Label and TextBox controls for this example.</span></span> <span data-ttu-id="7fe20-200">我們可以透過其 `ID` 屬性值直接參考它們。</span><span class="sxs-lookup"><span data-stu-id="7fe20-200">We could reference them directly via their `ID` property values.</span></span> <span data-ttu-id="7fe20-201">我在這裡使用 `FindControl` 來說明從內容頁面使用 `FindControl` 時，會發生什麼事。</span><span class="sxs-lookup"><span data-stu-id="7fe20-201">I use `FindControl` here to illustrate what happens when using `FindControl` from a content page.</span></span>

[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample7.vb)]

<span data-ttu-id="7fe20-202">雖然用來呼叫 `FindControl` 方法的語法在 `SubmitButton_Click`的前兩行中稍有不同，但它們在語義上是相等的。</span><span class="sxs-lookup"><span data-stu-id="7fe20-202">While the syntax used to call the `FindControl` method differs slightly in the first two lines of `SubmitButton_Click`, they are semantically equivalent.</span></span> <span data-ttu-id="7fe20-203">回想一下，所有的 ASP.NET 伺服器控制項都包含一個 `FindControl` 方法。</span><span class="sxs-lookup"><span data-stu-id="7fe20-203">Recall that all ASP.NET server controls include a `FindControl` method.</span></span> <span data-ttu-id="7fe20-204">這包括 `Page` 類別，所有 ASP.NET 程式碼後置類別都必須從中衍生。</span><span class="sxs-lookup"><span data-stu-id="7fe20-204">This includes the `Page` class, from which all ASP.NET code-behind classes must derive from.</span></span> <span data-ttu-id="7fe20-205">因此，如果您未覆寫程式碼後置類別或自訂基類中的 `FindControl` 方法，則呼叫 `FindControl("controlID")` 相當於呼叫 `Page.FindControl("controlID")`。</span><span class="sxs-lookup"><span data-stu-id="7fe20-205">Therefore, calling `FindControl("controlID")` is equivalent to calling `Page.FindControl("controlID")`, assuming you haven't overridden the `FindControl` method in your code-behind class or in a custom base class.</span></span>

<span data-ttu-id="7fe20-206">輸入此程式碼之後，請造訪瀏覽器中的 [`IDIssues.aspx`] 頁面，輸入您的年齡，然後按一下 [提交] 按鈕。</span><span class="sxs-lookup"><span data-stu-id="7fe20-206">After entering this code, visit the `IDIssues.aspx` page through a browser, enter your age, and click the "Submit" button.</span></span> <span data-ttu-id="7fe20-207">按一下 [提交] 按鈕時，會引發 `NullReferenceException` （請參閱 [圖 5]）。</span><span class="sxs-lookup"><span data-stu-id="7fe20-207">Upon clicking the "Submit" button a `NullReferenceException` is raised (see Figure 5).</span></span>

<span data-ttu-id="7fe20-208">[![引發 NullReferenceException](control-id-naming-in-content-pages-vb/_static/image8.png)](control-id-naming-in-content-pages-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="7fe20-208">[![A NullReferenceException is Raised](control-id-naming-in-content-pages-vb/_static/image8.png)](control-id-naming-in-content-pages-vb/_static/image7.png)</span></span>

<span data-ttu-id="7fe20-209">**圖 05**：引發 `NullReferenceException` （[按一下以觀看完整大小的影像](control-id-naming-in-content-pages-vb/_static/image9.png)）</span><span class="sxs-lookup"><span data-stu-id="7fe20-209">**Figure 05**: A `NullReferenceException` is Raised  ([Click to view full-size image](control-id-naming-in-content-pages-vb/_static/image9.png))</span></span>

<span data-ttu-id="7fe20-210">如果您在 `SubmitButton_Click` 事件處理常式中設定中斷點，您會看到 `FindControl` 的兩個呼叫都會傳回 `Nothing`。</span><span class="sxs-lookup"><span data-stu-id="7fe20-210">If you set a breakpoint in the `SubmitButton_Click` event handler you will see that both calls to `FindControl` return `Nothing`.</span></span> <span data-ttu-id="7fe20-211">當我們嘗試存取 `Age` TextBox 的 `Text` 屬性時，就會引發 `NullReferenceException`。</span><span class="sxs-lookup"><span data-stu-id="7fe20-211">The `NullReferenceException` is raised when we attempt to access the `Age` TextBox's `Text` property.</span></span>

<span data-ttu-id="7fe20-212">問題在於，`Control.FindControl` 只會搜尋位於相同命名容器中的*控制項*子代。</span><span class="sxs-lookup"><span data-stu-id="7fe20-212">The problem is that `Control.FindControl` only searches *Control*'s descendents that are in the same naming container.</span></span> <span data-ttu-id="7fe20-213">因為主版頁面構成新的命名容器，所以 `Page.FindControl("controlID")` 的呼叫永遠不會 permeates 主版頁面物件 `ctl00`。</span><span class="sxs-lookup"><span data-stu-id="7fe20-213">Because the master page constitutes a new naming container, a call to `Page.FindControl("controlID")` never permeates the master page object `ctl00`.</span></span> <span data-ttu-id="7fe20-214">（請回到 [圖 4] 來觀看控制項階層，其中顯示 `Page` 物件做為主版頁面物件的父系 `ctl00`）。因此，找不到 [`Results` 標籤] 和 [`Age`] 文字方塊，`ResultsLabel` 和 `AgeTextBox` 指派 `Nothing`的值。</span><span class="sxs-lookup"><span data-stu-id="7fe20-214">(Refer back to Figure 4 to view the control hierarchy, which shows the `Page` object as the parent of the master page object `ctl00`.) Therefore, the `Results` Label and `Age` TextBox are not found and `ResultsLabel` and `AgeTextBox` are assigned values of `Nothing`.</span></span>

<span data-ttu-id="7fe20-215">這項挑戰有兩種因應措施：我們可以向下切入，一次一個命名容器，到適當的控制項;或者，我們也可以建立自己的 `FindControl` 方法來 permeates 命名容器。</span><span class="sxs-lookup"><span data-stu-id="7fe20-215">There are two workarounds to this challenge: we can drill down, one naming container at a time, to the appropriate control; or we can create our own `FindControl` method that permeates naming containers.</span></span> <span data-ttu-id="7fe20-216">讓我們來檢查每個選項。</span><span class="sxs-lookup"><span data-stu-id="7fe20-216">Let's examine each of these options.</span></span>

### <a name="drilling-into-the-appropriate-naming-container"></a><span data-ttu-id="7fe20-217">深入探索適當的命名容器</span><span class="sxs-lookup"><span data-stu-id="7fe20-217">Drilling Into the Appropriate Naming Container</span></span>

<span data-ttu-id="7fe20-218">若要使用 `FindControl` 來參考 `Results` 標籤或 `Age` TextBox，我們必須從相同命名容器中的祖系控制項呼叫 `FindControl`。</span><span class="sxs-lookup"><span data-stu-id="7fe20-218">To use `FindControl` to reference the `Results` Label or `Age` TextBox, we need to call `FindControl` from an ancestor control in the same naming container.</span></span> <span data-ttu-id="7fe20-219">如 [圖 4] 所示，`MainContent` ContentPlaceHolder 控制項是相同命名容器內 `Results` 或 `Age` 的唯一祖系。</span><span class="sxs-lookup"><span data-stu-id="7fe20-219">As Figure 4 showed, the `MainContent` ContentPlaceHolder control is the only ancestor of `Results` or `Age` that is within the same naming container.</span></span> <span data-ttu-id="7fe20-220">換句話說，從 `MainContent` 控制項呼叫 `FindControl` 方法（如下列程式碼片段所示），會正確地傳回 `Results` 或 `Age` 控制項的參考。</span><span class="sxs-lookup"><span data-stu-id="7fe20-220">In other words, calling the `FindControl` method from the `MainContent` control, as shown in the code snippet below, correctly returns a reference to the `Results` or `Age` controls.</span></span>

[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample8.vb)]

<span data-ttu-id="7fe20-221">不過，我們無法使用上述語法來處理內容頁面的程式碼後置類別中的 `MainContent` ContentPlaceHolder，因為 ContentPlaceHolder 是在主版頁面中定義。</span><span class="sxs-lookup"><span data-stu-id="7fe20-221">However, we cannot work with the `MainContent` ContentPlaceHolder from our content page's code-behind class using the above syntax because the ContentPlaceHolder is defined in the master page.</span></span> <span data-ttu-id="7fe20-222">相反地，我們必須使用 `FindControl` 來取得 `MainContent`的參考。</span><span class="sxs-lookup"><span data-stu-id="7fe20-222">Instead, we have to use `FindControl` to get a reference to `MainContent`.</span></span> <span data-ttu-id="7fe20-223">將 `SubmitButton_Click` 事件處理常式中的程式碼取代為下列修改：</span><span class="sxs-lookup"><span data-stu-id="7fe20-223">Replace the code in the `SubmitButton_Click` event handler with the following modifications:</span></span>

[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample9.vb)]

<span data-ttu-id="7fe20-224">如果您透過瀏覽器造訪頁面，請輸入您的年齡，然後按一下 [Submit （提交）] 按鈕，就會引發 `NullReferenceException`。</span><span class="sxs-lookup"><span data-stu-id="7fe20-224">If you visit the page through a browser, enter your age, and click the "Submit" button, a `NullReferenceException` is raised.</span></span> <span data-ttu-id="7fe20-225">如果您在 `SubmitButton_Click` 事件處理常式中設定中斷點，您會看到在嘗試呼叫 `MainContent` 物件的 `FindControl` 方法時，會發生這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7fe20-225">If you set a breakpoint in the `SubmitButton_Click` event handler you will see that this exception occurs when attempting to call the `MainContent` object's `FindControl` method.</span></span> <span data-ttu-id="7fe20-226">`MainContent` 物件等於 `Nothing`，因為 `FindControl` 方法找不到名為 "MainContent" 的物件。</span><span class="sxs-lookup"><span data-stu-id="7fe20-226">The `MainContent` object is equal to `Nothing` because the `FindControl` method cannot locate an object named "MainContent".</span></span> <span data-ttu-id="7fe20-227">根本原因與 [`Results` 標籤] 和 [`Age` TextBox] 控制項相同： `FindControl` 從控制項階層的頂端開始搜尋，而不會滲透命名容器，但 `MainContent` ContentPlaceHolder 是在主版頁面內，也就是命名容器。</span><span class="sxs-lookup"><span data-stu-id="7fe20-227">The underlying reason is the same as with the `Results` Label and `Age` TextBox controls: `FindControl` starts its search from the top of the control hierarchy and does not penetrate naming containers, but the `MainContent` ContentPlaceHolder is within the master page, which is a naming container.</span></span>

<span data-ttu-id="7fe20-228">我們必須先參考主版頁面控制項，才可以使用 `FindControl` 取得 `MainContent`的參考。</span><span class="sxs-lookup"><span data-stu-id="7fe20-228">Before we can use `FindControl` to get a reference to `MainContent`, we first need a reference to the master page control.</span></span> <span data-ttu-id="7fe20-229">參考主版頁面之後，我們就可以透過 `FindControl` 取得 `MainContent` ContentPlaceHolder 的參考，並從該處參考 `Results` 標籤和 `Age` TextBox （同樣地，使用 `FindControl`）。</span><span class="sxs-lookup"><span data-stu-id="7fe20-229">Once we have a reference to the master page we can get a reference to the `MainContent` ContentPlaceHolder via `FindControl` and, from there, references to the `Results` Label and `Age` TextBox (again, through using `FindControl`).</span></span> <span data-ttu-id="7fe20-230">但是，我們要如何取得主版頁面的參考？</span><span class="sxs-lookup"><span data-stu-id="7fe20-230">But how do we get a reference to the master page?</span></span> <span data-ttu-id="7fe20-231">藉由檢查所轉譯標記中的 `id` 屬性，很明顯地 `ctl00`主版頁面的 `ID` 值。</span><span class="sxs-lookup"><span data-stu-id="7fe20-231">By inspecting the `id` attributes in the rendered markup it's evident that the master page's `ID` value is `ctl00`.</span></span> <span data-ttu-id="7fe20-232">因此，我們可以使用 `Page.FindControl("ctl00")` 取得主版頁面的參考，然後使用該物件取得 `MainContent`的參考，依此類推。</span><span class="sxs-lookup"><span data-stu-id="7fe20-232">Therefore, we could use `Page.FindControl("ctl00")` to get a reference to the master page, then use that object to get a reference to `MainContent`, and so on.</span></span> <span data-ttu-id="7fe20-233">下列程式碼片段說明此邏輯：</span><span class="sxs-lookup"><span data-stu-id="7fe20-233">The following snippet illustrates this logic:</span></span>

[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample10.vb)]

<span data-ttu-id="7fe20-234">雖然這段程式碼肯定可行，但它會假設主版頁面自動產生的 `ID` 一律會 `ctl00`。</span><span class="sxs-lookup"><span data-stu-id="7fe20-234">While this code will certainly work, it assumes that the master page's autogenerated `ID` will always be `ctl00`.</span></span> <span data-ttu-id="7fe20-235">最好不要對自動產生的值進行假設。</span><span class="sxs-lookup"><span data-stu-id="7fe20-235">It's never a good idea to make assumptions about autogenerated values.</span></span>

<span data-ttu-id="7fe20-236">幸運的是，主版頁面的參考可透過 `Page` 類別的 `Master` 屬性來存取。</span><span class="sxs-lookup"><span data-stu-id="7fe20-236">Fortunately, a reference to the master page is accessible through the `Page` class's `Master` property.</span></span> <span data-ttu-id="7fe20-237">因此，我們可以改為使用 `Page.Master.FindControl("MainContent")`，而不需要使用 `FindControl("ctl00")` 來取得主版頁面的參考，以便存取 `MainContent` ContentPlaceHolder。</span><span class="sxs-lookup"><span data-stu-id="7fe20-237">Therefore, instead of having to use `FindControl("ctl00")` to get a reference of the master page in order to access the `MainContent` ContentPlaceHolder, we can instead use `Page.Master.FindControl("MainContent")`.</span></span> <span data-ttu-id="7fe20-238">使用下列程式碼更新 `SubmitButton_Click` 事件處理常式：</span><span class="sxs-lookup"><span data-stu-id="7fe20-238">Update the `SubmitButton_Click` event handler with the following code:</span></span>

[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample11.vb)]

<span data-ttu-id="7fe20-239">此時，透過瀏覽器造訪頁面、輸入您的年齡，然後按一下 [提交] 按鈕，就會如預期般在 [`Results`] 標籤中顯示訊息。</span><span class="sxs-lookup"><span data-stu-id="7fe20-239">This time, visiting the page through a browser, entering your age, and clicking the "Submit" button displays the message in the `Results` Label, as expected.</span></span>

<span data-ttu-id="7fe20-240">[![使用者的年齡會顯示在標籤中](control-id-naming-in-content-pages-vb/_static/image11.png)](control-id-naming-in-content-pages-vb/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="7fe20-240">[![The User's Age is Displayed in the Label](control-id-naming-in-content-pages-vb/_static/image11.png)](control-id-naming-in-content-pages-vb/_static/image10.png)</span></span>

<span data-ttu-id="7fe20-241">**圖 06**：使用者的年齡會顯示在標籤中（[按一下以觀看完整大小的影像](control-id-naming-in-content-pages-vb/_static/image12.png)）</span><span class="sxs-lookup"><span data-stu-id="7fe20-241">**Figure 06**: The User's Age is Displayed in the Label  ([Click to view full-size image](control-id-naming-in-content-pages-vb/_static/image12.png))</span></span>

### <a name="recursively-searching-through-naming-containers"></a><span data-ttu-id="7fe20-242">以遞迴方式搜尋命名容器</span><span class="sxs-lookup"><span data-stu-id="7fe20-242">Recursively Searching Through Naming Containers</span></span>

<span data-ttu-id="7fe20-243">先前的程式碼範例從主版頁面參考 `MainContent` ContentPlaceHolder 控制項，然後 `MainContent`的 [`Results` 標籤] 和 [`Age` TextBox] 控制項，是因為 `Control.FindControl` 方法只會在*控制項*的命名容器中搜尋。</span><span class="sxs-lookup"><span data-stu-id="7fe20-243">The reason the previous code example referenced the `MainContent` ContentPlaceHolder control from the master page, and then the `Results` Label and `Age` TextBox controls from `MainContent`, is because the `Control.FindControl` method only searches within *Control*'s naming container.</span></span> <span data-ttu-id="7fe20-244">在大部分的情況下，讓 `FindControl` 保持在命名容器內是合理的，因為兩個不同的命名容器中的兩個控制項可能會有相同的 `ID` 值。</span><span class="sxs-lookup"><span data-stu-id="7fe20-244">Having `FindControl` stay within the naming container makes sense in most scenarios because two controls in two different naming containers may have the same `ID` values.</span></span> <span data-ttu-id="7fe20-245">請考慮 GridView 的案例，其會在其中一個 TemplateFields 中定義名為 `ProductName` 的標籤 Web 控制項。</span><span class="sxs-lookup"><span data-stu-id="7fe20-245">Consider the case of a GridView that defines a Label Web control named `ProductName` within one of its TemplateFields.</span></span> <span data-ttu-id="7fe20-246">當資料在執行時間系結至 GridView 時，會為每個 GridView 資料列建立一個 `ProductName` 標籤。</span><span class="sxs-lookup"><span data-stu-id="7fe20-246">When the data is bound to the GridView at runtime, a `ProductName` Label is created for each GridView row.</span></span> <span data-ttu-id="7fe20-247">如果 `FindControl` 搜尋所有的命名容器，而我們呼叫 `Page.FindControl("ProductName")`，`FindControl` 會傳回哪個標籤實例？</span><span class="sxs-lookup"><span data-stu-id="7fe20-247">If `FindControl` searched through all naming containers and we called `Page.FindControl("ProductName")`, what Label instance should the `FindControl` return?</span></span> <span data-ttu-id="7fe20-248">第一個 GridView 資料列中的 `ProductName` 標籤？</span><span class="sxs-lookup"><span data-stu-id="7fe20-248">The `ProductName` Label in the first GridView row?</span></span> <span data-ttu-id="7fe20-249">最後一個資料列中的那一個？</span><span class="sxs-lookup"><span data-stu-id="7fe20-249">The one in the last row?</span></span>

<span data-ttu-id="7fe20-250">因此，讓 `Control.FindControl` 搜尋只是*控制項*的命名容器，在大多數情況下都是合理的。</span><span class="sxs-lookup"><span data-stu-id="7fe20-250">So having `Control.FindControl` search just *Control*'s naming container makes sense in most cases.</span></span> <span data-ttu-id="7fe20-251">但還有其他案例，例如，我們在所有命名容器中都有唯一的 `ID`，而且想要避免必須精心參考控制項階層中的每個命名容器來存取控制項。</span><span class="sxs-lookup"><span data-stu-id="7fe20-251">But there are other cases, such as the one facing us, where we have a unique `ID` across all naming containers and want to avoid having to meticulously reference each naming container in the control hierarchy to access a control.</span></span> <span data-ttu-id="7fe20-252">擁有會以遞迴方式搜尋所有命名容器的 `FindControl` variant 也是合理的。</span><span class="sxs-lookup"><span data-stu-id="7fe20-252">Having a `FindControl` variant that recursively searches all naming containers makes sense, too.</span></span> <span data-ttu-id="7fe20-253">可惜的是，.NET Framework 不包含這種方法。</span><span class="sxs-lookup"><span data-stu-id="7fe20-253">Unfortunately, the .NET Framework does not include such a method.</span></span>

<span data-ttu-id="7fe20-254">好消息是，我們可以建立自己的 `FindControl` 方法，以遞迴方式搜尋所有的命名容器。</span><span class="sxs-lookup"><span data-stu-id="7fe20-254">The good news is that we can create our own `FindControl` method that recursively searches all naming containers.</span></span> <span data-ttu-id="7fe20-255">事實上，使用*擴充方法*時，我們可以將 `FindControlRecursive` 方法加到 `Control` 類別，以伴隨其現有的 `FindControl` 方法。</span><span class="sxs-lookup"><span data-stu-id="7fe20-255">In fact, using *extension methods* we can tack on a `FindControlRecursive` method to the `Control` class to accompany its existing `FindControl` method.</span></span>

> [!NOTE]
> <span data-ttu-id="7fe20-256">擴充方法是C# 3.0 和 Visual Basic 9 的新功能，這是隨附于 .NET Framework 3.5 版和 Visual Studio 2008 的語言。</span><span class="sxs-lookup"><span data-stu-id="7fe20-256">Extension methods are a feature new to C# 3.0 and Visual Basic 9, which are the languages that ship with the .NET Framework version 3.5 and Visual Studio 2008.</span></span> <span data-ttu-id="7fe20-257">簡單地說，擴充方法可讓開發人員透過特殊語法，為現有的類別類型建立新的方法。</span><span class="sxs-lookup"><span data-stu-id="7fe20-257">In short, extension methods allow for a developer to create a new method for an existing class type through a special syntax.</span></span> <span data-ttu-id="7fe20-258">如需這項實用功能的詳細資訊，請參閱我的文章[使用擴充方法擴充基底類型功能](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx)。</span><span class="sxs-lookup"><span data-stu-id="7fe20-258">For more information on this helpful feature, refer to my article, [Extending Base Type Functionality with Extension Methods](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx).</span></span>

<span data-ttu-id="7fe20-259">若要建立擴充方法，請將新檔案新增至名為 `PageExtensionMethods.vb`的 `App_Code` 資料夾。</span><span class="sxs-lookup"><span data-stu-id="7fe20-259">To create the extension method, add a new file to the `App_Code` folder named `PageExtensionMethods.vb`.</span></span> <span data-ttu-id="7fe20-260">新增名為 `FindControlRecursive` 的擴充方法，以接受名為 `controlID`的 `String` 參數作為輸入。</span><span class="sxs-lookup"><span data-stu-id="7fe20-260">Add an extension method named `FindControlRecursive` that takes as an input a `String` parameter named `controlID`.</span></span> <span data-ttu-id="7fe20-261">若要讓擴充方法正常運作，請務必將類別標記為 `Module`，而且擴充方法的前面會加上 `<Extension()>` 屬性。</span><span class="sxs-lookup"><span data-stu-id="7fe20-261">For extension methods to work properly, it is vital that the class be marked as a `Module` and that the extension methods be prefixed with the `<Extension()>` attribute.</span></span> <span data-ttu-id="7fe20-262">此外，所有擴充方法都必須接受延伸方法所套用之類型的物件做為其第一個參數。</span><span class="sxs-lookup"><span data-stu-id="7fe20-262">Moreover, all extension methods must accept as their first parameter an object of the type to which the extension method applies.</span></span>

<span data-ttu-id="7fe20-263">將下列程式碼新增至 `PageExtensionMethods.vb` 檔案，以定義此 `Module` 和 `FindControlRecursive` 擴充方法：</span><span class="sxs-lookup"><span data-stu-id="7fe20-263">Add the following code to the `PageExtensionMethods.vb` file to define this `Module` and the `FindControlRecursive` extension method:</span></span>

[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample12.vb)]

<span data-ttu-id="7fe20-264">將此程式碼備妥之後，請返回 `IDIssues.aspx` 頁面的程式碼後置類別，並將目前的 `FindControl` 方法呼叫標記為批註。</span><span class="sxs-lookup"><span data-stu-id="7fe20-264">With this code in place, return to the `IDIssues.aspx` page's code-behind class and comment out the current `FindControl` method calls.</span></span> <span data-ttu-id="7fe20-265">以 `Page.FindControlRecursive("controlID")`的呼叫來取代它們。</span><span class="sxs-lookup"><span data-stu-id="7fe20-265">Replace them with calls to `Page.FindControlRecursive("controlID")`.</span></span> <span data-ttu-id="7fe20-266">擴充方法的最棒之處在于，它們會直接出現在 IntelliSense 下拉式清單中。</span><span class="sxs-lookup"><span data-stu-id="7fe20-266">What's neat about extension methods is that they appear directly within the IntelliSense drop-down lists.</span></span> <span data-ttu-id="7fe20-267">如 [圖 7] 所示，當您輸入 `Page` 然後按下句點時，`FindControlRecursive` 方法會連同其他 `Control` 類別方法一起包含在 IntelliSense 下拉式集中。</span><span class="sxs-lookup"><span data-stu-id="7fe20-267">As Figure 7 shows, when you type `Page` and then hit period, the `FindControlRecursive` method is included in the IntelliSense drop-down along with the other `Control` class methods.</span></span>

<span data-ttu-id="7fe20-268">[IntelliSense 下拉式清單中包含 ![擴充方法](control-id-naming-in-content-pages-vb/_static/image14.png)](control-id-naming-in-content-pages-vb/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="7fe20-268">[![Extension Methods are Included in the IntelliSense Drop-Downs](control-id-naming-in-content-pages-vb/_static/image14.png)](control-id-naming-in-content-pages-vb/_static/image13.png)</span></span>

<span data-ttu-id="7fe20-269">**圖 07**：擴充方法包含在 [IntelliSense] 下拉式清單中（[按一下以觀看完整大小的影像](control-id-naming-in-content-pages-vb/_static/image15.png)）</span><span class="sxs-lookup"><span data-stu-id="7fe20-269">**Figure 07**: Extension Methods are Included in the IntelliSense Drop-Downs  ([Click to view full-size image](control-id-naming-in-content-pages-vb/_static/image15.png))</span></span>

<span data-ttu-id="7fe20-270">在 `SubmitButton_Click` 事件處理常式中輸入下列程式碼，然後藉由造訪頁面並輸入您的年齡，然後按一下 [提交] 按鈕進行測試。</span><span class="sxs-lookup"><span data-stu-id="7fe20-270">Enter the following code into the `SubmitButton_Click` event handler and then test it by visiting the page, entering your age, and clicking the "Submit" button.</span></span> <span data-ttu-id="7fe20-271">如 [圖 6] 所示，產生的輸出將會是「您的年齡年份已過時！」訊息。</span><span class="sxs-lookup"><span data-stu-id="7fe20-271">As shown back in Figure 6, the resulting output will be the message, "You are age years old!"</span></span>

[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample13.vb)]

> [!NOTE]
> <span data-ttu-id="7fe20-272">由於擴充方法是C# 3.0 和 Visual Basic 9 的新功能，因此如果您使用 Visual Studio 2005，就無法使用擴充方法。</span><span class="sxs-lookup"><span data-stu-id="7fe20-272">Because extension methods are new to C# 3.0 and Visual Basic 9, if you are using Visual Studio 2005 you cannot use extension methods.</span></span> <span data-ttu-id="7fe20-273">相反地，您必須在 helper 類別中執行 `FindControlRecursive` 方法。</span><span class="sxs-lookup"><span data-stu-id="7fe20-273">Instead, you'll need to implement the `FindControlRecursive` method in a helper class.</span></span> <span data-ttu-id="7fe20-274">[Rick Strahl](http://www.west-wind.com/WebLog/default.aspx)在他的 blog 文章中有這類的範例， [ASP.NET 的微波激頁和 `FindControl`](http://www.west-wind.com/WebLog/posts/5127.aspx)。</span><span class="sxs-lookup"><span data-stu-id="7fe20-274">[Rick Strahl](http://www.west-wind.com/WebLog/default.aspx) has such an example in his blog post, [ASP.NET Maser Pages and `FindControl`](http://www.west-wind.com/WebLog/posts/5127.aspx).</span></span>

## <a name="step-4-using-the-correctidattribute-value-in-client-side-script"></a><span data-ttu-id="7fe20-275">步驟4：在用戶端腳本中使用正確的`id`屬性值</span><span class="sxs-lookup"><span data-stu-id="7fe20-275">Step 4: Using the Correct`id`Attribute Value in Client-Side Script</span></span>

<span data-ttu-id="7fe20-276">如本教學課程簡介中所述，在用戶端腳本中，通常會使用 Web 控制項的轉譯 `id` 屬性，以程式設計方式參考特定的 HTML 專案。</span><span class="sxs-lookup"><span data-stu-id="7fe20-276">As noted in this tutorial's introduction, a Web control's rendered `id` attribute is oftentimes used in client-side script to programmatically reference a particular HTML element.</span></span> <span data-ttu-id="7fe20-277">例如，下列 JavaScript 會依 `id` 參考 HTML 專案，然後在強制回應訊息框中顯示其值：</span><span class="sxs-lookup"><span data-stu-id="7fe20-277">For example, the following JavaScript references an HTML element by its `id` and then displays its value in a modal message box:</span></span>

[!code-csharp[Main](control-id-naming-in-content-pages-vb/samples/sample14.cs)]

<span data-ttu-id="7fe20-278">回想一下，在不包含命名容器的 ASP.NET 網頁中，呈現的 HTML 專案的 `id` 屬性與 Web 控制項的 `ID` 屬性值相同。</span><span class="sxs-lookup"><span data-stu-id="7fe20-278">Recall that in ASP.NET pages that do not include a naming container, the rendered HTML element's `id` attribute is identical to the Web control's `ID` property value.</span></span> <span data-ttu-id="7fe20-279">因此，在 JavaScript 程式碼中，將 `id` 屬性值中的硬程式碼很吸引人。</span><span class="sxs-lookup"><span data-stu-id="7fe20-279">Because of this, it is tempting to hard code in `id` attribute values into JavaScript code.</span></span> <span data-ttu-id="7fe20-280">也就是說，如果您知道您想要透過用戶端腳本來存取 `Age` TextBox Web 控制項，請藉由呼叫 `document.getElementById("Age")`來執行此動作。</span><span class="sxs-lookup"><span data-stu-id="7fe20-280">That is, if you know you want to access the `Age` TextBox Web control through client-side script, do so via a call to `document.getElementById("Age")`.</span></span>

<span data-ttu-id="7fe20-281">這種方法的問題在於，使用主版頁面（或其他命名容器控制項）時，轉譯的 HTML `id` 與 Web 控制項的 `ID` 屬性不同義。</span><span class="sxs-lookup"><span data-stu-id="7fe20-281">The problem with this approach is that when using master pages (or other naming container controls), the rendered HTML `id` is not synonymous with the Web control's `ID` property.</span></span> <span data-ttu-id="7fe20-282">您的第一步可能是透過瀏覽器造訪頁面，並查看來源以判斷實際的 `id` 屬性。</span><span class="sxs-lookup"><span data-stu-id="7fe20-282">Your first inclination may be to visit the page through a browser and view the source to determine the actual `id` attribute.</span></span> <span data-ttu-id="7fe20-283">一旦知道轉譯的 `id` 值，您就可以將它貼入 `getElementById` 的呼叫中，以存取您需要透過用戶端腳本使用的 HTML 元素。</span><span class="sxs-lookup"><span data-stu-id="7fe20-283">Once you know the rendered `id` value, you can paste it into the call to `getElementById` to access the HTML element you need to work with through client-side script.</span></span> <span data-ttu-id="7fe20-284">這種方法並不理想，因為對頁面的控制項階層進行某些變更，或對命名控制項的 `ID` 屬性所做的變更，將會改變產生的 `id` 屬性，進而中斷您的 JavaScript 程式碼。</span><span class="sxs-lookup"><span data-stu-id="7fe20-284">This approach is less than ideal because certain changes to the page's control hierarchy or changes to the `ID` properties of the naming controls will alter the resulting `id` attribute, thereby breaking your JavaScript code.</span></span>

<span data-ttu-id="7fe20-285">好消息是，您可以透過 Web 控制項的[`ClientID` 屬性](https://msdn.microsoft.com/library/system.web.ui.control.clientid.aspx)，在伺服器端程式碼中存取所呈現的 `id` 屬性值。</span><span class="sxs-lookup"><span data-stu-id="7fe20-285">The good news is that the `id` attribute value that is rendered is accessible in server-side code through the Web control's [`ClientID` property](https://msdn.microsoft.com/library/system.web.ui.control.clientid.aspx).</span></span> <span data-ttu-id="7fe20-286">您應該使用這個屬性來判斷用戶端腳本中使用的 `id` 屬性值。</span><span class="sxs-lookup"><span data-stu-id="7fe20-286">You should use this property to determine the `id` attribute value used in client-side script.</span></span> <span data-ttu-id="7fe20-287">例如，若要將 JavaScript 函式加入至頁面，當呼叫時，會在強制回應訊息框中顯示 `Age` 文字方塊的值，將下列程式碼加入 `Page_Load` 事件處理常式：</span><span class="sxs-lookup"><span data-stu-id="7fe20-287">For example, to add a JavaScript function to the page that, when called, displays the value of the `Age` TextBox in a modal message box, add the following code to the `Page_Load` event handler:</span></span>

[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample15.vb)]

<span data-ttu-id="7fe20-288">上述程式碼會將 `Age` TextBox 的 `ClientID` 屬性值插入至 `getElementById`的 JavaScript 呼叫中。</span><span class="sxs-lookup"><span data-stu-id="7fe20-288">The above code injects the value of the `Age` TextBox's `ClientID` property into the JavaScript call to `getElementById`.</span></span> <span data-ttu-id="7fe20-289">如果您透過瀏覽器造訪此頁面並觀看 HTML 原始碼，您會發現下列 JavaScript 程式碼：</span><span class="sxs-lookup"><span data-stu-id="7fe20-289">If you visit this page through a browser and view the HTML source, you'll find the following JavaScript code:</span></span>

[!code-html[Main](control-id-naming-in-content-pages-vb/samples/sample16.html)]

<span data-ttu-id="7fe20-290">請注意，在 `getElementById`的呼叫中會出現正確的 `id` 屬性值 `ctl00_MainContent_Age`。</span><span class="sxs-lookup"><span data-stu-id="7fe20-290">Notice how the correct `id` attribute value, `ctl00_MainContent_Age`, appears within the call to `getElementById`.</span></span> <span data-ttu-id="7fe20-291">因為這個值是在執行時間計算的，所以不論頁面控制項階層的後續變更為何，都可以運作。</span><span class="sxs-lookup"><span data-stu-id="7fe20-291">Because this value is calculated at runtime, it works regardless of later changes to the page control hierarchy.</span></span>

> [!NOTE]
> <span data-ttu-id="7fe20-292">這個 JavaScript 範例只示範如何新增 JavaScript 函式，該函式會正確地參考伺服器控制項所呈現的 HTML 元素。</span><span class="sxs-lookup"><span data-stu-id="7fe20-292">This JavaScript example merely shows how to add a JavaScript function that correctly references the HTML element rendered by a server control.</span></span> <span data-ttu-id="7fe20-293">若要使用此函式，您必須撰寫額外的 JavaScript，以便在檔載入時或特定的使用者動作過大幅簡化時呼叫函式。</span><span class="sxs-lookup"><span data-stu-id="7fe20-293">To use this function you would need to author additional JavaScript to call the function when the document loads or when some specific user action transpires.</span></span> <span data-ttu-id="7fe20-294">如需這些和相關主題的詳細資訊，請參閱[使用用戶端腳本](https://msdn.microsoft.com/library/aa479302.aspx)。</span><span class="sxs-lookup"><span data-stu-id="7fe20-294">For more information on these and related topics, read [Working with Client-Side Script](https://msdn.microsoft.com/library/aa479302.aspx).</span></span>

## <a name="summary"></a><span data-ttu-id="7fe20-295">總結</span><span class="sxs-lookup"><span data-stu-id="7fe20-295">Summary</span></span>

<span data-ttu-id="7fe20-296">某些 ASP.NET 伺服器控制項的作用是命名容器，這會影響其子控制項的轉譯 `id` 屬性值，以及 `FindControl` 方法所 canvassed 的控制項範圍。</span><span class="sxs-lookup"><span data-stu-id="7fe20-296">Certain ASP.NET server controls act as naming containers, which affects the rendered `id` attribute values of their descendent controls as well as the scope of controls canvassed by the `FindControl` method.</span></span> <span data-ttu-id="7fe20-297">與主版頁面相關的是，主版頁面本身和其 ContentPlaceHolder 控制項都是命名容器。</span><span class="sxs-lookup"><span data-stu-id="7fe20-297">With regards to master pages, both the master page itself and its ContentPlaceHolder controls are naming containers.</span></span> <span data-ttu-id="7fe20-298">因此，我們需要使用 `FindControl`，在內容頁面中以程式設計方式參考控制項。</span><span class="sxs-lookup"><span data-stu-id="7fe20-298">Consequently, we need to put forth a bit more work to programmatically reference controls within the content page using `FindControl`.</span></span> <span data-ttu-id="7fe20-299">在本教學課程中，我們探討了兩種技術：深入探索 ContentPlaceHolder 控制項並呼叫其 `FindControl` 方法;並輪流執行自己的 `FindControl` 執行，以遞迴方式搜尋所有的命名容器。</span><span class="sxs-lookup"><span data-stu-id="7fe20-299">In this tutorial we examined two techniques: drilling into the ContentPlaceHolder control and calling its `FindControl` method; and rolling our own `FindControl` implementation that recursively searches through all naming containers.</span></span>

<span data-ttu-id="7fe20-300">除了參考 Web 控制項的伺服器端問題命名容器之外，也有用戶端問題。</span><span class="sxs-lookup"><span data-stu-id="7fe20-300">In addition to the server-side issues naming containers introduce with regards to referencing Web controls, there are also client-side issues.</span></span> <span data-ttu-id="7fe20-301">在沒有命名容器的情況下，Web 控制項的 `ID` 屬性值和轉譯的 `id` 屬性值都是同一個。</span><span class="sxs-lookup"><span data-stu-id="7fe20-301">In the absence of naming containers, the Web control's `ID` property value and rendered `id` attribute value are one in the same.</span></span> <span data-ttu-id="7fe20-302">但是在新增命名容器之後，轉譯的 `id` 屬性會同時包含 Web 控制項的 `ID` 值和其控制項階層上階中的命名容器。</span><span class="sxs-lookup"><span data-stu-id="7fe20-302">But with the addition of naming container, the rendered `id` attribute includes both the `ID` values of the Web control and the naming container(s) in its control hierarchy's ancestry.</span></span> <span data-ttu-id="7fe20-303">只要您使用 Web 控制項的 `ClientID` 屬性來判斷用戶端腳本中轉譯的 `id` 屬性值，這些命名問題就不會有問題。</span><span class="sxs-lookup"><span data-stu-id="7fe20-303">These naming concerns are a non-issue as long as you use the Web control's `ClientID` property to determine the rendered `id` attribute value in your client-side script.</span></span>

<span data-ttu-id="7fe20-304">快樂的程式設計！</span><span class="sxs-lookup"><span data-stu-id="7fe20-304">Happy Programming!</span></span>

### <a name="further-reading"></a><span data-ttu-id="7fe20-305">進一步閱讀</span><span class="sxs-lookup"><span data-stu-id="7fe20-305">Further Reading</span></span>

<span data-ttu-id="7fe20-306">如需本教學課程中所討論之主題的詳細資訊，請參閱下列資源：</span><span class="sxs-lookup"><span data-stu-id="7fe20-306">For more information on the topics discussed in this tutorial, refer to the following resources:</span></span>

- [<span data-ttu-id="7fe20-307">ASP.NET 主版頁面和 `FindControl`</span><span class="sxs-lookup"><span data-stu-id="7fe20-307">ASP.NET Master Pages and `FindControl`</span></span>](http://www.west-wind.com/WebLog/posts/5127.aspx)
- [<span data-ttu-id="7fe20-308">建立動態資料輸入使用者介面</span><span class="sxs-lookup"><span data-stu-id="7fe20-308">Creating Dynamic Data Entry User Interfaces</span></span>](https://msdn.microsoft.com/library/aa479330.aspx)
- [<span data-ttu-id="7fe20-309">使用擴充方法擴充基底類型功能</span><span class="sxs-lookup"><span data-stu-id="7fe20-309">Extending Base Type Functionality with Extension Methods</span></span>](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx)
- [<span data-ttu-id="7fe20-310">如何：參考 ASP.NET 主版頁面內容</span><span class="sxs-lookup"><span data-stu-id="7fe20-310">How To: Reference ASP.NET Master Page Content</span></span>](https://msdn.microsoft.com/library/xxwa0ff0.aspx)
- [<span data-ttu-id="7fe20-311">宿主頁面：秘訣、訣竅和陷阱</span><span class="sxs-lookup"><span data-stu-id="7fe20-311">Mater Pages: Tips, Tricks, and Traps</span></span>](http://www.odetocode.com/articles/450.aspx)
- [<span data-ttu-id="7fe20-312">使用用戶端腳本</span><span class="sxs-lookup"><span data-stu-id="7fe20-312">Working with Client-Side Script</span></span>](https://msdn.microsoft.com/library/aa479302.aspx)

### <a name="about-the-author"></a><span data-ttu-id="7fe20-313">關於作者</span><span class="sxs-lookup"><span data-stu-id="7fe20-313">About the Author</span></span>

<span data-ttu-id="7fe20-314">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，自1998起，有多個 ASP/ASP. NET 書籍和創辦人的4GuysFromRolla.com。</span><span class="sxs-lookup"><span data-stu-id="7fe20-314">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of multiple ASP/ASP.NET books and founder of 4GuysFromRolla.com, has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="7fe20-315">Scott 以獨立的顧問、訓練員和作者的身分運作。</span><span class="sxs-lookup"><span data-stu-id="7fe20-315">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="7fe20-316">他的最新著作是[*在24小時內讓自己的 ASP.NET 3.5*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="7fe20-316">His latest book is [*Sams Teach Yourself ASP.NET 3.5 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="7fe20-317">Scott 可以在[mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com)或透過他在[http://ScottOnWriting.NET](http://scottonwriting.net/)的 blog。</span><span class="sxs-lookup"><span data-stu-id="7fe20-317">Scott can be reached at [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com) or via his blog at [http://ScottOnWriting.NET](http://scottonwriting.net/).</span></span>

### <a name="special-thanks-to"></a><span data-ttu-id="7fe20-318">特別感謝</span><span class="sxs-lookup"><span data-stu-id="7fe20-318">Special Thanks To</span></span>

<span data-ttu-id="7fe20-319">本教學課程系列已由許多有用的審核者所審查。</span><span class="sxs-lookup"><span data-stu-id="7fe20-319">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="7fe20-320">本教學課程的領導審查者為 Zack，Suchi Barnerjee。</span><span class="sxs-lookup"><span data-stu-id="7fe20-320">Lead reviewers for this tutorial were Zack Jones and Suchi Barnerjee.</span></span> <span data-ttu-id="7fe20-321">有興趣複習我即將發行的 MSDN 文章嗎？</span><span class="sxs-lookup"><span data-stu-id="7fe20-321">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="7fe20-322">若是如此，請在[mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com)的那一行下拉式。</span><span class="sxs-lookup"><span data-stu-id="7fe20-322">If so, drop me a line at [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="7fe20-323">[上一頁](urls-in-master-pages-vb.md)
> [下一頁](interacting-with-the-master-page-from-the-content-page-vb.md)</span><span class="sxs-lookup"><span data-stu-id="7fe20-323">[Previous](urls-in-master-pages-vb.md)
[Next](interacting-with-the-master-page-from-the-content-page-vb.md)</span></span>
