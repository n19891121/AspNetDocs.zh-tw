---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: 理解和處理信號R中的連接壽命事件 |微軟文件
author: bradygaster
description: 本文介紹如何使用中心 API 公開的事件。
ms.author: bradyg
ms.date: 01/15/2019
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 5bdf20549fccab5d644e35fdf4ce351540c8620d
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/06/2020
ms.locfileid: "80676213"
---
# <a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="49e86-103">了解及處理 SignalR 的連線存留期事件</span><span class="sxs-lookup"><span data-stu-id="49e86-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="49e86-104">本文概述了可以處理的 SignalR 連接、重新連接和斷開連接事件,以及可以配置的超時和保持活動設置。</span><span class="sxs-lookup"><span data-stu-id="49e86-104">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
>
> <span data-ttu-id="49e86-105">本文假定您已經對 SignalR 和連接存留期事件有所瞭解。</span><span class="sxs-lookup"><span data-stu-id="49e86-105">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="49e86-106">有關信號R 的介紹,請參閱[信號R 簡介](../getting-started/introduction-to-signalr.md)。</span><span class="sxs-lookup"><span data-stu-id="49e86-106">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="49e86-107">有關連接存留期事件的清單,請參閱以下資源:</span><span class="sxs-lookup"><span data-stu-id="49e86-107">For lists of connection lifetime events, see the following resources:</span></span>
>
> - [<span data-ttu-id="49e86-108">如何處理集線器類別的連線存留期事件</span><span class="sxs-lookup"><span data-stu-id="49e86-108">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="49e86-109">如何處理 JavaScript 用戶端的連線存留期事件</span><span class="sxs-lookup"><span data-stu-id="49e86-109">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="49e86-110">如何處理 .NET 用戶端的連線存留期事件</span><span class="sxs-lookup"><span data-stu-id="49e86-110">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
>
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="49e86-111">本主題中使用的軟體版本</span><span class="sxs-lookup"><span data-stu-id="49e86-111">Software versions used in this topic</span></span>
>
>
> - [<span data-ttu-id="49e86-112">Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="49e86-112">Visual Studio 2017</span></span>](https://visualstudio.microsoft.com/downloads/)
> - <span data-ttu-id="49e86-113">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="49e86-113">.NET 4.5</span></span>
> - <span data-ttu-id="49e86-114">信號R版本 2</span><span class="sxs-lookup"><span data-stu-id="49e86-114">SignalR version 2</span></span>
>
>
>
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="49e86-115">本主題的早期版本</span><span class="sxs-lookup"><span data-stu-id="49e86-115">Previous versions of this topic</span></span>
>
> <span data-ttu-id="49e86-116">有關早期版本的 SignalR 的資訊,請參閱[SignalR 舊版本](../older-versions/index.md)。</span><span class="sxs-lookup"><span data-stu-id="49e86-116">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
>
> ## <a name="questions-and-comments"></a><span data-ttu-id="49e86-117">問題和評論</span><span class="sxs-lookup"><span data-stu-id="49e86-117">Questions and comments</span></span>
>
> <span data-ttu-id="49e86-118">請留下反饋,關於你喜歡本教程的方式,以及我們可以在頁面底部的評論中改進什麼。</span><span class="sxs-lookup"><span data-stu-id="49e86-118">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="49e86-119">如果您有與本教學沒有直接關係的問題,您可以將它們發表到[ASP.NET SignalR 論壇](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR)或[StackOverflow.com](http://stackoverflow.com/)。</span><span class="sxs-lookup"><span data-stu-id="49e86-119">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>

## <a name="overview"></a><span data-ttu-id="49e86-120">概觀</span><span class="sxs-lookup"><span data-stu-id="49e86-120">Overview</span></span>

<span data-ttu-id="49e86-121">本文包含下列各節：</span><span class="sxs-lookup"><span data-stu-id="49e86-121">This article contains the following sections:</span></span>

- [<span data-ttu-id="49e86-122">連線存留期的術語和機制</span><span class="sxs-lookup"><span data-stu-id="49e86-122">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="49e86-123">訊號R連線、傳輸連線和物理連線</span><span class="sxs-lookup"><span data-stu-id="49e86-123">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="49e86-124">傳輸斷線連接</span><span class="sxs-lookup"><span data-stu-id="49e86-124">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="49e86-125">用戶端斷線連接機制</span><span class="sxs-lookup"><span data-stu-id="49e86-125">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="49e86-126">伺服器斷線連接機制</span><span class="sxs-lookup"><span data-stu-id="49e86-126">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="49e86-127">逾時與保持活動設定</span><span class="sxs-lookup"><span data-stu-id="49e86-127">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="49e86-128">連線逾時</span><span class="sxs-lookup"><span data-stu-id="49e86-128">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="49e86-129">離線逾時</span><span class="sxs-lookup"><span data-stu-id="49e86-129">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="49e86-130">保持活力</span><span class="sxs-lookup"><span data-stu-id="49e86-130">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="49e86-131">如何變更逾時並保持活動設定</span><span class="sxs-lookup"><span data-stu-id="49e86-131">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="49e86-132">如何通知使用者斷線連線</span><span class="sxs-lookup"><span data-stu-id="49e86-132">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="49e86-133">如何持續重新連線</span><span class="sxs-lookup"><span data-stu-id="49e86-133">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="49e86-134">如何在伺服器代碼中斷開客戶端</span><span class="sxs-lookup"><span data-stu-id="49e86-134">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="49e86-135">偵測斷連線的原因</span><span class="sxs-lookup"><span data-stu-id="49e86-135">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="49e86-136">指向 API 參考主題的連結指向 API 的 .NET 4.5 版本。</span><span class="sxs-lookup"><span data-stu-id="49e86-136">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="49e86-137">如果使用 .NET 4,請參閱[API 主題的 .NET 4 版本](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx)。</span><span class="sxs-lookup"><span data-stu-id="49e86-137">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="49e86-138">連線存留期的術語和機制</span><span class="sxs-lookup"><span data-stu-id="49e86-138">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="49e86-139">SignalR Hub`OnReconnected`中的事件處理程式可以直接在給`OnConnected`定用戶端`OnDisconnected`之後執行, 但不能在之後執行。</span><span class="sxs-lookup"><span data-stu-id="49e86-139">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="49e86-140">在沒有斷開連接的情況下進行重新連接的原因是,在 SignalR 中使用"連接"一詞有多種方式。</span><span class="sxs-lookup"><span data-stu-id="49e86-140">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="49e86-141">訊號R連線、傳輸連線和物理連線</span><span class="sxs-lookup"><span data-stu-id="49e86-141">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="49e86-142">本文將區分*SignalR 連線*,*傳輸連線*與*物理連線*:</span><span class="sxs-lookup"><span data-stu-id="49e86-142">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="49e86-143">**SignalR 連接**是指用戶端和伺服器 URL 之間的邏輯關係,由 SignalR API 維護,並由連接 ID 唯一標識。</span><span class="sxs-lookup"><span data-stu-id="49e86-143">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="49e86-144">有關此關係的數據由 SignalR 維護,用於建立傳輸連接。</span><span class="sxs-lookup"><span data-stu-id="49e86-144">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="49e86-145">當用戶端調用`Stop`方法或達到超時限制時,當 SignalR 嘗試重新建立丟失的傳輸連接時,關係結束,SignalR 會釋放數據。</span><span class="sxs-lookup"><span data-stu-id="49e86-145">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="49e86-146">**傳輸連接**是指用戶端和伺服器之間的邏輯關係,由四個傳輸 API 之一維護:WebSockets、伺服器發送的事件、永久幀或長輪詢。</span><span class="sxs-lookup"><span data-stu-id="49e86-146">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="49e86-147">SignalR 使用傳輸 API 創建傳輸連接,傳輸 API 取決於物理網路連接的存在來創建傳輸連接。</span><span class="sxs-lookup"><span data-stu-id="49e86-147">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="49e86-148">當 SignalR 終止傳輸連接或傳輸 API 檢測到物理連接斷開時,傳輸連接將結束。</span><span class="sxs-lookup"><span data-stu-id="49e86-148">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="49e86-149">**物理連接**是指促進用戶端計算機與伺服器計算機之間通信的實體網路鏈路(電線、無線信號、路由器等)。</span><span class="sxs-lookup"><span data-stu-id="49e86-149">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="49e86-150">物理連接必須存在才能建立傳輸連接,並且必須建立傳輸連接才能建立 SignalR 連接。</span><span class="sxs-lookup"><span data-stu-id="49e86-150">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="49e86-151">但是,中斷物理連接並不總是會立即結束傳輸連接或 SignalR 連接,本主題稍後將對此進行說明。</span><span class="sxs-lookup"><span data-stu-id="49e86-151">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="49e86-152">在下圖中,SignalR 連接由集線器 API 和持久連接 API SignalR 層表示,傳輸連接由傳輸層表示,物理連接由伺服器和用戶端之間的線表示。</span><span class="sxs-lookup"><span data-stu-id="49e86-152">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![訊號R架構圖](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="49e86-154">在 SignalR`Start`用戶端中呼叫 該方法時,您提供 SignalR 用戶端代碼,並提供它所需的所有資訊,以便建立與伺服器的物理連接。</span><span class="sxs-lookup"><span data-stu-id="49e86-154">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="49e86-155">SignalR 用戶端代碼使用此資訊發出 HTTP 請求,並建立使用四種傳輸方法之一的物理連接。</span><span class="sxs-lookup"><span data-stu-id="49e86-155">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="49e86-156">如果傳輸連接失敗或伺服器發生故障,SignalR 連接不會立即消失,因為用戶端仍然擁有自動重新建立到同一 SignalR URL 的新傳輸連接所需的資訊。</span><span class="sxs-lookup"><span data-stu-id="49e86-156">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="49e86-157">在這種情況下,不涉及來自使用者應用程式的干預,當 SignalR 用戶端代碼建立新的傳輸連接時,它不會啟動新的 SignalR 連接。</span><span class="sxs-lookup"><span data-stu-id="49e86-157">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="49e86-158">SignalR 連接的連續性反映在這樣一個事實中:在調`Start`用 方法時創建的連接 ID 不會更改。</span><span class="sxs-lookup"><span data-stu-id="49e86-158">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="49e86-159">當`OnReconnected`傳輸連接在丟失後自動重新建立時,中心上的事件處理程式將執行。</span><span class="sxs-lookup"><span data-stu-id="49e86-159">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="49e86-160">事件`OnDisconnected`處理程式在 SignalR 連接的末尾執行。</span><span class="sxs-lookup"><span data-stu-id="49e86-160">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="49e86-161">SignalR 連線可以以以下任何方式結束:</span><span class="sxs-lookup"><span data-stu-id="49e86-161">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="49e86-162">如果用戶端呼叫方法`Stop`,將停止訊息將發送到伺服器,並且客戶端和伺服器都會立即終止 SignalR 連接。</span><span class="sxs-lookup"><span data-stu-id="49e86-162">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="49e86-163">用戶端和伺服器之間的連接丟失後,用戶端將嘗試重新連接,並且伺服器等待用戶端重新連接。</span><span class="sxs-lookup"><span data-stu-id="49e86-163">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="49e86-164">如果重新連接的嘗試不成功,並且斷開連接超時期結束,則用戶端和伺服器都終止 SignalR 連接。</span><span class="sxs-lookup"><span data-stu-id="49e86-164">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="49e86-165">用戶端停止嘗試重新連接,伺服器將釋放其 SignalR 連接的表示形式。</span><span class="sxs-lookup"><span data-stu-id="49e86-165">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="49e86-166">如果用戶端停止運行而沒有機會調用`Stop`該方法,伺服器將等待用戶端重新連接,然後在斷開連接超時期后結束 SignalR 連接。</span><span class="sxs-lookup"><span data-stu-id="49e86-166">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="49e86-167">如果伺服器停止運行,用戶端將嘗試重新連接(重新建立傳輸連接),然後在斷開連接超時期間後結束 SignalR 連接。</span><span class="sxs-lookup"><span data-stu-id="49e86-167">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="49e86-168">當沒有連接問題時,並且使用者應用程式通過調用`Stop`該方法結束 SignalR 連接時,SignalR 連接和傳輸連接大約在同一時間開始和結束。</span><span class="sxs-lookup"><span data-stu-id="49e86-168">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="49e86-169">以下各節將更詳細地介紹其他方案。</span><span class="sxs-lookup"><span data-stu-id="49e86-169">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="49e86-170">傳輸斷線連接</span><span class="sxs-lookup"><span data-stu-id="49e86-170">Transport disconnection scenarios</span></span>

<span data-ttu-id="49e86-171">物理連接可能很慢,或者連接可能有中斷。</span><span class="sxs-lookup"><span data-stu-id="49e86-171">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="49e86-172">根據中斷長度等因素,可能會斷開傳輸連接。</span><span class="sxs-lookup"><span data-stu-id="49e86-172">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="49e86-173">然後,SignalR 嘗試重新建立傳輸連接。</span><span class="sxs-lookup"><span data-stu-id="49e86-173">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="49e86-174">有時傳輸連接 API 檢測到中斷並丟棄傳輸連接,SignalR 會立即發現連接丟失。</span><span class="sxs-lookup"><span data-stu-id="49e86-174">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="49e86-175">在其他情況下,傳輸連接 API 和 SignalR 都不會立即意識到連接已丟失。</span><span class="sxs-lookup"><span data-stu-id="49e86-175">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="49e86-176">對於除長輪詢之外的所有傳輸,SignalR 用戶端使用名為 *"保持活動"* 的函數來檢查傳輸 API 無法檢測到的連接損失。</span><span class="sxs-lookup"><span data-stu-id="49e86-176">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="49e86-177">有關長輪詢連接的資訊,請參閱本主題後面的[超時和保持活動設定](#timeoutkeepalive)。</span><span class="sxs-lookup"><span data-stu-id="49e86-177">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="49e86-178">當連接處於非活動狀態時,伺服器會定期向客戶端發送保持活動數據包。</span><span class="sxs-lookup"><span data-stu-id="49e86-178">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="49e86-179">截至撰寫本文之日,默認頻率為每 10 秒一次。</span><span class="sxs-lookup"><span data-stu-id="49e86-179">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="49e86-180">通過偵聽這些數據包,用戶端可以判斷是否有連接問題。</span><span class="sxs-lookup"><span data-stu-id="49e86-180">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="49e86-181">如果預期時未收到保持活動數據包,則在短時間內用戶端假定存在連接問題,如速度緩慢或中斷。</span><span class="sxs-lookup"><span data-stu-id="49e86-181">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="49e86-182">如果長時間后仍未收到保持活動,則用戶端假定連接已斷開,並開始嘗試重新連接。</span><span class="sxs-lookup"><span data-stu-id="49e86-182">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="49e86-183">下圖說明了在典型方案中在傳輸 API 無法立即識別的物理連接出現問題時引發的用戶端和伺服器事件。</span><span class="sxs-lookup"><span data-stu-id="49e86-183">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="49e86-184">該圖適用於以下情況:</span><span class="sxs-lookup"><span data-stu-id="49e86-184">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="49e86-185">傳輸是 WebSocket、永久幀或伺服器發送的事件。</span><span class="sxs-lookup"><span data-stu-id="49e86-185">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="49e86-186">物理網路連接中斷的時間各不相同。</span><span class="sxs-lookup"><span data-stu-id="49e86-186">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="49e86-187">傳輸 API 不會意識到中斷,因此 SignalR 依賴於保持狀態功能來檢測中斷。</span><span class="sxs-lookup"><span data-stu-id="49e86-187">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![傳輸斷線](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="49e86-189">如果用戶端進入重新連接模式,但無法在斷開連接超時限制內建立傳輸連接,伺服器將終止 SignalR 連接。</span><span class="sxs-lookup"><span data-stu-id="49e86-189">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="49e86-190">發生這種情況時,伺服器將執行 Hub`OnDisconnected`的方法,並排隊將斷開連接消息發送到用戶端,以防用戶端以後設法連接。</span><span class="sxs-lookup"><span data-stu-id="49e86-190">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="49e86-191">如果客戶端隨後重新連接,它將接收斷開連接命令並調`Stop`用 方法。</span><span class="sxs-lookup"><span data-stu-id="49e86-191">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="49e86-192">在這種情況下,`OnReconnected`在用戶端重新連接時不執行,`OnDisconnected`並且在用戶端調`Stop`用 時不執行。</span><span class="sxs-lookup"><span data-stu-id="49e86-192">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="49e86-193">下圖說明了此方案。</span><span class="sxs-lookup"><span data-stu-id="49e86-193">The following diagram illustrates this scenario.</span></span>

![傳輸中斷 - 伺服器逾時](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="49e86-195">可能在用戶端上引發的 SignalR 連接存留期事件如下:</span><span class="sxs-lookup"><span data-stu-id="49e86-195">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="49e86-196">`ConnectionSlow`用戶端事件。</span><span class="sxs-lookup"><span data-stu-id="49e86-196">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="49e86-197">自收到最後一條消息或保持活 ping 以來,保持活動超時的預設比例已過時引發。</span><span class="sxs-lookup"><span data-stu-id="49e86-197">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="49e86-198">默認保持活動超時警告週期為保持活動超時的 2/3。</span><span class="sxs-lookup"><span data-stu-id="49e86-198">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="49e86-199">保持活動超時為 20 秒,因此警告在大約 13 秒時發生。</span><span class="sxs-lookup"><span data-stu-id="49e86-199">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="49e86-200">默認情況下,伺服器每 10 秒發送一次保持活動 ping,客戶端大約每 2 秒檢查一次保持活動 ping(保持活動超時值和保持活動超時警告值之間的三分之一差異)。</span><span class="sxs-lookup"><span data-stu-id="49e86-200">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="49e86-201">如果傳輸 API 意識到斷開連接,則在保持活動超時警告期之前,可能會通知 SignalR 斷開連接。</span><span class="sxs-lookup"><span data-stu-id="49e86-201">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="49e86-202">在這種情況下,`ConnectionSlow`將不會引發該事件,SignalR 將直接轉`Reconnecting`到該 事件。</span><span class="sxs-lookup"><span data-stu-id="49e86-202">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="49e86-203">`Reconnecting`用戶端事件。</span><span class="sxs-lookup"><span data-stu-id="49e86-203">`Reconnecting` client event.</span></span>

    <span data-ttu-id="49e86-204">當 (a) 傳輸 API 檢測到連接丟失,或 (b) 自上次收到消息或保持活動 ping 以來,保持活動超時期已過。</span><span class="sxs-lookup"><span data-stu-id="49e86-204">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="49e86-205">SignalR 用戶端代碼開始嘗試重新連接。</span><span class="sxs-lookup"><span data-stu-id="49e86-205">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="49e86-206">如果您希望應用程式在傳輸連接丟失時執行某些操作,則可以處理此事件。</span><span class="sxs-lookup"><span data-stu-id="49e86-206">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="49e86-207">預設保持活動超時期限當前為 20 秒。</span><span class="sxs-lookup"><span data-stu-id="49e86-207">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="49e86-208">如果用戶端代碼嘗試在 SignalR 處於重新連接模式時調用 Hub 方法,SignalR 將嘗試發送命令。</span><span class="sxs-lookup"><span data-stu-id="49e86-208">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="49e86-209">大多數時候,這種嘗試會失敗,但在某些情況下,它們可能會成功。</span><span class="sxs-lookup"><span data-stu-id="49e86-209">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="49e86-210">對於伺服器發送的事件、永久幀和長輪詢傳輸,SignalR 使用兩個通信通道,一個通信通道是用戶端用於發送消息的,另一個用於接收消息。</span><span class="sxs-lookup"><span data-stu-id="49e86-210">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="49e86-211">用於接收的通道是永久打開的通道,在物理連接中斷時,該通道將關閉。</span><span class="sxs-lookup"><span data-stu-id="49e86-211">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="49e86-212">用於發送的通道仍然可用,因此,如果恢復物理連接,則在重新建立接收通道之前,用戶端到伺服器的方法調用可能成功。</span><span class="sxs-lookup"><span data-stu-id="49e86-212">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="49e86-213">在 SignalR 重新打開用於接收的通道之前,不會接收返回值。</span><span class="sxs-lookup"><span data-stu-id="49e86-213">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="49e86-214">`Reconnected`用戶端事件。</span><span class="sxs-lookup"><span data-stu-id="49e86-214">`Reconnected` client event.</span></span>

    <span data-ttu-id="49e86-215">重新建立傳輸連接時引發。</span><span class="sxs-lookup"><span data-stu-id="49e86-215">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="49e86-216">中心`OnReconnected`中的事件處理程序執行。</span><span class="sxs-lookup"><span data-stu-id="49e86-216">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="49e86-217">`Closed`用戶端事件(JAVAScript`disconnected`中的事件)。</span><span class="sxs-lookup"><span data-stu-id="49e86-217">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="49e86-218">當斷開連接超時期到期時,當 SignalR 用戶端代碼在丟失傳輸連接後嘗試重新連接時引發。</span><span class="sxs-lookup"><span data-stu-id="49e86-218">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="49e86-219">默認斷開連接超時為 30 秒。</span><span class="sxs-lookup"><span data-stu-id="49e86-219">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="49e86-220">(當連接結束時,也會引發此事件,`Stop`因為呼叫該方法。</span><span class="sxs-lookup"><span data-stu-id="49e86-220">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="49e86-221">傳輸 API 未偵測到的傳輸連接中斷,並且不會延遲伺服器中保持活動 ping 的接收時間超過保持活動超時警告期的時間,則可能導致引發任何連接存留期事件。</span><span class="sxs-lookup"><span data-stu-id="49e86-221">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="49e86-222">某些網路環境有意關閉空閒連接,保持狀態數據包的另一個功能是通過讓這些網路知道 SignalR 連接正在使用來説明防止這種情況。</span><span class="sxs-lookup"><span data-stu-id="49e86-222">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="49e86-223">在極端情況下,保持活值的默認頻率可能不足以阻止關閉連接。</span><span class="sxs-lookup"><span data-stu-id="49e86-223">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="49e86-224">在這種情況下,您可以將保持活動 ping 配置為更頻繁地發送。</span><span class="sxs-lookup"><span data-stu-id="49e86-224">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="49e86-225">有關詳細資訊,請參閱本主題後面的[超時和保持活動設定](#timeoutkeepalive)。</span><span class="sxs-lookup"><span data-stu-id="49e86-225">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE]
>
> <span data-ttu-id="49e86-226">**重要提示**:此處描述的事件序列不保證。</span><span class="sxs-lookup"><span data-stu-id="49e86-226">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="49e86-227">根據此方案,SignalR 會嘗試以可預測的方式引發連接存留期事件,但網路事件有許多變化,以及傳輸 API 等基礎通訊框架處理這些事件的許多方式。</span><span class="sxs-lookup"><span data-stu-id="49e86-227">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="49e86-228">例如,用戶端重新`Reconnected`連接時可能不會引發該事件,或者當嘗試建立連接失敗`OnConnected`時,伺服器上的處理程式可能會運行。</span><span class="sxs-lookup"><span data-stu-id="49e86-228">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="49e86-229">本主題僅描述通常由某些典型情況產生的影響。</span><span class="sxs-lookup"><span data-stu-id="49e86-229">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>

<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="49e86-230">用戶端斷線連接機制</span><span class="sxs-lookup"><span data-stu-id="49e86-230">Client disconnection scenarios</span></span>

<span data-ttu-id="49e86-231">在瀏覽器用戶端中,維護 SignalR 連接的 SignalR 用戶端代碼在網頁的 JavaScript 上下文中運行。</span><span class="sxs-lookup"><span data-stu-id="49e86-231">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="49e86-232">這就是為什麼當您從一個頁面導航到另一個頁面時,SignalR 連接必須結束,這就是為什麼如果您從多個瀏覽器視窗或選項卡連接時,您有多個連接與多個連接指示。</span><span class="sxs-lookup"><span data-stu-id="49e86-232">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="49e86-233">當使用者關閉瀏覽器視窗或選項卡,或導航到新頁面或刷新頁面時,SignalR 連接將立即結束,因為 SignalR 用戶端代碼會為您處理該瀏覽器事件`Stop`並調用 該方法。</span><span class="sxs-lookup"><span data-stu-id="49e86-233">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="49e86-234">在這些情況下,或者在應用程式`Stop`呼叫方法時的任何用戶端平臺中`OnDisconnected`, 事件處理程式會立即在伺服器上執行,並且`Closed`客戶端引發事件(事件在 JAvaScript`disconnected`中命名)。</span><span class="sxs-lookup"><span data-stu-id="49e86-234">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="49e86-235">如果用戶端應用程式或運行在崩潰時運行的電腦崩潰或進入睡眠狀態(例如,當使用者關閉便攜式計算機時),伺服器不會被告知發生了什麼。</span><span class="sxs-lookup"><span data-stu-id="49e86-235">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="49e86-236">據伺服器所知,用戶端丟失可能是由於連接中斷,用戶端可能嘗試重新連接。</span><span class="sxs-lookup"><span data-stu-id="49e86-236">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="49e86-237">因此,在這些情況下,伺服器等待給用戶端重新連接的機會,並且`OnDisconnected`在斷開連接超時期到期之前不會執行(預設情況下約為 30 秒)。</span><span class="sxs-lookup"><span data-stu-id="49e86-237">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="49e86-238">下圖說明了此方案。</span><span class="sxs-lookup"><span data-stu-id="49e86-238">The following diagram illustrates this scenario.</span></span>

![用戶端電腦故障](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="49e86-240">伺服器斷線連接機制</span><span class="sxs-lookup"><span data-stu-id="49e86-240">Server disconnection scenarios</span></span>

<span data-ttu-id="49e86-241">當伺服器離線時 (它重新啟動、 失敗、 應用域回收等 ) 結果可能類似於遺失的連接,或者傳輸 API 和 SignalR 可能立即知道伺服器已消失,SignalR 可能開始嘗試重新連線而不引發`ConnectionSlow`事件。</span><span class="sxs-lookup"><span data-stu-id="49e86-241">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="49e86-242">如果用戶端進入重新連接模式,並且伺服器恢復或重新啟動,或者新伺服器在斷開連接超時期到期之前連線,則客戶端將重新連接到已還原或新伺服器。</span><span class="sxs-lookup"><span data-stu-id="49e86-242">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="49e86-243">在這種情況下,SignalR 連接將繼續在用戶端上`Reconnected`, 並引發事件。</span><span class="sxs-lookup"><span data-stu-id="49e86-243">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="49e86-244">在第一台伺服器上,`OnDisconnected`從不執行,在新伺服器上執行`OnReconnected`,`OnConnected`儘管 以前從未為該伺服器上的用戶端執行過。</span><span class="sxs-lookup"><span data-stu-id="49e86-244">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="49e86-245">(如果用戶端在重新啟動或應用域回收后重新連接到同一伺服器,則效果相同,因為當伺服器重新啟動時,它沒有以前連接活動的記憶體。下圖假定傳輸 API 會立即意識到丟失的連接,`ConnectionSlow`因此不會引發 事件。</span><span class="sxs-lookup"><span data-stu-id="49e86-245">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![伺服器容錯並重新連線](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="49e86-247">如果伺服器在斷開連接超時期間不可用,SignalR 連接將結束。</span><span class="sxs-lookup"><span data-stu-id="49e86-247">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="49e86-248">在這種情況下,事件`Closed`(`disconnected`在 JAvaScript 用戶端中)在用戶端上引發,`OnDisconnected`但從未在伺服器上調用。</span><span class="sxs-lookup"><span data-stu-id="49e86-248">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="49e86-249">下圖假定傳輸 API 不會意識到丟失的連接,因此 SignalR 保持`ConnectionSlow`活動功能檢測到該 事件並引發事件。</span><span class="sxs-lookup"><span data-stu-id="49e86-249">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![伺服器故障和逾時](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="49e86-251">逾時與保持活動設定</span><span class="sxs-lookup"><span data-stu-id="49e86-251">Timeout and keepalive settings</span></span>

<span data-ttu-id="49e86-252">預設`ConnectionTimeout`的`DisconnectTimeout`和`KeepAlive`值適用於大多數方案,但如果環境有特殊需要,則可以更改。</span><span class="sxs-lookup"><span data-stu-id="49e86-252">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="49e86-253">例如,如果網路環境關閉空閒 5 秒的連接,則可能必須減小保持活動值。</span><span class="sxs-lookup"><span data-stu-id="49e86-253">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="49e86-254">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="49e86-254">ConnectionTimeout</span></span>

<span data-ttu-id="49e86-255">此設定表示在關閉傳輸連接和打開新連接之前保持傳輸連接打開並等待回應的時間量。</span><span class="sxs-lookup"><span data-stu-id="49e86-255">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="49e86-256">默認值為 110 秒。</span><span class="sxs-lookup"><span data-stu-id="49e86-256">The default value is 110 seconds.</span></span>

<span data-ttu-id="49e86-257">此設置僅在禁用保持活動功能時適用,這通常僅適用於長輪詢傳輸。</span><span class="sxs-lookup"><span data-stu-id="49e86-257">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="49e86-258">下圖說明了此設置對長輪詢傳輸連接的影響。</span><span class="sxs-lookup"><span data-stu-id="49e86-258">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![長輪詢傳輸連線](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="49e86-260">離線逾時</span><span class="sxs-lookup"><span data-stu-id="49e86-260">DisconnectTimeout</span></span>

<span data-ttu-id="49e86-261">此設置表示引發`Disconnected`事件之前傳輸連接丟失後等待的時間量。</span><span class="sxs-lookup"><span data-stu-id="49e86-261">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="49e86-262">預設值為 30 秒。</span><span class="sxs-lookup"><span data-stu-id="49e86-262">The default value is 30 seconds.</span></span> <span data-ttu-id="49e86-263">設定時`DisconnectTimeout`,`KeepAlive`將自動設定為值`DisconnectTimeout`的 1/3。</span><span class="sxs-lookup"><span data-stu-id="49e86-263">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="49e86-264">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="49e86-264">KeepAlive</span></span>

<span data-ttu-id="49e86-265">此設置表示在通過空閒連接發送保持活動數據包之前等待的時間量。</span><span class="sxs-lookup"><span data-stu-id="49e86-265">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="49e86-266">預設值為 10 秒。</span><span class="sxs-lookup"><span data-stu-id="49e86-266">The default value is 10 seconds.</span></span> <span data-ttu-id="49e86-267">此值不能超過該值的`DisconnectTimeout`1/3。</span><span class="sxs-lookup"><span data-stu-id="49e86-267">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="49e86-268">`DisconnectTimeout`如果要設定與`KeepAlive`,則`KeepAlive`設定為`DisconnectTimeout`。</span><span class="sxs-lookup"><span data-stu-id="49e86-268">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="49e86-269">否則,`KeepAlive`當自動設置`KeepAlive`為 超時`DisconnectTimeout`值的 1/3 時,您的設置將被覆蓋。</span><span class="sxs-lookup"><span data-stu-id="49e86-269">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="49e86-270">如果要關閉保持活動功能,請設定為`KeepAlive`null。</span><span class="sxs-lookup"><span data-stu-id="49e86-270">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="49e86-271">對於長輪詢傳輸,將自動禁用保持活動功能。</span><span class="sxs-lookup"><span data-stu-id="49e86-271">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="49e86-272">如何變更逾時並保持活動設定</span><span class="sxs-lookup"><span data-stu-id="49e86-272">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="49e86-273">要更改這些設定的預設值,請將其設置在`Application_Start` *Global.asax*檔中,如以下範例所示。</span><span class="sxs-lookup"><span data-stu-id="49e86-273">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="49e86-274">範例代碼中顯示的值與預設值相同。</span><span class="sxs-lookup"><span data-stu-id="49e86-274">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="49e86-275">如何通知使用者斷線連線</span><span class="sxs-lookup"><span data-stu-id="49e86-275">How to notify the user about disconnections</span></span>

<span data-ttu-id="49e86-276">在某些應用程式中,您可能希望在存在連接問題時向用戶顯示消息。</span><span class="sxs-lookup"><span data-stu-id="49e86-276">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="49e86-277">對於如何以及何時執行此操作,您有多種選擇。</span><span class="sxs-lookup"><span data-stu-id="49e86-277">You have several options for how and when to do this.</span></span> <span data-ttu-id="49e86-278">以下代碼示例適用於使用生成的代理的 JavaScript 用戶端。</span><span class="sxs-lookup"><span data-stu-id="49e86-278">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="49e86-279">在`connectionSlow`SignalR 意識到連接問題後,在事件進入重新連接模式時,立即處理該事件以顯示消息。</span><span class="sxs-lookup"><span data-stu-id="49e86-279">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="49e86-280">當`reconnecting`SignalR 意識到斷開並進入重新連接模式時,處理事件以顯示消息。</span><span class="sxs-lookup"><span data-stu-id="49e86-280">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="49e86-281">當嘗試`disconnected`重新連接超時時,處理事件以顯示消息。在這種情況下,再次與伺服器重新建立連接的唯一方法是透過調用`Start`方法重新啟動 SignalR 連接,這將創建新的連接 ID。</span><span class="sxs-lookup"><span data-stu-id="49e86-281">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="49e86-282">以下代碼示例使用標誌來確保僅在重新連接超時後發出通知,而不是在調用`Stop`方法導致的 SignalR 連接的正常結束之後發出通知。</span><span class="sxs-lookup"><span data-stu-id="49e86-282">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="49e86-283">如何持續重新連線</span><span class="sxs-lookup"><span data-stu-id="49e86-283">How to continuously reconnect</span></span>

<span data-ttu-id="49e86-284">在某些應用程式中,您可能希望在連接丟失且重新連接嘗試超時後自動重新建立連接。為此,可以從`Start``Closed`事件處理程式(JAvaScript`disconnected`用戶端上的事件處理程式)調用方法。</span><span class="sxs-lookup"><span data-stu-id="49e86-284">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="49e86-285">您可能需要在調用`Start`之前等待一段時間,以避免在伺服器或物理連接不可用時過於頻繁地執行此操作。</span><span class="sxs-lookup"><span data-stu-id="49e86-285">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="49e86-286">以下代碼示例適用於使用生成的代理的 JavaScript 用戶端。</span><span class="sxs-lookup"><span data-stu-id="49e86-286">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="49e86-287">在移動用戶端中需要注意的一個潛在問題是,當伺服器或物理連接不可用時,連續重新連接嘗試可能會導致不必要的電池耗盡。</span><span class="sxs-lookup"><span data-stu-id="49e86-287">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="49e86-288">如何在伺服器代碼中斷開客戶端</span><span class="sxs-lookup"><span data-stu-id="49e86-288">How to disconnect a client in server code</span></span>

<span data-ttu-id="49e86-289">SignalR 版本 2 沒有用於斷開用戶端的內建伺服器 API。</span><span class="sxs-lookup"><span data-stu-id="49e86-289">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="49e86-290">有[計劃在未來新增此功能](https://github.com/SignalR/SignalR/issues/2101)。</span><span class="sxs-lookup"><span data-stu-id="49e86-290">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="49e86-291">在當前 SignalR 版本中,將用戶端與伺服器斷開連接的最簡單方法是在用戶端上實現斷開連接方法,並從伺服器調用該方法。</span><span class="sxs-lookup"><span data-stu-id="49e86-291">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="49e86-292">以下代碼示例顯示了使用生成的代理的 JavaScript 客戶端的斷開連接方法。</span><span class="sxs-lookup"><span data-stu-id="49e86-292">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="49e86-293">安全性 - 此連接用戶端的方法和建議的內置 API 都不會解決運行惡意代碼的受駭客攻擊的用戶端的情況,因為用戶端可以重新連接,或者被駭客攻擊`stopClient`的代碼可能會刪除 該方法或更改它的作用。</span><span class="sxs-lookup"><span data-stu-id="49e86-293">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="49e86-294">實現有狀態拒絕服務 (DOS) 保護的適當位置不在框架或伺服器層中,而是在前端基礎結構中。</span><span class="sxs-lookup"><span data-stu-id="49e86-294">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>

<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="49e86-295">偵測斷連線的原因</span><span class="sxs-lookup"><span data-stu-id="49e86-295">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="49e86-296">SignalR 2.1`OnDisconnect`向伺服器 事件添加重載,指示用戶端是否有意斷開連接,而不是超時。如果`StopCalled`客戶端顯示式關閉連接,則參數為 true。</span><span class="sxs-lookup"><span data-stu-id="49e86-296">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="49e86-297">在 JavaScript 中,如果伺服器錯誤導致客戶端斷線連接,則錯誤資訊將作為`$.connection.hub.lastError`傳遞給用戶端 。</span><span class="sxs-lookup"><span data-stu-id="49e86-297">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="49e86-298">**C# 伺服器`stopCalled`代碼 :參數**</span><span class="sxs-lookup"><span data-stu-id="49e86-298">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="49e86-299">**JavaScript 客戶端代碼`lastError``disconnect`:在 事件中訪問。**</span><span class="sxs-lookup"><span data-stu-id="49e86-299">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
