---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: 瞭解和處理 SignalR 中的連接存留期事件 |Microsoft Docs
author: bradygaster
description: 本文說明如何使用中樞 API 所公開的事件。
ms.author: bradyg
ms.date: 01/15/2019
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 5bdf20549fccab5d644e35fdf4ce351540c8620d
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/06/2020
ms.locfileid: "78578810"
---
# <a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="27723-103">了解及處理 SignalR 的連線存留期事件</span><span class="sxs-lookup"><span data-stu-id="27723-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="27723-104">本文概要說明您可以處理的 SignalR 連線、重新連線和中斷線上活動，以及您可以設定的 timeout 和 keepalive 設定。</span><span class="sxs-lookup"><span data-stu-id="27723-104">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
>
> <span data-ttu-id="27723-105">本文假設您已經瞭解 SignalR 和連線存留期事件。</span><span class="sxs-lookup"><span data-stu-id="27723-105">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="27723-106">如需 SignalR 的簡介，請參閱[SignalR 簡介](../getting-started/introduction-to-signalr.md)。</span><span class="sxs-lookup"><span data-stu-id="27723-106">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="27723-107">如需連線存留期事件的清單，請參閱下列資源：</span><span class="sxs-lookup"><span data-stu-id="27723-107">For lists of connection lifetime events, see the following resources:</span></span>
>
> - [<span data-ttu-id="27723-108">如何處理中樞類別中的連接存留期事件</span><span class="sxs-lookup"><span data-stu-id="27723-108">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="27723-109">如何處理 JavaScript 用戶端中的連接存留期事件</span><span class="sxs-lookup"><span data-stu-id="27723-109">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="27723-110">如何處理 .NET 用戶端中的連接存留期事件</span><span class="sxs-lookup"><span data-stu-id="27723-110">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
>
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="27723-111">本主題中使用的軟體版本</span><span class="sxs-lookup"><span data-stu-id="27723-111">Software versions used in this topic</span></span>
>
>
> - [<span data-ttu-id="27723-112">Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="27723-112">Visual Studio 2017</span></span>](https://visualstudio.microsoft.com/downloads/)
> - <span data-ttu-id="27723-113">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="27723-113">.NET 4.5</span></span>
> - <span data-ttu-id="27723-114">SignalR 第2版</span><span class="sxs-lookup"><span data-stu-id="27723-114">SignalR version 2</span></span>
>
>
>
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="27723-115">本主題的先前版本</span><span class="sxs-lookup"><span data-stu-id="27723-115">Previous versions of this topic</span></span>
>
> <span data-ttu-id="27723-116">如需舊版 SignalR 的詳細資訊，請參閱[SignalR 較舊的版本](../older-versions/index.md)。</span><span class="sxs-lookup"><span data-stu-id="27723-116">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
>
> ## <a name="questions-and-comments"></a><span data-ttu-id="27723-117">問題與意見</span><span class="sxs-lookup"><span data-stu-id="27723-117">Questions and comments</span></span>
>
> <span data-ttu-id="27723-118">請留下有關您喜歡本教學課程的意見反應，以及我們可以在頁面底部的批註中改進的內容。</span><span class="sxs-lookup"><span data-stu-id="27723-118">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="27723-119">如果您有與本教學課程不直接相關的問題，您可以將其張貼至[ASP.NET SignalR 論壇](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR)或[StackOverflow.com](http://stackoverflow.com/)。</span><span class="sxs-lookup"><span data-stu-id="27723-119">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>

## <a name="overview"></a><span data-ttu-id="27723-120">概觀</span><span class="sxs-lookup"><span data-stu-id="27723-120">Overview</span></span>

<span data-ttu-id="27723-121">本文包含下列章節：</span><span class="sxs-lookup"><span data-stu-id="27723-121">This article contains the following sections:</span></span>

- [<span data-ttu-id="27723-122">連線存留期術語和案例</span><span class="sxs-lookup"><span data-stu-id="27723-122">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="27723-123">SignalR 連線、傳輸連線和實體連接</span><span class="sxs-lookup"><span data-stu-id="27723-123">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="27723-124">傳輸中斷連接案例</span><span class="sxs-lookup"><span data-stu-id="27723-124">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="27723-125">用戶端中斷連接案例</span><span class="sxs-lookup"><span data-stu-id="27723-125">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="27723-126">伺服器中斷連接案例</span><span class="sxs-lookup"><span data-stu-id="27723-126">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="27723-127">Timeout 和 keepalive 設定</span><span class="sxs-lookup"><span data-stu-id="27723-127">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="27723-128">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="27723-128">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="27723-129">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="27723-129">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="27723-130">保</span><span class="sxs-lookup"><span data-stu-id="27723-130">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="27723-131">如何變更 timeout 和 keepalive 設定</span><span class="sxs-lookup"><span data-stu-id="27723-131">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="27723-132">如何通知使用者中斷連線</span><span class="sxs-lookup"><span data-stu-id="27723-132">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="27723-133">如何持續重新連線</span><span class="sxs-lookup"><span data-stu-id="27723-133">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="27723-134">如何中斷用戶端與伺服器程式碼的連線</span><span class="sxs-lookup"><span data-stu-id="27723-134">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="27723-135">偵測中斷連接的原因</span><span class="sxs-lookup"><span data-stu-id="27723-135">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="27723-136">API 參考主題的連結是針對 .NET 4.5 版的 API。</span><span class="sxs-lookup"><span data-stu-id="27723-136">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="27723-137">如果您使用的是 .NET 4，請參閱[.net 4 版本的 API 主題](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx)。</span><span class="sxs-lookup"><span data-stu-id="27723-137">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="27723-138">連線存留期術語和案例</span><span class="sxs-lookup"><span data-stu-id="27723-138">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="27723-139">SignalR 中樞內的 `OnReconnected` 事件處理常式可以在 `OnConnected` 之後直接執行，而不是在指定的用戶端 `OnDisconnected` 之後。</span><span class="sxs-lookup"><span data-stu-id="27723-139">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="27723-140">您可以在沒有中斷連線的情況下進行重新連線的原因，就是在 SignalR 中使用「連線」這個字的幾種方式。</span><span class="sxs-lookup"><span data-stu-id="27723-140">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="27723-141">SignalR 連線、傳輸連線和實體連接</span><span class="sxs-lookup"><span data-stu-id="27723-141">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="27723-142">本文將區別*SignalR 連接*、*傳輸*連線和*實體*連線：</span><span class="sxs-lookup"><span data-stu-id="27723-142">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="27723-143">**SignalR**連線是指用戶端和伺服器 URL 之間的邏輯關聯性，由 SignalR API 維護，並由連接識別碼唯一識別。</span><span class="sxs-lookup"><span data-stu-id="27723-143">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="27723-144">此關聯性的相關資料是由 SignalR 維護，用來建立傳輸連接。</span><span class="sxs-lookup"><span data-stu-id="27723-144">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="27723-145">當用戶端呼叫 `Stop` 方法，或當 SignalR 嘗試重新建立遺失的傳輸連線時，當到達時，關聯性會結束並 SignalR 處置資料。</span><span class="sxs-lookup"><span data-stu-id="27723-145">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="27723-146">**傳輸**連線指的是用戶端與伺服器之間的邏輯關聯性，由四個傳輸 api 的其中一個來維護： websocket、伺服器傳送事件、永久框架或長時間輪詢。</span><span class="sxs-lookup"><span data-stu-id="27723-146">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="27723-147">SignalR 使用傳輸 API 來建立傳輸連線，而傳輸 API 則取決於實體網路連線是否存在，以建立傳輸連接。</span><span class="sxs-lookup"><span data-stu-id="27723-147">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="27723-148">當 SignalR 終止時，或當傳輸 API 偵測到實體連接中斷時，傳輸連接就會結束。</span><span class="sxs-lookup"><span data-stu-id="27723-148">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="27723-149">**實體**連線指的是實體網路連結（有線、無線信號、路由器等），可協助用戶端電腦和伺服器電腦之間的通訊。</span><span class="sxs-lookup"><span data-stu-id="27723-149">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="27723-150">必須要有實體連接，才能建立傳輸連線，而且必須建立傳輸連線，才能建立 SignalR 連接。</span><span class="sxs-lookup"><span data-stu-id="27723-150">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="27723-151">不過，中斷實體連接並不一定會立即結束傳輸連線或 SignalR 連線，如本主題稍後所述。</span><span class="sxs-lookup"><span data-stu-id="27723-151">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="27723-152">在下圖中，SignalR 連線是由中樞 API 和 PersistentConnection API SignalR 層代表，傳輸連接是以傳輸層來表示，而實體連接則是由伺服器之間的程式程式碼來表示。和用戶端。</span><span class="sxs-lookup"><span data-stu-id="27723-152">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![SignalR 架構圖](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="27723-154">當您在 SignalR 用戶端中呼叫 `Start` 方法時，您會提供 SignalR 用戶端程式代碼，以及建立與伺服器的實體連接時所需的所有資訊。</span><span class="sxs-lookup"><span data-stu-id="27723-154">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="27723-155">SignalR 用戶端程式代碼會使用這項資訊來提出 HTTP 要求，並建立使用四種傳輸方法之一的實體連接。</span><span class="sxs-lookup"><span data-stu-id="27723-155">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="27723-156">如果傳輸連線失敗或伺服器失敗，則 SignalR 連線不會立即消失，因為用戶端仍具有自動重新建立連線到相同 SignalR URL 的新傳輸連接所需的資訊。</span><span class="sxs-lookup"><span data-stu-id="27723-156">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="27723-157">在此案例中，不涉及使用者應用程式的介入，而且當 SignalR 用戶端程式代碼建立新的傳輸連線時，並不會啟動新的 SignalR 連接。</span><span class="sxs-lookup"><span data-stu-id="27723-157">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="27723-158">SignalR 連接的持續性會反映在您呼叫 `Start` 方法時所建立的連線識別碼不會變更的事實中。</span><span class="sxs-lookup"><span data-stu-id="27723-158">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="27723-159">當傳輸連線在遺失後自動重新建立時，中樞上的 `OnReconnected` 事件處理常式就會執行。</span><span class="sxs-lookup"><span data-stu-id="27723-159">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="27723-160">`OnDisconnected` 事件處理常式會在 SignalR 連接結束時執行。</span><span class="sxs-lookup"><span data-stu-id="27723-160">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="27723-161">SignalR 連接可以下列任何一種方式結束：</span><span class="sxs-lookup"><span data-stu-id="27723-161">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="27723-162">如果用戶端呼叫 `Stop` 方法，就會將停止訊息傳送至伺服器，而且用戶端和伺服器都會立即結束 SignalR 連線。</span><span class="sxs-lookup"><span data-stu-id="27723-162">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="27723-163">在用戶端與伺服器之間的連線中斷之後，用戶端會嘗試重新連接，而伺服器會等待用戶端重新連線。</span><span class="sxs-lookup"><span data-stu-id="27723-163">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="27723-164">如果嘗試重新連線失敗，而中斷連線超時期間結束，則用戶端和伺服器都會結束 SignalR 連線。</span><span class="sxs-lookup"><span data-stu-id="27723-164">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="27723-165">用戶端會停止嘗試重新連線，而伺服器會處置其 SignalR 連接的表示。</span><span class="sxs-lookup"><span data-stu-id="27723-165">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="27723-166">如果用戶端在沒有機會呼叫 `Stop` 方法的情況下停止執行，伺服器會等待用戶端重新連線，然後在中斷連線超時時間之後結束 SignalR 連線。</span><span class="sxs-lookup"><span data-stu-id="27723-166">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="27723-167">如果伺服器停止執行，用戶端會嘗試重新連線（重新建立傳輸連線），然後在中斷連線超時時間之後結束 SignalR 連接。</span><span class="sxs-lookup"><span data-stu-id="27723-167">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="27723-168">當沒有連線問題時，如果使用者應用程式藉由呼叫 `Stop` 方法來結束 SignalR 連接，則 SignalR 連接和傳輸連接會在大約相同的時間開始和結束。</span><span class="sxs-lookup"><span data-stu-id="27723-168">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="27723-169">下列各節將更詳細地說明其他案例。</span><span class="sxs-lookup"><span data-stu-id="27723-169">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="27723-170">傳輸中斷連接案例</span><span class="sxs-lookup"><span data-stu-id="27723-170">Transport disconnection scenarios</span></span>

<span data-ttu-id="27723-171">實體連接可能很慢，或連線中斷。</span><span class="sxs-lookup"><span data-stu-id="27723-171">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="27723-172">視停機時間長度的因素而定，傳輸連接可能會被捨棄。</span><span class="sxs-lookup"><span data-stu-id="27723-172">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="27723-173">SignalR 接著會嘗試重新建立傳輸連接。</span><span class="sxs-lookup"><span data-stu-id="27723-173">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="27723-174">有時傳輸連線 API 會偵測中斷並卸載傳輸連線，而 SignalR 會立即發現連線已中斷。</span><span class="sxs-lookup"><span data-stu-id="27723-174">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="27723-175">在其他情況下，傳輸連線 API 和 SignalR 都不會立即得知連線是否已中斷。</span><span class="sxs-lookup"><span data-stu-id="27723-175">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="27723-176">對於長時間輪詢以外的所有傳輸，SignalR 用戶端會使用名為*keepalive*的函數來檢查傳輸 API 無法偵測到的連線中斷。</span><span class="sxs-lookup"><span data-stu-id="27723-176">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="27723-177">如需長時間輪詢連接的詳細資訊，請參閱本主題稍後的[Timeout 和 keepalive 設定](#timeoutkeepalive)。</span><span class="sxs-lookup"><span data-stu-id="27723-177">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="27723-178">當連接處於非作用中狀態時，伺服器會定期將 keepalive 封包傳送至用戶端。</span><span class="sxs-lookup"><span data-stu-id="27723-178">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="27723-179">在撰寫本文的日期起，預設頻率為每10秒一次。</span><span class="sxs-lookup"><span data-stu-id="27723-179">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="27723-180">藉由接聽這些封包，用戶端可以判斷是否有連線問題。</span><span class="sxs-lookup"><span data-stu-id="27723-180">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="27723-181">如果預期不會收到 keepalive 封包，則在短暫的時間之後，用戶端會假設有連線問題，例如緩慢或中斷。</span><span class="sxs-lookup"><span data-stu-id="27723-181">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="27723-182">如果在較長的時間之後仍未收到 keepalive，用戶端會假設已卸載連接，並開始嘗試重新連線。</span><span class="sxs-lookup"><span data-stu-id="27723-182">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="27723-183">下圖說明當傳輸 API 無法立即辨識實體連線問題時，在一般案例中引發的用戶端和伺服器事件。</span><span class="sxs-lookup"><span data-stu-id="27723-183">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="27723-184">圖表適用于下列情況：</span><span class="sxs-lookup"><span data-stu-id="27723-184">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="27723-185">傳輸是 Websocket、永久框架或伺服器傳送事件。</span><span class="sxs-lookup"><span data-stu-id="27723-185">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="27723-186">實體網路連線有不同的中斷期間。</span><span class="sxs-lookup"><span data-stu-id="27723-186">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="27723-187">傳輸 API 不會察覺中斷，因此 SignalR 會依賴 keepalive 功能來偵測它們。</span><span class="sxs-lookup"><span data-stu-id="27723-187">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![傳輸中斷連線](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="27723-189">如果用戶端進入重新連線模式，但無法在中斷連線超時限制內建立傳輸連線，伺服器就會終止 SignalR 連接。</span><span class="sxs-lookup"><span data-stu-id="27723-189">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="27723-190">發生這種情況時，伺服器會執行中樞的 `OnDisconnected` 方法，並將中斷連線訊息排入佇列，以在用戶端管理以供稍後連線時傳送至用戶端。</span><span class="sxs-lookup"><span data-stu-id="27723-190">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="27723-191">如果用戶端接著重新連接，它會接收 disconnect 命令並呼叫 `Stop` 方法。</span><span class="sxs-lookup"><span data-stu-id="27723-191">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="27723-192">在此案例中，當用戶端重新連接時，不會執行 `OnReconnected`，而且當用戶端呼叫 `Stop`時，不會執行 `OnDisconnected`。</span><span class="sxs-lookup"><span data-stu-id="27723-192">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="27723-193">下圖說明此案例。</span><span class="sxs-lookup"><span data-stu-id="27723-193">The following diagram illustrates this scenario.</span></span>

![傳輸中斷-伺服器超時](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="27723-195">可能在用戶端上引發的 SignalR 連接存留期事件如下：</span><span class="sxs-lookup"><span data-stu-id="27723-195">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="27723-196">`ConnectionSlow` 用戶端事件。</span><span class="sxs-lookup"><span data-stu-id="27723-196">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="27723-197">當 keepalive 超時期間的預設比例在收到最後一則訊息或 keepalive ping 之後引發。</span><span class="sxs-lookup"><span data-stu-id="27723-197">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="27723-198">預設的 keepalive 超時警告期間為2/3 的 keepalive 時間。</span><span class="sxs-lookup"><span data-stu-id="27723-198">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="27723-199">Keepalive 超時時間為20秒，因此警告大約會在13秒內發生。</span><span class="sxs-lookup"><span data-stu-id="27723-199">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="27723-200">根據預設，伺服器每隔10秒會傳送 keepalive ping，而且用戶端會每隔2秒檢查一次 keepalive ping （keepalive 超時值與 keepalive 超時警告值之間的差異三分之一）。</span><span class="sxs-lookup"><span data-stu-id="27723-200">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="27723-201">如果傳輸 API 會察覺中斷連線，則在 keepalive 超時警告期間通過之前，SignalR 可能會收到中斷連線的通知。</span><span class="sxs-lookup"><span data-stu-id="27723-201">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="27723-202">在此情況下，將不會引發 `ConnectionSlow` 事件，而 SignalR 會直接進入 `Reconnecting` 事件。</span><span class="sxs-lookup"><span data-stu-id="27723-202">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="27723-203">`Reconnecting` 用戶端事件。</span><span class="sxs-lookup"><span data-stu-id="27723-203">`Reconnecting` client event.</span></span>

    <span data-ttu-id="27723-204">當（a）傳輸 API 偵測到連接遺失時引發，或（b）在收到最後一則訊息或 keepalive ping 之後已經過。</span><span class="sxs-lookup"><span data-stu-id="27723-204">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="27723-205">SignalR 用戶端程式代碼會開始嘗試重新連線。</span><span class="sxs-lookup"><span data-stu-id="27723-205">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="27723-206">如果您想要讓應用程式在傳輸連接中斷時採取某種動作，可以處理這個事件。</span><span class="sxs-lookup"><span data-stu-id="27723-206">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="27723-207">預設的 keepalive 超時時間目前為20秒。</span><span class="sxs-lookup"><span data-stu-id="27723-207">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="27723-208">如果您的用戶端程式代碼在 SignalR 處於重新連線模式時嘗試呼叫中樞方法，SignalR 會嘗試傳送命令。</span><span class="sxs-lookup"><span data-stu-id="27723-208">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="27723-209">在大部分的情況下，這類嘗試會失敗，但在某些情況下，可能會成功。</span><span class="sxs-lookup"><span data-stu-id="27723-209">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="27723-210">對於伺服器傳送的事件、永遠的框架和長輪詢傳輸，SignalR 會使用兩個通道，其中一個是用戶端用來傳送訊息的通道，另一個則是用來接收訊息。</span><span class="sxs-lookup"><span data-stu-id="27723-210">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="27723-211">用來接收的通道是永久開啟的通道，這是實體連接中斷時所關閉的通道。</span><span class="sxs-lookup"><span data-stu-id="27723-211">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="27723-212">用於傳送的通道仍可供使用，因此，如果還原實體連線，從用戶端到伺服器的方法呼叫可能會在接收通道重新建立之前成功。</span><span class="sxs-lookup"><span data-stu-id="27723-212">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="27723-213">在 SignalR 重新開啟用來接收的通道之前，不會收到傳回值。</span><span class="sxs-lookup"><span data-stu-id="27723-213">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="27723-214">`Reconnected` 用戶端事件。</span><span class="sxs-lookup"><span data-stu-id="27723-214">`Reconnected` client event.</span></span>

    <span data-ttu-id="27723-215">重新建立傳輸連接時引發。</span><span class="sxs-lookup"><span data-stu-id="27723-215">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="27723-216">中樞內的 `OnReconnected` 事件處理常式會執行。</span><span class="sxs-lookup"><span data-stu-id="27723-216">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="27723-217">`Closed` 用戶端事件（JavaScript 中的`disconnected` 事件）。</span><span class="sxs-lookup"><span data-stu-id="27723-217">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="27723-218">當 SignalR 用戶端程式代碼在失去傳輸連線後嘗試重新連線時，當中斷連線超時期間過期時引發。</span><span class="sxs-lookup"><span data-stu-id="27723-218">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="27723-219">預設的中斷連線超時時間為30秒。</span><span class="sxs-lookup"><span data-stu-id="27723-219">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="27723-220">（當連接因為呼叫 `Stop` 方法而結束時，也會引發這個事件）。</span><span class="sxs-lookup"><span data-stu-id="27723-220">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="27723-221">傳輸 API 不會偵測到傳輸連線中斷，而且不會延遲從伺服器接收 keepalive ping 的時間超過 keepalive 超時警告期間，可能不會導致任何連線存留期事件引發。</span><span class="sxs-lookup"><span data-stu-id="27723-221">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="27723-222">有些網路環境故意關閉閒置連線，而 keepalive 封包的另一個功能是讓這些網路知道 SignalR 連線正在使用中，藉此避免這種情況。</span><span class="sxs-lookup"><span data-stu-id="27723-222">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="27723-223">在極端情況下，keepalive ping 的預設頻率可能不足以防止關閉的連接。</span><span class="sxs-lookup"><span data-stu-id="27723-223">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="27723-224">在此情況下，您可以設定讓 keepalive ping 更頻繁地傳送。</span><span class="sxs-lookup"><span data-stu-id="27723-224">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="27723-225">如需詳細資訊，請參閱本主題稍後的[Timeout 和 keepalive 設定](#timeoutkeepalive)。</span><span class="sxs-lookup"><span data-stu-id="27723-225">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE]
>
> <span data-ttu-id="27723-226">**重要**事項：不保證此處所述的事件順序。</span><span class="sxs-lookup"><span data-stu-id="27723-226">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="27723-227">SignalR 會根據此配置，以可預測的方式讓每次嘗試引發連線存留期事件，但有許多網路事件的變化，還有許多方法，例如傳輸 Api 處理它們的基礎通訊架構。</span><span class="sxs-lookup"><span data-stu-id="27723-227">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="27723-228">例如，當用戶端重新連線時，可能不會引發 `Reconnected` 事件，或者當嘗試建立連線失敗時，伺服器上的 `OnConnected` 處理常式可能會執行。</span><span class="sxs-lookup"><span data-stu-id="27723-228">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="27723-229">本主題僅說明某些一般情況下通常會產生的效果。</span><span class="sxs-lookup"><span data-stu-id="27723-229">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>

<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="27723-230">用戶端中斷連接案例</span><span class="sxs-lookup"><span data-stu-id="27723-230">Client disconnection scenarios</span></span>

<span data-ttu-id="27723-231">在瀏覽器用戶端中，維護 SignalR 連接的 SignalR 用戶端程式代碼會在網頁的 JavaScript 內容中執行。</span><span class="sxs-lookup"><span data-stu-id="27723-231">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="27723-232">這就是為什麼當您從一頁流覽到另一個頁面時，SignalR 連線必須結束，這就是為什麼當您從多個瀏覽器視窗或索引標籤連接時，如果您有多個連接識別碼的連接，就會有</span><span class="sxs-lookup"><span data-stu-id="27723-232">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="27723-233">當使用者關閉瀏覽器視窗或索引標籤，或流覽至新頁面或重新整理頁面時，SignalR 連接會立即結束，因為 SignalR 用戶端程式代碼會為您處理該瀏覽器事件，並呼叫 `Stop` 方法。</span><span class="sxs-lookup"><span data-stu-id="27723-233">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="27723-234">在這些情況下，或在任何用戶端平臺中，當您的應用程式呼叫 `Stop` 方法時，`OnDisconnected` 事件處理常式會在伺服器上立即執行，而用戶端會引發 `Closed` 事件（此事件在 JavaScript 中會命名為 `disconnected`）。</span><span class="sxs-lookup"><span data-stu-id="27723-234">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="27723-235">如果用戶端應用程式或其執行所在的電腦損毀或進入睡眠狀態（例如，當使用者關閉膝上型電腦時），伺服器就不會收到發生什麼情況的通知。</span><span class="sxs-lookup"><span data-stu-id="27723-235">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="27723-236">只要伺服器知道，遺失用戶端可能是因為連線中斷，而且用戶端可能嘗試重新連線。</span><span class="sxs-lookup"><span data-stu-id="27723-236">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="27723-237">因此，在這些案例中，伺服器會等待讓用戶端有機會重新連線，而且 `OnDisconnected` 在中斷連線超時期間（預設為大約30秒）後才會執行。</span><span class="sxs-lookup"><span data-stu-id="27723-237">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="27723-238">下圖說明此案例。</span><span class="sxs-lookup"><span data-stu-id="27723-238">The following diagram illustrates this scenario.</span></span>

![用戶端電腦失敗](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="27723-240">伺服器中斷連接案例</span><span class="sxs-lookup"><span data-stu-id="27723-240">Server disconnection scenarios</span></span>

<span data-ttu-id="27723-241">當伺服器離線時--它會重新開機、失敗、應用程式網域回收等等。--結果可能類似于連線中斷，或傳輸 API 和 SignalR 可能會立即得知伺服器已消失，而 SignalR 可能會開始嘗試重新連線，而不會引發 `ConnectionSlow` 事件。</span><span class="sxs-lookup"><span data-stu-id="27723-241">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="27723-242">如果用戶端進入重新連線模式，且伺服器復原或重新開機，或是新的伺服器在中斷連接逾時期限到期之前上線，用戶端就會重新連接到已還原或新的伺服器。</span><span class="sxs-lookup"><span data-stu-id="27723-242">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="27723-243">在此情況下，SignalR 連接會繼續在用戶端上執行，並引發 `Reconnected` 事件。</span><span class="sxs-lookup"><span data-stu-id="27723-243">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="27723-244">在第一部伺服器上，一律不會執行 `OnDisconnected`，而在新的伺服器上，`OnReconnected` 會執行，但在之前，該伺服器上的該用戶端從未執行過 `OnConnected`。</span><span class="sxs-lookup"><span data-stu-id="27723-244">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="27723-245">（如果用戶端在重新開機或應用程式域回收後重新連線到相同的伺服器，效果就會相同，因為當伺服器重新開機時，它沒有任何記憶體的先前連線活動）。下圖假設傳輸 API 會立即察覺遺失的連線，因此不會引發 `ConnectionSlow` 事件。</span><span class="sxs-lookup"><span data-stu-id="27723-245">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![伺服器失敗和重新連接](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="27723-247">如果伺服器在中斷連線超時時間內無法使用，SignalR 連接就會結束。</span><span class="sxs-lookup"><span data-stu-id="27723-247">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="27723-248">在此案例中，`Closed` 事件（在 JavaScript 用戶端中`disconnected`）會在用戶端上引發，但伺服器上永遠不會呼叫 `OnDisconnected`。</span><span class="sxs-lookup"><span data-stu-id="27723-248">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="27723-249">下圖假設傳輸 API 不會察覺到連線中斷，因此 SignalR keepalive 功能會偵測到該連接，並引發 `ConnectionSlow` 事件。</span><span class="sxs-lookup"><span data-stu-id="27723-249">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![伺服器失敗和超時](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="27723-251">Timeout 和 keepalive 設定</span><span class="sxs-lookup"><span data-stu-id="27723-251">Timeout and keepalive settings</span></span>

<span data-ttu-id="27723-252">預設 `ConnectionTimeout`、`DisconnectTimeout`和 `KeepAlive` 值適用于大部分的案例，但如果您的環境有特殊需求，則可加以變更。</span><span class="sxs-lookup"><span data-stu-id="27723-252">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="27723-253">例如，如果您的網路環境關閉閒置5秒的連線，您可能必須減少 keepalive 值。</span><span class="sxs-lookup"><span data-stu-id="27723-253">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="27723-254">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="27723-254">ConnectionTimeout</span></span>

<span data-ttu-id="27723-255">這項設定代表在關閉傳輸連線並等候回應，然後開啟新的連線時，所需的時間量。</span><span class="sxs-lookup"><span data-stu-id="27723-255">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="27723-256">預設值為110秒。</span><span class="sxs-lookup"><span data-stu-id="27723-256">The default value is 110 seconds.</span></span>

<span data-ttu-id="27723-257">此設定僅適用于停用 keepalive 功能時，這通常只適用于長時間輪詢傳輸。</span><span class="sxs-lookup"><span data-stu-id="27723-257">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="27723-258">下圖說明此設定在長輪詢傳輸連接上的效果。</span><span class="sxs-lookup"><span data-stu-id="27723-258">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![長時間輪詢傳輸連接](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="27723-260">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="27723-260">DisconnectTimeout</span></span>

<span data-ttu-id="27723-261">此設定代表在引發 `Disconnected` 事件之前，傳輸連線中斷後所要等待的時間量。</span><span class="sxs-lookup"><span data-stu-id="27723-261">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="27723-262">預設值為 30 秒。</span><span class="sxs-lookup"><span data-stu-id="27723-262">The default value is 30 seconds.</span></span> <span data-ttu-id="27723-263">當您設定 `DisconnectTimeout`時，`KeepAlive` 會自動設定為1/3 的 `DisconnectTimeout` 值。</span><span class="sxs-lookup"><span data-stu-id="27723-263">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="27723-264">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="27723-264">KeepAlive</span></span>

<span data-ttu-id="27723-265">此設定代表透過閒置連線傳送 keepalive 封包之前要等待的時間量。</span><span class="sxs-lookup"><span data-stu-id="27723-265">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="27723-266">預設值為 10 秒。</span><span class="sxs-lookup"><span data-stu-id="27723-266">The default value is 10 seconds.</span></span> <span data-ttu-id="27723-267">此值不得超過1/3 的 `DisconnectTimeout` 值。</span><span class="sxs-lookup"><span data-stu-id="27723-267">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="27723-268">如果您想要同時設定 `DisconnectTimeout` 和 `KeepAlive`，請在 `DisconnectTimeout`之後設定 `KeepAlive`。</span><span class="sxs-lookup"><span data-stu-id="27723-268">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="27723-269">否則，當 `DisconnectTimeout` 自動將 `KeepAlive` 設定為 timeout 值的1/3 時，將會覆寫您的 `KeepAlive` 設定。</span><span class="sxs-lookup"><span data-stu-id="27723-269">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="27723-270">如果您想要停用 keepalive 功能，請將 `KeepAlive` 設定為 null。</span><span class="sxs-lookup"><span data-stu-id="27723-270">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="27723-271">長期輪詢傳輸會自動停用 Keepalive 功能。</span><span class="sxs-lookup"><span data-stu-id="27723-271">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="27723-272">如何變更 timeout 和 keepalive 設定</span><span class="sxs-lookup"><span data-stu-id="27723-272">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="27723-273">若要變更這些設定的預設值，請在*global.asax*檔案的 `Application_Start` 中設定它們，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="27723-273">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="27723-274">範例程式碼中所顯示的值與預設值相同。</span><span class="sxs-lookup"><span data-stu-id="27723-274">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="27723-275">如何通知使用者中斷連線</span><span class="sxs-lookup"><span data-stu-id="27723-275">How to notify the user about disconnections</span></span>

<span data-ttu-id="27723-276">在某些應用程式中，當發生連線問題時，您可能會想要向使用者顯示訊息。</span><span class="sxs-lookup"><span data-stu-id="27723-276">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="27723-277">您有數個選項可用於執行此動作的方式和時機。</span><span class="sxs-lookup"><span data-stu-id="27723-277">You have several options for how and when to do this.</span></span> <span data-ttu-id="27723-278">下列程式碼範例適用于使用所產生之 proxy 的 JavaScript 用戶端。</span><span class="sxs-lookup"><span data-stu-id="27723-278">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="27723-279">處理 `connectionSlow` 事件，以便在 SignalR 知道連線問題，然後進入重新連接模式之前，立即顯示訊息。</span><span class="sxs-lookup"><span data-stu-id="27723-279">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="27723-280">處理 `reconnecting` 事件，以在 SignalR 感知中斷連線且進入重新連接模式時顯示訊息。</span><span class="sxs-lookup"><span data-stu-id="27723-280">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="27723-281">處理 `disconnected` 事件，以在嘗試重新連線時顯示訊息。在此案例中，重新建立與伺服器之連線的唯一方法是，藉由呼叫 `Start` 方法來重新開機 SignalR 連接，這會建立新的連線識別碼。</span><span class="sxs-lookup"><span data-stu-id="27723-281">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="27723-282">下列程式碼範例會使用旗標，確保您只會在重新連接的超時時間之後發出通知，而不是在正常結束後，透過呼叫 `Stop` 方法所造成的 SignalR 連接。</span><span class="sxs-lookup"><span data-stu-id="27723-282">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="27723-283">如何持續重新連線</span><span class="sxs-lookup"><span data-stu-id="27723-283">How to continuously reconnect</span></span>

<span data-ttu-id="27723-284">在某些應用程式中，您可能會想要在連線中斷之後自動重新建立連線，而重新連接的嘗試已超時。若要這麼做，您可以從 `Closed` 事件處理常式（JavaScript 用戶端上的`disconnected` 事件處理常式）呼叫 `Start` 方法。</span><span class="sxs-lookup"><span data-stu-id="27723-284">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="27723-285">在呼叫 `Start` 之前，您可能會想要等待一段時間，以避免在伺服器或實體連接無法使用時，過於頻繁地這麼做。</span><span class="sxs-lookup"><span data-stu-id="27723-285">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="27723-286">下列程式碼範例適用于使用所產生之 proxy 的 JavaScript 用戶端。</span><span class="sxs-lookup"><span data-stu-id="27723-286">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="27723-287">在行動用戶端中必須注意的一個潛在問題是，當伺服器或實體連線無法使用時，連續重新連線嘗試可能會造成不必要的電池耗盡。</span><span class="sxs-lookup"><span data-stu-id="27723-287">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="27723-288">如何中斷用戶端與伺服器程式碼的連線</span><span class="sxs-lookup"><span data-stu-id="27723-288">How to disconnect a client in server code</span></span>

<span data-ttu-id="27723-289">SignalR 第2版沒有內建的伺服器 API 可中斷用戶端的連線。</span><span class="sxs-lookup"><span data-stu-id="27723-289">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="27723-290">未來會有[新增這項功能的計畫](https://github.com/SignalR/SignalR/issues/2101)。</span><span class="sxs-lookup"><span data-stu-id="27723-290">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="27723-291">在目前的 SignalR 版本中，將用戶端與伺服器中斷連線的最簡單方式，就是在用戶端上執行 disconnect 方法，並從伺服器呼叫該方法。</span><span class="sxs-lookup"><span data-stu-id="27723-291">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="27723-292">下列程式碼範例會使用產生的 proxy，顯示 JavaScript 用戶端的中斷連接方法。</span><span class="sxs-lookup"><span data-stu-id="27723-292">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="27723-293">安全性-這不是用來中斷用戶端連線的這種方法，也不是建議的內建 API，會解決因為用戶端可能會重新連線，或遭到駭客攻擊的程式碼可能會移除 `stopClient` 方法或變更其用途的攻擊。</span><span class="sxs-lookup"><span data-stu-id="27723-293">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="27723-294">執行具狀態的拒絕服務（DOS）保護的適當位置不在架構或伺服器層中，而是在前端基礎結構中。</span><span class="sxs-lookup"><span data-stu-id="27723-294">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>

<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="27723-295">偵測中斷連接的原因</span><span class="sxs-lookup"><span data-stu-id="27723-295">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="27723-296">SignalR 2.1 會將多載加入伺服器 `OnDisconnect` 事件，以指出用戶端是否刻意中斷連接，而不是計時。如果用戶端明確關閉連接，`StopCalled` 參數為 true。</span><span class="sxs-lookup"><span data-stu-id="27723-296">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="27723-297">在 JavaScript 中，如果伺服器錯誤導致用戶端中斷連線，錯誤資訊會以 `$.connection.hub.lastError`的形式傳遞給用戶端。</span><span class="sxs-lookup"><span data-stu-id="27723-297">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="27723-298">**C#伺服器程式碼： `stopCalled` 參數**</span><span class="sxs-lookup"><span data-stu-id="27723-298">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="27723-299">**JavaScript 用戶端程式代碼：存取 `disconnect` 事件中的 `lastError`。**</span><span class="sxs-lookup"><span data-stu-id="27723-299">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
