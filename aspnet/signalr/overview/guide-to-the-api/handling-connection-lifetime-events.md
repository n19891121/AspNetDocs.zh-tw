---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: 了解和處理 signalr 的連線存留期事件 |Microsoft Docs
author: bradygaster
description: 本文說明如何使用事件中樞 API 所公開。
ms.author: bradyg
ms.date: 01/15/2019
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 9e6b0b3b86839efa393659531d8b74770226f383
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/09/2019
ms.locfileid: "59401461"
---
# <a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="1cb33-103">了解及處理 SignalR 的連線存留期事件</span><span class="sxs-lookup"><span data-stu-id="1cb33-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>


[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="1cb33-104">這篇文章提供 SignalR 連線、 重新連線，以及中斷連線事件，您可以控制，以及您可以設定的逾時和 keepalive 設定的總覽。</span><span class="sxs-lookup"><span data-stu-id="1cb33-104">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
>
> <span data-ttu-id="1cb33-105">本文假設您已經具備 SignalR 和連線的存留期事件的一些知識。</span><span class="sxs-lookup"><span data-stu-id="1cb33-105">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="1cb33-106">Signalr 簡介，請參閱[SignalR 簡介](../getting-started/introduction-to-signalr.md)。</span><span class="sxs-lookup"><span data-stu-id="1cb33-106">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="1cb33-107">如需連線存留期事件清單，請參閱下列資源：</span><span class="sxs-lookup"><span data-stu-id="1cb33-107">For lists of connection lifetime events, see the following resources:</span></span>
>
> - [<span data-ttu-id="1cb33-108">如何處理中樞類別中的連線存留期事件</span><span class="sxs-lookup"><span data-stu-id="1cb33-108">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="1cb33-109">如何處理 JavaScript 用戶端連線存留期事件</span><span class="sxs-lookup"><span data-stu-id="1cb33-109">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="1cb33-110">如何處理.NET 用戶端連線存留期事件</span><span class="sxs-lookup"><span data-stu-id="1cb33-110">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
>
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="1cb33-111">本主題中使用的軟體版本</span><span class="sxs-lookup"><span data-stu-id="1cb33-111">Software versions used in this topic</span></span>
>
>
> - [<span data-ttu-id="1cb33-112">Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="1cb33-112">Visual Studio 2017</span></span>](https://visualstudio.microsoft.com/downloads/)
> - <span data-ttu-id="1cb33-113">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="1cb33-113">.NET 4.5</span></span>
> - <span data-ttu-id="1cb33-114">SignalR 第 2 版</span><span class="sxs-lookup"><span data-stu-id="1cb33-114">SignalR version 2</span></span>
>
>
>
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="1cb33-115">本主題的上一個版本</span><span class="sxs-lookup"><span data-stu-id="1cb33-115">Previous versions of this topic</span></span>
>
> <span data-ttu-id="1cb33-116">如需舊版 SignalR 的資訊，請參閱[SignalR 舊版](../older-versions/index.md)。</span><span class="sxs-lookup"><span data-stu-id="1cb33-116">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
>
> ## <a name="questions-and-comments"></a><span data-ttu-id="1cb33-117">提出問題或意見</span><span class="sxs-lookup"><span data-stu-id="1cb33-117">Questions and comments</span></span>
>
> <span data-ttu-id="1cb33-118">您喜歡本教學課程中的方式，和我們可以改善在頁面底部的註解中，歡迎留下意見反應。</span><span class="sxs-lookup"><span data-stu-id="1cb33-118">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="1cb33-119">如果您有不直接相關的教學課程中的問題，您可以張貼他們[ASP.NET SignalR 論壇](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR)或是[StackOverflow.com](http://stackoverflow.com/)。</span><span class="sxs-lookup"><span data-stu-id="1cb33-119">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>

## <a name="overview"></a><span data-ttu-id="1cb33-120">總覽</span><span class="sxs-lookup"><span data-stu-id="1cb33-120">Overview</span></span>

<span data-ttu-id="1cb33-121">本文包含下列章節：</span><span class="sxs-lookup"><span data-stu-id="1cb33-121">This article contains the following sections:</span></span>

- [<span data-ttu-id="1cb33-122">連接的存留期術語和案例</span><span class="sxs-lookup"><span data-stu-id="1cb33-122">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="1cb33-123">SignalR 連線、 傳輸連線和實體的連線</span><span class="sxs-lookup"><span data-stu-id="1cb33-123">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="1cb33-124">傳輸中斷連線的案例</span><span class="sxs-lookup"><span data-stu-id="1cb33-124">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="1cb33-125">用戶端中斷連線的案例</span><span class="sxs-lookup"><span data-stu-id="1cb33-125">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="1cb33-126">伺服器中斷連線的案例</span><span class="sxs-lookup"><span data-stu-id="1cb33-126">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="1cb33-127">逾時和 keepalive 設定</span><span class="sxs-lookup"><span data-stu-id="1cb33-127">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="1cb33-128">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="1cb33-128">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="1cb33-129">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="1cb33-129">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="1cb33-130">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="1cb33-130">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="1cb33-131">如何變更逾時和 keepalive 設定</span><span class="sxs-lookup"><span data-stu-id="1cb33-131">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="1cb33-132">如何通知使用者有關的連線中斷</span><span class="sxs-lookup"><span data-stu-id="1cb33-132">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="1cb33-133">如何持續重新連接</span><span class="sxs-lookup"><span data-stu-id="1cb33-133">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="1cb33-134">如何中斷連接的伺服器程式碼中的用戶端</span><span class="sxs-lookup"><span data-stu-id="1cb33-134">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="1cb33-135">偵測中斷連線的原因</span><span class="sxs-lookup"><span data-stu-id="1cb33-135">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="1cb33-136">API 參考主題的連結是 API 的.NET 4.5 版本。</span><span class="sxs-lookup"><span data-stu-id="1cb33-136">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="1cb33-137">如果您使用.NET 4，請參閱[API 主題的.NET 4 版本](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx)。</span><span class="sxs-lookup"><span data-stu-id="1cb33-137">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="1cb33-138">連接的存留期術語和案例</span><span class="sxs-lookup"><span data-stu-id="1cb33-138">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="1cb33-139">`OnReconnected` SignalR 中樞的事件處理常式可以直接在之後執行`OnConnected`但不是晚`OnDisconnected`指定用戶端。</span><span class="sxs-lookup"><span data-stu-id="1cb33-139">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="1cb33-140">您可以重新連線，而不中斷的原因是，有數個 「 連線 」 這個字用於 SignalR 的方式。</span><span class="sxs-lookup"><span data-stu-id="1cb33-140">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="1cb33-141">SignalR 連線、 傳輸連線和實體的連線</span><span class="sxs-lookup"><span data-stu-id="1cb33-141">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="1cb33-142">這篇文章會區別*SignalR 連線*，*傳輸連線*，並*實體連線*:</span><span class="sxs-lookup"><span data-stu-id="1cb33-142">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="1cb33-143">**SignalR 連線**指的用戶端和伺服器 URL、 SignalR API 所維護，而且可以連接 ID 唯一識別之間的邏輯關聯性</span><span class="sxs-lookup"><span data-stu-id="1cb33-143">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="1cb33-144">此關聯性的相關資料由 SignalR 維護，並用來建立傳輸連接。</span><span class="sxs-lookup"><span data-stu-id="1cb33-144">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="1cb33-145">SignalR 和關聯性結尾時，處置資料的用戶端呼叫`Stop`SignalR 嘗試重新建立遺失的傳輸連線期間達到方法或逾時限制。</span><span class="sxs-lookup"><span data-stu-id="1cb33-145">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="1cb33-146">**傳輸連線**指的用戶端和伺服器，維護的其中一個四種傳輸 Api 之間的邏輯關聯性：Websocket 伺服器傳送事件、 不限次數的框架或長輪詢。</span><span class="sxs-lookup"><span data-stu-id="1cb33-146">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="1cb33-147">SignalR 使用傳輸 API 以建立傳輸連接，並傳輸 API 取決於建立傳輸連線的實體網路連線存在。</span><span class="sxs-lookup"><span data-stu-id="1cb33-147">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="1cb33-148">SignalR 終止它時，或當傳輸 API 偵測到的實體連接已中斷，就會結束傳輸連線。</span><span class="sxs-lookup"><span data-stu-id="1cb33-148">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="1cb33-149">**實體連接**參考的實體網路的連結-線、 無線訊號，路由器等，可簡化用戶端電腦和伺服器電腦之間的通訊。</span><span class="sxs-lookup"><span data-stu-id="1cb33-149">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="1cb33-150">實體連線必須存在於若要建立傳輸連線，而且必須以建立 SignalR 連線建立傳輸連接。</span><span class="sxs-lookup"><span data-stu-id="1cb33-150">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="1cb33-151">不過，重大的實體連接不一定會立即結束的傳輸連線或 SignalR 連線，如稍後本主題將說明。</span><span class="sxs-lookup"><span data-stu-id="1cb33-151">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="1cb33-152">在下列圖表中，由 SignalR 連線的中樞 API 和 PersistentConnection API SignalR 層級、 傳輸連線由傳輸層和實體連接由伺服器之間的線條和用戶端。</span><span class="sxs-lookup"><span data-stu-id="1cb33-152">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![SignalR 架構圖](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="1cb33-154">當您呼叫`Start`SignalR 用戶端中的方法，您會提供 SignalR 用戶端程式碼需才能建立實體連接到伺服器的所有資訊。</span><span class="sxs-lookup"><span data-stu-id="1cb33-154">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="1cb33-155">SignalR 用戶端程式碼會使用這項資訊來發出 HTTP 要求，並建立使用其中一種四種傳輸方法的實體連接。</span><span class="sxs-lookup"><span data-stu-id="1cb33-155">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="1cb33-156">如果傳輸連線失敗，或伺服器失敗，SignalR 連線不會消失立即因為用戶端仍然需要自動重新建立新的傳輸連線至相同的 SignalR URL 的資訊。</span><span class="sxs-lookup"><span data-stu-id="1cb33-156">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="1cb33-157">在此案例中，從使用者的應用程式不需要介入是，而且當 SignalR 用戶端程式碼會建立新的傳輸連線，它不會啟動新的 SignalR 連線。</span><span class="sxs-lookup"><span data-stu-id="1cb33-157">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="1cb33-158">SignalR 連線的持續性會反映在事實的連線識別碼，這當您呼叫建立`Start`方法，不會變更。</span><span class="sxs-lookup"><span data-stu-id="1cb33-158">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="1cb33-159">`OnReconnected`集線器上的事件處理常式執行時的傳輸連線之後自動重新建立已遺失。</span><span class="sxs-lookup"><span data-stu-id="1cb33-159">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="1cb33-160">`OnDisconnected`事件處理常式執行 SignalR 連線的結尾。</span><span class="sxs-lookup"><span data-stu-id="1cb33-160">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="1cb33-161">SignalR 連線可以在下列任一方式結束：</span><span class="sxs-lookup"><span data-stu-id="1cb33-161">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="1cb33-162">如果用戶端呼叫`Stop`方法中，「 停止 」 訊息傳送至伺服器，以及用戶端和伺服器 SignalR 連線立即結束。</span><span class="sxs-lookup"><span data-stu-id="1cb33-162">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="1cb33-163">用戶端與伺服器之間的連線中斷後，用戶端會嘗試重新連線，以及伺服器等候用戶端重新連線。</span><span class="sxs-lookup"><span data-stu-id="1cb33-163">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="1cb33-164">如果要重新連線嘗試未成功，而且在中斷連線逾時期間結束，用戶端和伺服器端 SignalR 連線。</span><span class="sxs-lookup"><span data-stu-id="1cb33-164">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="1cb33-165">用戶端會停止嘗試重新連線，並處置它表示 SignalR 連線的伺服器。</span><span class="sxs-lookup"><span data-stu-id="1cb33-165">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="1cb33-166">如果用戶端會停止執行，而不需要呼叫有機會`Stop`方法中，伺服器等候用戶端重新連線，然後結束 中斷連線逾時期限之後 SignalR 連線。</span><span class="sxs-lookup"><span data-stu-id="1cb33-166">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="1cb33-167">如果伺服器停止執行，用戶端會嘗試重新連線 （重新建立傳輸連線），然後結束 中斷連線逾時期限之後 SignalR 連線。</span><span class="sxs-lookup"><span data-stu-id="1cb33-167">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="1cb33-168">沒有連線問題，與使用者應用程式藉由呼叫結束 SignalR 連線時`Stop`方法、 SignalR 連線和傳輸連線在開始與結束大約相同的時間。</span><span class="sxs-lookup"><span data-stu-id="1cb33-168">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="1cb33-169">下列各節更詳細說明其他案例。</span><span class="sxs-lookup"><span data-stu-id="1cb33-169">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="1cb33-170">傳輸中斷連線的案例</span><span class="sxs-lookup"><span data-stu-id="1cb33-170">Transport disconnection scenarios</span></span>

<span data-ttu-id="1cb33-171">實體連線可能會變慢，或可能會有中斷連線。</span><span class="sxs-lookup"><span data-stu-id="1cb33-171">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="1cb33-172">中斷時間的長度等因素，傳輸連線可能會被捨棄。</span><span class="sxs-lookup"><span data-stu-id="1cb33-172">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="1cb33-173">SignalR 接著會嘗試重新建立傳輸連線。</span><span class="sxs-lookup"><span data-stu-id="1cb33-173">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="1cb33-174">有時候傳輸連線 API 偵測到中斷傳輸連線，會卸除和 SignalR 發現立即連線已中斷。</span><span class="sxs-lookup"><span data-stu-id="1cb33-174">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="1cb33-175">在其他情況下，既不傳輸連線的 API 或 SignalR 察覺立即連線已遺失。</span><span class="sxs-lookup"><span data-stu-id="1cb33-175">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="1cb33-176">除了長輪詢傳輸所有 SignalR 用戶端會都使用函式，呼叫*keepalive*檢查的傳輸 API 是無法偵測到的連線中斷。</span><span class="sxs-lookup"><span data-stu-id="1cb33-176">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="1cb33-177">如需長時間輪詢連線資訊，請參閱 <<c0> [ 逾時和 keepalive 設定](#timeoutkeepalive)本主題稍後的。</span><span class="sxs-lookup"><span data-stu-id="1cb33-177">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="1cb33-178">非使用中連接時，會定期伺服器傳送 keepalive 封包到用戶端。</span><span class="sxs-lookup"><span data-stu-id="1cb33-178">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="1cb33-179">正在寫入這篇文章的日期，從預設的頻率是每隔 10 秒。</span><span class="sxs-lookup"><span data-stu-id="1cb33-179">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="1cb33-180">藉由接聽這些封包，用戶端就可以知道是否有連線問題。</span><span class="sxs-lookup"><span data-stu-id="1cb33-180">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="1cb33-181">如果未在預期時，會收到 keepalive 封包，在短時間後用戶端會假設有連線問題，例如速度很慢或中斷。</span><span class="sxs-lookup"><span data-stu-id="1cb33-181">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="1cb33-182">如果 keepalive 仍未收到較長的時間之後，用戶端會假設此連接已經卸除，，然後開始嘗試重新連線。</span><span class="sxs-lookup"><span data-stu-id="1cb33-182">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="1cb33-183">下圖說明用戶端和伺服器事件不是立即辨識傳輸 API 的實體連接問題時，所引發的一般案例。</span><span class="sxs-lookup"><span data-stu-id="1cb33-183">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="1cb33-184">圖適用於下列情況：</span><span class="sxs-lookup"><span data-stu-id="1cb33-184">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="1cb33-185">傳輸方式是 WebSockets、 永久框架或伺服器傳送事件。</span><span class="sxs-lookup"><span data-stu-id="1cb33-185">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="1cb33-186">有不同的期間，在實體網路連線中斷的位置。</span><span class="sxs-lookup"><span data-stu-id="1cb33-186">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="1cb33-187">傳輸 API 不會知道中斷，因此 SignalR 依賴 keepalive 功能，以偵測到這些控制項。</span><span class="sxs-lookup"><span data-stu-id="1cb33-187">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![傳輸中斷連線](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="1cb33-189">如果用戶端便會進入重新連接模式，但無法建立傳輸連線在中斷連線的逾時限制內，伺服器會終止 SignalR 連線。</span><span class="sxs-lookup"><span data-stu-id="1cb33-189">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="1cb33-190">當發生這種情況時，伺服器會執行的中樞`OnDisconnected`方法，並將傳送至用戶端，如果用戶端會管理連接稍後中斷連線訊息的佇列。</span><span class="sxs-lookup"><span data-stu-id="1cb33-190">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="1cb33-191">如果用戶端接著會重新連線，它會收到中斷連接命令和呼叫`Stop`方法。</span><span class="sxs-lookup"><span data-stu-id="1cb33-191">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="1cb33-192">在此案例中，`OnReconnected`不會執行，當用戶端重新連線，並`OnDisconnected`不會執行，當用戶端呼叫`Stop`。</span><span class="sxs-lookup"><span data-stu-id="1cb33-192">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="1cb33-193">下圖說明此案例。</span><span class="sxs-lookup"><span data-stu-id="1cb33-193">The following diagram illustrates this scenario.</span></span>

![傳輸中斷-伺服器逾時](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="1cb33-195">在用戶端，可能會引發 SignalR 連線存留期事件，如下所示：</span><span class="sxs-lookup"><span data-stu-id="1cb33-195">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- `ConnectionSlow` <span data-ttu-id="1cb33-196">用戶端的事件。</span><span class="sxs-lookup"><span data-stu-id="1cb33-196">client event.</span></span>

    <span data-ttu-id="1cb33-197">Keepalive 逾時期限的預設的比例過的最後一個訊息，或收到 keepalive ping 時，就會引發。</span><span class="sxs-lookup"><span data-stu-id="1cb33-197">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="1cb33-198">預設 keepalive 逾時警告期間是 2/3 keepalive 逾時。</span><span class="sxs-lookup"><span data-stu-id="1cb33-198">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="1cb33-199">Keepalive 逾時為 20 秒，因此在大約 13 秒就會發生警告。</span><span class="sxs-lookup"><span data-stu-id="1cb33-199">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="1cb33-200">根據預設，伺服器會傳送 keepalive ping 每隔 10 秒，並在用戶端檢查 keepalive ping 每 2 秒 （三分之一 keepalive 逾時值和 keepalive 逾時的警告值之間的差異） 的相關。</span><span class="sxs-lookup"><span data-stu-id="1cb33-200">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="1cb33-201">如果傳輸 API 察覺的中斷，SignalR 可能通知中斷連接之前 keepalive 逾時警告期間傳遞。</span><span class="sxs-lookup"><span data-stu-id="1cb33-201">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="1cb33-202">在此情況下，`ConnectionSlow`不會引發事件，以及 SignalR 會直接移至`Reconnecting`事件。</span><span class="sxs-lookup"><span data-stu-id="1cb33-202">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- `Reconnecting` <span data-ttu-id="1cb33-203">用戶端的事件。</span><span class="sxs-lookup"><span data-stu-id="1cb33-203">client event.</span></span>

    <span data-ttu-id="1cb33-204">當 API （a） 傳輸偵測到的連線已中斷，或 （b） 的 keepalive 逾時期限後的最後一個訊息，已經過或 keepalive ping 接收時，就會引發。</span><span class="sxs-lookup"><span data-stu-id="1cb33-204">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="1cb33-205">SignalR 用戶端程式碼開始嘗試重新連線。</span><span class="sxs-lookup"><span data-stu-id="1cb33-205">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="1cb33-206">如果您想要您的應用程式的傳輸連線已遺失時採取某個動作，您可以處理這個事件。</span><span class="sxs-lookup"><span data-stu-id="1cb33-206">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="1cb33-207">20 秒的目前預設 keepalive 逾時期限。</span><span class="sxs-lookup"><span data-stu-id="1cb33-207">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="1cb33-208">如果您的用戶端程式碼嘗試呼叫中樞方法，而 SignalR 是在重新連線模式，SignalR 會嘗試傳送命令。</span><span class="sxs-lookup"><span data-stu-id="1cb33-208">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="1cb33-209">大部分的情況下，這類的嘗試都會失敗，但在某些情況下可能會成功。</span><span class="sxs-lookup"><span data-stu-id="1cb33-209">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="1cb33-210">伺服器傳送事件、 永久框架和長輪詢傳輸，SignalR 使用兩個通訊通道，其中用戶端用來傳送訊息，它會使用來接收訊息的另一個。</span><span class="sxs-lookup"><span data-stu-id="1cb33-210">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="1cb33-211">用來接收的通道是永遠開啟，而這是實體的連線中斷時，會關閉的一個。</span><span class="sxs-lookup"><span data-stu-id="1cb33-211">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="1cb33-212">通道用於傳送仍可供使用，因此，接收通道後重新建立實體的連線還原時，如果伺服器的方法呼叫從用戶端可能會成功。</span><span class="sxs-lookup"><span data-stu-id="1cb33-212">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="1cb33-213">直到 SignalR 重新開啟用來接收的通道，就不會收到傳回的值。</span><span class="sxs-lookup"><span data-stu-id="1cb33-213">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- `Reconnected` <span data-ttu-id="1cb33-214">用戶端的事件。</span><span class="sxs-lookup"><span data-stu-id="1cb33-214">client event.</span></span>

    <span data-ttu-id="1cb33-215">當傳輸重新建立連線時，就會引發。</span><span class="sxs-lookup"><span data-stu-id="1cb33-215">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="1cb33-216">`OnReconnected`在中樞的事件處理常式執行。</span><span class="sxs-lookup"><span data-stu-id="1cb33-216">The `OnReconnected` event handler in the Hub executes.</span></span>
- `Closed` <span data-ttu-id="1cb33-217">用戶端事件 (`disconnected`在 JavaScript 中的事件)。</span><span class="sxs-lookup"><span data-stu-id="1cb33-217">client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="1cb33-218">在中斷連線逾時期限到期時 SignalR 用戶端程式碼嘗試傳輸連線中斷之後重新連線時引發。</span><span class="sxs-lookup"><span data-stu-id="1cb33-218">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="1cb33-219">預設的中斷連線逾時為 30 秒。</span><span class="sxs-lookup"><span data-stu-id="1cb33-219">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="1cb33-220">(因為，連線結束時，也會引發這個事件`Stop`呼叫方法。)</span><span class="sxs-lookup"><span data-stu-id="1cb33-220">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="1cb33-221">未偵測到傳輸 API，且沒有延遲的 keepalive ping 從超過 keepalive 逾時警告期間伺服器接收的傳輸連線中斷可能會不會造成任何連線存留期間来引發的事件。</span><span class="sxs-lookup"><span data-stu-id="1cb33-221">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="1cb33-222">有些網路環境刻意關閉閒置的連接，並 keepalive 封包的另一個函式是為了避免這個問題讓這些網路可讓您知道 SignalR 連線正在使用中。</span><span class="sxs-lookup"><span data-stu-id="1cb33-222">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="1cb33-223">在極端情況下 keepalive ping 預設頻率不可能不足以防止已關閉的連線。</span><span class="sxs-lookup"><span data-stu-id="1cb33-223">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="1cb33-224">在此情況下，您可以設定更常傳送 keepalive ping。</span><span class="sxs-lookup"><span data-stu-id="1cb33-224">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="1cb33-225">如需詳細資訊，請參閱 <<c0> [ 逾時和 keepalive 設定](#timeoutkeepalive)本主題稍後的。</span><span class="sxs-lookup"><span data-stu-id="1cb33-225">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE]
>
> <span data-ttu-id="1cb33-226">**重要**：此處所述的事件的順序並不保證。</span><span class="sxs-lookup"><span data-stu-id="1cb33-226">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="1cb33-227">SignalR 會不斷嘗試以便引發連線存留期事件，此配置中，根據可預測的方式，但有許多變化的網路事件和多種資訊，請在其中基礎的通訊架構，例如傳輸 Api 處理它們。</span><span class="sxs-lookup"><span data-stu-id="1cb33-227">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="1cb33-228">例如，`Reconnected`可能不會引發事件，當用戶端重新連接，或`OnConnected`建立的連線嘗試不成功時，可能會執行伺服器上的處理常式。</span><span class="sxs-lookup"><span data-stu-id="1cb33-228">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="1cb33-229">本主題說明某些常見的情況下將通常會產生的效果。</span><span class="sxs-lookup"><span data-stu-id="1cb33-229">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>


<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="1cb33-230">用戶端中斷連線的案例</span><span class="sxs-lookup"><span data-stu-id="1cb33-230">Client disconnection scenarios</span></span>

<span data-ttu-id="1cb33-231">在瀏覽器用戶端會維護 SignalR 連線的 SignalR 用戶端程式碼的內容中執行 JavaScript 的網頁。</span><span class="sxs-lookup"><span data-stu-id="1cb33-231">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="1cb33-232">具有為什麼 SignalR 連線已結束，當您從一個頁面上與另一個，且的為什麼您有多個連線使用多個連線識別碼如果您從多個瀏覽器視窗或索引標籤連線。</span><span class="sxs-lookup"><span data-stu-id="1cb33-232">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="1cb33-233">當使用者關閉瀏覽器視窗或索引標籤上，或瀏覽至新的頁面或重新整理頁面時，SignalR 連線會立即結束因為 SignalR 用戶端程式碼會處理該瀏覽器事件，寄件者和呼叫`Stop`方法。</span><span class="sxs-lookup"><span data-stu-id="1cb33-233">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="1cb33-234">在這些情況下，或當您的應用程式呼叫的任何用戶端平台`Stop`方法中，`OnDisconnected`事件處理常式會在伺服器上立即執行，並在用戶端引發`Closed`事件 (事件的名稱為`disconnected`中JavaScript)。</span><span class="sxs-lookup"><span data-stu-id="1cb33-234">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="1cb33-235">如果用戶端應用程式或電腦上執行的損毀或進入睡眠狀態 （例如，當使用者關閉的膝上型電腦），伺服器不會發生了什麼事收到通知。</span><span class="sxs-lookup"><span data-stu-id="1cb33-235">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="1cb33-236">只要伺服器知道，遺失的用戶端可能是因為連線中斷，用戶端可能會嘗試重新連線。</span><span class="sxs-lookup"><span data-stu-id="1cb33-236">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="1cb33-237">因此，在這些案例中，伺服器會等待讓用戶端重新連線，有機會和`OnDisconnected`不會執行到中斷連線逾時期限到期為止 （大約 30 秒的預設值）。</span><span class="sxs-lookup"><span data-stu-id="1cb33-237">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="1cb33-238">下圖說明此案例。</span><span class="sxs-lookup"><span data-stu-id="1cb33-238">The following diagram illustrates this scenario.</span></span>

![用戶端電腦的失敗](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="1cb33-240">伺服器中斷連線的案例</span><span class="sxs-lookup"><span data-stu-id="1cb33-240">Server disconnection scenarios</span></span>

<span data-ttu-id="1cb33-241">當伺服器離線時，它會重新啟動、 失敗，應用程式網域回收，等-結果可能會類似於遺失的連線，或傳輸 API，並使用 SignalR 可能立即得知伺服器不見了，而 SignalR 可能會開始嘗試重新連線，而不需要引發`ConnectionSlow`事件。</span><span class="sxs-lookup"><span data-stu-id="1cb33-241">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="1cb33-242">如果用戶端會進入重新連接 模式中，而且伺服器復原或重新啟動或新的伺服器處於線上時中斷連線逾時期間到期之前，用戶端會重新連接到已還原或新的伺服器。</span><span class="sxs-lookup"><span data-stu-id="1cb33-242">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="1cb33-243">在此情況下，SignalR 連線會繼續在用戶端和`Reconnected`就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="1cb33-243">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="1cb33-244">第一部伺服器中，`OnDisconnected`永遠不會執行，並在新伺服器上，`OnReconnected`雖然執行`OnConnected`永遠不會執行該用戶端之前，該伺服器上。</span><span class="sxs-lookup"><span data-stu-id="1cb33-244">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="1cb33-245">（效果是相同的用戶端之後重新連線到相同的伺服器重新開機或應用程式網域回收，因為當伺服器重新啟動它，所以如果有先前的連接活動的任何記憶體）。下圖假設，傳輸 API 察覺到連線中斷立即執行，因此`ConnectionSlow`不會引發事件。</span><span class="sxs-lookup"><span data-stu-id="1cb33-245">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![伺服器失敗和重新連線](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="1cb33-247">如果伺服器尚未變成可用的中斷連線逾時期限內，SignalR 連線就會結束。</span><span class="sxs-lookup"><span data-stu-id="1cb33-247">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="1cb33-248">在此案例中，`Closed`事件 (`disconnected` JavaScript 用戶端中) 會在用戶端上引發，但`OnDisconnected`絕不會呼叫伺服器上。</span><span class="sxs-lookup"><span data-stu-id="1cb33-248">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="1cb33-249">下圖假設，傳輸 API 不會留意失去連線，因此它會偵測到 SignalR keepalive 功能和`ConnectionSlow`就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="1cb33-249">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![伺服器發生錯誤及逾時](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="1cb33-251">逾時和 keepalive 設定</span><span class="sxs-lookup"><span data-stu-id="1cb33-251">Timeout and keepalive settings</span></span>

<span data-ttu-id="1cb33-252">預設值`ConnectionTimeout`， `DisconnectTimeout`，和`KeepAlive`值適用於大部分的情況下，但如果您的環境具有特殊需求，可以變更。</span><span class="sxs-lookup"><span data-stu-id="1cb33-252">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="1cb33-253">比方說，如果您的網路環境關閉 5 秒會處於閒置狀態的連線，您可能會降低的 keepalive 值。</span><span class="sxs-lookup"><span data-stu-id="1cb33-253">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="1cb33-254">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="1cb33-254">ConnectionTimeout</span></span>

<span data-ttu-id="1cb33-255">這項設定代表開啟並等待回應，以關閉它，並開啟新連接之前離開的傳輸連線的時間量。</span><span class="sxs-lookup"><span data-stu-id="1cb33-255">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="1cb33-256">預設值為 110 秒。</span><span class="sxs-lookup"><span data-stu-id="1cb33-256">The default value is 110 seconds.</span></span>

<span data-ttu-id="1cb33-257">此設定適用於僅 keepalive 功能停用時，這通常僅適用於長輪詢傳輸。</span><span class="sxs-lookup"><span data-stu-id="1cb33-257">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="1cb33-258">下圖說明這項設定在長時間的影響輪詢傳輸連線。</span><span class="sxs-lookup"><span data-stu-id="1cb33-258">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![長輪詢傳輸的連線](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="1cb33-260">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="1cb33-260">DisconnectTimeout</span></span>

<span data-ttu-id="1cb33-261">這項設定代表之後的傳輸連線已遺失引發之前等待的時間量`Disconnected`事件。</span><span class="sxs-lookup"><span data-stu-id="1cb33-261">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="1cb33-262">預設值為 30 秒。</span><span class="sxs-lookup"><span data-stu-id="1cb33-262">The default value is 30 seconds.</span></span> <span data-ttu-id="1cb33-263">當您設定`DisconnectTimeout`，`KeepAlive`會自動設為 1/3`DisconnectTimeout`值。</span><span class="sxs-lookup"><span data-stu-id="1cb33-263">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="1cb33-264">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="1cb33-264">KeepAlive</span></span>

<span data-ttu-id="1cb33-265">這項設定代表透過閒置連線傳送 keepalive 封包之前等待時間的量。</span><span class="sxs-lookup"><span data-stu-id="1cb33-265">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="1cb33-266">預設值為 10 秒。</span><span class="sxs-lookup"><span data-stu-id="1cb33-266">The default value is 10 seconds.</span></span> <span data-ttu-id="1cb33-267">此值不能超過 1/3`DisconnectTimeout`值。</span><span class="sxs-lookup"><span data-stu-id="1cb33-267">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="1cb33-268">如果您想要同時設定`DisconnectTimeout`並`KeepAlive`，將`KeepAlive`之後`DisconnectTimeout`。</span><span class="sxs-lookup"><span data-stu-id="1cb33-268">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="1cb33-269">否則您`KeepAlive`設定將會覆寫時`DisconnectTimeout`會自動設定`KeepAlive`的逾時值的 1/3。</span><span class="sxs-lookup"><span data-stu-id="1cb33-269">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="1cb33-270">如果您想要停用 keepalive 功能，設定`KeepAlive`為 null。</span><span class="sxs-lookup"><span data-stu-id="1cb33-270">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="1cb33-271">Keepalive 功能會自動停用的長輪詢傳輸。</span><span class="sxs-lookup"><span data-stu-id="1cb33-271">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="1cb33-272">如何變更逾時和 keepalive 設定</span><span class="sxs-lookup"><span data-stu-id="1cb33-272">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="1cb33-273">若要變更這些設定的預設值，以設定它們`Application_Start`在您*Global.asax*檔案，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="1cb33-273">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="1cb33-274">範例程式碼所示的值是相同的預設值。</span><span class="sxs-lookup"><span data-stu-id="1cb33-274">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="1cb33-275">如何通知使用者有關的連線中斷</span><span class="sxs-lookup"><span data-stu-id="1cb33-275">How to notify the user about disconnections</span></span>

<span data-ttu-id="1cb33-276">在某些應用程式，您可能要向使用者顯示一則訊息時有連線問題。</span><span class="sxs-lookup"><span data-stu-id="1cb33-276">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="1cb33-277">您有數個選項，以及何時要執行這項操作。</span><span class="sxs-lookup"><span data-stu-id="1cb33-277">You have several options for how and when to do this.</span></span> <span data-ttu-id="1cb33-278">下列程式碼範例專供 JavaScript 用戶端使用產生的 proxy。</span><span class="sxs-lookup"><span data-stu-id="1cb33-278">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="1cb33-279">處理`connectionSlow`事件，以顯示一則訊息，一旦 SignalR 的連線問題，了解之前，它會進入重新連接模式。</span><span class="sxs-lookup"><span data-stu-id="1cb33-279">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="1cb33-280">處理`reconnecting`SignalR 所知的中斷並進入重新連線模式時，顯示一則訊息的事件。</span><span class="sxs-lookup"><span data-stu-id="1cb33-280">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="1cb33-281">處理`disconnected`事件，以顯示一則訊息時嘗試重新連線已逾時。在此案例中，重新建立與伺服器連線一次的唯一方式是藉由呼叫重新 SignalR 連線`Start`方法，這將會建立新的連接識別碼。</span><span class="sxs-lookup"><span data-stu-id="1cb33-281">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="1cb33-282">下列程式碼範例使用旗標，藉此確定您發出的通知後重新連線的逾時，才不晚於藉由呼叫造成 SignalR 連線正常結束`Stop`方法。</span><span class="sxs-lookup"><span data-stu-id="1cb33-282">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="1cb33-283">如何持續重新連接</span><span class="sxs-lookup"><span data-stu-id="1cb33-283">How to continuously reconnect</span></span>

<span data-ttu-id="1cb33-284">在某些應用程式可能會想要已遺失，並嘗試重新連線已逾時之後自動重新建立連線。若要這樣做，您可以呼叫`Start`方法，從您`Closed`事件處理常式 (`disconnected` JavaScript 用戶端上的事件處理常式)。</span><span class="sxs-lookup"><span data-stu-id="1cb33-284">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="1cb33-285">您可能想要等候一段時間，然後再呼叫`Start`為了避免這樣太頻繁伺服器或實體的連線時無法使用。</span><span class="sxs-lookup"><span data-stu-id="1cb33-285">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="1cb33-286">下列程式碼範例是 JavaScript 用戶端使用產生的 proxy。</span><span class="sxs-lookup"><span data-stu-id="1cb33-286">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="1cb33-287">要注意的行動用戶端中的潛在問題是連續的重新連線嘗試的伺服器或實體的連線無法使用時，可能會導致不必要的電池清空。</span><span class="sxs-lookup"><span data-stu-id="1cb33-287">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="1cb33-288">如何中斷連接的伺服器程式碼中的用戶端</span><span class="sxs-lookup"><span data-stu-id="1cb33-288">How to disconnect a client in server code</span></span>

<span data-ttu-id="1cb33-289">SignalR 第 2 版並沒有內建的伺服器 API 的用戶端連接中斷。</span><span class="sxs-lookup"><span data-stu-id="1cb33-289">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="1cb33-290">有[計劃在未來新增這項功能](https://github.com/SignalR/SignalR/issues/2101)。</span><span class="sxs-lookup"><span data-stu-id="1cb33-290">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="1cb33-291">在目前的 SignalR 版本中，從伺服器中斷連線的用戶端的最簡單方式是實作在用戶端上的 中斷連線方法，並從伺服器呼叫該方法。</span><span class="sxs-lookup"><span data-stu-id="1cb33-291">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="1cb33-292">下列程式碼範例顯示使用產生的 proxy 的 JavaScript 用戶端中斷連線的方法。</span><span class="sxs-lookup"><span data-stu-id="1cb33-292">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="1cb33-293">安全性-既不中斷用戶端連接此方法也不建議的內建 API 會處理案例的遭駭客入侵的用戶端執行惡意程式碼，因為用戶端無法重新連線或遭駭客入侵的程式碼可能會移除`stopClient`方法或變更其用途。</span><span class="sxs-lookup"><span data-stu-id="1cb33-293">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="1cb33-294">實作可設定狀態的阻斷服務 (DOS) 保護的適當位置是不在 framework 或伺服器層中，但前端的基礎結構中，而不是。</span><span class="sxs-lookup"><span data-stu-id="1cb33-294">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>


<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="1cb33-295">偵測中斷連線的原因</span><span class="sxs-lookup"><span data-stu-id="1cb33-295">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="1cb33-296">SignalR 2.1 新增到伺服器的多載`OnDisconnect`事件，表示用戶端是否刻意中斷連線，而不是逾時。`StopCalled`參數為 true，如果用戶端明確地關閉連接。</span><span class="sxs-lookup"><span data-stu-id="1cb33-296">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="1cb33-297">在 JavaScript 中，如果伺服器錯誤導致用戶端中斷連線，錯誤資訊會傳遞至用戶端`$.connection.hub.lastError`。</span><span class="sxs-lookup"><span data-stu-id="1cb33-297">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

**<span data-ttu-id="1cb33-298">C#伺服端程式碼：`stopCalled`參數</span><span class="sxs-lookup"><span data-stu-id="1cb33-298">C# server code: `stopCalled` parameter</span></span>**

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

**<span data-ttu-id="1cb33-299">JavaScript 用戶端程式碼： 存取`lastError`在`disconnect`事件。</span><span class="sxs-lookup"><span data-stu-id="1cb33-299">JavaScript client code: accessing `lastError` in the `disconnect` event.</span></span>**

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
