---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: 瞭解和處理 SignalR 中的連接存留期事件 |Microsoft Docs
author: bradygaster
description: 本文說明如何使用中樞 API 所公開的事件。
ms.author: bradyg
ms.date: 01/15/2019
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 5bdf20549fccab5d644e35fdf4ce351540c8620d
ms.sourcegitcommit: c62ec20b453cee3249eb894ecd75013b57d078f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/21/2020
ms.locfileid: "92345228"
---
# <a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="77942-103">了解及處理 SignalR 的連線存留期事件</span><span class="sxs-lookup"><span data-stu-id="77942-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="77942-104">本文概述您可以處理的 SignalR 連線、重新連線和中斷線上活動，以及您可以設定的 timeout 和 keepalive 設定。</span><span class="sxs-lookup"><span data-stu-id="77942-104">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
>
> <span data-ttu-id="77942-105">本文假設您已具備 SignalR 和連線存留期事件的一些知識。</span><span class="sxs-lookup"><span data-stu-id="77942-105">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="77942-106">如需 SignalR 的簡介，請參閱 [SignalR 簡介](../getting-started/introduction-to-signalr.md)。</span><span class="sxs-lookup"><span data-stu-id="77942-106">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="77942-107">如需連接存留期事件的清單，請參閱下列資源：</span><span class="sxs-lookup"><span data-stu-id="77942-107">For lists of connection lifetime events, see the following resources:</span></span>
>
> - [<span data-ttu-id="77942-108">如何處理中樞類別中的連接存留期事件</span><span class="sxs-lookup"><span data-stu-id="77942-108">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="77942-109">如何在 JavaScript 用戶端中處理連接存留期事件</span><span class="sxs-lookup"><span data-stu-id="77942-109">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="77942-110">如何在 .NET 用戶端中處理連接存留期事件</span><span class="sxs-lookup"><span data-stu-id="77942-110">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
>
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="77942-111">本主題中使用的軟體版本</span><span class="sxs-lookup"><span data-stu-id="77942-111">Software versions used in this topic</span></span>
>
>
> - [<span data-ttu-id="77942-112">Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="77942-112">Visual Studio 2017</span></span>](https://visualstudio.microsoft.com/downloads/)
> - <span data-ttu-id="77942-113">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="77942-113">.NET 4.5</span></span>
> - <span data-ttu-id="77942-114">SignalR 第2版</span><span class="sxs-lookup"><span data-stu-id="77942-114">SignalR version 2</span></span>
>
>
>
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="77942-115">本主題的先前版本</span><span class="sxs-lookup"><span data-stu-id="77942-115">Previous versions of this topic</span></span>
>
> <span data-ttu-id="77942-116">如需舊版 SignalR 的詳細資訊，請參閱 [SignalR 較舊版本](../older-versions/index.md)。</span><span class="sxs-lookup"><span data-stu-id="77942-116">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
>
> ## <a name="questions-and-comments"></a><span data-ttu-id="77942-117">問題與意見</span><span class="sxs-lookup"><span data-stu-id="77942-117">Questions and comments</span></span>
>
> <span data-ttu-id="77942-118">請針對您喜歡本教學課程的方式，以及我們可以在頁面底部的批註中改進的內容，留下意見反應。</span><span class="sxs-lookup"><span data-stu-id="77942-118">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="77942-119">如果您有與本教學課程不直接相關的問題，您可以將這些問題張貼至 [ASP.NET SignalR 論壇](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) 或 [StackOverflow.com](http://stackoverflow.com/)。</span><span class="sxs-lookup"><span data-stu-id="77942-119">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>

## <a name="overview"></a><span data-ttu-id="77942-120">概觀</span><span class="sxs-lookup"><span data-stu-id="77942-120">Overview</span></span>

<span data-ttu-id="77942-121">本文包含下列各節：</span><span class="sxs-lookup"><span data-stu-id="77942-121">This article contains the following sections:</span></span>

- [<span data-ttu-id="77942-122">連接存留期術語和案例</span><span class="sxs-lookup"><span data-stu-id="77942-122">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="77942-123">SignalR 連接、傳輸連線和實體連線</span><span class="sxs-lookup"><span data-stu-id="77942-123">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="77942-124">傳輸中斷連接案例</span><span class="sxs-lookup"><span data-stu-id="77942-124">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="77942-125">用戶端中斷連接案例</span><span class="sxs-lookup"><span data-stu-id="77942-125">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="77942-126">伺服器中斷連接案例</span><span class="sxs-lookup"><span data-stu-id="77942-126">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="77942-127">Timeout 和 keepalive 設定</span><span class="sxs-lookup"><span data-stu-id="77942-127">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="77942-128">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="77942-128">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="77942-129">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="77942-129">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="77942-130">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="77942-130">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="77942-131">如何變更 timeout 和 keepalive 設定</span><span class="sxs-lookup"><span data-stu-id="77942-131">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="77942-132">如何通知使用者中斷連線</span><span class="sxs-lookup"><span data-stu-id="77942-132">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="77942-133">如何持續重新連線</span><span class="sxs-lookup"><span data-stu-id="77942-133">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="77942-134">如何在伺服器程式碼中中斷用戶端連線</span><span class="sxs-lookup"><span data-stu-id="77942-134">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="77942-135">偵測中斷連接的原因</span><span class="sxs-lookup"><span data-stu-id="77942-135">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="77942-136">API 參考主題的連結是 .NET 4.5 版的 API。</span><span class="sxs-lookup"><span data-stu-id="77942-136">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="77942-137">如果您使用的是 .NET 4，請參閱 [.net 4 版的 API 主題](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx)。</span><span class="sxs-lookup"><span data-stu-id="77942-137">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="77942-138">連接存留期術語和案例</span><span class="sxs-lookup"><span data-stu-id="77942-138">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="77942-139">`OnReconnected`SignalR 中樞內的事件處理常式可以在 `OnConnected` 指定用戶端的之後，直接執行，但不能執行 `OnDisconnected` 。</span><span class="sxs-lookup"><span data-stu-id="77942-139">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="77942-140">有幾種方式可讓您在沒有中斷連線的情況下重新連線，就是在 SignalR 中使用 "connection" 這個字。</span><span class="sxs-lookup"><span data-stu-id="77942-140">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="77942-141">SignalR 連接、傳輸連線和實體連線</span><span class="sxs-lookup"><span data-stu-id="77942-141">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="77942-142">本文將會區分 *SignalR 連接*、 *傳輸*連線和 *實體*連線：</span><span class="sxs-lookup"><span data-stu-id="77942-142">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="77942-143">**SignalR 連接** 是指用戶端和伺服器 URL 之間的邏輯關聯性，由 SignalR API 維護，並且以連接識別碼唯一識別。</span><span class="sxs-lookup"><span data-stu-id="77942-143">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="77942-144">有關此關聯性的資料是由 SignalR 維護，並且用來建立傳輸連接。</span><span class="sxs-lookup"><span data-stu-id="77942-144">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="77942-145">當用戶端呼叫方法時，關聯性的 end 和 SignalR 會處置資料，當 `Stop` SignalR 嘗試重新建立遺失的傳輸連線時，就會達到超時限制。</span><span class="sxs-lookup"><span data-stu-id="77942-145">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="77942-146">**傳輸連接** 是指用戶端與伺服器之間的邏輯關聯性，由四種傳輸 api 的其中一種來維護： websocket、伺服器傳送事件、永久框架或長輪詢。</span><span class="sxs-lookup"><span data-stu-id="77942-146">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="77942-147">SignalR 會使用傳輸 API 來建立傳輸連線，而傳輸 API 則取決於實體網路連接是否存在，以建立傳輸連線。</span><span class="sxs-lookup"><span data-stu-id="77942-147">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="77942-148">傳輸連線會在 SignalR 終止時結束，或在傳輸 API 偵測到實體連接中斷時結束。</span><span class="sxs-lookup"><span data-stu-id="77942-148">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="77942-149">**實體** 連線指的是可加速用戶端電腦與伺服器電腦之間通訊的實體網路連結（電線、無線信號、路由器等）。</span><span class="sxs-lookup"><span data-stu-id="77942-149">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="77942-150">必須要有實體連線才能建立傳輸連線，而且必須建立傳輸連線才能建立 SignalR 連接。</span><span class="sxs-lookup"><span data-stu-id="77942-150">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="77942-151">不過，中斷實體連線不一定會立即結束傳輸連線或 SignalR 連接，如本主題稍後所述。</span><span class="sxs-lookup"><span data-stu-id="77942-151">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="77942-152">在下圖中，SignalR 連線由中樞 API 和 PersistentConnection API SignalR 層代表，傳輸層會以傳輸層表示，而實體連線則是以伺服器和用戶端之間的程式列來表示。</span><span class="sxs-lookup"><span data-stu-id="77942-152">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![SignalR 架構圖表](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="77942-154">當您 `Start` 在 SignalR 用戶端中呼叫方法時，您會提供 SignalR 用戶端程式代碼，以建立與伺服器的實體連接所需的所有資訊。</span><span class="sxs-lookup"><span data-stu-id="77942-154">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="77942-155">SignalR 用戶端程式代碼會使用這項資訊來提出 HTTP 要求，並建立使用四種傳輸方法之一的實體連接。</span><span class="sxs-lookup"><span data-stu-id="77942-155">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="77942-156">如果傳輸連接失敗或伺服器失敗，SignalR 連線將不會立即消失，因為用戶端仍具有自動重新建立與相同 SignalR URL 的新傳輸連線所需的資訊。</span><span class="sxs-lookup"><span data-stu-id="77942-156">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="77942-157">在此案例中，不會涉及使用者應用程式的介入，而且當 SignalR 用戶端程式代碼建立新的傳輸連線時，不會啟動新的 SignalR 連接。</span><span class="sxs-lookup"><span data-stu-id="77942-157">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="77942-158">SignalR 連接的持續性反映在您呼叫方法時所建立的連接識別碼 `Start` 不會變更。</span><span class="sxs-lookup"><span data-stu-id="77942-158">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="77942-159">`OnReconnected`當傳輸連接在遺失之後自動重新建立時，中樞上的事件處理常式會執行。</span><span class="sxs-lookup"><span data-stu-id="77942-159">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="77942-160">`OnDisconnected`事件處理常式會在 SignalR 連接結束時執行。</span><span class="sxs-lookup"><span data-stu-id="77942-160">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="77942-161">SignalR 連接可以下列任何一種方式結束：</span><span class="sxs-lookup"><span data-stu-id="77942-161">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="77942-162">如果用戶端呼叫 `Stop` 方法，則會將停止訊息傳送至伺服器，而且用戶端和伺服器都會立即結束 SignalR 連接。</span><span class="sxs-lookup"><span data-stu-id="77942-162">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="77942-163">用戶端與伺服器之間的連線中斷之後，用戶端會嘗試重新連線，而且伺服器會等候用戶端重新連線。</span><span class="sxs-lookup"><span data-stu-id="77942-163">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="77942-164">如果嘗試重新連接失敗，而且中斷連接逾時期間結束，則用戶端和伺服器都會結束 SignalR 連接。</span><span class="sxs-lookup"><span data-stu-id="77942-164">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="77942-165">用戶端會停止嘗試重新連接，而伺服器會處置其 SignalR 連接的表示。</span><span class="sxs-lookup"><span data-stu-id="77942-165">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="77942-166">如果用戶端在沒有機會呼叫方法的情況下停止 `Stop` 執行，伺服器會等候用戶端重新連接，然後在中斷連接逾時時間之後結束 SignalR 連線。</span><span class="sxs-lookup"><span data-stu-id="77942-166">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="77942-167">如果伺服器停止執行，用戶端會嘗試重新連線 (重新建立傳輸連線) ，然後在中斷連線超時時間後結束 SignalR 連接。</span><span class="sxs-lookup"><span data-stu-id="77942-167">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="77942-168">如果沒有連線問題，而且使用者應用程式藉由呼叫方法來結束 SignalR 連接 `Stop` ，則 SignalR 連接和傳輸連接會在大約相同的時間開始和結束。</span><span class="sxs-lookup"><span data-stu-id="77942-168">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="77942-169">下列各節會更詳細地說明其他案例。</span><span class="sxs-lookup"><span data-stu-id="77942-169">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="77942-170">傳輸中斷連接案例</span><span class="sxs-lookup"><span data-stu-id="77942-170">Transport disconnection scenarios</span></span>

<span data-ttu-id="77942-171">實體連線可能很慢，或連線可能會中斷。</span><span class="sxs-lookup"><span data-stu-id="77942-171">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="77942-172">根據不同的因素，例如中斷的長度，可能會卸載傳輸連接。</span><span class="sxs-lookup"><span data-stu-id="77942-172">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="77942-173">SignalR 接著會嘗試重新建立傳輸連接。</span><span class="sxs-lookup"><span data-stu-id="77942-173">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="77942-174">有時傳輸連線 API 會偵測到中斷並卸載傳輸連線，而 SignalR 會立即發現連接中斷。</span><span class="sxs-lookup"><span data-stu-id="77942-174">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="77942-175">在其他案例中，傳輸連線 API 或 SignalR 都不會立即察覺連線已遺失。</span><span class="sxs-lookup"><span data-stu-id="77942-175">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="77942-176">對於長時間輪詢以外的所有傳輸，SignalR 用戶端會使用稱為 *keepalive* 的函式來檢查傳輸 API 無法偵測到的連線中斷。</span><span class="sxs-lookup"><span data-stu-id="77942-176">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="77942-177">如需長時間輪詢連接的詳細資訊，請參閱本主題稍後的「 [Timeout 和 keepalive」設定](#timeoutkeepalive) 。</span><span class="sxs-lookup"><span data-stu-id="77942-177">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="77942-178">當連線處於非使用中狀態時，伺服器會定期將 keepalive 封包傳送給用戶端。</span><span class="sxs-lookup"><span data-stu-id="77942-178">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="77942-179">在撰寫本文的日期起，預設頻率為每隔10秒。</span><span class="sxs-lookup"><span data-stu-id="77942-179">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="77942-180">藉由接聽這些封包，用戶端可以分辨是否有連線問題。</span><span class="sxs-lookup"><span data-stu-id="77942-180">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="77942-181">如果未在預期的情況下收到 keepalive 封包，則在一小段時間之後，用戶端會假設發生連線問題，例如緩慢或中斷。</span><span class="sxs-lookup"><span data-stu-id="77942-181">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="77942-182">如果持續時間超過一段時間後仍未收到，用戶端會假設連接已中斷，並開始嘗試重新連接。</span><span class="sxs-lookup"><span data-stu-id="77942-182">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="77942-183">下圖說明當傳輸 API 無法立即辨識的實體連線發生問題時，在一般案例中引發的用戶端和伺服器事件。</span><span class="sxs-lookup"><span data-stu-id="77942-183">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="77942-184">此圖表適用于下列狀況：</span><span class="sxs-lookup"><span data-stu-id="77942-184">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="77942-185">傳輸為 Websocket、永久框架或伺服器傳送的事件。</span><span class="sxs-lookup"><span data-stu-id="77942-185">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="77942-186">實體網路連線中有不同的停機時間。</span><span class="sxs-lookup"><span data-stu-id="77942-186">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="77942-187">傳輸 API 不會察覺到中斷，所以 SignalR 會依賴 keepalive 功能來偵測它們。</span><span class="sxs-lookup"><span data-stu-id="77942-187">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![傳輸中斷連線](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="77942-189">如果用戶端進入重新連線模式，但無法在中斷連接逾時限制內建立傳輸連線，伺服器就會終止 SignalR 連接。</span><span class="sxs-lookup"><span data-stu-id="77942-189">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="77942-190">發生這種情況時，伺服器會執行中樞的 `OnDisconnected` 方法，並將中斷連線的訊息排入佇列，以在用戶端管理稍後連線時傳送給用戶端。</span><span class="sxs-lookup"><span data-stu-id="77942-190">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="77942-191">如果用戶端接著重新連接，則會接收中斷連接命令，並呼叫 `Stop` 方法。</span><span class="sxs-lookup"><span data-stu-id="77942-191">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="77942-192">在此情況下， `OnReconnected` 不會在用戶端重新連線時執行，而且在 `OnDisconnected` 用戶端呼叫時不會執行 `Stop` 。</span><span class="sxs-lookup"><span data-stu-id="77942-192">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="77942-193">下圖說明此案例。</span><span class="sxs-lookup"><span data-stu-id="77942-193">The following diagram illustrates this scenario.</span></span>

![傳輸中斷-伺服器超時](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="77942-195">可能會在用戶端上引發的 SignalR 連接存留期事件如下：</span><span class="sxs-lookup"><span data-stu-id="77942-195">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="77942-196">`ConnectionSlow` 用戶端事件。</span><span class="sxs-lookup"><span data-stu-id="77942-196">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="77942-197">在收到上一個訊息或 keepalive 偵測後經過的預設持續時間（keepalive）時間比例時引發。</span><span class="sxs-lookup"><span data-stu-id="77942-197">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="77942-198">預設的持續時間警告期間是持續時間的2/3。</span><span class="sxs-lookup"><span data-stu-id="77942-198">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="77942-199">Keepalive timeout 為20秒，因此警告大約會出現13秒。</span><span class="sxs-lookup"><span data-stu-id="77942-199">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="77942-200">根據預設，伺服器每隔10秒就會傳送一次持續性偵測，而用戶端會每隔2秒檢查一次 keepalive ping， (keepalive timeout 值與 keepalive timeout 警告值) 之間的第三個差異。</span><span class="sxs-lookup"><span data-stu-id="77942-200">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="77942-201">如果傳輸 API 會察覺到中斷連線，則在持續性超時警告期間之前，SignalR 可能會收到中斷連接的通知。</span><span class="sxs-lookup"><span data-stu-id="77942-201">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="77942-202">在此情況下， `ConnectionSlow` 不會引發事件，而 SignalR 會直接進入 `Reconnecting` 事件。</span><span class="sxs-lookup"><span data-stu-id="77942-202">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="77942-203">`Reconnecting` 用戶端事件。</span><span class="sxs-lookup"><span data-stu-id="77942-203">`Reconnecting` client event.</span></span>

    <span data-ttu-id="77942-204">當 () 傳輸 API 偵測到連接遺失時引發，或 (b) 在收到最後一個訊息或 keepalive 偵測之後，已超過持續時間長度。</span><span class="sxs-lookup"><span data-stu-id="77942-204">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="77942-205">SignalR 用戶端程式代碼會開始嘗試重新連接。</span><span class="sxs-lookup"><span data-stu-id="77942-205">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="77942-206">如果您希望應用程式在傳輸連線遺失時採取一些動作，您可以處理這個事件。</span><span class="sxs-lookup"><span data-stu-id="77942-206">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="77942-207">預設 keepalive timeout 期限目前為20秒。</span><span class="sxs-lookup"><span data-stu-id="77942-207">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="77942-208">如果您的用戶端程式代碼在 SignalR 處於重新連接模式時嘗試呼叫中樞方法，SignalR 將會嘗試傳送命令。</span><span class="sxs-lookup"><span data-stu-id="77942-208">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="77942-209">大部分的情況下，這類嘗試將會失敗，但在某些情況下，可能會成功。</span><span class="sxs-lookup"><span data-stu-id="77942-209">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="77942-210">針對伺服器傳送的事件、永遠框架和長時間輪詢傳輸，SignalR 會使用兩個通道，用戶端會使用這兩個通道來傳送訊息，而另一個通道用來接收訊息。</span><span class="sxs-lookup"><span data-stu-id="77942-210">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="77942-211">用來接收的通道是永久開啟的通道，也就是實體連接中斷時所關閉的通道。</span><span class="sxs-lookup"><span data-stu-id="77942-211">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="77942-212">用於傳送的通道仍可供使用，因此，如果已還原實體連接，則從用戶端到伺服器的方法呼叫可能會成功，然後才會重新建立接收通道。</span><span class="sxs-lookup"><span data-stu-id="77942-212">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="77942-213">在 SignalR 重新開啟用於接收的通道之前，將不會收到傳回值。</span><span class="sxs-lookup"><span data-stu-id="77942-213">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="77942-214">`Reconnected` 用戶端事件。</span><span class="sxs-lookup"><span data-stu-id="77942-214">`Reconnected` client event.</span></span>

    <span data-ttu-id="77942-215">重新建立傳輸連接時引發。</span><span class="sxs-lookup"><span data-stu-id="77942-215">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="77942-216">`OnReconnected`中樞內的事件處理常式會執行。</span><span class="sxs-lookup"><span data-stu-id="77942-216">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="77942-217">`Closed``disconnected`JavaScript) 中的用戶端事件 (事件。</span><span class="sxs-lookup"><span data-stu-id="77942-217">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="77942-218">當 SignalR 用戶端程式代碼在遺失傳輸連線之後嘗試重新連接時，在中斷連接逾時期間過期時引發。</span><span class="sxs-lookup"><span data-stu-id="77942-218">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="77942-219">預設的中斷連接逾時為30秒。</span><span class="sxs-lookup"><span data-stu-id="77942-219">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="77942-220"> (當連接結束時，也會引發此事件，因為 `Stop` 呼叫方法。 ) </span><span class="sxs-lookup"><span data-stu-id="77942-220">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="77942-221">傳輸 API 未偵測到傳輸連接中斷，且不會延遲伺服器的持續性偵測超過 keepalive 超時警告期間，可能不會引發任何連接存留期事件。</span><span class="sxs-lookup"><span data-stu-id="77942-221">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="77942-222">有些網路環境刻意關閉閒置的連線，而 keepalive 封包的另一項功能是，藉由讓這些網路知道 SignalR 連線正在使用中，來協助防止這種情況。</span><span class="sxs-lookup"><span data-stu-id="77942-222">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="77942-223">在極端情況下，keepalive 偵測的預設頻率可能不足以防止關閉連接。</span><span class="sxs-lookup"><span data-stu-id="77942-223">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="77942-224">在這種情況下，您可以設定讓 keepalive ping 更頻繁地傳送。</span><span class="sxs-lookup"><span data-stu-id="77942-224">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="77942-225">如需詳細資訊，請參閱本主題稍後的「 [Timeout 和 keepalive」設定](#timeoutkeepalive) 。</span><span class="sxs-lookup"><span data-stu-id="77942-225">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE]
>
> <span data-ttu-id="77942-226">**重要**：不保證此處所述的事件順序。</span><span class="sxs-lookup"><span data-stu-id="77942-226">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="77942-227">SignalR 會根據此配置，以可預測的方式讓每次嘗試引發連接存留期事件，但有許多不同的網路事件變化，以及許多基礎通訊架構（例如傳輸 Api）處理這些事件的方式。</span><span class="sxs-lookup"><span data-stu-id="77942-227">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="77942-228">例如， `Reconnected` 當用戶端重新連接時，可能不會引發事件，或是 `OnConnected` 當嘗試建立連接失敗時，伺服器上的處理常式可能會執行。</span><span class="sxs-lookup"><span data-stu-id="77942-228">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="77942-229">本主題只會說明通常會由特定一般情況產生的效果。</span><span class="sxs-lookup"><span data-stu-id="77942-229">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>

<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="77942-230">用戶端中斷連接案例</span><span class="sxs-lookup"><span data-stu-id="77942-230">Client disconnection scenarios</span></span>

<span data-ttu-id="77942-231">在瀏覽器用戶端中，維護 SignalR 連接的 SignalR 用戶端程式代碼會在網頁的 JavaScript 內容中執行。</span><span class="sxs-lookup"><span data-stu-id="77942-231">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="77942-232">這就是為什麼當您從某個頁面流覽至另一個頁面時，SignalR 連接必須結束的原因，因此，如果您從多個瀏覽器視窗或索引標籤連線，就會有多個連接識別碼的連接。</span><span class="sxs-lookup"><span data-stu-id="77942-232">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="77942-233">當使用者關閉瀏覽器視窗或索引標籤，或流覽至新頁面或重新整理頁面時，SignalR 連接會立即結束，因為 SignalR 用戶端程式代碼會為您處理該瀏覽器事件，並呼叫 `Stop` 方法。</span><span class="sxs-lookup"><span data-stu-id="77942-233">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="77942-234">在這些情況下，或在任何用戶端平臺中，當您的應用程式呼叫 `Stop` 方法時， `OnDisconnected` 事件處理常式會在伺服器上立即執行，而且用戶端 `Closed` 會引發事件 (事件是 `disconnected` 以 JavaScript) 命名。</span><span class="sxs-lookup"><span data-stu-id="77942-234">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="77942-235">如果用戶端應用程式或其執行的電腦損毀或進入睡眠 (例如，當使用者關閉膝上型電腦) 時，不會通知伺服器發生什麼事。</span><span class="sxs-lookup"><span data-stu-id="77942-235">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="77942-236">在伺服器知道的情況下，用戶端可能會因為連線中斷而遺失，而用戶端可能會嘗試重新連線。</span><span class="sxs-lookup"><span data-stu-id="77942-236">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="77942-237">因此，在這些情況下，伺服器會等候用戶端重新連線，而且 `OnDisconnected` 在中斷連接逾時期間到期之前 (大約30秒) 。</span><span class="sxs-lookup"><span data-stu-id="77942-237">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="77942-238">下圖說明此案例。</span><span class="sxs-lookup"><span data-stu-id="77942-238">The following diagram illustrates this scenario.</span></span>

![用戶端電腦失敗](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="77942-240">伺服器中斷連接案例</span><span class="sxs-lookup"><span data-stu-id="77942-240">Server disconnection scenarios</span></span>

<span data-ttu-id="77942-241">當伺服器離線時，它會重新開機、失敗、應用程式網域回收等等。--結果可能類似于遺失的連接，或者傳輸 API 和 SignalR 可能會立即知道伺服器已消失，而且 SignalR 可能會開始嘗試重新連接，而不會引發 `ConnectionSlow` 事件。</span><span class="sxs-lookup"><span data-stu-id="77942-241">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="77942-242">如果用戶端進入重新連接模式，而且伺服器復原或重新開機，或在中斷連接逾時期間過期之前讓新的伺服器上線，用戶端會重新連接到已還原的伺服器或新的伺服器。</span><span class="sxs-lookup"><span data-stu-id="77942-242">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="77942-243">在此情況下，SignalR 連接會在用戶端上繼續，並 `Reconnected` 引發事件。</span><span class="sxs-lookup"><span data-stu-id="77942-243">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="77942-244">在第一部伺服器上，絕對不會 `OnDisconnected` 執行，而且在新的伺服器上， `OnReconnected` 會執行，但在 `OnConnected` 之前從未針對該伺服器上的該用戶端執行。</span><span class="sxs-lookup"><span data-stu-id="77942-244">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="77942-245">如果用戶端在重新開機或應用程式網域回收之後重新連線至相同的伺服器， (效果相同，因為當伺服器重新開機時，沒有先前連接活動的記憶體。 ) 下圖假設傳輸 API 會立即察覺遺失的連接，因此 `ConnectionSlow` 不會引發事件。</span><span class="sxs-lookup"><span data-stu-id="77942-245">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![伺服器失敗並重新連接](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="77942-247">如果伺服器在中斷連線超時時間內無法使用，SignalR 連接會結束。</span><span class="sxs-lookup"><span data-stu-id="77942-247">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="77942-248">在此案例中， `Closed` `disconnected` JavaScript 用戶端) 中的事件 (會在用戶端上引發，但 `OnDisconnected` 永遠不會在伺服器上呼叫。</span><span class="sxs-lookup"><span data-stu-id="77942-248">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="77942-249">下圖假設傳輸 API 不會察覺遺失的連接，因此 SignalR 的 keepalive 功能會偵測到它，並 `ConnectionSlow` 引發事件。</span><span class="sxs-lookup"><span data-stu-id="77942-249">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![伺服器失敗和超時](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="77942-251">Timeout 和 keepalive 設定</span><span class="sxs-lookup"><span data-stu-id="77942-251">Timeout and keepalive settings</span></span>

<span data-ttu-id="77942-252">預設 `ConnectionTimeout` 值、 `DisconnectTimeout` 和 `KeepAlive` 值適用于大部分的情況，但如果您的環境具有特殊需求，則可以變更。</span><span class="sxs-lookup"><span data-stu-id="77942-252">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="77942-253">例如，如果您的網路環境關閉閒置5秒鐘的連線，您可能必須減少 keepalive 值。</span><span class="sxs-lookup"><span data-stu-id="77942-253">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="77942-254">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="77942-254">ConnectionTimeout</span></span>

<span data-ttu-id="77942-255">這項設定代表開啟傳輸連線，並在關閉並開啟新連接之前等候回應的時間長度。</span><span class="sxs-lookup"><span data-stu-id="77942-255">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="77942-256">預設值為110秒。</span><span class="sxs-lookup"><span data-stu-id="77942-256">The default value is 110 seconds.</span></span>

<span data-ttu-id="77942-257">這項設定僅適用于停用 keepalive 功能時，通常僅適用于長時間輪詢傳輸。</span><span class="sxs-lookup"><span data-stu-id="77942-257">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="77942-258">下圖說明此設定在長輪詢傳輸連線上的效果。</span><span class="sxs-lookup"><span data-stu-id="77942-258">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![長時間輪詢傳輸連接](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="77942-260">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="77942-260">DisconnectTimeout</span></span>

<span data-ttu-id="77942-261">這項設定代表在引發事件之前，在傳輸連線遺失之前等候的時間量 `Disconnected` 。</span><span class="sxs-lookup"><span data-stu-id="77942-261">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="77942-262">預設值為 30 秒。</span><span class="sxs-lookup"><span data-stu-id="77942-262">The default value is 30 seconds.</span></span> <span data-ttu-id="77942-263">當您設定時 `DisconnectTimeout` ， `KeepAlive` 會自動將值設為 1/3 `DisconnectTimeout` 。</span><span class="sxs-lookup"><span data-stu-id="77942-263">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="77942-264">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="77942-264">KeepAlive</span></span>

<span data-ttu-id="77942-265">這項設定代表透過閒置連接傳送 keepalive 封包之前所等待的時間量。</span><span class="sxs-lookup"><span data-stu-id="77942-265">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="77942-266">預設值為 10 秒。</span><span class="sxs-lookup"><span data-stu-id="77942-266">The default value is 10 seconds.</span></span> <span data-ttu-id="77942-267">此值不得超過1/3 的 `DisconnectTimeout` 值。</span><span class="sxs-lookup"><span data-stu-id="77942-267">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="77942-268">如果您想要同時設定 `DisconnectTimeout` 和 `KeepAlive` ，請設定 `KeepAlive` after `DisconnectTimeout` 。</span><span class="sxs-lookup"><span data-stu-id="77942-268">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="77942-269">否則， `KeepAlive` 當 `DisconnectTimeout` 自動將 timeout 值設定為1/3 時，將會覆寫您 `KeepAlive` 的設定。</span><span class="sxs-lookup"><span data-stu-id="77942-269">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="77942-270">如果您想要停用 keepalive 功能，請設定 `KeepAlive` 為 null。</span><span class="sxs-lookup"><span data-stu-id="77942-270">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="77942-271">長期輪詢傳輸會自動停用 Keepalive 功能。</span><span class="sxs-lookup"><span data-stu-id="77942-271">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="77942-272">如何變更 timeout 和 keepalive 設定</span><span class="sxs-lookup"><span data-stu-id="77942-272">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="77942-273">若要變更這些設定的預設值，請在 global.asax 檔案中將它們設定 `Application_Start` 為，如下列範例所示。 *Global.asax*</span><span class="sxs-lookup"><span data-stu-id="77942-273">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="77942-274">範例程式碼中顯示的值與預設值相同。</span><span class="sxs-lookup"><span data-stu-id="77942-274">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="77942-275">如何通知使用者中斷連線</span><span class="sxs-lookup"><span data-stu-id="77942-275">How to notify the user about disconnections</span></span>

<span data-ttu-id="77942-276">在某些應用程式中，您可能會想要在發生連線問題時向使用者顯示訊息。</span><span class="sxs-lookup"><span data-stu-id="77942-276">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="77942-277">您有數個選項可供您和何時進行。</span><span class="sxs-lookup"><span data-stu-id="77942-277">You have several options for how and when to do this.</span></span> <span data-ttu-id="77942-278">下列程式碼範例適用于使用所產生之 proxy 的 JavaScript 用戶端。</span><span class="sxs-lookup"><span data-stu-id="77942-278">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="77942-279">處理 `connectionSlow` 事件，以便在 SignalR 知道連線問題時，立即顯示訊息，然後再進入重新連接模式。</span><span class="sxs-lookup"><span data-stu-id="77942-279">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="77942-280">處理 `reconnecting` 事件，以便在 SignalR 感知中斷連線並進入重新連接模式時顯示訊息。</span><span class="sxs-lookup"><span data-stu-id="77942-280">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="77942-281">處理 `disconnected` 事件，以便在重新連接嘗試超時時顯示訊息。在此案例中，重新建立與伺服器之連接的唯一方法，是藉由呼叫方法來重新開機 SignalR 連接 `Start` ，這將會建立新的連接識別碼。</span><span class="sxs-lookup"><span data-stu-id="77942-281">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="77942-282">下列程式碼範例會使用旗標，以確保您只會在重新連接逾時之後發出通知，而不是在呼叫方法所造成 SignalR 連接的一般端之後發出通知 `Stop` 。</span><span class="sxs-lookup"><span data-stu-id="77942-282">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="77942-283">如何持續重新連線</span><span class="sxs-lookup"><span data-stu-id="77942-283">How to continuously reconnect</span></span>

<span data-ttu-id="77942-284">在某些應用程式中，您可能會想要在連線遺失之後自動重新建立連線，並將重新連線的嘗試超時。若要這樣做，您可以 `Start` 從事件處理常式中呼叫方法， `Closed` (`disconnected` JavaScript 用戶端上的事件處理常式) 。</span><span class="sxs-lookup"><span data-stu-id="77942-284">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="77942-285">在呼叫之前，您可能會想要等候一段時間 `Start` ，以避免在伺服器或實體連線無法使用時，過於頻繁地執行此操作。</span><span class="sxs-lookup"><span data-stu-id="77942-285">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="77942-286">下列程式碼範例適用于使用所產生之 proxy 的 JavaScript 用戶端。</span><span class="sxs-lookup"><span data-stu-id="77942-286">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="77942-287">在行動用戶端中可能要注意的問題是，當伺服器或實體連線無法使用時，連續重新連接嘗試可能會造成不必要的電池耗盡。</span><span class="sxs-lookup"><span data-stu-id="77942-287">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="77942-288">如何在伺服器程式碼中中斷用戶端連線</span><span class="sxs-lookup"><span data-stu-id="77942-288">How to disconnect a client in server code</span></span>

<span data-ttu-id="77942-289">SignalR 第2版沒有內建的伺服器 API 可中斷用戶端連線。</span><span class="sxs-lookup"><span data-stu-id="77942-289">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="77942-290">未來會有 [新增此功能的計畫](https://github.com/SignalR/SignalR/issues/2101)。</span><span class="sxs-lookup"><span data-stu-id="77942-290">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="77942-291">在目前的 SignalR 版本中，將用戶端與伺服器中斷連線最簡單的方式，就是在用戶端上執行中斷連接方法，並從伺服器呼叫該方法。</span><span class="sxs-lookup"><span data-stu-id="77942-291">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="77942-292">下列程式碼範例顯示使用產生的 proxy 之 JavaScript 用戶端的中斷連線方法。</span><span class="sxs-lookup"><span data-stu-id="77942-292">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="77942-293">安全性-此方法不會中斷用戶端的連線，也不會提供建議的內建 API，因為用戶端可以重新連線，或遭到駭客攻擊的程式碼可能會移除 `stopClient` 方法或變更其用途。</span><span class="sxs-lookup"><span data-stu-id="77942-293">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="77942-294">執行可設定狀態的拒絕服務 (DOS) 保護的適當位置不在架構或伺服器層，而是在前端基礎結構中。</span><span class="sxs-lookup"><span data-stu-id="77942-294">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>

<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="77942-295">偵測中斷連接的原因</span><span class="sxs-lookup"><span data-stu-id="77942-295">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="77942-296">SignalR 2.1 會將多載新增至伺服器 `OnDisconnect` 事件，指出用戶端是否刻意中斷連線，而不是超時。 `StopCalled` 如果用戶端明確關閉連接，則此參數為 true。</span><span class="sxs-lookup"><span data-stu-id="77942-296">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="77942-297">在 JavaScript 中，如果伺服器錯誤導致用戶端中斷連線，則會將錯誤資訊以形式傳遞給用戶端 `$.connection.hub.lastError` 。</span><span class="sxs-lookup"><span data-stu-id="77942-297">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="77942-298">**C # 伺服器程式碼： `stopCalled` 參數**</span><span class="sxs-lookup"><span data-stu-id="77942-298">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="77942-299">**JavaScript 用戶端程式代碼： `lastError` 在 `disconnect` 事件中存取。**</span><span class="sxs-lookup"><span data-stu-id="77942-299">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
