---
uid: aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/queue-centric-work-pattern
title: 以佇列為中心的工作模式（使用 Azure 建立真實世界的雲端應用程式） |Microsoft Docs
author: MikeWasson
description: 使用 Azure 電子書建立真實世界的雲端應用程式，是以 Scott Guthrie 所開發的簡報為基礎。 它會說明13個模式和實務，
ms.author: riande
ms.date: 06/12/2014
ms.assetid: cc1ad51b-40c3-4c68-8620-9aaa0fd1f6cf
msc.legacyurl: /aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/queue-centric-work-pattern
msc.type: authoredcontent
ms.openlocfilehash: c73b070f11366e781bcea70ffc84fd49a47d469a
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/28/2019
ms.locfileid: "74582754"
---
# <a name="queue-centric-work-pattern-building-real-world-cloud-apps-with-azure"></a><span data-ttu-id="3e128-104">以佇列為中心的工作模式（使用 Azure 建立真實世界的雲端應用程式）</span><span class="sxs-lookup"><span data-stu-id="3e128-104">Queue-Centric Work Pattern (Building Real-World Cloud Apps with Azure)</span></span>

<span data-ttu-id="3e128-105">由[Mike Wasson](https://github.com/MikeWasson)， [Rick Anderson]((https://twitter.com/RickAndMSFT))， [Tom 作者: dykstra](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="3e128-105">by [Mike Wasson](https://github.com/MikeWasson), [Rick Anderson]((https://twitter.com/RickAndMSFT)), [Tom Dykstra](https://github.com/tdykstra)</span></span>

<span data-ttu-id="3e128-106">[下載 Fix It 專案](https://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4)或[下載電子書](https://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)</span><span class="sxs-lookup"><span data-stu-id="3e128-106">[Download Fix It Project](https://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4) or [Download E-book](https://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)</span></span>

> <span data-ttu-id="3e128-107">**使用 Azure 電子書建立真實世界的雲端應用程式**，是以 Scott Guthrie 所開發的簡報為基礎。</span><span class="sxs-lookup"><span data-stu-id="3e128-107">The **Building Real World Cloud Apps with Azure** e-book is based on a presentation developed by Scott Guthrie.</span></span> <span data-ttu-id="3e128-108">其中說明13種模式和作法，可協助您成功開發雲端 web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="3e128-108">It explains 13 patterns and practices that can help you be successful developing web apps for the cloud.</span></span> <span data-ttu-id="3e128-109">如需電子書的相關資訊，請參閱[第一章](introduction.md)。</span><span class="sxs-lookup"><span data-stu-id="3e128-109">For information about the e-book, see [the first chapter](introduction.md).</span></span>

<span data-ttu-id="3e128-110">稍早，我們看到使用多個服務可能會產生「複合」 SLA，其中應用程式的有效 SLA 是個別 Sla 的*產品*。</span><span class="sxs-lookup"><span data-stu-id="3e128-110">Earlier, we saw that using multiple services can result in a "composite" SLA, where the app's effective SLA is the *product* of the individual SLAs.</span></span> <span data-ttu-id="3e128-111">例如，Fix It 應用程式會使用網站、儲存體和 SQL Database。</span><span class="sxs-lookup"><span data-stu-id="3e128-111">For example, the Fix It app uses Web Sites, Storage, and SQL Database.</span></span> <span data-ttu-id="3e128-112">如果其中任何一項服務失敗，應用程式將會對使用者傳回錯誤。</span><span class="sxs-lookup"><span data-stu-id="3e128-112">If any one of these services fails, the app will return an error to the user.</span></span>

<span data-ttu-id="3e128-113">快取是處理唯讀內容的暫時性失敗的好方法。</span><span class="sxs-lookup"><span data-stu-id="3e128-113">Caching is a good way to handle transient failures for read-only content.</span></span> <span data-ttu-id="3e128-114">但如果您的應用程式需要執行工作，該怎麼辦？</span><span class="sxs-lookup"><span data-stu-id="3e128-114">But what if your application needs to do work?</span></span> <span data-ttu-id="3e128-115">例如，當使用者提交新的 [修正 It] 工作時，應用程式就不能只是將工作放入快取中。</span><span class="sxs-lookup"><span data-stu-id="3e128-115">For example, when the user submits a new Fix It task, the app can't just put the task into the cache.</span></span> <span data-ttu-id="3e128-116">應用程式必須將 Fix It 工作寫入持續性資料存放區，才能進行處理。</span><span class="sxs-lookup"><span data-stu-id="3e128-116">The app needs to write the Fix It task into a persistent data store, so it can be processed.</span></span>

<span data-ttu-id="3e128-117">這就是以佇列為中心的工作模式。</span><span class="sxs-lookup"><span data-stu-id="3e128-117">That's where the queue-centric work pattern comes in.</span></span> <span data-ttu-id="3e128-118">此模式可讓 web 層和後端服務之間的鬆散結合。</span><span class="sxs-lookup"><span data-stu-id="3e128-118">This pattern enables loose coupling between a web tier and a backend service.</span></span>

<span data-ttu-id="3e128-119">以下是模式的運作方式。</span><span class="sxs-lookup"><span data-stu-id="3e128-119">Here's how the pattern works.</span></span> <span data-ttu-id="3e128-120">當應用程式取得要求時，它會將工作專案放在佇列上，並立即傳迴響應。</span><span class="sxs-lookup"><span data-stu-id="3e128-120">When the application gets a request, it puts a work item onto a queue and immediately returns the response.</span></span> <span data-ttu-id="3e128-121">接著，個別的後端程序會將工作項目從佇列拉出並執行工作。</span><span class="sxs-lookup"><span data-stu-id="3e128-121">Then a separate backend process pulls work items from the queue and does the work.</span></span>

<span data-ttu-id="3e128-122">以佇列為中心的工作模式適用于：</span><span class="sxs-lookup"><span data-stu-id="3e128-122">The queue-centric work pattern is useful for:</span></span>

- <span data-ttu-id="3e128-123">耗費時間的工作（高延遲）。</span><span class="sxs-lookup"><span data-stu-id="3e128-123">Work that is time consuming (high latency).</span></span>
- <span data-ttu-id="3e128-124">需要外部服務的工作，可能永遠無法使用。</span><span class="sxs-lookup"><span data-stu-id="3e128-124">Work that requires an external service that might not always be available.</span></span>
- <span data-ttu-id="3e128-125">需要大量資源的工作（高 CPU）。</span><span class="sxs-lookup"><span data-stu-id="3e128-125">Work that is resource-intensive (high CPU).</span></span>
- <span data-ttu-id="3e128-126">可受益于比率調節的工作（受限於突然的負載高載）。</span><span class="sxs-lookup"><span data-stu-id="3e128-126">Work that would benefit from rate leveling (subject to sudden load bursts).</span></span>

## <a name="reduced-latency"></a><span data-ttu-id="3e128-127">降低延遲</span><span class="sxs-lookup"><span data-stu-id="3e128-127">Reduced Latency</span></span>

<span data-ttu-id="3e128-128">當您執行耗時的工作時，佇列會很有用。</span><span class="sxs-lookup"><span data-stu-id="3e128-128">Queues are useful any time you are doing time-consuming work.</span></span> <span data-ttu-id="3e128-129">如果工作需要幾秒鐘或更久的時間，而不是封鎖終端使用者，請將工作專案放入佇列中。</span><span class="sxs-lookup"><span data-stu-id="3e128-129">If a task takes a few seconds or longer, instead of blocking the end user, put the work item into a queue.</span></span> <span data-ttu-id="3e128-130">告訴使用者「我們正在處理它」，然後使用佇列接聽程式在背景中處理工作。</span><span class="sxs-lookup"><span data-stu-id="3e128-130">Tell the user "We're working on it," and then use a queue listener to process the task in the background.</span></span>

<span data-ttu-id="3e128-131">例如，當您在線上零售商購買某個專案時，網站會立即確認您的訂單。</span><span class="sxs-lookup"><span data-stu-id="3e128-131">For example, when you purchase something at an online retailer, the web site confirms your order immediately.</span></span> <span data-ttu-id="3e128-132">但這並不表示您的東西已經在交付卡車中。</span><span class="sxs-lookup"><span data-stu-id="3e128-132">But that doesn't mean your stuff is already in a truck being delivered.</span></span> <span data-ttu-id="3e128-133">他們會在佇列中放入一項工作，而在背景中，他們會進行信用檢查、準備要運送的專案等等。</span><span class="sxs-lookup"><span data-stu-id="3e128-133">They put a task in a queue, and in the background they are doing the credit check, preparing your items for shipping, and so forth.</span></span>

<span data-ttu-id="3e128-134">對於延遲較短的案例，端對端時間總計可能會比使用佇列更長，相較于同步執行工作。</span><span class="sxs-lookup"><span data-stu-id="3e128-134">For scenarios with short latency, the total end-to-end time might be longer using a queue, compared with doing the task synchronously.</span></span> <span data-ttu-id="3e128-135">但是就算如此，其他優點也可能超過該缺點。</span><span class="sxs-lookup"><span data-stu-id="3e128-135">But even then, the other benefits can outweigh that disadvantage.</span></span>

## <a name="increased-reliability"></a><span data-ttu-id="3e128-136">提高可靠性</span><span class="sxs-lookup"><span data-stu-id="3e128-136">Increased Reliability</span></span>

<span data-ttu-id="3e128-137">在修正此問題的版本中，web 前端會與 SQL Database 後端緊密結合在一起。</span><span class="sxs-lookup"><span data-stu-id="3e128-137">In the version of Fix It that we've been looking at so far, the web front-end is tightly coupled with the SQL Database back-end.</span></span> <span data-ttu-id="3e128-138">如果 SQL database 服務無法使用，使用者會收到錯誤。</span><span class="sxs-lookup"><span data-stu-id="3e128-138">If the SQL database service is unavailable, the user gets an error.</span></span> <span data-ttu-id="3e128-139">如果重試無效（也就是失敗不是暫時性），您唯一可以做的就是顯示錯誤，並要求使用者稍後再試一次。</span><span class="sxs-lookup"><span data-stu-id="3e128-139">If retries don't work (that is, the failure is more than transient), the only thing you can do is show an error and ask the user to try again later.</span></span>

![顯示 SQL Database 後端失敗時的 web 前端失敗的圖表](queue-centric-work-pattern/_static/image1.png)

<span data-ttu-id="3e128-141">使用佇列，當使用者提交 Fix It 工作時，應用程式會將訊息寫入佇列。</span><span class="sxs-lookup"><span data-stu-id="3e128-141">Using queues, when a user submits a Fix It task, the app writes a message to the queue.</span></span> <span data-ttu-id="3e128-142">訊息承載是工作的[JSON](http://json.org/)標記法。</span><span class="sxs-lookup"><span data-stu-id="3e128-142">The message payload is a [JSON](http://json.org/) representation of the task.</span></span> <span data-ttu-id="3e128-143">一旦訊息寫入佇列，應用程式就會傳回，並立即向使用者顯示成功訊息。</span><span class="sxs-lookup"><span data-stu-id="3e128-143">As soon as the message is written to the queue, the app returns and immediately shows a success message to the user.</span></span>

<span data-ttu-id="3e128-144">如果任何後端服務（例如 SQL database 或佇列接聽程式）離線，使用者仍然可以提交新的 Fix It 工作。</span><span class="sxs-lookup"><span data-stu-id="3e128-144">If any of the backend services – such as the SQL database or the queue listener -- go offline, users can still submit new Fix It tasks.</span></span> <span data-ttu-id="3e128-145">訊息只會排入佇列，直到後端服務再次可用為止。</span><span class="sxs-lookup"><span data-stu-id="3e128-145">The messages will just queue up until the backend services are available again.</span></span> <span data-ttu-id="3e128-146">此時，後端服務會趕上待處理專案。</span><span class="sxs-lookup"><span data-stu-id="3e128-146">At that point, the backend services will catch up on the backlog.</span></span>

![顯示 web 前端在發生 SQL Database 錯誤時繼續運作的圖表](queue-centric-work-pattern/_static/image2.png)

<span data-ttu-id="3e128-148">此外，您現在可以新增更多後端邏輯，而不需擔心前端的復原。</span><span class="sxs-lookup"><span data-stu-id="3e128-148">Moreover, now you can add more backend logic without worrying about the resiliency of the front end.</span></span> <span data-ttu-id="3e128-149">例如，您可能會想要在每次指派新的修正程式時，傳送電子郵件或 SMS 訊息給擁有者。</span><span class="sxs-lookup"><span data-stu-id="3e128-149">For example, you might want to send an email or SMS message to the owner whenever a new Fix It is assigned.</span></span> <span data-ttu-id="3e128-150">如果電子郵件或 SMS 服務變得無法使用，您可以處理其他所有專案，然後將訊息放入不同的佇列，以便傳送電子郵件/SMS 訊息。</span><span class="sxs-lookup"><span data-stu-id="3e128-150">If the email or SMS service becomes unavailable, you can process everything else, and then put a message into a separate queue for sending email/SMS messages.</span></span>

<span data-ttu-id="3e128-151">在過去，我們的有效 SLA 已 Web Apps &times; 儲存體 &times; SQL Database = 99.7%。</span><span class="sxs-lookup"><span data-stu-id="3e128-151">Previously, our effective SLA was Web Apps &times; Storage &times; SQL Database = 99.7%.</span></span> <span data-ttu-id="3e128-152">（請參閱[設計到存活的失敗](design-to-survive-failures.md)）。</span><span class="sxs-lookup"><span data-stu-id="3e128-152">(See [Design to Survive Failures](design-to-survive-failures.md).)</span></span>

<span data-ttu-id="3e128-153">當我們將應用程式變更為使用佇列時，web 前端只會相依于 Web Apps 和儲存體，以取得99.8% 的複合 SLA。</span><span class="sxs-lookup"><span data-stu-id="3e128-153">When we change the app to use a queue, the web front end depends only on Web Apps and Storage, for a composite SLA of 99.8%.</span></span> <span data-ttu-id="3e128-154">（請注意，佇列是 Azure 儲存體服務的一部分，因此包含在與 blob 儲存體相同的 SLA 中）。</span><span class="sxs-lookup"><span data-stu-id="3e128-154">(Note that queues are part of the Azure storage service, so they are included in the same SLA as blob storage.)</span></span>

<span data-ttu-id="3e128-155">如果您的需求高於99.8%，您可以在兩個不同的區域中建立兩個佇列。</span><span class="sxs-lookup"><span data-stu-id="3e128-155">If you need even better than 99.8%, you can create two queues in two different regions.</span></span> <span data-ttu-id="3e128-156">指定一個做為主要，另一個做為次要。</span><span class="sxs-lookup"><span data-stu-id="3e128-156">Designate one as the primary, and the other as the secondary.</span></span> <span data-ttu-id="3e128-157">在您的應用程式中，如果主要佇列無法使用，則故障切換至次要佇列。</span><span class="sxs-lookup"><span data-stu-id="3e128-157">In your app, fail over to the secondary queue if the primary queue is not available.</span></span> <span data-ttu-id="3e128-158">同時無法使用的機會很小。</span><span class="sxs-lookup"><span data-stu-id="3e128-158">The chance of both being unavailable at the same time is very small.</span></span>

## <a name="rate-leveling-and-independent-scaling"></a><span data-ttu-id="3e128-159">比率調節和獨立調整</span><span class="sxs-lookup"><span data-stu-id="3e128-159">Rate Leveling and Independent Scaling</span></span>

<span data-ttu-id="3e128-160">佇列也適用于所謂的*速率調節*或*負載調節*。</span><span class="sxs-lookup"><span data-stu-id="3e128-160">Queues are also useful for something called *rate leveling* or *load leveling*.</span></span>

<span data-ttu-id="3e128-161">Web 應用程式通常會受到流量突然激增的影響。</span><span class="sxs-lookup"><span data-stu-id="3e128-161">Web apps are often susceptible to sudden bursts in traffic.</span></span> <span data-ttu-id="3e128-162">雖然您可以使用自動調整來自動新增網頁伺服器，以處理增加的網路流量，但自動調整可能無法快速回應，以處理負載突然尖峰的情況。</span><span class="sxs-lookup"><span data-stu-id="3e128-162">While you can use autoscaling to automatically add web servers to handle increased web traffic, autoscaling might not be able to react quickly enough to handle abrupt spikes in load.</span></span> <span data-ttu-id="3e128-163">如果 web 伺服器可以藉由將訊息寫入佇列來卸載他們必須執行的工作，則可以處理更多的流量。</span><span class="sxs-lookup"><span data-stu-id="3e128-163">If the web servers can offload some of the work they have to do by writing a message to a queue, they can handle more traffic.</span></span> <span data-ttu-id="3e128-164">後端服務可以從佇列讀取訊息並加以處理。</span><span class="sxs-lookup"><span data-stu-id="3e128-164">A backend service can then read messages from the queue and process them.</span></span> <span data-ttu-id="3e128-165">佇列的深度會隨著傳入負載的變化而成長或縮小。</span><span class="sxs-lookup"><span data-stu-id="3e128-165">The depth of the queue will grow or shrink as the incoming load varies.</span></span>

<span data-ttu-id="3e128-166">由於許多耗時的工作都已登出後端服務，因此 web 層可以更輕鬆地回應流量突然激增的情況。</span><span class="sxs-lookup"><span data-stu-id="3e128-166">With much of its time-consuming work off-loaded to a backend service, the web tier can more easily respond to sudden spikes in traffic.</span></span> <span data-ttu-id="3e128-167">而且您可以節省成本，因為有任何特定數量的流量可由較少的 web 伺服器處理。</span><span class="sxs-lookup"><span data-stu-id="3e128-167">And you save money because any given amount of traffic can be handled by fewer web servers.</span></span>

<span data-ttu-id="3e128-168">您可以獨立調整 web 層和後端服務。</span><span class="sxs-lookup"><span data-stu-id="3e128-168">You can scale the web tier and backend service independently.</span></span> <span data-ttu-id="3e128-169">例如，您可能需要三部 web 伺服器，但只能有一個伺服器處理佇列訊息。</span><span class="sxs-lookup"><span data-stu-id="3e128-169">For example, you might need three web servers but only one server processing queue messages.</span></span> <span data-ttu-id="3e128-170">或者，如果您在背景執行大量運算工作，可能需要更多的後端伺服器。</span><span class="sxs-lookup"><span data-stu-id="3e128-170">Or if you're running a compute-intensive task in the background, you might need more backend servers.</span></span>

![](queue-centric-work-pattern/_static/image3.png)

<span data-ttu-id="3e128-171">自動調整適用于後端服務以及 web 層。</span><span class="sxs-lookup"><span data-stu-id="3e128-171">Autoscaling works with backend services as well as with the web tier.</span></span> <span data-ttu-id="3e128-172">根據後端 Vm 的 CPU 使用量，您可以相應增加或相應減少正在佇列中處理工作的 Vm 數目。</span><span class="sxs-lookup"><span data-stu-id="3e128-172">You can scale up or scale down the number of VMs that are processing the tasks in the queue, based on the CPU usage of the backend VMs.</span></span> <span data-ttu-id="3e128-173">或者，您可以根據佇列中的專案數自動調整。</span><span class="sxs-lookup"><span data-stu-id="3e128-173">Or, you can autoscale based on how many items are in a queue.</span></span> <span data-ttu-id="3e128-174">例如，您可以指示自動調整以嘗試在佇列中保留10個以上的專案。</span><span class="sxs-lookup"><span data-stu-id="3e128-174">For example, you can tell autoscale to try to keep no more than 10 items in the queue.</span></span> <span data-ttu-id="3e128-175">如果佇列有10個以上的專案，自動調整將會新增 Vm。</span><span class="sxs-lookup"><span data-stu-id="3e128-175">If the queue has more than 10 items, autoscale will add VMs.</span></span> <span data-ttu-id="3e128-176">當他們趕上時，自動調整將會卸載額外的 Vm。</span><span class="sxs-lookup"><span data-stu-id="3e128-176">When they catch up, autoscale will tear down the extra VMs.</span></span>

## <a name="adding-queues-to-the-fix-it-application"></a><span data-ttu-id="3e128-177">將佇列新增至修正 It 應用程式</span><span class="sxs-lookup"><span data-stu-id="3e128-177">Adding Queues to the Fix It Application</span></span>

<span data-ttu-id="3e128-178">若要執行佇列模式，我們必須對 Fix It 應用程式進行兩個變更。</span><span class="sxs-lookup"><span data-stu-id="3e128-178">To implement the queue pattern, we need to make two changes to the Fix It app.</span></span>

- <span data-ttu-id="3e128-179">當使用者提交新的 Fix It 工作時，請將工作放在佇列中，而不是將它寫入資料庫中。</span><span class="sxs-lookup"><span data-stu-id="3e128-179">When a user submits a new Fix It task, put the task in the queue, instead of writing it to the database.</span></span>
- <span data-ttu-id="3e128-180">建立後端服務，以處理佇列中的訊息。</span><span class="sxs-lookup"><span data-stu-id="3e128-180">Create a back-end service that processes messages in the queue.</span></span>

<span data-ttu-id="3e128-181">對於佇列，我們將使用[Azure 佇列儲存體服務](https://www.windowsazure.com/develop/net/how-to-guides/queue-service/)。</span><span class="sxs-lookup"><span data-stu-id="3e128-181">For the queue, we'll use the [Azure Queue Storage Service](https://www.windowsazure.com/develop/net/how-to-guides/queue-service/).</span></span> <span data-ttu-id="3e128-182">另一個選項是使用[Azure 服務匯流排](https://docs.microsoft.com/azure/service-bus/)。</span><span class="sxs-lookup"><span data-stu-id="3e128-182">Another option is to use [Azure Service Bus](https://docs.microsoft.com/azure/service-bus/).</span></span>

<span data-ttu-id="3e128-183">若要決定要使用哪個佇列服務，請考慮您的應用程式需要在佇列中傳送和接收訊息的方式：</span><span class="sxs-lookup"><span data-stu-id="3e128-183">To decide which queue service to use, consider how your app needs to send and receive the messages in the queue:</span></span>

- <span data-ttu-id="3e128-184">如果您有合作的生產者和競爭取用者，請考慮使用 Azure 佇列儲存體服務。</span><span class="sxs-lookup"><span data-stu-id="3e128-184">If you have cooperating producers and competing consumers, consider using Azure Queue Storage Service.</span></span> <span data-ttu-id="3e128-185">「合作的產生者」表示多個進程正在將訊息新增至佇列。</span><span class="sxs-lookup"><span data-stu-id="3e128-185">"Cooperating producers" means multiple processes are adding messages to a queue.</span></span> <span data-ttu-id="3e128-186">「競爭取用者」表示多個進程會從佇列中提取訊息來處理它們，但是任何指定的訊息只能由一個「取用者」處理。</span><span class="sxs-lookup"><span data-stu-id="3e128-186">"Competing consumers" means multiple processes are pulling messages off the queue to process them, but any given message can only be processed by one "consumer."</span></span> <span data-ttu-id="3e128-187">如果您需要的輸送量比單一佇列所能取得的更多，請使用額外的佇列和/或其他儲存體帳戶。</span><span class="sxs-lookup"><span data-stu-id="3e128-187">If you need more throughput than you can get with a single queue, use additional queues and/or additional storage accounts.</span></span>
- <span data-ttu-id="3e128-188">如果您需要[發行/訂閱模型](http://en.wikipedia.org/wiki/Publish/subscribe)，請考慮使用 Azure 服務匯流排的佇列。</span><span class="sxs-lookup"><span data-stu-id="3e128-188">If you need a [publish/subscribe model](http://en.wikipedia.org/wiki/Publish/subscribe), consider using Azure Service Bus Queues.</span></span>

<span data-ttu-id="3e128-189">修正 It 應用程式會符合合作的產生者和競爭取用者模型。</span><span class="sxs-lookup"><span data-stu-id="3e128-189">The Fix It app fits the cooperating producers and competing consumers model.</span></span>

<span data-ttu-id="3e128-190">另一個考慮是應用程式可用性。</span><span class="sxs-lookup"><span data-stu-id="3e128-190">Another consideration is application availability.</span></span> <span data-ttu-id="3e128-191">佇列儲存體服務是我們用於 blob 儲存體之相同服務的一部分，因此使用它不會影響我們的 SLA。</span><span class="sxs-lookup"><span data-stu-id="3e128-191">The Queue Storage Service is part of the same service that we're using for blob storage, so using it has no effect on our SLA.</span></span> <span data-ttu-id="3e128-192">Azure 服務匯流排是個別的服務，具有自己的 SLA。</span><span class="sxs-lookup"><span data-stu-id="3e128-192">Azure Service Bus is a separate service with its own SLA.</span></span> <span data-ttu-id="3e128-193">如果我們使用服務匯流排的佇列，我們必須考慮額外的 SLA 百分比，而我們的複合 SLA 會較低。</span><span class="sxs-lookup"><span data-stu-id="3e128-193">If we used Service Bus Queues, we would have to factor in an additional SLA percentage, and our composite SLA would be lower.</span></span> <span data-ttu-id="3e128-194">當您選擇佇列服務時，請確定您瞭解您對應用程式可用性所做的影響。</span><span class="sxs-lookup"><span data-stu-id="3e128-194">When you're choosing a queue service, make sure you understand the impact of your choice on application availability.</span></span> <span data-ttu-id="3e128-195">如需詳細資訊，請參閱[Resources](#resources)一節。</span><span class="sxs-lookup"><span data-stu-id="3e128-195">For more information, see the [Resources](#resources) section.</span></span>

## <a name="creating-queue-messages"></a><span data-ttu-id="3e128-196">建立佇列訊息</span><span class="sxs-lookup"><span data-stu-id="3e128-196">Creating Queue Messages</span></span>

<span data-ttu-id="3e128-197">若要在佇列上放置 Fix It 工作，web 前端會執行下列步驟：</span><span class="sxs-lookup"><span data-stu-id="3e128-197">To put a Fix It task on the queue, the web front end performs the following steps:</span></span>

1. <span data-ttu-id="3e128-198">建立[CloudQueueClient](https://msdn.microsoft.com/library/microsoft.windowsazure.storage.queue.cloudqueueclient.aspx)實例。</span><span class="sxs-lookup"><span data-stu-id="3e128-198">Create a [CloudQueueClient](https://msdn.microsoft.com/library/microsoft.windowsazure.storage.queue.cloudqueueclient.aspx) instance.</span></span> <span data-ttu-id="3e128-199">`CloudQueueClient` 實例是用來對佇列服務執行要求。</span><span class="sxs-lookup"><span data-stu-id="3e128-199">The `CloudQueueClient` instance is used to execute requests against the Queue Service.</span></span>
2. <span data-ttu-id="3e128-200">建立佇列（如果尚不存在）。</span><span class="sxs-lookup"><span data-stu-id="3e128-200">Create the queue, if it doesn't exist yet.</span></span>
3. <span data-ttu-id="3e128-201">序列化 Fix It 工作。</span><span class="sxs-lookup"><span data-stu-id="3e128-201">Serialize the Fix It task.</span></span>
4. <span data-ttu-id="3e128-202">呼叫[CloudQueue. AddMessageAsync](https://msdn.microsoft.com/library/microsoft.windowsazure.storage.queue.cloudqueue.addmessageasync.aspx) ，將訊息放入佇列。</span><span class="sxs-lookup"><span data-stu-id="3e128-202">Call [CloudQueue.AddMessageAsync](https://msdn.microsoft.com/library/microsoft.windowsazure.storage.queue.cloudqueue.addmessageasync.aspx) to put the message onto the queue.</span></span>

<span data-ttu-id="3e128-203">我們將在新 `FixItQueueManager` 類別的函式和 `SendMessageAsync` 方法中執行這項工作。</span><span class="sxs-lookup"><span data-stu-id="3e128-203">We'll do this work in the constructor and `SendMessageAsync` method of a new `FixItQueueManager` class.</span></span>

[!code-csharp[Main](queue-centric-work-pattern/samples/sample1.cs?highlight=11-12,16,18-25)]

<span data-ttu-id="3e128-204">在這裡，我們會使用[Json.NET](https://github.com/JamesNK/Newtonsoft.Json)程式庫，將 fixit 序列化為 Json 格式。</span><span class="sxs-lookup"><span data-stu-id="3e128-204">Here we are using the [Json.NET](https://github.com/JamesNK/Newtonsoft.Json) library to serialize the fixit to JSON format.</span></span> <span data-ttu-id="3e128-205">您可以使用您偏好的任何序列化方法。</span><span class="sxs-lookup"><span data-stu-id="3e128-205">You can use whatever serialization approach you prefer.</span></span> <span data-ttu-id="3e128-206">JSON 的優點是人們可讀取，而比 XML 較不詳細。</span><span class="sxs-lookup"><span data-stu-id="3e128-206">JSON has the advantage of being human-readable, while being less verbose than XML.</span></span>

<span data-ttu-id="3e128-207">生產品質的程式碼會新增錯誤處理邏輯、在資料庫變得無法使用時暫停、更明確地處理復原、在應用程式啟動時建立佇列，以及管理「[有害」訊息](https://msdn.microsoft.com/library/ms789028(v=vs.110).aspx)。</span><span class="sxs-lookup"><span data-stu-id="3e128-207">Production-quality code would add error handling logic, pause if the database became unavailable, handle recovery more cleanly, create the queue on application start-up, and manage "[poison" messages](https://msdn.microsoft.com/library/ms789028(v=vs.110).aspx).</span></span> <span data-ttu-id="3e128-208">（有害訊息是因為某些原因而無法處理的訊息。</span><span class="sxs-lookup"><span data-stu-id="3e128-208">(A poison message is a message that cannot be processed for some reason.</span></span> <span data-ttu-id="3e128-209">您不希望有害訊息位於佇列中，背景工作角色會持續嘗試處理、失敗、再試一次、失敗等等）。</span><span class="sxs-lookup"><span data-stu-id="3e128-209">You don't want poison messages to sit in the queue, where the worker role will continually try to process them, fail, try again, fail, and so on.)</span></span>

<span data-ttu-id="3e128-210">在前端 MVC 應用程式中，我們需要更新建立新工作的程式碼。</span><span class="sxs-lookup"><span data-stu-id="3e128-210">In the front-end MVC application, we need to update the code that creates a new task.</span></span> <span data-ttu-id="3e128-211">請不要將工作放入存放庫中，而是呼叫如上所示的 `SendMessageAsync` 方法。</span><span class="sxs-lookup"><span data-stu-id="3e128-211">Instead of putting the task into the repository, call the `SendMessageAsync` method shown above.</span></span>

[!code-csharp[Main](queue-centric-work-pattern/samples/sample2.cs?highlight=10)]

## <a name="processing-queue-messages"></a><span data-ttu-id="3e128-212">處理佇列訊息</span><span class="sxs-lookup"><span data-stu-id="3e128-212">Processing Queue Messages</span></span>

<span data-ttu-id="3e128-213">為了處理佇列中的訊息，我們將建立後端服務。</span><span class="sxs-lookup"><span data-stu-id="3e128-213">To process messages in the queue, we'll create a backend service.</span></span> <span data-ttu-id="3e128-214">後端服務將會執行無限迴圈，以執行下列步驟：</span><span class="sxs-lookup"><span data-stu-id="3e128-214">The backend service will run an infinite loop that performs the following steps:</span></span>

1. <span data-ttu-id="3e128-215">取得佇列中的下一個訊息。</span><span class="sxs-lookup"><span data-stu-id="3e128-215">Get the next message from the queue.</span></span>
2. <span data-ttu-id="3e128-216">將訊息還原序列化為 Fix It 工作。</span><span class="sxs-lookup"><span data-stu-id="3e128-216">Deserialize the message to a Fix It task.</span></span>
3. <span data-ttu-id="3e128-217">將 [修正 It] 工作寫入資料庫。</span><span class="sxs-lookup"><span data-stu-id="3e128-217">Write the Fix It task to the database.</span></span>

<span data-ttu-id="3e128-218">為了裝載後端服務，我們將建立包含背景*工作角色*的 Azure 雲端服務。</span><span class="sxs-lookup"><span data-stu-id="3e128-218">To host the backend service, we'll create an Azure Cloud Service that contains a *worker role*.</span></span> <span data-ttu-id="3e128-219">背景工作角色是由一或多個可執行後端處理的 Vm 所組成。</span><span class="sxs-lookup"><span data-stu-id="3e128-219">A worker role consists of one or more VMs that can do backend processing.</span></span> <span data-ttu-id="3e128-220">在這些 Vm 中執行的程式碼會在佇列可供使用時，從佇列中提取訊息。</span><span class="sxs-lookup"><span data-stu-id="3e128-220">The code that runs in these VMs will pull messages from the queue as they become available.</span></span> <span data-ttu-id="3e128-221">針對每個訊息，我們會將 JSON 承載還原序列化，並使用我們稍早在 web 層中使用的相同存放庫，將 Fix It 工作實體的實例寫入資料庫。</span><span class="sxs-lookup"><span data-stu-id="3e128-221">For each message, we'll deserialize the JSON payload and write an instance of the Fix It Task entity to the database, using the same repository that we used earlier in the web tier.</span></span>

<span data-ttu-id="3e128-222">下列步驟示範如何將背景工作角色專案新增至具有標準 Web 專案的方案。</span><span class="sxs-lookup"><span data-stu-id="3e128-222">The following steps show how to add a worker role project to a solution that has a standard web project.</span></span> <span data-ttu-id="3e128-223">這些步驟已在您可以下載的修正 It 專案中完成。</span><span class="sxs-lookup"><span data-stu-id="3e128-223">These steps have already been done in the Fix It project that you can download.</span></span>

<span data-ttu-id="3e128-224">首先，將雲端服務專案新增至 Visual Studio 解決方案。</span><span class="sxs-lookup"><span data-stu-id="3e128-224">First add a Cloud Service project to the Visual Studio solution.</span></span> <span data-ttu-id="3e128-225">以滑鼠右鍵按一下方案，然後依序選取 [**加入**] 和 [**新增專案**]。</span><span class="sxs-lookup"><span data-stu-id="3e128-225">Right-click the solution and select **Add**, then **New Project**.</span></span> <span data-ttu-id="3e128-226">在左窗格中，展開 **[ C#視覺效果**]，然後選取 [**雲端**]。</span><span class="sxs-lookup"><span data-stu-id="3e128-226">In the left pane, expand **Visual C#** and select **Cloud**.</span></span>

[![](queue-centric-work-pattern/_static/image5.png)](queue-centric-work-pattern/_static/image4.png)

<span data-ttu-id="3e128-227">在 [**新增 Azure 雲端服務**] 對話方塊中，展開左窗格上的 [**視覺效果C#**  ] 節點。</span><span class="sxs-lookup"><span data-stu-id="3e128-227">In the **New Azure Cloud Service** dialog, expand the **Visual C#** node on the left pane.</span></span> <span data-ttu-id="3e128-228">選取 [背景**工作角色**]，然後按一下向右箭號圖示。</span><span class="sxs-lookup"><span data-stu-id="3e128-228">Select **Worker Role** and click the right-arrow icon.</span></span>

![](queue-centric-work-pattern/_static/image6.png)

<span data-ttu-id="3e128-229">（請注意，您也可以新增*web 角色*。</span><span class="sxs-lookup"><span data-stu-id="3e128-229">(Notice that you can also add a *web role*.</span></span> <span data-ttu-id="3e128-230">我們可以在同一個雲端服務中的前端進行修正，而不是在 Azure 網站中執行。</span><span class="sxs-lookup"><span data-stu-id="3e128-230">We could run the Fix It front-end in the same Cloud Service instead of running it in an Azure Web Site.</span></span> <span data-ttu-id="3e128-231">這對於在前端和後端之間進行連線的優勢更容易協調。</span><span class="sxs-lookup"><span data-stu-id="3e128-231">That has some advantages in making connections between front-end and back-end easier to coordinate.</span></span> <span data-ttu-id="3e128-232">不過，為了簡化此示範，我們會將前端保留在 Azure App Service Web 應用程式中，並只在雲端服務中執行後端。）</span><span class="sxs-lookup"><span data-stu-id="3e128-232">However, to keep this demo simple, we're keeping the front-end in an Azure App Service Web App and only running the back-end in a Cloud Service.)</span></span>

<span data-ttu-id="3e128-233">預設名稱會指派給背景工作角色。</span><span class="sxs-lookup"><span data-stu-id="3e128-233">A default name is assigned to the worker role.</span></span> <span data-ttu-id="3e128-234">若要變更名稱，請將滑鼠游標移至右窗格中的背景工作角色上方，然後按一下鉛筆圖示。</span><span class="sxs-lookup"><span data-stu-id="3e128-234">To change the name, hover the mouse over the worker role in the right pane, then click the pencil icon.</span></span>

![](queue-centric-work-pattern/_static/image7.png)

<span data-ttu-id="3e128-235">按一下 **[確定**] 以完成對話方塊。</span><span class="sxs-lookup"><span data-stu-id="3e128-235">Click **OK** to complete the dialog.</span></span> <span data-ttu-id="3e128-236">這會將兩個專案新增至 Visual Studio 解決方案。</span><span class="sxs-lookup"><span data-stu-id="3e128-236">This adds two projects to the Visual Studio solution.</span></span>

- <span data-ttu-id="3e128-237">定義雲端服務的 Azure 專案，包括設定資訊。</span><span class="sxs-lookup"><span data-stu-id="3e128-237">an Azure project that defines the cloud service, including configuration information.</span></span>
- <span data-ttu-id="3e128-238">定義背景工作角色的背景工作角色專案。</span><span class="sxs-lookup"><span data-stu-id="3e128-238">A worker role project that defines the worker role.</span></span>

![](queue-centric-work-pattern/_static/image8.png)

<span data-ttu-id="3e128-239">如需詳細資訊，請參閱[使用 Visual Studio 建立 Azure 專案。](https://msdn.microsoft.com/library/windowsazure/ee405487.aspx)</span><span class="sxs-lookup"><span data-stu-id="3e128-239">For more information, see [Creating an Azure Project with Visual Studio.](https://msdn.microsoft.com/library/windowsazure/ee405487.aspx)</span></span>

<span data-ttu-id="3e128-240">在背景工作角色中，我們會藉由呼叫我們稍早所見 `FixItQueueManager` 類別的 `ProcessMessageAsync` 方法來輪詢訊息。</span><span class="sxs-lookup"><span data-stu-id="3e128-240">Inside the worker role, we poll for messages by calling the `ProcessMessageAsync` method of the `FixItQueueManager` class that we saw earlier.</span></span>

[!code-csharp[Main](queue-centric-work-pattern/samples/sample3.cs?highlight=25)]

<span data-ttu-id="3e128-241">`ProcessMessagesAsync` 方法會檢查是否有訊息正在等待。</span><span class="sxs-lookup"><span data-stu-id="3e128-241">The `ProcessMessagesAsync` method checks if there's a message waiting.</span></span> <span data-ttu-id="3e128-242">如果有的話，它會將訊息還原序列化為 `FixItTask` 的實體，並將實體儲存在資料庫中。</span><span class="sxs-lookup"><span data-stu-id="3e128-242">If there is one, it deserializes the message into a `FixItTask` entity and saves the entity in the database.</span></span> <span data-ttu-id="3e128-243">它會迴圈，直到佇列是空的為止。</span><span class="sxs-lookup"><span data-stu-id="3e128-243">It loops until the queue is empty.</span></span>

[!code-csharp[Main](queue-centric-work-pattern/samples/sample4.cs)]

<span data-ttu-id="3e128-244">輪詢佇列訊息會產生較小的交易費用，因此，當沒有訊息等候處理時，背景工作角色的 `RunAsync` 方法會等待一秒，再呼叫 `Task.Delay(1000)`再次輪詢。</span><span class="sxs-lookup"><span data-stu-id="3e128-244">Polling for queue messages incurs a small transaction charge, so when there's no message waiting to be processed, the worker role's `RunAsync` method waits a second before polling again by calling `Task.Delay(1000)`.</span></span>

<span data-ttu-id="3e128-245">在 Web 專案中，新增非同步程式碼可以自動改善效能，因為 IIS 會管理有限的執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="3e128-245">In a web project, adding asynchronous code can automatically improve performance because IIS manages a limited thread pool.</span></span> <span data-ttu-id="3e128-246">背景工作角色專案中不會發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="3e128-246">That is not the case in a worker role project.</span></span> <span data-ttu-id="3e128-247">若要改善背景工作角色的擴充性，您可以撰寫多執行緒程式碼，或使用非同步程式碼來執行[平行程式設計](https://msdn.microsoft.com/library/ff963553.aspx)。</span><span class="sxs-lookup"><span data-stu-id="3e128-247">To improve scalability of the worker role, you can write multi-threaded code or use asynchronous code to implement [parallel programming](https://msdn.microsoft.com/library/ff963553.aspx).</span></span> <span data-ttu-id="3e128-248">此範例不會執行平行程式設計，但會示範如何讓程式碼非同步，讓您可以執行平行程式設計。</span><span class="sxs-lookup"><span data-stu-id="3e128-248">The sample doesn't implement parallel programming but shows how to make the code asynchronous so you can implement parallel programming.</span></span>

## <a name="summary"></a><span data-ttu-id="3e128-249">總結</span><span class="sxs-lookup"><span data-stu-id="3e128-249">Summary</span></span>

<span data-ttu-id="3e128-250">在本章中，您已瞭解如何藉由執行以佇列為中心的工作模式來改善應用程式回應性、可靠性和擴充性。</span><span class="sxs-lookup"><span data-stu-id="3e128-250">In this chapter you've seen how to improve application responsiveness, reliability, and scalability by implementing the queue-centric work pattern.</span></span>

<span data-ttu-id="3e128-251">這是本電子書中涵蓋的13種模式的最後一項，但當然還有許多其他模式和作法可協助您建立成功的雲端應用程式。</span><span class="sxs-lookup"><span data-stu-id="3e128-251">This is the last of the 13 patterns covered in this e-book, but there are of course many other patterns and practices that can help you build successful cloud apps.</span></span> <span data-ttu-id="3e128-252">[最後一章](more-patterns-and-guidance.md)提供尚未在這13種模式中涵蓋之主題的資源連結。</span><span class="sxs-lookup"><span data-stu-id="3e128-252">The [final chapter](more-patterns-and-guidance.md) provides links to resources for topics that haven't been covered in these 13 patterns.</span></span>

<a id="resources"></a>
## <a name="resources"></a><span data-ttu-id="3e128-253">資源</span><span class="sxs-lookup"><span data-stu-id="3e128-253">Resources</span></span>

<span data-ttu-id="3e128-254">如需佇列的詳細資訊，請參閱下列資源。</span><span class="sxs-lookup"><span data-stu-id="3e128-254">For more information about queues, see the following resources.</span></span>

<span data-ttu-id="3e128-255">文件：</span><span class="sxs-lookup"><span data-stu-id="3e128-255">Documentation:</span></span>

- <span data-ttu-id="3e128-256">[Microsoft Azure 儲存體佇列第1部分：消費者入門](https://www.red-gate.com/simple-talk/cloud/platform-as-a-service/microsoft-azure-storage-queues-part-1-getting-started/)。</span><span class="sxs-lookup"><span data-stu-id="3e128-256">[Microsoft Azure Storage Queues Part 1: Getting Started](https://www.red-gate.com/simple-talk/cloud/platform-as-a-service/microsoft-azure-storage-queues-part-1-getting-started/).</span></span> <span data-ttu-id="3e128-257">依羅馬字 Schacherl 的文章。</span><span class="sxs-lookup"><span data-stu-id="3e128-257">Article by Roman Schacherl.</span></span>
- <span data-ttu-id="3e128-258">[執行背景](https://msdn.microsoft.com/library/ff803365.aspx)工作，從 Microsoft 的模式和實務[將應用程式移至雲端的第](https://msdn.microsoft.com/library/ff728592.aspx)5 章。</span><span class="sxs-lookup"><span data-stu-id="3e128-258">[Executing Background Tasks](https://msdn.microsoft.com/library/ff803365.aspx), chapter 5 of [Moving Applications to the Cloud, 3rd Edition](https://msdn.microsoft.com/library/ff728592.aspx) from Microsoft Patterns and Practices.</span></span> <span data-ttu-id="3e128-259">（尤其是「[使用 Azure 儲存體的佇列](https://msdn.microsoft.com/library/ff803365.aspx#sec7)」一節）。</span><span class="sxs-lookup"><span data-stu-id="3e128-259">(In particular, the section ["Using Azure Storage Queues"](https://msdn.microsoft.com/library/ff803365.aspx#sec7).)</span></span>
- <span data-ttu-id="3e128-260">[Azure 上以佇列為基礎的訊息解決方案最大化擴充性和成本效益的最佳作法](https://msdn.microsoft.com/library/windowsazure/hh697709.aspx)。</span><span class="sxs-lookup"><span data-stu-id="3e128-260">[Best Practices for Maximizing Scalability and Cost Effectiveness of Queue-Based Messaging Solutions on Azure](https://msdn.microsoft.com/library/windowsazure/hh697709.aspx).</span></span> <span data-ttu-id="3e128-261">白皮書： Valery Mizonov。</span><span class="sxs-lookup"><span data-stu-id="3e128-261">White paper by Valery Mizonov.</span></span>
- <span data-ttu-id="3e128-262">[比較 Azure 佇列和服務匯流排佇列](https://msdn.microsoft.com/magazine/jj159884.aspx)。</span><span class="sxs-lookup"><span data-stu-id="3e128-262">[Comparing Azure Queues and Service Bus Queues](https://msdn.microsoft.com/magazine/jj159884.aspx).</span></span> <span data-ttu-id="3e128-263">MSDN 雜誌文章提供其他資訊，可協助您選擇要使用的佇列服務。</span><span class="sxs-lookup"><span data-stu-id="3e128-263">MSDN Magazine article, provides additional information that can help you choose which queue service to use.</span></span> <span data-ttu-id="3e128-264">本文提及服務匯流排相依于用於驗證的 ACS，這表示當 ACS 無法使用時，您的 SB 佇列將無法使用。</span><span class="sxs-lookup"><span data-stu-id="3e128-264">The article mentions that Service Bus is dependent on ACS for authentication, which means your SB queues would be unavailable when ACS is unavailable.</span></span> <span data-ttu-id="3e128-265">不過，由於文章已撰寫，因此 SB 已變更為可讓您使用[SAS 權杖](https://msdn.microsoft.com/library/windowsazure/dn170477.aspx)作為 ACS 的替代方案。</span><span class="sxs-lookup"><span data-stu-id="3e128-265">However, since the article was written, SB was changed to enable you to use [SAS tokens](https://msdn.microsoft.com/library/windowsazure/dn170477.aspx) as an alternative to ACS.</span></span>
- <span data-ttu-id="3e128-266">[Microsoft 模式和實務-Azure 指引](https://msdn.microsoft.com/library/dn568099.aspx)。</span><span class="sxs-lookup"><span data-stu-id="3e128-266">[Microsoft Patterns and Practices - Azure Guidance](https://msdn.microsoft.com/library/dn568099.aspx).</span></span> <span data-ttu-id="3e128-267">請參閱非同步訊息入門、管道和篩選模式、補償交易模式、競爭取用者模式、CQRS 模式。</span><span class="sxs-lookup"><span data-stu-id="3e128-267">See Asynchronous Messaging primer, Pipes and Filters pattern, Compensating Transaction pattern, Competing Consumers pattern, CQRS pattern.</span></span>
- <span data-ttu-id="3e128-268">[CQRS 旅程](https://msdn.microsoft.com/library/jj554200)。</span><span class="sxs-lookup"><span data-stu-id="3e128-268">[CQRS Journey](https://msdn.microsoft.com/library/jj554200).</span></span> <span data-ttu-id="3e128-269">電子書，依據 Microsoft 的模式與實務來介紹 CQRS。</span><span class="sxs-lookup"><span data-stu-id="3e128-269">E-book about CQRS by Microsoft Patterns and Practices.</span></span>

<span data-ttu-id="3e128-270">影片：</span><span class="sxs-lookup"><span data-stu-id="3e128-270">Video:</span></span>

- <span data-ttu-id="3e128-271">[防安全功能：建立可擴充、可復原的雲端服務](https://channel9.msdn.com/Series/FailSafe)。</span><span class="sxs-lookup"><span data-stu-id="3e128-271">[FailSafe: Building Scalable, Resilient Cloud Services](https://channel9.msdn.com/Series/FailSafe).</span></span> <span data-ttu-id="3e128-272">Ulrich Homann、Marc Mercuri 和 Mark Simm 的九個部分影片系列。</span><span class="sxs-lookup"><span data-stu-id="3e128-272">Nine-part video series by Ulrich Homann, Marc Mercuri, and Mark Simms.</span></span> <span data-ttu-id="3e128-273">以非常容易存取且有趣的方式呈現高階概念和架構原則，並提供 Microsoft 客戶諮詢小組（CAT）體驗與實際客戶的故事。</span><span class="sxs-lookup"><span data-stu-id="3e128-273">Presents high-level concepts and architectural principles in a very accessible and interesting way, with stories drawn from Microsoft Customer Advisory Team (CAT) experience with actual customers.</span></span> <span data-ttu-id="3e128-274">如需 Azure 儲存體服務和佇列的簡介，請參閱第5集，從35:13 開始。</span><span class="sxs-lookup"><span data-stu-id="3e128-274">For an introduction to the Azure Storage service and queues, see episode 5 starting at 35:13.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="3e128-275">[上一頁](distributed-caching.md)
> [下一頁](more-patterns-and-guidance.md)</span><span class="sxs-lookup"><span data-stu-id="3e128-275">[Previous](distributed-caching.md)
[Next](more-patterns-and-guidance.md)</span></span>
