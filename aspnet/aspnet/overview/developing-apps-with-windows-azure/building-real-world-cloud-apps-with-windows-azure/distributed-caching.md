---
uid: aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/distributed-caching
title: 分散式緩存(使用 Azure 構建真實世界雲應用) |微軟文件
author: MikeWasson
description: 使用 Azure 電子書建構真實世界雲端應用基於 Scott Guthrie 開發的演示文稿。 它解釋了13種模式和做法,他可以...
ms.author: riande
ms.date: 07/20/2015
ms.assetid: 406518e9-3817-49ce-8b90-e82bc461e2c0
msc.legacyurl: /aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/distributed-caching
msc.type: authoredcontent
ms.openlocfilehash: 87a7516415895e761d1589fd459b93e5c15c0f85
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/06/2020
ms.locfileid: "80676017"
---
# <a name="distributed-caching-building-real-world-cloud-apps-with-azure"></a><span data-ttu-id="41bd0-104">分散式緩存(使用 Azure 建構真實世界雲應用)</span><span class="sxs-lookup"><span data-stu-id="41bd0-104">Distributed Caching (Building Real-World Cloud Apps with Azure)</span></span>

<span data-ttu-id="41bd0-105">由[邁克·瓦森](https://github.com/MikeWasson),[里克·安德森](https://twitter.com/RickAndMSFT),[湯姆·戴克斯特拉](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="41bd0-105">by [Mike Wasson](https://github.com/MikeWasson), [Rick Anderson](https://twitter.com/RickAndMSFT), [Tom Dykstra](https://github.com/tdykstra)</span></span>

<span data-ttu-id="41bd0-106">[下載修復項目](https://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4)或[下載電子書](https://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)</span><span class="sxs-lookup"><span data-stu-id="41bd0-106">[Download Fix It Project](https://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4) or [Download E-book](https://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)</span></span>

> <span data-ttu-id="41bd0-107">使用 Azure 電子書**建構真實世界雲端應用**基於 Scott Guthrie 開發的演示文稿。</span><span class="sxs-lookup"><span data-stu-id="41bd0-107">The **Building Real World Cloud Apps with Azure** e-book is based on a presentation developed by Scott Guthrie.</span></span> <span data-ttu-id="41bd0-108">它解釋了 13 種模式和做法,這些模式和做法可以説明您成功開發雲端的 Web 應用。</span><span class="sxs-lookup"><span data-stu-id="41bd0-108">It explains 13 patterns and practices that can help you be successful developing web apps for the cloud.</span></span> <span data-ttu-id="41bd0-109">有關電子書的資訊,請參閱[第一章](introduction.md)。</span><span class="sxs-lookup"><span data-stu-id="41bd0-109">For information about the e-book, see [the first chapter](introduction.md).</span></span>

<span data-ttu-id="41bd0-110">上一章研究了瞬態故障處理,並提到緩存作為斷路器策略。</span><span class="sxs-lookup"><span data-stu-id="41bd0-110">The previous chapter looked at transient fault handling and mentioned caching as a circuit breaker strategy.</span></span> <span data-ttu-id="41bd0-111">本章提供了有關緩存的更多背景,包括何時使用它、使用它的常見模式以及如何在 Azure 中實現緩存。</span><span class="sxs-lookup"><span data-stu-id="41bd0-111">This chapter gives more background about caching, including when to use it, common patterns for using it, and how to implement it in Azure.</span></span>

## <a name="what-is-distributed-caching"></a><span data-ttu-id="41bd0-112">什麼是分散式緩存</span><span class="sxs-lookup"><span data-stu-id="41bd0-112">What is distributed caching</span></span>

<span data-ttu-id="41bd0-113">緩存通過將數據存儲在記憶體中,提供對通常訪問的應用程序數據的高輸送量、低延遲訪問。</span><span class="sxs-lookup"><span data-stu-id="41bd0-113">A cache provides high throughput, low-latency access to commonly accessed application data, by storing the data in memory.</span></span> <span data-ttu-id="41bd0-114">對於雲端應用,最有用的緩存類型是分散式緩存,這意味著數據不是存儲在單個 Web 伺服器的記憶體上,而是存儲在其他雲端資源上,緩存的數據可供應用程式的所有 Web 伺服器(或應用程式使用的其他雲端 VM)使用。</span><span class="sxs-lookup"><span data-stu-id="41bd0-114">For a cloud app the most useful type of cache is distributed cache, which means the data is not stored on the individual web server's memory but on other cloud resources, and the cached data is made available to all of an application's web servers (or other cloud VMs that are used by the application).</span></span>

![顯示存取同一快取伺服器的多個 Web 伺服器的圖表](distributed-caching/_static/image1.png)

<span data-ttu-id="41bd0-116">當應用程式通過添加或刪除伺服器進行擴展,或者當伺服器由於升級或故障而更換時,緩存的數據仍可供運行該應用程式的每個伺服器訪問。</span><span class="sxs-lookup"><span data-stu-id="41bd0-116">When the application scales by adding or removing servers, or when servers are replaced due to upgrades or faults, the cached data remains accessible to every server that runs the application.</span></span>

<span data-ttu-id="41bd0-117">通過避免持久數據存儲的高延遲數據訪問,緩存可以顯著提高應用程式的回應能力。</span><span class="sxs-lookup"><span data-stu-id="41bd0-117">By avoiding the high latency data access of a persistent data store, caching can dramatically improve application responsiveness.</span></span> <span data-ttu-id="41bd0-118">例如,從緩存檢索數據比從關係資料庫檢索數據要快得多。</span><span class="sxs-lookup"><span data-stu-id="41bd0-118">For example, retrieving data from cache is much faster than retrieving it from a relational database.</span></span>

<span data-ttu-id="41bd0-119">緩存的一個附帶好處是減少了持久數據存儲的流量,當持久數據存儲需要數據出口費用時,這可能會導致更低的成本。</span><span class="sxs-lookup"><span data-stu-id="41bd0-119">A side benefit of caching is reduced traffic to the persistent data store, which may result in lower costs when there are data egress charges for the persistent data store.</span></span>

## <a name="when-to-use-distributed-caching"></a><span data-ttu-id="41bd0-120">何時使用分散式快取</span><span class="sxs-lookup"><span data-stu-id="41bd0-120">When to use distributed caching</span></span>

<span data-ttu-id="41bd0-121">快取最適合使用比寫入資料更多的讀取工作負荷,以及當資料模型支援用於在快取中儲存和檢索資料的鍵/值組織時。</span><span class="sxs-lookup"><span data-stu-id="41bd0-121">Caching works best for application workloads that do more reading than writing of data, and when the data model supports the key/value organization that you use to store and retrieve data in cache.</span></span> <span data-ttu-id="41bd0-122">當應用程式使用者共用大量常見數據時,它也更有用;例如,如果每個使用者通常檢索該用戶獨有的數據,則緩存不會提供盡可能多的好處。</span><span class="sxs-lookup"><span data-stu-id="41bd0-122">It's also more useful when application users share a lot of common data; for example, cache would not provide as many benefits if each user typically retrieves data unique to that user.</span></span> <span data-ttu-id="41bd0-123">緩存可能非常有益的一個範例是產品目錄,因為資料不會頻繁更改,並且所有客戶都在查看相同的數據。</span><span class="sxs-lookup"><span data-stu-id="41bd0-123">An example where caching could be very beneficial is a product catalog, because the data does not change frequently, and all customers are looking at the same data.</span></span>

<span data-ttu-id="41bd0-124">緩存的好處越來越可衡量,應用程式越擴展,持久數據存儲的輸送量限制和延遲延遲就對整體應用程式性能造成更大的限制。</span><span class="sxs-lookup"><span data-stu-id="41bd0-124">The benefit of caching becomes increasingly measurable the more an application scales, as the throughput limits and latency delays of the persistent data store become more of a limit on overall application performance.</span></span> <span data-ttu-id="41bd0-125">但是,您可能出於其他原因實現緩存,而不是性能。</span><span class="sxs-lookup"><span data-stu-id="41bd0-125">However, you might implement caching for other reasons than performance as well.</span></span> <span data-ttu-id="41bd0-126">對於在向用戶顯示時不必完全最新的數據,緩存訪問可以作為斷路器,用於持久數據存儲無回應或不可用時的數據。</span><span class="sxs-lookup"><span data-stu-id="41bd0-126">For data that doesn't have to be perfectly up-to-date when shown to the user, cache access can serve as a circuit breaker for when the persistent data store is unresponsive or unavailable.</span></span>

## <a name="popular-cache-population-strategies"></a><span data-ttu-id="41bd0-127">流行的快取填充原則</span><span class="sxs-lookup"><span data-stu-id="41bd0-127">Popular cache population strategies</span></span>

<span data-ttu-id="41bd0-128">為了能夠從快取中檢索資料,您必須先將其儲存在該緩存中。</span><span class="sxs-lookup"><span data-stu-id="41bd0-128">In order to be able to retrieve data from cache, you have to store it there first.</span></span> <span data-ttu-id="41bd0-129">有幾種策略用於將資料放入快取中:</span><span class="sxs-lookup"><span data-stu-id="41bd0-129">There are several strategies for getting data that you need into a cache:</span></span>

- <span data-ttu-id="41bd0-130">按需/快取旁</span><span class="sxs-lookup"><span data-stu-id="41bd0-130">On Demand / Cache Aside</span></span>

    <span data-ttu-id="41bd0-131">應用程序嘗試從快取中檢索資料,當快取沒有資料("錯誤")時,應用程式將資料存儲在快取中,以便下次資料可用。</span><span class="sxs-lookup"><span data-stu-id="41bd0-131">The application tries to retrieve data from cache, and when the cache doesn't have the data (a "miss"), the application stores the data in the cache so that it will be available the next time.</span></span> <span data-ttu-id="41bd0-132">下次應用程序嘗試獲取相同的數據時,它會在緩存中找到它要查找的內容("命中")。</span><span class="sxs-lookup"><span data-stu-id="41bd0-132">The next time the application tries to get the same data, it finds what it's looking for in the cache (a "hit").</span></span> <span data-ttu-id="41bd0-133">為了防止獲取資料庫中已更改的緩存數據,在更改數據存儲時使緩存無效。</span><span class="sxs-lookup"><span data-stu-id="41bd0-133">To prevent fetching cached data that has changed on the database, you invalidate the cache when making changes to the data store.</span></span>
- <span data-ttu-id="41bd0-134">背景推送</span><span class="sxs-lookup"><span data-stu-id="41bd0-134">Background Data Push</span></span>

    <span data-ttu-id="41bd0-135">後台服務會定期將數據推送到緩存中,並且應用始終從緩存中拉出。</span><span class="sxs-lookup"><span data-stu-id="41bd0-135">Background services push data into the cache on a regular schedule, and the app always pulls from the cache.</span></span> <span data-ttu-id="41bd0-136">此方法非常適合不需要始終返回最新數據的高延遲數據源。</span><span class="sxs-lookup"><span data-stu-id="41bd0-136">This approach works great with high latency data sources that don't require you always return the latest data.</span></span>
- <span data-ttu-id="41bd0-137">斷路器</span><span class="sxs-lookup"><span data-stu-id="41bd0-137">Circuit Breaker</span></span>

    <span data-ttu-id="41bd0-138">應用程式通常直接與持久數據存儲通信,但當持久數據存儲存在可用性問題時,應用程式將從緩存中檢索數據。</span><span class="sxs-lookup"><span data-stu-id="41bd0-138">The application normally communicates directly with the persistent data store, but when the persistent data store has availability problems, the application retrieves data from cache.</span></span> <span data-ttu-id="41bd0-139">數據可能已使用緩存旁或後台數據推送策略放入緩存中。</span><span class="sxs-lookup"><span data-stu-id="41bd0-139">Data may have been put in cache using either the cache aside or background data push strategy.</span></span> <span data-ttu-id="41bd0-140">這是一種故障處理策略,而不是性能增強策略。</span><span class="sxs-lookup"><span data-stu-id="41bd0-140">This is a fault handling strategy rather than a performance enhancing strategy.</span></span>

<span data-ttu-id="41bd0-141">為了保持快取中的數據最新,可以在應用程式創建、更新或刪除資料時刪除相關的緩存條目。</span><span class="sxs-lookup"><span data-stu-id="41bd0-141">In order to keep data in the cache current, you can delete related cache entries when your application creates, updates, or deletes data.</span></span> <span data-ttu-id="41bd0-142">如果應用程式有時可以獲取稍微過時的數據,則可以依靠可配置的過期時間來設置緩存數據可能有多舊的限制。</span><span class="sxs-lookup"><span data-stu-id="41bd0-142">If it's alright for your application to sometimes get data that is slightly out-of-date, you can rely on a configurable expiration time to set a limit on how old cache data can be.</span></span>

<span data-ttu-id="41bd0-143">您可以設定絕對過期(自創建緩存項以來的時間量)或滑動過期(自上次存取緩存項以來的時間量)。</span><span class="sxs-lookup"><span data-stu-id="41bd0-143">You can configure absolute expiration (amount of time since the cache item was created) or sliding expiration (amount of time since the last time a cache item was accessed).</span></span> <span data-ttu-id="41bd0-144">當您依賴於緩存過期機制以防止數據變得過於陳舊時,將使用絕對過期。</span><span class="sxs-lookup"><span data-stu-id="41bd0-144">Absolute expiration is used when you are depending on the cache expiration mechanism to prevent the data from becoming too stale.</span></span> <span data-ttu-id="41bd0-145">在 Fix It 應用中,我們將手動驅逐陳舊的緩存項,我們將使用滑動過期來將最新的數據保存在緩存中。</span><span class="sxs-lookup"><span data-stu-id="41bd0-145">In the Fix It app, we'll manually evict stale cache items and we'll use sliding expiration to keep the most current data in cache.</span></span> <span data-ttu-id="41bd0-146">無論您選擇哪種過期策略,當達到緩存的記憶體限制時,緩存將自動驅逐最舊的(最近使用或 LRU)專案。</span><span class="sxs-lookup"><span data-stu-id="41bd0-146">Regardless of the expiration policy you choose, the cache will automatically evict the oldest (Least Recently Used or LRU) items when the cache's memory limit is reached.</span></span>

## <a name="sample-cache-aside-code-for-fix-it-app"></a><span data-ttu-id="41bd0-147">修復用應用程式的範例快取的程式碼</span><span class="sxs-lookup"><span data-stu-id="41bd0-147">Sample cache-aside code for Fix It app</span></span>

<span data-ttu-id="41bd0-148">在以下示例代碼中,在檢索修復 It 任務時,我們首先檢查緩存。</span><span class="sxs-lookup"><span data-stu-id="41bd0-148">In the following sample code, we check the cache first when retrieving a Fix It task.</span></span> <span data-ttu-id="41bd0-149">如果在緩存中找到任務,我們會返回它;如果任務在緩存中找到,則返回它。如果未找到,我們會從資料庫中獲取它並將其存儲在緩存中。</span><span class="sxs-lookup"><span data-stu-id="41bd0-149">If the task is found in cache, we return it; if not found, we get it from the database and store it in the cache.</span></span> <span data-ttu-id="41bd0-150">要向`FindTaskByIdAsync`方法添加緩存所做的更改將突出顯示。</span><span class="sxs-lookup"><span data-stu-id="41bd0-150">The changes you'd make to add caching to the `FindTaskByIdAsync` method are highlighted.</span></span>

[!code-csharp[Main](distributed-caching/samples/sample1.cs?highlight=5,9-11,13-15,19)]

<span data-ttu-id="41bd0-151">更新或刪除修復 It 工作時,必須使快取的任務無效(刪除)。</span><span class="sxs-lookup"><span data-stu-id="41bd0-151">When you update or delete a Fix It task, you have to invalidate (remove) the cached task.</span></span> <span data-ttu-id="41bd0-152">否則,將來嘗試讀取該任務將繼續從快取中獲取舊資料。</span><span class="sxs-lookup"><span data-stu-id="41bd0-152">Otherwise, future attempts to read that task will continue to get the old data from the cache.</span></span>

[!code-csharp[Main](distributed-caching/samples/sample2.cs?highlight=7)]

<span data-ttu-id="41bd0-153">這些示例說明了簡單的緩存代碼;緩存尚未在可下載的修復 It 專案中實現。</span><span class="sxs-lookup"><span data-stu-id="41bd0-153">These are samples to illustrate simple caching code; caching has not been implemented in the downloadable Fix It project.</span></span>

## <a name="azure-caching-services"></a><span data-ttu-id="41bd0-154">Azure 快取服務</span><span class="sxs-lookup"><span data-stu-id="41bd0-154">Azure caching services</span></span>

<span data-ttu-id="41bd0-155">Azure 提供以下快取服務[:Azure Redis 快取](https://msdn.microsoft.com/library/dn690523.aspx)與[Azure 託管快取](https://msdn.microsoft.com/library/dn386094.aspx)。</span><span class="sxs-lookup"><span data-stu-id="41bd0-155">Azure offers the following caching services: [Azure Redis Cache](https://msdn.microsoft.com/library/dn690523.aspx) and [Azure Managed Cache](https://msdn.microsoft.com/library/dn386094.aspx).</span></span> <span data-ttu-id="41bd0-156">Azure Redis 緩存基於流行的[開源 Redis 緩存](http://redis.io/),是大多數緩存方案的首選。</span><span class="sxs-lookup"><span data-stu-id="41bd0-156">Azure Redis cache is based on the popular [open source Redis Cache](http://redis.io/) and is the first choice for most caching scenarios.</span></span>

<a id="sessionstate"></a>
## <a name="aspnet-session-state-using-a-cache-provider"></a><span data-ttu-id="41bd0-157">使用快取提供者ASP.NET工作階段狀態</span><span class="sxs-lookup"><span data-stu-id="41bd0-157">ASP.NET session state using a cache provider</span></span>

<span data-ttu-id="41bd0-158">如 Web[開發最佳實踐章節](web-development-best-practices.md)所述,最佳做法是避免使用會話狀態。</span><span class="sxs-lookup"><span data-stu-id="41bd0-158">As mentioned in the [web development best practices chapter](web-development-best-practices.md), a best practice is to avoid using session state.</span></span> <span data-ttu-id="41bd0-159">如果應用程式需要會話狀態,則下一個最佳做法是避免預設記憶體中提供程式,因為這不會啟用橫向擴展(Web 伺服器的多個實例)。</span><span class="sxs-lookup"><span data-stu-id="41bd0-159">If your application requires session state, the next best practice is to avoid the default in-memory provider because that doesn't enable scale out (multiple instances of the web server).</span></span> <span data-ttu-id="41bd0-160">ASP.NET SQL Server 工作階段狀態提供程式使在多個 Web 伺服器上運行的網站能夠使用作業階段狀態,但與記憶體中提供程式相比,它會產生較高的延遲成本。</span><span class="sxs-lookup"><span data-stu-id="41bd0-160">The ASP.NET SQL Server session state provider enables a site that runs on multiple web servers to use session state, but it incurs a high latency cost compared to an in-memory provider.</span></span> <span data-ttu-id="41bd0-161">如果必須使用工作階段狀態,則最佳解決方案是使用快取提供者,例如[Azure 快取的作業階段狀態提供者](https://msdn.microsoft.com/library/windowsazure/gg185668.aspx)。</span><span class="sxs-lookup"><span data-stu-id="41bd0-161">The best solution if you have to use session state is to use a cache provider, such as the [Session State Provider for Azure Cache](https://msdn.microsoft.com/library/windowsazure/gg185668.aspx).</span></span>

## <a name="summary"></a><span data-ttu-id="41bd0-162">總結</span><span class="sxs-lookup"><span data-stu-id="41bd0-162">Summary</span></span>

<span data-ttu-id="41bd0-163">您已經看到 Fix It 應用如何實現緩存,以提高回應時間和可伸縮性,並使應用在資料庫不可用時繼續為讀取操作回應。</span><span class="sxs-lookup"><span data-stu-id="41bd0-163">You've seen how the Fix It app could implement caching in order to improve response time and scalability, and to enable the app to continue to be responsive for read operations when the database is unavailable.</span></span> <span data-ttu-id="41bd0-164">[在下一章](queue-centric-work-pattern.md)中,我們將介紹如何進一步提高可伸縮性,並使應用繼續對寫入操作進行回應。</span><span class="sxs-lookup"><span data-stu-id="41bd0-164">In the [next chapter](queue-centric-work-pattern.md) we'll show how to further improve scalability and make the app continue to be responsive for write operations.</span></span>

## <a name="resources"></a><span data-ttu-id="41bd0-165">資源</span><span class="sxs-lookup"><span data-stu-id="41bd0-165">Resources</span></span>

<span data-ttu-id="41bd0-166">有關緩存的詳細資訊,請參閱以下資源。</span><span class="sxs-lookup"><span data-stu-id="41bd0-166">For more information about caching, see the following resources.</span></span>

<span data-ttu-id="41bd0-167">文件</span><span class="sxs-lookup"><span data-stu-id="41bd0-167">Documentation</span></span>

- <span data-ttu-id="41bd0-168">[Azure 快取](https://msdn.microsoft.com/library/gg278356.aspx)。</span><span class="sxs-lookup"><span data-stu-id="41bd0-168">[Azure Cache](https://msdn.microsoft.com/library/gg278356.aspx).</span></span> <span data-ttu-id="41bd0-169">有關 Azure 快取的官方 MSDN 文檔。</span><span class="sxs-lookup"><span data-stu-id="41bd0-169">Official MSDN documentation on caching in Azure.</span></span>
- <span data-ttu-id="41bd0-170">[微軟模式與實作 - Azure 指南](https://msdn.microsoft.com/library/dn568099.aspx)。</span><span class="sxs-lookup"><span data-stu-id="41bd0-170">[Microsoft Patterns and Practices - Azure Guidance](https://msdn.microsoft.com/library/dn568099.aspx).</span></span> <span data-ttu-id="41bd0-171">請參閱緩存指南和緩存放置模式。</span><span class="sxs-lookup"><span data-stu-id="41bd0-171">See Caching guidance and Cache-Aside pattern.</span></span>
- <span data-ttu-id="41bd0-172">[容錯保護:彈性雲體系結構指南](https://msdn.microsoft.com/library/windowsazure/jj853352.aspx)。</span><span class="sxs-lookup"><span data-stu-id="41bd0-172">[Failsafe: Guidance for Resilient Cloud Architectures](https://msdn.microsoft.com/library/windowsazure/jj853352.aspx).</span></span> <span data-ttu-id="41bd0-173">馬克·默庫里、烏爾里希·霍曼和安德魯·湯希爾的白皮書。</span><span class="sxs-lookup"><span data-stu-id="41bd0-173">White paper by Marc Mercuri, Ulrich Homann, and Andrew Townhill.</span></span> <span data-ttu-id="41bd0-174">請參閱有關緩存的部分。</span><span class="sxs-lookup"><span data-stu-id="41bd0-174">See the section on Caching.</span></span>
- <span data-ttu-id="41bd0-175">[Azure 雲服務上大規模服務設計的最佳做法](https://msdn.microsoft.com/library/windowsazure/jj717232.aspx)。</span><span class="sxs-lookup"><span data-stu-id="41bd0-175">[Best Practices for the Design of Large-Scale Services on Azure Cloud Services](https://msdn.microsoft.com/library/windowsazure/jj717232.aspx).</span></span> <span data-ttu-id="41bd0-176">W.</span><span class="sxs-lookup"><span data-stu-id="41bd0-176">W.</span></span> <span data-ttu-id="41bd0-177">馬克·西姆斯和邁克爾·托馬斯的白皮書。</span><span class="sxs-lookup"><span data-stu-id="41bd0-177">White paper by Mark Simms and Michael Thomassy.</span></span> <span data-ttu-id="41bd0-178">請參閱有關分散式緩存的部分。</span><span class="sxs-lookup"><span data-stu-id="41bd0-178">See the section on distributed caching.</span></span>
- <span data-ttu-id="41bd0-179">[分散式緩存在可伸縮性路徑上](https://msdn.microsoft.com/magazine/dd942840.aspx)。</span><span class="sxs-lookup"><span data-stu-id="41bd0-179">[Distributed Caching On The Path To Scalability](https://msdn.microsoft.com/magazine/dd942840.aspx).</span></span> <span data-ttu-id="41bd0-180">一篇較老的(2009)MSDN雜誌文章,但一般對分散式緩存的清晰書面介紹;比故障安全和最佳實踐白皮書的緩存部分更深入。</span><span class="sxs-lookup"><span data-stu-id="41bd0-180">An older (2009) MSDN Magazine article, but a clearly written introduction to distributed caching in general; goes into more depth than the caching sections of the FailSafe and Best Practices white papers.</span></span>

<span data-ttu-id="41bd0-181">影片</span><span class="sxs-lookup"><span data-stu-id="41bd0-181">Videos</span></span>

- <span data-ttu-id="41bd0-182">[容解安全:建譯可擴充的、有彈性的雲端服務](https://channel9.msdn.com/Series/FailSafe)。</span><span class="sxs-lookup"><span data-stu-id="41bd0-182">[FailSafe: Building Scalable, Resilient Cloud Services](https://channel9.msdn.com/Series/FailSafe).</span></span> <span data-ttu-id="41bd0-183">由烏爾里希·霍曼、馬克·默庫里和馬克·西姆斯的九集系列。</span><span class="sxs-lookup"><span data-stu-id="41bd0-183">Nine-part series by Ulrich Homann, Marc Mercuri, and Mark Simms.</span></span> <span data-ttu-id="41bd0-184">提供如何構建雲應用的 400 級視圖。</span><span class="sxs-lookup"><span data-stu-id="41bd0-184">Presents a 400-level view of how to architect cloud apps.</span></span> <span data-ttu-id="41bd0-185">本系列主要探討理論和原因;有關更多如何使用的詳細資訊,請參閱馬克·西姆斯的"建築大"系列。</span><span class="sxs-lookup"><span data-stu-id="41bd0-185">This series focuses on theory and reasons why; for more how-to details, see the Building Big series by Mark Simms.</span></span> <span data-ttu-id="41bd0-186">請參閱第 3 集的緩存討論,從 1:24:14 開始。</span><span class="sxs-lookup"><span data-stu-id="41bd0-186">See the caching discussion in episode 3 starting at 1:24:14.</span></span>
- <span data-ttu-id="41bd0-187">[建構大:從 Azure 客戶那裡吸取的教訓 - 第 I 部分](https://channel9.msdn.com/Events/Build/2012/3-029)。西蒙·戴維斯討論從46:00開始的分散式緩存。</span><span class="sxs-lookup"><span data-stu-id="41bd0-187">[Building Big: Lessons learned from Azure customers - Part I](https://channel9.msdn.com/Events/Build/2012/3-029). Simon Davies discusses distributed caching starting at 46:00.</span></span> <span data-ttu-id="41bd0-188">類似於故障安全系列,但進入更多如何使用的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="41bd0-188">Similar to the Failsafe series but goes into more how-to details.</span></span> <span data-ttu-id="41bd0-189">該演示文稿於 2012 年 10 月 31 日提供,因此不包括 2013 年推出的 Azure 應用服務中的 Web 應用緩存服務。</span><span class="sxs-lookup"><span data-stu-id="41bd0-189">The presentation was given October 31, 2012, so it does not cover caching service of Web Apps in Azure App Service that was introduced in 2013.</span></span>

<span data-ttu-id="41bd0-190">程式碼範例</span><span class="sxs-lookup"><span data-stu-id="41bd0-190">Code sample</span></span>

- <span data-ttu-id="41bd0-191">[Azure 的雲服務基礎知識](https://code.msdn.microsoft.com/Cloud-Service-Fundamentals-4ca72649)。</span><span class="sxs-lookup"><span data-stu-id="41bd0-191">[Cloud Service Fundamentals in Azure](https://code.msdn.microsoft.com/Cloud-Service-Fundamentals-4ca72649).</span></span> <span data-ttu-id="41bd0-192">實現分散式緩存的範例應用程式。</span><span class="sxs-lookup"><span data-stu-id="41bd0-192">Sample application that implements distributed caching.</span></span> <span data-ttu-id="41bd0-193">請參閱隨附的博客文章[「雲服務基礎知識 + 緩存基礎知識](https://blogs.msdn.com/b/windowsazure/archive/2013/10/03/cloud-service-fundamentals-caching-basics.aspx)」 "。</span><span class="sxs-lookup"><span data-stu-id="41bd0-193">See the accompanying blog post [Cloud Service Fundamentals – Caching Basics](https://blogs.msdn.com/b/windowsazure/archive/2013/10/03/cloud-service-fundamentals-caching-basics.aspx).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="41bd0-194">[前一個](transient-fault-handling.md)
> [下一個](queue-centric-work-pattern.md)</span><span class="sxs-lookup"><span data-stu-id="41bd0-194">[Previous](transient-fault-handling.md)
[Next](queue-centric-work-pattern.md)</span></span>
