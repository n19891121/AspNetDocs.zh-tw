---
uid: aspnet/overview/owin-and-katana/an-overview-of-project-katana
title: 專案 Katana 的總覽 |Microsoft Docs
author: howarddierking
description: ASP.NET 架構已有超過十年的時間，而平臺已啟用無數網站和服務的開發。 作為 Web & 。
ms.author: riande
ms.date: 08/30/2013
ms.assetid: 0ee21741-c1bf-4025-a9b0-24580cae24bc
msc.legacyurl: /aspnet/overview/owin-and-katana/an-overview-of-project-katana
msc.type: authoredcontent
ms.openlocfilehash: 1f28db822930cdfd2ebf4cf9bb27d173f4aa4201
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/06/2020
ms.locfileid: "78617233"
---
# <a name="an-overview-of-project-katana"></a><span data-ttu-id="c5989-104">Katana 專案概觀</span><span class="sxs-lookup"><span data-stu-id="c5989-104">An Overview of Project Katana</span></span>

<span data-ttu-id="c5989-105">依[Howard Dierking](https://github.com/howarddierking)</span><span class="sxs-lookup"><span data-stu-id="c5989-105">by [Howard Dierking](https://github.com/howarddierking)</span></span>

> <span data-ttu-id="c5989-106">ASP.NET 架構已有超過十年的時間，而平臺已啟用無數網站和服務的開發。</span><span class="sxs-lookup"><span data-stu-id="c5989-106">The ASP.NET Framework has been around for over ten years, and the platform has enabled the development of countless Web sites and services.</span></span> <span data-ttu-id="c5989-107">隨著 Web 應用程式開發策略的演變，架構也能夠以 ASP.NET MVC 和 ASP.NET Web API 之類的技術來逐步發展。</span><span class="sxs-lookup"><span data-stu-id="c5989-107">As Web application development strategies have evolved, the framework has been able to evolve in step with technologies like ASP.NET MVC and ASP.NET Web API.</span></span> <span data-ttu-id="c5989-108">隨著 Web 應用程式開發進入雲端運算世界的下一個進化性步驟，project [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET)提供了基礎元件集來 ASP.NET 應用程式，讓它們具有彈性、可攜、輕量，並提供更好的效能，而另一種方式是讓 project [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) cloud 優化您的 ASP.NET 應用程式。</span><span class="sxs-lookup"><span data-stu-id="c5989-108">As Web application development takes its next evolutionary step into the world of cloud computing, project [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) provides the underlying set of components to ASP.NET applications, enabling them to be flexible, portable, lightweight, and provide better performance – put another way, project [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) cloud optimizes your ASP.NET applications.</span></span>

## <a name="why-katana--why-now"></a><span data-ttu-id="c5989-109">為什麼要 Katana –為什麼要這麼做？</span><span class="sxs-lookup"><span data-stu-id="c5989-109">Why Katana – Why Now?</span></span>

 <span data-ttu-id="c5989-110">無論是在討論開發人員架構或使用者產品，都必須瞭解建立產品的基礎動機，其中包括知道產品的建立物件。</span><span class="sxs-lookup"><span data-stu-id="c5989-110">Regardless whether one is discussing a developer framework or end-user product, it's important to understand the underlying motivations for creating the product – and part of that includes knowing who the product was created for.</span></span> <span data-ttu-id="c5989-111">ASP.NET 最初是以兩個客戶為考慮而建立的。</span><span class="sxs-lookup"><span data-stu-id="c5989-111">ASP.NET was originally created with two customers in mind.</span></span>   
  
<span data-ttu-id="c5989-112">**第一組客戶是傳統 ASP 開發人員。**</span><span class="sxs-lookup"><span data-stu-id="c5989-112">**The first group of customers was classic ASP developers.**</span></span> <span data-ttu-id="c5989-113">在此期間，ASP 是透過 interweaving 標記和伺服器端腳本來建立動態、資料驅動的網站和應用程式的其中一種主要技術。</span><span class="sxs-lookup"><span data-stu-id="c5989-113">At the time, ASP was one of the primary technologies for creating dynamic, data-driven Web sites and applications by interweaving markup and server-side script.</span></span> <span data-ttu-id="c5989-114">ASP 執行時間提供的伺服器端腳本具有一組物件，可將基礎 HTTP 通訊協定和 Web 服務器的核心層面抽象化，並提供存取其他服務，例如會話和應用程式狀態管理、快取等。雖然功能強大的傳統 ASP 應用程式在規模和複雜度的成長方面變得很困難。</span><span class="sxs-lookup"><span data-stu-id="c5989-114">The ASP runtime supplied server-side script with a set of objects that abstracted core aspects of the underlying HTTP protocol and Web server and provided access to additional services such session and application state management, cache, etc. While powerful, classic ASP applications became a challenge to manage as they grew in size and complexity.</span></span> <span data-ttu-id="c5989-115">這主要是因為在腳本環境中找不到結構，並結合了程式碼和標記交錯所產生的程式碼重複。</span><span class="sxs-lookup"><span data-stu-id="c5989-115">This was largely due to the lack of structure found in scripting environments coupled with the duplication of code resulting from the interleaving of code and markup.</span></span> <span data-ttu-id="c5989-116">為了充分運用傳統 ASP 的優勢，同時解決一些挑戰，ASP.NET 利用 .NET Framework 的物件導向語言所提供的程式碼組織，同時保留伺服器端程式設計模型傳統 ASP 開發人員已習慣地成長。</span><span class="sxs-lookup"><span data-stu-id="c5989-116">In order to capitalize on the strengths of classic ASP while addressing some of its challenges, ASP.NET took advantage of the code organization provided by the object-oriented languages of the .NET Framework while also preserving the server-side programming model to which classic ASP developers had grown accustomed.</span></span>

<span data-ttu-id="c5989-117">**ASP.NET 的第二個目標客戶群組是 Windows 商務應用程式開發人員。**</span><span class="sxs-lookup"><span data-stu-id="c5989-117">**The second group of target customers for ASP.NET was Windows business application developers.**</span></span> <span data-ttu-id="c5989-118">不同于傳統 ASP 開發人員，他們習慣撰寫 HTML 標籤和程式碼來產生更多 HTML 標籤，WinForms 的開發人員（如他們之前的 VB6 開發人員）習慣于設計階段經驗，其中包含畫布和一組豐富的使用者介面控制項。</span><span class="sxs-lookup"><span data-stu-id="c5989-118">Unlike classic ASP developers, who were accustomed to writing HTML markup and the code to generate more HTML markup, WinForms developers (like the VB6 developers before them) were accustomed to a design time experience that included a canvas and a rich set of user interface controls.</span></span> <span data-ttu-id="c5989-119">第一版的 ASP.NET （也稱為「Web form」）提供了類似的設計階段經驗，以及使用者介面元件的伺服器端事件模型，以及一組基礎結構功能（例如 ViewState）來建立順暢的開發人員體驗在用戶端和伺服器端程式設計之間。</span><span class="sxs-lookup"><span data-stu-id="c5989-119">The first version of ASP.NET – also known as "Web Forms" provided a similar design time experience along with a server-side event model for user interface components and a set of infrastructure features (such as ViewState) to create a seamless developer experience between client and server side programming.</span></span> <span data-ttu-id="c5989-120">Web form 在 WinForms 開發人員熟悉的具狀態事件模型底下，有效地隱藏 Web 的無狀態性質。</span><span class="sxs-lookup"><span data-stu-id="c5989-120">Web Forms effectively hid the Web's stateless nature under a stateful event model that was familiar to WinForms developers.</span></span>

### <a name="challenges-raised-by-the-historical-model"></a><span data-ttu-id="c5989-121">歷程記錄模型所引發的挑戰</span><span class="sxs-lookup"><span data-stu-id="c5989-121">Challenges Raised by the Historical Model</span></span>

<span data-ttu-id="c5989-122">**最終結果是一個成熟、功能豐富的執行時間和開發人員程式設計模型。**</span><span class="sxs-lookup"><span data-stu-id="c5989-122">**The net result was a mature, feature-rich runtime and developer programming model.**</span></span> <span data-ttu-id="c5989-123">不過，有了這項功能，豐富的挑戰就是幾個值得注意的問題。</span><span class="sxs-lookup"><span data-stu-id="c5989-123">However, with that feature-richness came a couple notable challenges.</span></span> <span data-ttu-id="c5989-124">首先 **，架構是整合**式的，在同一個 system.web .dll 元件（例如，使用 Web form 架構的核心 HTTP 物件）中，具有邏輯上不同的功能單位會緊密結合。</span><span class="sxs-lookup"><span data-stu-id="c5989-124">Firstly, the framework was **monolithic**, with logically disparate units of functionality being tightly coupled in the same System.Web.dll assembly (for example, the core HTTP objects with the Web forms framework).</span></span> <span data-ttu-id="c5989-125">其次，ASP.NET 已包含在較大的 .NET Framework 中，這表示**發行之間的時間是以年**為單位。</span><span class="sxs-lookup"><span data-stu-id="c5989-125">Secondly, ASP.NET was included as a part of the larger .NET Framework, which meant that the **time between releases was on the order of years.**</span></span> <span data-ttu-id="c5989-126">這使得 ASP.NET 變得很容易，讓您在快速進化的 Web 程式開發過程中進行所有變更。</span><span class="sxs-lookup"><span data-stu-id="c5989-126">This made it difficult for ASP.NET to keep pace with all of the changes happening in rapidly evolving Web development.</span></span> <span data-ttu-id="c5989-127">最後，system.web 本身是以幾種不同的方式結合特定的 Web 裝載選項： Internet Information Services （IIS）。</span><span class="sxs-lookup"><span data-stu-id="c5989-127">Finally, System.Web.dll itself was coupled in a few different ways to a specific Web hosting option: Internet Information Services (IIS).</span></span>

### <a name="evolutionary-steps-aspnet-mvc-and-aspnet-web-api"></a><span data-ttu-id="c5989-128">進化步驟： ASP.NET MVC 和 ASP.NET Web API</span><span class="sxs-lookup"><span data-stu-id="c5989-128">Evolutionary steps: ASP.NET MVC and ASP.NET Web API</span></span>

<span data-ttu-id="c5989-129">網頁程式開發中發生了許多變更！</span><span class="sxs-lookup"><span data-stu-id="c5989-129">And lots of change was happening in Web development!</span></span> <span data-ttu-id="c5989-130">Web 應用程式逐漸開發成一系列的小型、重點元件，而不是大型架構。</span><span class="sxs-lookup"><span data-stu-id="c5989-130">Web applications were increasingly being developed as a series of small, focused components rather than large frameworks.</span></span> <span data-ttu-id="c5989-131">元件的數目以及其發行的頻率會以前所未有的速度增加。</span><span class="sxs-lookup"><span data-stu-id="c5989-131">The number of components as well as the frequency with which they were released was increasing at an ever faster rate.</span></span> <span data-ttu-id="c5989-132">很明顯地，保持 Web 步調會要求架構變得更小、分離且更具焦點，而不是較大且功能更豐富，因此**ASP.NET 團隊採取幾個進化的步驟，讓 ASP.NET 成為一系列的可插入 Web 元件，而不是單一架構**。</span><span class="sxs-lookup"><span data-stu-id="c5989-132">It was clear that keeping pace with the Web would require frameworks to get smaller, decoupled and more focused rather than larger and more feature-rich, therefore the **ASP.NET team took several evolutionary steps to enable ASP.NET as a family of pluggable Web components rather than a single framework**.</span></span>

<span data-ttu-id="c5989-133">其中一項早期的變更是眾所周知的模型視圖控制器（MVC）設計模式的普及度，因為這類 Web 開發架構（例如 Ruby on Rails）。</span><span class="sxs-lookup"><span data-stu-id="c5989-133">One of the early changes was the rise in popularity of the well-known model-view-controller (MVC) design pattern thanks to Web development frameworks like Ruby on Rails.</span></span> <span data-ttu-id="c5989-134">這種建立 Web 應用程式的風格讓開發人員可以更充分掌控應用程式的標記，同時仍然保有標記和商務邏輯的分隔，這是 ASP.NET 的初始銷售要點之一。</span><span class="sxs-lookup"><span data-stu-id="c5989-134">This style of building Web applications gave the developer greater control over her application's markup while still preserving the separation of markup and business logic, which was one of the initial selling points for ASP.NET.</span></span> <span data-ttu-id="c5989-135">為了滿足這種 Web 應用程式開發風格的需求，Microsoft 藉由**開發超出範圍的 ASP.NET MVC** （而不是在 .NET Framework 中），使其更適合未來的位置。</span><span class="sxs-lookup"><span data-stu-id="c5989-135">To meet the demand for this style of Web application development, Microsoft took the opportunity to position itself better for the future by **developing ASP.NET MVC out of band** (and not including it in the .NET Framework).</span></span> <span data-ttu-id="c5989-136">ASP.NET MVC 已發行為獨立下載。</span><span class="sxs-lookup"><span data-stu-id="c5989-136">ASP.NET MVC was released as an independent download.</span></span> <span data-ttu-id="c5989-137">如此一來，工程團隊就能彈性比以往更常提供更新。</span><span class="sxs-lookup"><span data-stu-id="c5989-137">This gave the engineering team the flexibility to deliver updates much more frequently than had been previously possible.</span></span>

<span data-ttu-id="c5989-138">Web 應用程式開發的另一項主要轉變，是將動態、伺服器產生的網頁轉換成靜態初始標記，並從用戶端腳本產生的頁面動態區段，**透過 AJAX 要求與後端 Web api**進行通訊。</span><span class="sxs-lookup"><span data-stu-id="c5989-138">Another major shift in Web application development was the shift from dynamic, server-generated Web pages to static initial markup with dynamic sections of the page generated from client-side script communicating **with backend Web APIs through AJAX requests**.</span></span> <span data-ttu-id="c5989-139">此架構轉移有助於前所未見 Web Api 的增加，以及開發 ASP.NET Web API 架構。</span><span class="sxs-lookup"><span data-stu-id="c5989-139">This architectural shift helped propel the rise of Web APIs, and the development of the ASP.NET Web API framework.</span></span> <span data-ttu-id="c5989-140">就像 ASP.NET MVC 一樣，ASP.NET Web API 的版本提供了另一種將 ASP.NET 發展成更模組化架構的機會。</span><span class="sxs-lookup"><span data-stu-id="c5989-140">As in the case of ASP.NET MVC, the release of ASP.NET Web API provided another opportunity to evolve ASP.NET further as a more modular framework.</span></span> <span data-ttu-id="c5989-141">工程小組利用商機和內**建 ASP.NET Web API，讓它不會相依于在 system.web .dll 中找到的任何核心架構類型**。</span><span class="sxs-lookup"><span data-stu-id="c5989-141">The engineering team took advantage of the opportunity and **built ASP.NET Web API such that it had no dependencies on any of the core framework types found in System.Web.dll**.</span></span> <span data-ttu-id="c5989-142">這項功能已啟用兩個動作：首先，這表示 ASP.NET Web API 可以完全獨立的方式進行發展（而且它可以繼續快速地反復執行，因為它是透過 NuGet 傳遞）。</span><span class="sxs-lookup"><span data-stu-id="c5989-142">This enabled two things: first, it meant that ASP.NET Web API could evolve in a completely self-contained manner (and it could continue to iterate quickly because it is delivered via NuGet).</span></span> <span data-ttu-id="c5989-143">第二，由於沒有對 System.web 的外部相依性，因此不會相依于 IIS，ASP.NET Web API 包含在自訂主機（例如主控台應用程式、Windows 服務等）中執行的功能。</span><span class="sxs-lookup"><span data-stu-id="c5989-143">Second, because there were no external dependencies to System.Web.dll, and therefore, no dependencies to IIS, ASP.NET Web API included the capability to run in a custom host (for example, a console application, Windows service, etc.)</span></span>

### <a name="the-future-a-nimble-framework"></a><span data-ttu-id="c5989-144">未來：敏捷架構</span><span class="sxs-lookup"><span data-stu-id="c5989-144">The Future: A Nimble Framework</span></span>

<span data-ttu-id="c5989-145">藉由將架構元件彼此分離，然後在 NuGet 上釋放它們，framework 現在可以**更獨立且更快速地反復**執行。</span><span class="sxs-lookup"><span data-stu-id="c5989-145">By decoupling framework components from one another and then releasing them on NuGet, frameworks could now **iterate more independently and more quickly**.</span></span> <span data-ttu-id="c5989-146">此外，Web API 自我裝載功能的威力和彈性對於想要**小型、輕量主機**來提供服務的開發人員而言，非常吸引人。</span><span class="sxs-lookup"><span data-stu-id="c5989-146">Additionally, the power and flexibility of Web API's self-hosting capability proved very attractive to developers who wanted a **small, lightweight host** for their services.</span></span> <span data-ttu-id="c5989-147">它證明了，其他架構也會想要這項功能，而這也是一項新的挑戰，因為每個架構都是在自己的基底位址上，在自己的主機進程中執行，而且需要獨立管理（啟動、停止等）。</span><span class="sxs-lookup"><span data-stu-id="c5989-147">It proved so attractive, in fact, that other frameworks also wanted this capability, and this surfaced a new challenge in that each framework ran in its own host process on its own base address and needed to be managed (started, stopped, etc.) independently.</span></span> <span data-ttu-id="c5989-148">新式 Web 應用程式通常支援靜態檔案服務、動態頁面產生、Web API，以及更新的即時/推播通知。</span><span class="sxs-lookup"><span data-stu-id="c5989-148">A modern Web application generally supports static file serving, dynamic page generation, Web API, and more recently real-time/push notifications.</span></span> <span data-ttu-id="c5989-149">預期每個服務都應該單獨執行和管理，其實並不切合實際。</span><span class="sxs-lookup"><span data-stu-id="c5989-149">Expecting that each of these services should be run and managed independently was simply not realistic.</span></span>

<span data-ttu-id="c5989-150">需要的是單一裝載抽象概念，可讓開發人員從各種不同的元件和架構撰寫應用程式，然後在支援的主機上執行該應用程式。</span><span class="sxs-lookup"><span data-stu-id="c5989-150">What was needed was a single hosting abstraction that would enable a developer to compose an application from a variety of different components and frameworks, and then run that application on a supporting host.</span></span>

## <a name="the-open-web-interface-for-net-owin"></a><span data-ttu-id="c5989-151">Open Web Interface for .NET （OWIN）</span><span class="sxs-lookup"><span data-stu-id="c5989-151">The Open Web Interface for .NET (OWIN)</span></span>

 <span data-ttu-id="c5989-152">由 Ruby 社區中的[機架](http://rack.github.io/)所達成的優點來啟發，這是 .net 社區的幾個成員，可以在網頁伺服器和架構元件之間建立抽象概念。</span><span class="sxs-lookup"><span data-stu-id="c5989-152">Inspired by the benefits achieved by [Rack](http://rack.github.io/) in the Ruby community, several members of the .NET community set out to create an abstraction between Web servers and framework components.</span></span> <span data-ttu-id="c5989-153">OWIN 抽象的兩個設計目標是很簡單，而且可能會對其他架構類型採取最少的相依性。</span><span class="sxs-lookup"><span data-stu-id="c5989-153">Two design goals for the OWIN abstraction were that it was simple and that it took the fewest possible dependencies on other framework types.</span></span> <span data-ttu-id="c5989-154">這兩個目標有助於確保：</span><span class="sxs-lookup"><span data-stu-id="c5989-154">These two goals help ensure:</span></span>

- <span data-ttu-id="c5989-155">可以更輕鬆地開發和使用新的元件。</span><span class="sxs-lookup"><span data-stu-id="c5989-155">New components could be more easily developed and consumed.</span></span>
- <span data-ttu-id="c5989-156">應用程式可以更輕鬆地在主機和可能整個平臺/作業系統之間移植。</span><span class="sxs-lookup"><span data-stu-id="c5989-156">Applications could be more easily ported between hosts and potentially entire platforms/operating systems.</span></span>

<span data-ttu-id="c5989-157">產生的抽象概念包含兩個核心元素。</span><span class="sxs-lookup"><span data-stu-id="c5989-157">The resulting abstraction consists of two core elements.</span></span> <span data-ttu-id="c5989-158">第一個是環境字典。</span><span class="sxs-lookup"><span data-stu-id="c5989-158">The first is the environment dictionary.</span></span> <span data-ttu-id="c5989-159">此資料結構負責儲存處理 HTTP 要求和回應所需的所有狀態，以及任何相關的伺服器狀態。</span><span class="sxs-lookup"><span data-stu-id="c5989-159">This data structure is responsible for storing all of the state necessary for processing an HTTP request and response, as well as any relevant server state.</span></span> <span data-ttu-id="c5989-160">環境字典的定義如下：</span><span class="sxs-lookup"><span data-stu-id="c5989-160">The environment dictionary is defined as follows:</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample1.cmd)]

<span data-ttu-id="c5989-161">OWIN 相容的 Web 服務器負責將資料填入環境字典，例如 HTTP 要求和回應的主體串流和標頭集合。</span><span class="sxs-lookup"><span data-stu-id="c5989-161">An OWIN-compatible Web server is responsible for populating the environment dictionary with data such as the body streams and header collections for an HTTP request and response.</span></span> <span data-ttu-id="c5989-162">接著，應用程式或架構元件會負責填入或更新字典，並將其他值寫入回應主體資料流程。</span><span class="sxs-lookup"><span data-stu-id="c5989-162">It is then the responsibility of the application or framework components to populate or update the dictionary with additional values and write to the response body stream.</span></span>

<span data-ttu-id="c5989-163">除了指定環境字典的類型，OWIN 規格也會定義核心字典索引鍵值組的清單。</span><span class="sxs-lookup"><span data-stu-id="c5989-163">In addition to specifying the type for the environment dictionary, the OWIN specification defines a list of core dictionary key value pairs.</span></span> <span data-ttu-id="c5989-164">例如，下表顯示 HTTP 要求所需的字典索引鍵：</span><span class="sxs-lookup"><span data-stu-id="c5989-164">For example, the following table shows the required dictionary keys for an HTTP request:</span></span>

| <span data-ttu-id="c5989-165">索引鍵名稱</span><span class="sxs-lookup"><span data-stu-id="c5989-165">Key Name</span></span> | <span data-ttu-id="c5989-166">值描述</span><span class="sxs-lookup"><span data-stu-id="c5989-166">Value Description</span></span> |
| --- | --- |
| `"owin.RequestBody"` | <span data-ttu-id="c5989-167">包含要求主體的資料流程（如果有的話）。</span><span class="sxs-lookup"><span data-stu-id="c5989-167">A Stream with the request body, if any.</span></span> <span data-ttu-id="c5989-168">如果沒有要求主體，可能會使用 Null 做為預留位置。</span><span class="sxs-lookup"><span data-stu-id="c5989-168">Stream.Null MAY be used as a placeholder if there is no request body.</span></span> <span data-ttu-id="c5989-169">請參閱[要求主體](http://owin.org/html/owin.html#34-request-body-100-continue-and-completed-semantics)。</span><span class="sxs-lookup"><span data-stu-id="c5989-169">See [Request Body](http://owin.org/html/owin.html#34-request-body-100-continue-and-completed-semantics).</span></span> |
| `"owin.RequestHeaders"` | <span data-ttu-id="c5989-170">要求標頭的 `IDictionary<string, string[]>`。</span><span class="sxs-lookup"><span data-stu-id="c5989-170">An `IDictionary<string, string[]>` of request headers.</span></span> <span data-ttu-id="c5989-171">請參閱[標頭](http://owin.org/html/owin.html#3-3-headers)。</span><span class="sxs-lookup"><span data-stu-id="c5989-171">See [Headers](http://owin.org/html/owin.html#3-3-headers).</span></span> |
| `"owin.RequestMethod"` | <span data-ttu-id="c5989-172">`string`，其中包含要求的 HTTP 要求方法（例如，`"GET"`、`"POST"`）。</span><span class="sxs-lookup"><span data-stu-id="c5989-172">A `string` containing the HTTP request method of the request (e.g., `"GET"`, `"POST"`).</span></span> |
| `"owin.RequestPath"` | <span data-ttu-id="c5989-173">包含要求路徑的 `string`。</span><span class="sxs-lookup"><span data-stu-id="c5989-173">A `string` containing the request path.</span></span> <span data-ttu-id="c5989-174">路徑必須相對於應用程式委派的 "root";請參閱[路徑](http://owin.org/html/owin.html#5-3-paths)。</span><span class="sxs-lookup"><span data-stu-id="c5989-174">The path MUST be relative to the "root" of the application delegate; see [Paths](http://owin.org/html/owin.html#5-3-paths).</span></span> |
| `"owin.RequestPathBase"` | <span data-ttu-id="c5989-175">`string`，其中包含對應至應用程式委派「根」之要求路徑的部分;請參閱[路徑](http://owin.org/html/owin.html#5-3-paths)。</span><span class="sxs-lookup"><span data-stu-id="c5989-175">A `string` containing the portion of the request path corresponding to the "root" of the application delegate; see [Paths](http://owin.org/html/owin.html#5-3-paths).</span></span> |
| `"owin.RequestProtocol"` | <span data-ttu-id="c5989-176">包含通訊協定名稱和版本的 `string` （例如 `"HTTP/1.0"` 或 `"HTTP/1.1"`）。</span><span class="sxs-lookup"><span data-stu-id="c5989-176">A `string` containing the protocol name and version (e.g. `"HTTP/1.0"` or `"HTTP/1.1"`).</span></span> |
| `"owin.RequestQueryString"` | <span data-ttu-id="c5989-177">`string`，其中包含 HTTP 要求 URI 的查詢字串元件，沒有前置的 "？"（例如，`"foo=bar&baz=quux"`）。</span><span class="sxs-lookup"><span data-stu-id="c5989-177">A `string` containing the query string component of the HTTP request URI, without the leading "?" (e.g., `"foo=bar&baz=quux"`).</span></span> <span data-ttu-id="c5989-178">此值可以是空字串。</span><span class="sxs-lookup"><span data-stu-id="c5989-178">The value may be an empty string.</span></span> |
| `"owin.RequestScheme"` | <span data-ttu-id="c5989-179">`string`，其中包含用於要求的 URI 配置（例如，`"http"`、`"https"`）;請參閱[URI 配置](http://owin.org/html/owin.html#5-1-uri-scheme)。</span><span class="sxs-lookup"><span data-stu-id="c5989-179">A `string` containing the URI scheme used for the request (e.g., `"http"`, `"https"`); see [URI Scheme](http://owin.org/html/owin.html#5-1-uri-scheme).</span></span> |

<span data-ttu-id="c5989-180">OWIN 的第二個主要元素是應用程式委派。</span><span class="sxs-lookup"><span data-stu-id="c5989-180">The second key element of OWIN is the application delegate.</span></span> <span data-ttu-id="c5989-181">這是函式簽章，可作為 OWIN 應用程式中所有元件之間的主要介面。</span><span class="sxs-lookup"><span data-stu-id="c5989-181">This is a function signature which serves as the primary interface between all components in an OWIN application.</span></span> <span data-ttu-id="c5989-182">應用程式委派的定義如下所示：</span><span class="sxs-lookup"><span data-stu-id="c5989-182">The definition for the application delegate is as follows:</span></span>

`Func<IDictionary<string, object>, Task>;`

<span data-ttu-id="c5989-183">然後，應用程式委派只是一個 Func 委派型別的實作為函式，其中函式會接受環境字典做為輸入，並傳回工作。</span><span class="sxs-lookup"><span data-stu-id="c5989-183">The application delegate then is simply an implementation of the Func delegate type where the function accepts the environment dictionary as input and returns a Task.</span></span> <span data-ttu-id="c5989-184">這項設計對開發人員有幾個含意：</span><span class="sxs-lookup"><span data-stu-id="c5989-184">This design has several implications for developers:</span></span>

- <span data-ttu-id="c5989-185">需要非常少量的類型相依性，才能撰寫 OWIN 元件。</span><span class="sxs-lookup"><span data-stu-id="c5989-185">There are a very small number of type dependencies required in order to write OWIN components.</span></span> <span data-ttu-id="c5989-186">這會大幅增加 OWIN 給開發人員的存取權。</span><span class="sxs-lookup"><span data-stu-id="c5989-186">This greatly increases the accessibility of OWIN to developers.</span></span>
- <span data-ttu-id="c5989-187">非同步設計讓抽象功能能夠有效率地處理運算資源，特別是在需要大量 i/o 的作業中。</span><span class="sxs-lookup"><span data-stu-id="c5989-187">The asynchronous design enables the abstraction to be efficient with its handling of computing resources, particularly in more I/O intensive operations.</span></span>
- <span data-ttu-id="c5989-188">因為應用程式委派是一個不可部分完成的執行單位，而且因為環境字典會當做委派的參數來執行，所以 OWIN 元件可以輕鬆地連結在一起，以建立複雜的 HTTP 處理管線。</span><span class="sxs-lookup"><span data-stu-id="c5989-188">Because the application delegate is an atomic unit of execution and because the environment dictionary is carried as a parameter on the delegate, OWIN components can be easily chained together to create complex HTTP processing pipelines.</span></span>

<span data-ttu-id="c5989-189">從執行的觀點來看，OWIN 是一種規格（[http://owin.org/html/owin.html](http://owin.org/html/owin.html)）。</span><span class="sxs-lookup"><span data-stu-id="c5989-189">From an implementation perspective, OWIN is a specification ([http://owin.org/html/owin.html](http://owin.org/html/owin.html)).</span></span> <span data-ttu-id="c5989-190">它的目標不是下一個 Web 架構，而是 Web 架構和網頁伺服器如何互動的規格。</span><span class="sxs-lookup"><span data-stu-id="c5989-190">Its goal is not to be the next Web framework, but rather a specification for how Web frameworks and Web servers interact.</span></span>

<span data-ttu-id="c5989-191">如果您已調查過[OWIN](http://owin.org/)或[Katana](https://github.com/aspnet/AspNetKatana/wiki)，您可能也已經注意到[OWIN NuGet 封裝](http://nuget.org/packages/Owin)和 OWIN。</span><span class="sxs-lookup"><span data-stu-id="c5989-191">If you've investigated [OWIN](http://owin.org/) or [Katana](https://github.com/aspnet/AspNetKatana/wiki), you may also have noticed the [Owin NuGet package](http://nuget.org/packages/Owin) and Owin.dll.</span></span> <span data-ttu-id="c5989-192">此程式庫包含單一介面[IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs)，可將 OWIN 規格第[4 節](http://owin.org/html/owin.html#4-application-startup)所述的啟動順序正規化並制訂。</span><span class="sxs-lookup"><span data-stu-id="c5989-192">This library contains a single interface, [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs), which formalizes and codifies the startup sequence described in [section 4](http://owin.org/html/owin.html#4-application-startup) of the OWIN specification.</span></span> <span data-ttu-id="c5989-193">雖然不一定要建立 OWIN 伺服器，但[IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs)介面會提供具象的參考點，而且它是由 Katana 專案元件所使用。</span><span class="sxs-lookup"><span data-stu-id="c5989-193">While not required in order to build OWIN servers, the [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs) interface provides a concrete reference point, and it is used by the Katana project components.</span></span>

## <a name="project-katana"></a><span data-ttu-id="c5989-194">專案 Katana</span><span class="sxs-lookup"><span data-stu-id="c5989-194">Project Katana</span></span>

<span data-ttu-id="c5989-195">雖然[OWIN](http://owin.org/html/owin.html)規格和*OWIN*都是由社區所擁有，而社區則是執行開放原始碼的工作，但[KATANA](https://github.com/aspnet/AspNetKatana/wiki)專案代表一組 OWIN 元件，而仍然是開放原始碼，則是由 Microsoft 所建立和發行。</span><span class="sxs-lookup"><span data-stu-id="c5989-195">Whereas both the [OWIN](http://owin.org/html/owin.html) specification and *Owin.dll* are community owned and community run open source efforts, the [Katana](https://github.com/aspnet/AspNetKatana/wiki) project represents the set of OWIN components that, while still open source, are built and released by Microsoft.</span></span> <span data-ttu-id="c5989-196">這些元件包括基礎結構元件，例如主機和伺服器，以及功能元件，例如驗證元件和架構的系結，例如[SignalR](../../../signalr/index.md)和[ASP.NET Web API](../../../web-api/overview/getting-started-with-aspnet-web-api/index.md)。</span><span class="sxs-lookup"><span data-stu-id="c5989-196">These components include both infrastructure components, such as hosts and servers, as well as functional components, such as authentication components and bindings to frameworks such as [SignalR](../../../signalr/index.md) and [ASP.NET Web API](../../../web-api/overview/getting-started-with-aspnet-web-api/index.md).</span></span> <span data-ttu-id="c5989-197">專案具有下列三個高階目標：</span><span class="sxs-lookup"><span data-stu-id="c5989-197">The project has the following three high level goals:</span></span> 

- <span data-ttu-id="c5989-198">**可移植**–元件應該能夠在新元件可供使用時輕鬆地取代。</span><span class="sxs-lookup"><span data-stu-id="c5989-198">**Portable** – Components should be able to be easily substituted for new components as they become available.</span></span> <span data-ttu-id="c5989-199">這包括從架構到伺服器和主機的所有元件類型。</span><span class="sxs-lookup"><span data-stu-id="c5989-199">This includes all types of components, from the framework to the server and host.</span></span> <span data-ttu-id="c5989-200">此目標的含意是，協力廠商架構可以順暢地在 Microsoft 伺服器上執行，而 Microsoft framework 可能會在協力廠商伺服器和主機上執行。</span><span class="sxs-lookup"><span data-stu-id="c5989-200">The implication of this goal is that third party frameworks can seamlessly run on Microsoft servers while Microsoft frameworks can potentially run on third party servers and hosts.</span></span>
- <span data-ttu-id="c5989-201">**模組化/彈性**–不同于許多架構，其中包含預設開啟的多種功能，Katana 專案元件應該是小型且專注的，讓應用程式開發人員可以控制要在應用程式中使用哪些元件。</span><span class="sxs-lookup"><span data-stu-id="c5989-201">**Modular/flexible**– Unlike many frameworks which include a myriad of features that are turned on by default, Katana project components should be small and focused, giving control over to the application developer in determining which components to use in her application.</span></span>
- <span data-ttu-id="c5989-202">**輕量/效能/可**調整–藉由將架構的傳統概念細分成一組由應用程式開發人員明確新增的小型、重點元件，產生的 Katana 應用程式可能會耗用較少的運算資源，因此可以處理更多負載，而不是使用其他類型的伺服器和架構。</span><span class="sxs-lookup"><span data-stu-id="c5989-202">**Lightweight/performant/scalable** – By breaking the traditional notion of a framework into a set of small, focused components which are added explicitly by the application developer, a resulting Katana application can consume fewer computing resources, and as a result, handle more load, than with other types of servers and frameworks.</span></span> <span data-ttu-id="c5989-203">由於應用程式的需求需要基礎結構的更多功能，因此可以新增至 OWIN 管線，但這應該是應用程式開發人員部分的明確決策。</span><span class="sxs-lookup"><span data-stu-id="c5989-203">As the requirements of the application demand more features from the underlying infrastructure, those can be added to the OWIN pipeline, but that should be an explicit decision on the part of the application developer.</span></span> <span data-ttu-id="c5989-204">此外，較低層級元件的可替代性表示當它們變成可用時，可以順暢地引進新的高效能伺服器，以提升 OWIN 應用程式的效能，而不會中斷那些應用程式。</span><span class="sxs-lookup"><span data-stu-id="c5989-204">Additionally, the substitutability of lower level components means that as they become available, new high performance servers can seamlessly be introduced to improve the performance of OWIN applications without breaking those applications.</span></span>

## <a name="getting-started-with-katana-components"></a><span data-ttu-id="c5989-205">Katana 元件的消費者入門</span><span class="sxs-lookup"><span data-stu-id="c5989-205">Getting Started with Katana Components</span></span>

<span data-ttu-id="c5989-206">第一次引進時， [node.js 架構的](http://nodejs.org/)其中一個層面會立即吸引人們的注意力，這是一個可以撰寫和執行網頁伺服器的簡單性。</span><span class="sxs-lookup"><span data-stu-id="c5989-206">When it was first introduced, one aspect of the [Node.js](http://nodejs.org/) framework that immediately drew people's attention was the simplicity with which one could author and run a Web server.</span></span> <span data-ttu-id="c5989-207">如果 Katana 目標是以[node.js](http://nodejs.org/)為框架，則可能會藉由指出 Katana 帶來 node.js （和架構）的許多優點，而不會強迫開發人員在開發 ASP.NET Web 應用程式時，擲出她[知道的所有](http://nodejs.org/)專案。</span><span class="sxs-lookup"><span data-stu-id="c5989-207">If Katana goals were framed in light of [Node.js](http://nodejs.org/), one might summarize them by saying that Katana brings many of the benefits of [Node.js](http://nodejs.org/) (and frameworks like it) without forcing the developer to throw out everything she knows about developing ASP.NET Web applications.</span></span> <span data-ttu-id="c5989-208">若要讓此語句保持為 true，開始使用 Katana 專案對[node.js](http://nodejs.org/)而言應該同樣簡單。</span><span class="sxs-lookup"><span data-stu-id="c5989-208">For this statement to hold true, getting started with the Katana project should be equally simple in nature to [Node.js](http://nodejs.org/).</span></span>

## <a name="creating-hello-world"></a><span data-ttu-id="c5989-209">建立 "Hello World！"</span><span class="sxs-lookup"><span data-stu-id="c5989-209">Creating "Hello World!"</span></span>

<span data-ttu-id="c5989-210">JavaScript 和 .NET 開發之間有一項明顯的差異，就是編譯器的存在（或缺少）。</span><span class="sxs-lookup"><span data-stu-id="c5989-210">One notable difference between JavaScript and .NET development is the presence (or absence) of a compiler.</span></span> <span data-ttu-id="c5989-211">因此，簡單 Katana 伺服器的起點是 Visual Studio 專案。</span><span class="sxs-lookup"><span data-stu-id="c5989-211">As such, the starting point for a simple Katana server is a Visual Studio project.</span></span> <span data-ttu-id="c5989-212">不過，我們可以從最小的專案類型開始：空的 ASP.NET Web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="c5989-212">However, we can start with the most minimal of project types: the Empty ASP.NET Web Application.</span></span>

[![](an-overview-of-project-katana/_static/image1.png)](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb)

<span data-ttu-id="c5989-213">接下來，我們會將[SystemWeb](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) NuGet 套件安裝到專案中。</span><span class="sxs-lookup"><span data-stu-id="c5989-213">Next, we will install the [Microsoft.Owin.Host.SystemWeb](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) NuGet package into the project.</span></span> <span data-ttu-id="c5989-214">此套件提供在 ASP.NET 要求管線中執行的 OWIN 伺服器。</span><span class="sxs-lookup"><span data-stu-id="c5989-214">This package provides an OWIN server that runs in the ASP.NET request pipeline.</span></span> <span data-ttu-id="c5989-215">您可以在[NuGet 資源庫](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb)中找到，也可以使用 [Visual Studio 套件管理員] 對話方塊或 [套件管理員主控台] （使用下列命令）來安裝它：</span><span class="sxs-lookup"><span data-stu-id="c5989-215">It can be found on the [NuGet gallery](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) and can be installed using either the Visual Studio package manager dialog or the package manager console with the following command:</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample2.cmd)]

<span data-ttu-id="c5989-216">安裝 `Microsoft.Owin.Host.SystemWeb` 套件將會安裝一些額外的套件做為相依性。</span><span class="sxs-lookup"><span data-stu-id="c5989-216">Installing the `Microsoft.Owin.Host.SystemWeb` package will install a few additional packages as dependencies.</span></span> <span data-ttu-id="c5989-217">其中一個相依性是 `Microsoft.Owin`，這是一個程式庫，提供數種協助程式類型和方法來開發 OWIN 應用程式。</span><span class="sxs-lookup"><span data-stu-id="c5989-217">One of those dependencies is `Microsoft.Owin`, a library which provides several helper types and methods for developing OWIN applications.</span></span> <span data-ttu-id="c5989-218">我們可以使用這些類型快速地撰寫下列 "hello world" 伺服器。</span><span class="sxs-lookup"><span data-stu-id="c5989-218">We can use those types to quickly write the following "hello world" server.</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample3.cs)]

<span data-ttu-id="c5989-219">這個非常簡單的 Web 服務器現在可以使用 Visual Studio 的**F5**命令來執行，並包含完整的偵錯工具支援。</span><span class="sxs-lookup"><span data-stu-id="c5989-219">This very simple Web server can now be run using Visual Studio's **F5** command and includes full support for debugging.</span></span>

## <a name="switching-hosts"></a><span data-ttu-id="c5989-220">切換主機</span><span class="sxs-lookup"><span data-stu-id="c5989-220">Switching hosts</span></span>

<span data-ttu-id="c5989-221">根據預設，先前的 "hello world" 範例會在 ASP.NET 要求管線中執行，這會在 IIS 的內容中使用 System.web。</span><span class="sxs-lookup"><span data-stu-id="c5989-221">By default, the previous "hello world" example runs in the ASP.NET request pipeline, which uses System.Web in the context of IIS.</span></span> <span data-ttu-id="c5989-222">這可以自行增加價值，因為它可讓我們受益于 OWIN 管線的彈性和複合性，並具有 IIS 的管理功能和整體成熟度。</span><span class="sxs-lookup"><span data-stu-id="c5989-222">This can by itself add tremendous value as it enables us to benefit from the flexibility and composability of an OWIN pipeline with the management capabilities and overall maturity of IIS.</span></span> <span data-ttu-id="c5989-223">不過，在某些情況下，IIS 所提供的好處並不是必要的，而想要的是較小、更輕量的主機。</span><span class="sxs-lookup"><span data-stu-id="c5989-223">However, there may be cases where the benefits provided by IIS are not required and the desire is for a smaller, more lightweight host.</span></span> <span data-ttu-id="c5989-224">需要什麼，才能在 IIS 和 System.web 以外的地方執行簡單的 Web 服務器？</span><span class="sxs-lookup"><span data-stu-id="c5989-224">What is needed, then, to run our simple Web server outside of IIS and System.Web?</span></span>

<span data-ttu-id="c5989-225">為了說明可攜性目標，從 Web 服務器主機移至命令列主機只需要將新的伺服器和主機相依性新增至專案的輸出檔案夾，然後啟動主機。</span><span class="sxs-lookup"><span data-stu-id="c5989-225">To illustrate the portability goal, moving from a Web-server host to a command line host requires simply adding the new server and host dependencies to project's output folder and then starting the host.</span></span> <span data-ttu-id="c5989-226">在此範例中，我們會將 Web 服務器裝載在名為 `OwinHost.exe` 的 Katana 主機中，並使用 Katana HttpListener 伺服器。</span><span class="sxs-lookup"><span data-stu-id="c5989-226">In this example, we'll host our Web server in a Katana host called `OwinHost.exe` and will use the Katana HttpListener-based server.</span></span> <span data-ttu-id="c5989-227">類似于其他 Katana 元件，這些會使用下列命令從 NuGet 取得：</span><span class="sxs-lookup"><span data-stu-id="c5989-227">Similarly to the other Katana components, these will be acquired from NuGet using the following command:</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample4.cmd)]

<span data-ttu-id="c5989-228">接著，我們可以從命令列流覽至專案根資料夾，並直接執行 `OwinHost.exe` （安裝在其各自 NuGet 套件的 [工具] 資料夾中）。</span><span class="sxs-lookup"><span data-stu-id="c5989-228">From the command line, we can then navigate to the project root folder and simply run the `OwinHost.exe` (which was installed in the tools folder of its respective NuGet package).</span></span> <span data-ttu-id="c5989-229">根據預設，`OwinHost.exe` 會設定為尋找 HttpListener 伺服器，因此不需要額外的設定。</span><span class="sxs-lookup"><span data-stu-id="c5989-229">By default, `OwinHost.exe` is configured to look for the HttpListener-based server and so no additional configuration is needed.</span></span> <span data-ttu-id="c5989-230">在網頁瀏覽器中流覽至 `http://localhost:5000/` 會顯示現在透過主控台執行的應用程式。</span><span class="sxs-lookup"><span data-stu-id="c5989-230">Navigating in a Web browser to `http://localhost:5000/` shows the application now running through the console.</span></span>

![](an-overview-of-project-katana/_static/image2.png)

## <a name="katana-architecture"></a><span data-ttu-id="c5989-231">Katana 架構</span><span class="sxs-lookup"><span data-stu-id="c5989-231">Katana Architecture</span></span>

 <span data-ttu-id="c5989-232">Katana 元件架構會將應用程式分成四個邏輯層，如下所示：*主機、伺服器、中介軟體*和*應用程式*。</span><span class="sxs-lookup"><span data-stu-id="c5989-232">The Katana component architecture divides an application into four logical layers, as depicted below: *host, server, middleware,* and *application*.</span></span> <span data-ttu-id="c5989-233">元件架構的分解方式是，在許多情況下，可以輕鬆地取代這些層的執行，而不需要重新編譯應用程式。</span><span class="sxs-lookup"><span data-stu-id="c5989-233">The component architecture is factored in such a way that implementations of these layers can be easily substituted, in many cases, without requiring recompilation of the application.</span></span>   

![](an-overview-of-project-katana/_static/image3.png)

## <a name="host"></a><span data-ttu-id="c5989-234">主機</span><span class="sxs-lookup"><span data-stu-id="c5989-234">Host</span></span>

 <span data-ttu-id="c5989-235">主機負責：</span><span class="sxs-lookup"><span data-stu-id="c5989-235">The host is responsible for:</span></span>

- <span data-ttu-id="c5989-236">管理基礎進程。</span><span class="sxs-lookup"><span data-stu-id="c5989-236">Managing the underlying process.</span></span>
- <span data-ttu-id="c5989-237">協調工作流程，這會導致選取伺服器，以及將處理要求的 OWIN 管線的結構。</span><span class="sxs-lookup"><span data-stu-id="c5989-237">Orchestrating the workflow that results in the selection of a server and the construction of an OWIN pipeline through which requests will be handled.</span></span>

  <span data-ttu-id="c5989-238">目前，有3個主要裝載選項適用于 Katana 型應用程式：</span><span class="sxs-lookup"><span data-stu-id="c5989-238">At present, there are 3 primary hosting options for Katana-based applications:</span></span>  
  
<span data-ttu-id="c5989-239">**Iis/asp.net**：使用標準 HttpModule 和 HttpHandler 類型，OWIN 管線可以在 IIS 上作為 ASP.NET 要求流程的一部分來執行。</span><span class="sxs-lookup"><span data-stu-id="c5989-239">**IIS/ASP.NET**: Using the standard HttpModule and HttpHandler types, OWIN pipelines can run on IIS as a part of an ASP.NET request flow.</span></span> <span data-ttu-id="c5989-240">將 SystemWeb NuGet 套件安裝到 Web 應用程式專案中，即可啟用 ASP.NET 裝載支援。</span><span class="sxs-lookup"><span data-stu-id="c5989-240">ASP.NET hosting support is enabled by installing the Microsoft.AspNet.Host.SystemWeb NuGet package into a Web application project.</span></span> <span data-ttu-id="c5989-241">此外，由於 IIS 會同時做為主機和伺服器，因此在此 NuGet 套件中會混為一談 OWIN 伺服器/主機區分，這表示如果使用 SystemWeb 主機，開發人員就無法替代替代的伺服器。</span><span class="sxs-lookup"><span data-stu-id="c5989-241">Additionally, because IIS acts as both a host and a server, the OWIN server/host distinction is conflated in this NuGet package, meaning that if using the SystemWeb host, a developer cannot substitute an alternate server implementation.</span></span>  
  
<span data-ttu-id="c5989-242">**自訂主機**： Katana 元件套件讓開發人員能夠在自己的自訂進程中裝載應用程式，不論是主控台應用程式、Windows 服務等等。這項功能看起來類似于 Web API 所提供的自我裝載功能。</span><span class="sxs-lookup"><span data-stu-id="c5989-242">**Custom Host**: The Katana component suite gives a developer the ability to host applications in her own custom process, whether that is a console application, Windows service, etc. This capability looks similar to the self-host capability provided by Web API.</span></span> <span data-ttu-id="c5989-243">下列範例顯示 Web API 程式碼的自訂主機：</span><span class="sxs-lookup"><span data-stu-id="c5989-243">The following example shows a custom host of Web API code:</span></span>  

[!code-csharp[Main](an-overview-of-project-katana/samples/sample5.cs)]

<span data-ttu-id="c5989-244">Katana 應用程式的自我裝載設定類似：</span><span class="sxs-lookup"><span data-stu-id="c5989-244">The self-host setup for a Katana application is similar:</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample6.cs)]

<span data-ttu-id="c5989-245">Web API 與 Katana 自我裝載範例之間有一項明顯的差異，就是 Katana 自我裝載範例中缺少 Web API 設定程式碼。</span><span class="sxs-lookup"><span data-stu-id="c5989-245">One notable difference between the Web API and Katana self-host examples is that the Web API configuration code is missing from the Katana self-host example.</span></span> <span data-ttu-id="c5989-246">為了同時啟用可攜性和複合性，Katana 會將啟動伺服器的程式碼與設定要求處理管線的程式碼分開。</span><span class="sxs-lookup"><span data-stu-id="c5989-246">In order to enable both portability and composability, Katana separates the code that starts the server from the code that configures the request processing pipeline.</span></span> <span data-ttu-id="c5989-247">設定 Web API 的程式碼，接著會包含在類別啟動中，此外也會在 WebApplication 中指定為類型參數。</span><span class="sxs-lookup"><span data-stu-id="c5989-247">The code that configures Web API, then is contained in the class Startup, which is additionally specified as the type parameter in WebApplication.Start.</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample7.cs)]

<span data-ttu-id="c5989-248">本文章稍後會更詳細地討論 startup 類別。</span><span class="sxs-lookup"><span data-stu-id="c5989-248">The startup class will be discussed in greater detail later in the article.</span></span> <span data-ttu-id="c5989-249">不過，啟動 Katana 自我裝載程式所需的程式碼，看起來與您目前在 ASP.NET Web API 自我裝載應用程式中使用的程式碼類似非常。</span><span class="sxs-lookup"><span data-stu-id="c5989-249">However, the code required to start a Katana self-host process looks strikingly similar to the code that you may be using today in ASP.NET Web API self-host applications.</span></span>

<span data-ttu-id="c5989-250">**OwinHost .exe**：雖然有些人會想要撰寫自訂進程來執行 Katana Web 應用程式，但許多人偏好只啟動預先建立的可執行檔，以便啟動伺服器並執行其應用程式。</span><span class="sxs-lookup"><span data-stu-id="c5989-250">**OwinHost.exe**: While some will want to write a custom process to run Katana Web applications, many would prefer to simply launch a pre-built executable that can start a server and run their application.</span></span> <span data-ttu-id="c5989-251">在此案例中，Katana 元件套件包含 `OwinHost.exe`。</span><span class="sxs-lookup"><span data-stu-id="c5989-251">For this scenario, the Katana component suite includes `OwinHost.exe`.</span></span> <span data-ttu-id="c5989-252">從專案的根目錄執行時，此可執行檔會啟動伺服器（預設會使用 HttpListener 伺服器），並使用慣例來尋找和執行使用者的 startup 類別。</span><span class="sxs-lookup"><span data-stu-id="c5989-252">When run from within a project's root directory, this executable will start a server (it uses the HttpListener server by default) and use conventions to find and run the user's startup class.</span></span> <span data-ttu-id="c5989-253">如需更細微的控制，可執行檔會提供一些額外的命令列參數。</span><span class="sxs-lookup"><span data-stu-id="c5989-253">For more granular control, the executable provides a number of additional command line parameters.</span></span>

![](an-overview-of-project-katana/_static/image4.png)

## <a name="server"></a><span data-ttu-id="c5989-254">伺服器</span><span class="sxs-lookup"><span data-stu-id="c5989-254">Server</span></span>

 <span data-ttu-id="c5989-255">當主機負責啟動和維護應用程式執行所在的進程時，伺服器的責任是開啟網路通訊端，接聽要求，然後透過使用者指定的 OWIN 元件管線傳送給它們（可能已經注意到，此管線是在應用程式開發人員的 Startup 類別中指定）。</span><span class="sxs-lookup"><span data-stu-id="c5989-255">While the host is responsible for starting and maintaining process within which the application runs, the responsibility of the server is to open a network socket, listen for requests, and send them through the pipeline of OWIN components specified by the user (as you may have already noticed, this pipeline is specified in the application developer's Startup class).</span></span> <span data-ttu-id="c5989-256">目前，Katana 專案包含兩個伺服器實現：</span><span class="sxs-lookup"><span data-stu-id="c5989-256">Currently, the Katana project includes two server implementations:</span></span> 

- <span data-ttu-id="c5989-257">**SystemWeb**：如同先前所述，與 ASP.NET 管線共同的 IIS 會同時做為主機和伺服器。</span><span class="sxs-lookup"><span data-stu-id="c5989-257">**Microsoft.Owin.Host.SystemWeb**: As previously mentioned, IIS in concert with the ASP.NET pipeline acts as both a host and a server.</span></span> <span data-ttu-id="c5989-258">因此，在選擇此裝載選項時，IIS 會管理主機層級的考慮，例如進程啟動和接聽 HTTP 要求。</span><span class="sxs-lookup"><span data-stu-id="c5989-258">Therefore, when choosing this hosting option, IIS both manages host-level concerns such as process activation and listens for HTTP requests.</span></span> <span data-ttu-id="c5989-259">針對 ASP.NET Web 應用程式，它接著會將要求傳送至 ASP.NET 管線。</span><span class="sxs-lookup"><span data-stu-id="c5989-259">For ASP.NET Web applications, it then sends the requests into the ASP.NET pipeline.</span></span> <span data-ttu-id="c5989-260">Katana SystemWeb 主機會註冊 ASP.NET HttpModule 和 HttpHandler，以在要求流經 HTTP 管線並透過使用者指定的 OWIN 管線傳送它們時攔截它們。</span><span class="sxs-lookup"><span data-stu-id="c5989-260">The Katana SystemWeb host registers an ASP.NET HttpModule and HttpHandler to intercept requests as they flow through the HTTP pipeline and send them through the user-specified OWIN pipeline.</span></span>
- <span data-ttu-id="c5989-261">**Owin。 HttpListener**：如其名稱所示，此 Katana 伺服器會使用 .NET Framework 的 HttpListener 類別來開啟通訊端，並將要求傳送至開發人員指定的 Owin 管線。</span><span class="sxs-lookup"><span data-stu-id="c5989-261">**Microsoft.Owin.Host.HttpListener**: As its name indicates, this Katana server uses the .NET Framework's HttpListener class to open a socket and send requests into a developer-specified OWIN pipeline.</span></span> <span data-ttu-id="c5989-262">這是 Katana 自我裝載 API 和 OwinHost 目前的預設伺服器選擇。</span><span class="sxs-lookup"><span data-stu-id="c5989-262">This is currently the default server selection for both the Katana self-host API and OwinHost.exe.</span></span>

## <a name="middlewareframework"></a><span data-ttu-id="c5989-263">中介軟體/架構</span><span class="sxs-lookup"><span data-stu-id="c5989-263">Middleware/framework</span></span>

 <span data-ttu-id="c5989-264">如先前所述，當伺服器接受來自用戶端的要求時，它會負責透過 OWIN 元件（由開發人員的啟動程式碼所指定）的管線來傳遞它。</span><span class="sxs-lookup"><span data-stu-id="c5989-264">As previously mentioned, when the server accepts a request from a client, it is responsible for passing it through a pipeline of OWIN components, which are specified by the developer's startup code.</span></span> <span data-ttu-id="c5989-265">這些管線元件稱為中介軟體。</span><span class="sxs-lookup"><span data-stu-id="c5989-265">These pipeline components are known as middleware.</span></span>  
 <span data-ttu-id="c5989-266">在非常基本的層級中，OWIN 中介軟體元件只需要執行 OWIN 應用程式委派，就可以呼叫它。</span><span class="sxs-lookup"><span data-stu-id="c5989-266">At a very basic level, an OWIN middleware component simply needs to implement the OWIN application delegate so that it is callable.</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample8.cmd)]

<span data-ttu-id="c5989-267">不過，為了簡化中介軟體元件的開發和撰寫，Katana 支援一些中介軟體元件的慣例和 helper 類型。</span><span class="sxs-lookup"><span data-stu-id="c5989-267">However, in order to simplify the development and composition of middleware components, Katana supports a handful of conventions and helper types for middleware components.</span></span> <span data-ttu-id="c5989-268">其中最常見的就是 `OwinMiddleware` 類別。</span><span class="sxs-lookup"><span data-stu-id="c5989-268">The most common of these is the `OwinMiddleware` class.</span></span> <span data-ttu-id="c5989-269">使用此類別建立的自訂中介軟體元件看起來會像下面這樣：</span><span class="sxs-lookup"><span data-stu-id="c5989-269">A custom middleware component built using this class would look similar to the following:</span></span> 

[!code-csharp[Main](an-overview-of-project-katana/samples/sample9.cs)]

 <span data-ttu-id="c5989-270">這個類別衍生自 `OwinMiddleware`，它會執行可接受管線中下一個中介軟體的實例作為其引數之一的函式，然後將它傳遞至基底函數。</span><span class="sxs-lookup"><span data-stu-id="c5989-270">This class derives from `OwinMiddleware`, implements a constructor that accepts an instance of the next middleware in the pipeline as one of its arguments, and then passes it to the base constructor.</span></span> <span data-ttu-id="c5989-271">其他用來設定中介軟體的引數也會在下一個中介軟體參數之後宣告為「函式參數」。</span><span class="sxs-lookup"><span data-stu-id="c5989-271">Additional arguments used to configure the middleware are also declared as constructor parameters after the next middleware parameter.</span></span>   
  
<span data-ttu-id="c5989-272">在執行時間，中介軟體會透過覆寫的 `Invoke` 方法來執行。</span><span class="sxs-lookup"><span data-stu-id="c5989-272">At runtime, the middleware is executed via the overridden `Invoke` method.</span></span> <span data-ttu-id="c5989-273">這個方法會接受 `OwinContext`類型的單一引數。</span><span class="sxs-lookup"><span data-stu-id="c5989-273">This method takes a single argument of type `OwinContext`.</span></span> <span data-ttu-id="c5989-274">此內容物件是由先前所述的 `Microsoft.Owin` NuGet 套件提供，並提供對要求、回應和環境字典的強型別存取權，以及一些額外的協助程式類型。</span><span class="sxs-lookup"><span data-stu-id="c5989-274">This context object is provided by the `Microsoft.Owin` NuGet package described earlier and provides strongly-typed access to the request, response and environment dictionary, along with a few additional helper types.</span></span>   
  
<span data-ttu-id="c5989-275">中介軟體類別可以輕鬆地新增至應用程式啟動程式碼中的 OWIN 管線，如下所示：</span><span class="sxs-lookup"><span data-stu-id="c5989-275">The middleware class can be easily added to the OWIN pipeline in the application startup code as follows:</span></span>   

[!code-csharp[Main](an-overview-of-project-katana/samples/sample10.cs)]

<span data-ttu-id="c5989-276">由於 Katana 基礎結構只會建立 OWIN 中介軟體元件的管線，而且因為元件只需要支援應用程式委派來參與管線，所以中介軟體元件的複雜性可能會從簡單的記錄器到整個架構（例如 ASP.NET、Web API 或[SignalR](../../../signalr/index.md)）。</span><span class="sxs-lookup"><span data-stu-id="c5989-276">Because the Katana infrastructure simply builds up a pipeline of OWIN middleware components, and because the components simply need to support the application delegate to participate in the pipeline, middleware components can range in complexity from simple loggers to entire frameworks like ASP.NET, Web API, or [SignalR](../../../signalr/index.md).</span></span> <span data-ttu-id="c5989-277">例如，將 ASP.NET Web API 新增至先前的 OWIN 管線時，需要新增下列啟動程式碼：</span><span class="sxs-lookup"><span data-stu-id="c5989-277">For example, adding ASP.NET Web API to the previous OWIN pipeline requires adding the following startup code:</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample11.cs)]

<span data-ttu-id="c5989-278">Katana 基礎結構將會根據其在設定方法中新增至 IAppBuilder 物件的順序，建立中介軟體元件的管線。</span><span class="sxs-lookup"><span data-stu-id="c5989-278">The Katana infrastructure will build the pipeline of middleware components based on the order in which they were added to the IAppBuilder object in the Configuration method.</span></span> <span data-ttu-id="c5989-279">在我們的範例中，LoggerMiddleware 可以處理流經管線的所有要求，而不論這些要求的最終處理方式為何。</span><span class="sxs-lookup"><span data-stu-id="c5989-279">In our example, then, LoggerMiddleware can handle all requests that flow through the pipeline, regardless of how those requests are ultimately handled.</span></span> <span data-ttu-id="c5989-280">這可實現功能強大的案例，其中中介軟體元件（例如驗證元件）可以處理包含多個元件和架構之管線（例如 ASP.NET Web API、SignalR 和靜態檔案伺服器）的要求。</span><span class="sxs-lookup"><span data-stu-id="c5989-280">This enables powerful scenarios where a middleware component (e.g. an authentication component) can process requests for a pipeline that includes multiple components and frameworks (e.g. ASP.NET Web API, SignalR, and a static file server).</span></span>
 
## <a name="applications"></a><span data-ttu-id="c5989-281">應用程式</span><span class="sxs-lookup"><span data-stu-id="c5989-281">Applications</span></span>

<span data-ttu-id="c5989-282">如先前範例所述，OWIN 和 Katana 專案不應視為新的應用程式設計模型，而是用來將應用程式設計模型和架構與伺服器和裝載基礎結構分離的抽象概念。</span><span class="sxs-lookup"><span data-stu-id="c5989-282">As illustrated by the previous examples, OWIN and the Katana project should not be thought of as a new application programming model, but rather as an abstraction to decouple application programming models and frameworks from server and hosting infrastructure.</span></span> <span data-ttu-id="c5989-283">例如，建立 Web API 應用程式時，不論應用程式是否使用 Katana 專案中的元件在 OWIN 管線中執行，開發人員架構都會繼續使用 ASP.NET Web API 架構。</span><span class="sxs-lookup"><span data-stu-id="c5989-283">For example, when building Web API applications, the developer framework will continue to use the ASP.NET Web API framework, irrespective of whether or not the application runs in an OWIN pipeline using components from the Katana project.</span></span> <span data-ttu-id="c5989-284">應用程式開發人員可以看見 OWIN 相關程式碼的其中一個地方，就是開發人員撰寫 OWIN 管線的應用程式啟動代碼。</span><span class="sxs-lookup"><span data-stu-id="c5989-284">The one place where OWIN-related code will be visible to the application developer will be the application startup code, where the developer composes the OWIN pipeline.</span></span> <span data-ttu-id="c5989-285">在啟始程式碼中，開發人員會註冊一系列的 UseXx 語句，通常是每個會處理傳入要求的中介軟體元件。</span><span class="sxs-lookup"><span data-stu-id="c5989-285">In the startup code, the developer will register a series of UseXx statements, generally one for each middleware component that will process incoming requests.</span></span> <span data-ttu-id="c5989-286">這項體驗會與在目前的 System.web 環境中註冊 HTTP 模組的效果相同。</span><span class="sxs-lookup"><span data-stu-id="c5989-286">This experience will have the same effect as registering HTTP modules in the current System.Web world.</span></span> <span data-ttu-id="c5989-287">一般而言，較大的架構中介軟體（例如 ASP.NET Web API 或[SignalR](../../../signalr/index.md) ）將會在管線的結章節附註冊。</span><span class="sxs-lookup"><span data-stu-id="c5989-287">Typically, a larger framework middleware, such as ASP.NET Web API or [SignalR](../../../signalr/index.md) will be registered at the end of the pipeline.</span></span> <span data-ttu-id="c5989-288">跨領域中介軟體元件（例如用於驗證或快取的程式）通常會註冊到管線的開頭，讓它們能夠處理稍後在管線中註冊之所有架構和元件的要求。</span><span class="sxs-lookup"><span data-stu-id="c5989-288">Cross-cutting middleware components, such as those for authentication or caching, are generally registered towards the beginning of the pipeline so that they will process requests for all of the frameworks and components registered later in the pipeline.</span></span> <span data-ttu-id="c5989-289">將中介軟體元件與基礎結構元件分開，可讓元件在不同的速度上演進，同時確保整體系統保持穩定。</span><span class="sxs-lookup"><span data-stu-id="c5989-289">This separation of the middleware components from each other and from the underlying infrastructure components enables the components to evolve at different velocities while ensuring that the overall system remains stable.</span></span>

## <a name="components--nuget-packages"></a><span data-ttu-id="c5989-290">元件– NuGet 套件</span><span class="sxs-lookup"><span data-stu-id="c5989-290">Components – NuGet Packages</span></span>

<span data-ttu-id="c5989-291">如同許多目前的程式庫和架構，Katana 專案元件會以一組 NuGet 套件的形式提供。</span><span class="sxs-lookup"><span data-stu-id="c5989-291">Like many current libraries and frameworks, the Katana project components are delivered as a set of NuGet packages.</span></span> <span data-ttu-id="c5989-292">針對即將推出的版本2.0，Katana 套件相依性圖形如下所示。</span><span class="sxs-lookup"><span data-stu-id="c5989-292">For the upcoming version 2.0, the Katana package dependency graph looks as follows.</span></span> <span data-ttu-id="c5989-293">（按一下影像以放大圖片）。</span><span class="sxs-lookup"><span data-stu-id="c5989-293">(Click on image for larger view.)</span></span>

[![](an-overview-of-project-katana/_static/image6.png)](an-overview-of-project-katana/_static/image5.png)

<span data-ttu-id="c5989-294">Katana 專案中幾乎每個套件都會直接或間接相依于 Owin 套件。</span><span class="sxs-lookup"><span data-stu-id="c5989-294">Nearly every package in the Katana project depends, directly or indirectly, on the Owin package.</span></span> <span data-ttu-id="c5989-295">您可能還記得這是包含 IAppBuilder 介面的套件，它提供了 OWIN 規格第4節所述之應用程式啟動順序的具體執行。</span><span class="sxs-lookup"><span data-stu-id="c5989-295">You may remember that this is the package that contains the IAppBuilder interface, which provides a concrete implementation of the application startup sequence described in section 4 of the OWIN specification.</span></span> <span data-ttu-id="c5989-296">此外，許多封裝相依于 Owin，其提供一組協助程式類型來處理 HTTP 要求和回應。</span><span class="sxs-lookup"><span data-stu-id="c5989-296">Additionally, many of the packages depend on Microsoft.Owin, which provides a set of helper types for working with HTTP requests and responses.</span></span> <span data-ttu-id="c5989-297">套件的其餘部分可以分類為裝載基礎結構套件（伺服器或主機）或中介軟體。</span><span class="sxs-lookup"><span data-stu-id="c5989-297">The remainder of the package can be classified as either hosting infrastructure packages (servers or hosts) or middleware.</span></span> <span data-ttu-id="c5989-298">Katana 專案外部的套件和相依性會以橙色顯示。</span><span class="sxs-lookup"><span data-stu-id="c5989-298">Packages and dependencies that are external to the Katana project are displayed in orange.</span></span>

<span data-ttu-id="c5989-299">Katana 2.0 的裝載基礎結構同時包含 SystemWeb 和 HttpListener 型伺服器、使用 OWIN 執行 OWINHOST 應用程式的 OwinHost 套件，以及用於自我裝載 OWIN 應用程式的裝載套件自訂主機（例如主控台應用程式、Windows 服務等）</span><span class="sxs-lookup"><span data-stu-id="c5989-299">The hosting infrastructure for Katana 2.0 includes both the SystemWeb and HttpListener-based servers, the OwinHost package for running OWIN applications using OwinHost.exe, and the Microsoft.Owin.Hosting package for self-hosting OWIN applications in a custom host (e.g. console application, Windows service, etc.)</span></span>

<span data-ttu-id="c5989-300">針對 Katana 2.0，中介軟體元件主要著重于提供不同的驗證方法。</span><span class="sxs-lookup"><span data-stu-id="c5989-300">For Katana 2.0, the middleware components are primarily focused on providing different means of authentication.</span></span> <span data-ttu-id="c5989-301">提供診斷的一個額外中介軟體元件，其可支援 [開始] 和 [錯誤] 頁面。</span><span class="sxs-lookup"><span data-stu-id="c5989-301">One additional middleware component for diagnostics is provided, which enables support for a start and error page.</span></span> <span data-ttu-id="c5989-302">隨著 OWIN 成長到事實上的裝載抽象概念，中介軟體元件的生態系統（由 Microsoft 和協力廠商開發）也會以數位成長。</span><span class="sxs-lookup"><span data-stu-id="c5989-302">As OWIN grows into the de facto hosting abstraction, the ecosystem of middleware components, both those developed by Microsoft and third parties, will also grow in number.</span></span>

## <a name="conclusion"></a><span data-ttu-id="c5989-303">結論</span><span class="sxs-lookup"><span data-stu-id="c5989-303">Conclusion</span></span>

 <span data-ttu-id="c5989-304">從一開始，Katana 專案的目標並不是建立，因此會強制開發人員學習另一個 Web 架構。</span><span class="sxs-lookup"><span data-stu-id="c5989-304">From its beginning, the Katana project's goal has not been to create and thereby force developers to learn yet another Web framework.</span></span> <span data-ttu-id="c5989-305">相反地，目標是要建立一個抽象概念，讓 .NET Web 應用程式開發人員比以前更能選擇更多的選項。</span><span class="sxs-lookup"><span data-stu-id="c5989-305">Rather, the goal has been to create an abstraction to give .NET Web application developers more choice than has previously been possible.</span></span> <span data-ttu-id="c5989-306">藉由將一般 Web 應用程式堆疊的邏輯層分解成一組可取代的元件，Katana 專案可讓整個堆疊中的元件以對那些元件而言合理的速率來改善。</span><span class="sxs-lookup"><span data-stu-id="c5989-306">By breaking up the logical layers of a typical Web application stack into a set of replaceable components, the Katana project enables components throughout the stack to improve at whatever rate makes sense for those components.</span></span> <span data-ttu-id="c5989-307">藉由建立簡單 OWIN 抽象的所有元件，Katana 可讓架構和建置於其之上的應用程式在各種不同的伺服器和主機上都可攜。</span><span class="sxs-lookup"><span data-stu-id="c5989-307">By building all components around the simple OWIN abstraction, Katana enables frameworks and the applications built on top of them to be portable across a variety of different servers and hosts.</span></span> <span data-ttu-id="c5989-308">藉由讓開發人員掌控堆疊，Katana 可確保開發人員對其 Web 堆疊的羽量級或功能豐富程度做出最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="c5989-308">By putting the developer in control of the stack, Katana ensures that the developer makes the ultimate choice about how lightweight or how feature-rich her Web stack should be.</span></span>  

## <a name="for-more-information-about-katana"></a><span data-ttu-id="c5989-309">如需 Katana 的詳細資訊</span><span class="sxs-lookup"><span data-stu-id="c5989-309">For more information about Katana</span></span>

- <span data-ttu-id="c5989-310">GitHub 上的 Katana 專案： [https://github.com/aspnet/AspNetKatana/](https://github.com/aspnet/AspNetKatana/)。</span><span class="sxs-lookup"><span data-stu-id="c5989-310">The Katana project on GitHub: [https://github.com/aspnet/AspNetKatana/](https://github.com/aspnet/AspNetKatana/).</span></span>
- <span data-ttu-id="c5989-311">影片： [ASP.NET 的 Katana 專案 OWIN](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET)，由 Howard Dierking。</span><span class="sxs-lookup"><span data-stu-id="c5989-311">Video: [The Katana Project - OWIN for ASP.NET](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET), by Howard Dierking.</span></span>

## <a name="acknowledgements"></a><span data-ttu-id="c5989-312">通知</span><span class="sxs-lookup"><span data-stu-id="c5989-312">Acknowledgements</span></span>

- <span data-ttu-id="c5989-313">[Rick Anderson](https://blogs.msdn.com/b/rickandy/)：（twitter [@RickAndMSFT](http://twitter.com/RickAndMSFT) ） Rick 是 Microsoft 的資深程式設計作者，著重于 Azure 和 MVC。</span><span class="sxs-lookup"><span data-stu-id="c5989-313">[Rick Anderson](https://blogs.msdn.com/b/rickandy/): (twitter [@RickAndMSFT](http://twitter.com/RickAndMSFT) ) Rick is a senior programming writer for Microsoft focusing on Azure and MVC.</span></span>
- <span data-ttu-id="c5989-314">[Scott Hanselman](http://www.hanselman.com/blog/)：（twitter [@shanselman](https://twitter.com/shanselman) ）</span><span class="sxs-lookup"><span data-stu-id="c5989-314">[Scott Hanselman](http://www.hanselman.com/blog/): (twitter [@shanselman](https://twitter.com/shanselman) )</span></span>
- <span data-ttu-id="c5989-315">[Jon Galloway](https://weblogs.asp.net/jgalloway/default.aspx)：（twitter [@jongalloway](https://twitter.com/jongalloway) ）</span><span class="sxs-lookup"><span data-stu-id="c5989-315">[Jon Galloway](https://weblogs.asp.net/jgalloway/default.aspx): (twitter [@jongalloway](https://twitter.com/jongalloway) )</span></span>
