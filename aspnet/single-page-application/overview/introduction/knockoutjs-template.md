---
uid: single-page-application/overview/introduction/knockoutjs-template
title: 單一頁面應用程式： KnockoutJS 範本 |Microsoft Docs
author: MikeWasson
description: 挖的範本
ms.author: riande
ms.date: 01/30/2013
ms.assetid: f9c07af0-4b20-4b08-af8f-47fc3df169a2
msc.legacyurl: /single-page-application/overview/introduction/knockoutjs-template
msc.type: authoredcontent
ms.openlocfilehash: 3a551db1caa9636eb7f2e04c287d3ef371263584
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/06/2020
ms.locfileid: "78578691"
---
# <a name="single-page-application-knockoutjs-template"></a><span data-ttu-id="d4a4f-103">單一頁面應用程式： KnockoutJS 範本</span><span class="sxs-lookup"><span data-stu-id="d4a4f-103">Single Page Application: KnockoutJS template</span></span>

<span data-ttu-id="d4a4f-104">由[Mike Wasson](https://github.com/MikeWasson)</span><span class="sxs-lookup"><span data-stu-id="d4a4f-104">by [Mike Wasson](https://github.com/MikeWasson)</span></span>

> <span data-ttu-id="d4a4f-105">挖的 MVC 範本是 ASP.NET 和 Web 工具2012.2 的一部分</span><span class="sxs-lookup"><span data-stu-id="d4a4f-105">The Knockout MVC Template is part of ASP.NET and Web Tools 2012.2</span></span>
> 
> [<span data-ttu-id="d4a4f-106">下載 ASP.NET 和 Web 工具2012。2</span><span class="sxs-lookup"><span data-stu-id="d4a4f-106">Download ASP.NET and Web Tools 2012.2</span></span>](https://go.microsoft.com/fwlink/?LinkId=282650)

<span data-ttu-id="d4a4f-107">ASP.NET 和 Web 工具2012.2 更新包含適用于 ASP.NET MVC 4 的單一頁面應用程式（SPA）範本。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-107">The ASP.NET and Web Tools 2012.2 update includes a Single-Page Application (SPA) template for ASP.NET MVC 4.</span></span> <span data-ttu-id="d4a4f-108">此範本的設計目的是讓您快速開始建立互動式用戶端 web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-108">This template is designed to get you started quickly building interactive client-side web apps.</span></span>

<span data-ttu-id="d4a4f-109">「單頁應用程式」（SPA）是 web 應用程式的一般詞彙，它會載入單一 HTML 頁面，然後動態更新頁面，而不是載入新的頁面。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-109">"Single-page application" (SPA) is the general term for a web application that loads a single HTML page and then updates the page dynamically, instead of loading new pages.</span></span> <span data-ttu-id="d4a4f-110">載入初始頁面之後，SPA 會透過 AJAX 要求與伺服器交談。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-110">After the initial page load, the SPA talks with the server through AJAX requests.</span></span>

![](knockoutjs-template/_static/image1.png)

<span data-ttu-id="d4a4f-111">AJAX 是新的，但目前有 JavaScript 架構，可讓您更輕鬆地建立和維護大型的 SPA 應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-111">AJAX is nothing new, but today there are JavaScript frameworks that make it easier to build and maintain a large sophisticated SPA application.</span></span> <span data-ttu-id="d4a4f-112">此外，HTML 5 和 CSS3 可讓您更輕鬆地建立豐富的 Ui。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-112">Also, HTML 5 and CSS3 are making it easier to create rich UIs.</span></span>

<span data-ttu-id="d4a4f-113">為了讓您開始使用，SPA 範本會建立範例「待辦事項清單」應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-113">To get you started, the SPA template creates a sample "To-do list" application.</span></span> <span data-ttu-id="d4a4f-114">在本教學課程中，我們將引導您進行範本的導覽。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-114">In this tutorial, we'll take a guided tour of the template.</span></span> <span data-ttu-id="d4a4f-115">首先，我們將探討待辦事項清單應用程式本身，然後檢查使其正常工作的技術部分。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-115">First we'll look at the To-do list application itself, then examine the technology pieces that make it work.</span></span>

## <a name="create-a-new-spa-template-project"></a><span data-ttu-id="d4a4f-116">建立新的 SPA 範本專案</span><span class="sxs-lookup"><span data-stu-id="d4a4f-116">Create a New SPA Template Project</span></span>

<span data-ttu-id="d4a4f-117">需求：</span><span class="sxs-lookup"><span data-stu-id="d4a4f-117">Requirements:</span></span>

- <span data-ttu-id="d4a4f-118">適用于 Web 的 Visual Studio 2012 或 Visual Studio Express 2012</span><span class="sxs-lookup"><span data-stu-id="d4a4f-118">Visual Studio 2012 or Visual Studio Express 2012 for Web</span></span>
- <span data-ttu-id="d4a4f-119">ASP.NET Web 工具2012.2 更新。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-119">ASP.NET Web Tools 2012.2 update.</span></span> <span data-ttu-id="d4a4f-120">您可以在[這裡](https://www.microsoft.com/web/handlers/webpi.ashx?command=getinstallerredirect&appid=ASPDOTNETandWebTools2012_2)安裝更新。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-120">You can install the update [here](https://www.microsoft.com/web/handlers/webpi.ashx?command=getinstallerredirect&appid=ASPDOTNETandWebTools2012_2).</span></span>

<span data-ttu-id="d4a4f-121">啟動 Visual Studio，然後從 [開始] 頁面選取 [**新增專案**]。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-121">Start Visual Studio and select **New Project** from the Start page.</span></span> <span data-ttu-id="d4a4f-122">或者，**從 [檔案**] 功能表選取 [**新增**]，然後選取 [**專案**]。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-122">Or, from the **File** menu, select **New** and then **Project**.</span></span>

<span data-ttu-id="d4a4f-123">在 [**範本**] 窗格中，選取 [**已安裝的範本**]，然後展開 **C#視覺效果**節點。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-123">In the **Templates** pane, select **Installed Templates** and expand the **Visual C#** node.</span></span> <span data-ttu-id="d4a4f-124">在 **[ C#視覺效果**] 底下，選取 [ **Web**]。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-124">Under **Visual C#**, select **Web**.</span></span> <span data-ttu-id="d4a4f-125">在專案範本清單中，選取 [ **ASP.NET MVC 4 Web 應用程式**]。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-125">In the list of project templates, select **ASP.NET MVC 4 Web Application**.</span></span> <span data-ttu-id="d4a4f-126">為專案命名，然後按一下 [確定]。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-126">Name the project and click **OK**.</span></span>

![](knockoutjs-template/_static/image2.png)

<span data-ttu-id="d4a4f-127">在 [**新增專案**] 中，選取 [**單一頁面應用程式**]。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-127">In the **New Project** wizard, select **Single Page Application**.</span></span>

![](knockoutjs-template/_static/image3.png)

<span data-ttu-id="d4a4f-128">按 F5 鍵建置並執行應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-128">Press F5 to build and run the application.</span></span> <span data-ttu-id="d4a4f-129">當應用程式第一次執行時，它會顯示登入畫面。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-129">When the application first runs, it displays a login screen.</span></span>

![](knockoutjs-template/_static/image4.png)

<span data-ttu-id="d4a4f-130">按一下 [&quot;註冊&quot;] 連結，並建立新的使用者。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-130">Click the &quot;Sign up&quot; link and create a new user.</span></span>

![](knockoutjs-template/_static/image5.png)

<span data-ttu-id="d4a4f-131">在您登入之後，應用程式會建立含有兩個專案的預設待辦事項清單。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-131">After you log in, the application creates a default Todo list with two items.</span></span> <span data-ttu-id="d4a4f-132">您可以按一下 [新增待辦事項清單] 來加入新的清單。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-132">You can click "Add Todo list" to add a new list.</span></span>

![](knockoutjs-template/_static/image6.png)

<span data-ttu-id="d4a4f-133">重新命名清單、將專案新增至清單，然後將它們簽核。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-133">Rename the list, add items to the list, and check them off.</span></span> <span data-ttu-id="d4a4f-134">您也可以刪除專案或刪除整個清單。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-134">You can also delete items or delete an entire list.</span></span> <span data-ttu-id="d4a4f-135">這些變更會自動儲存到伺服器上的資料庫（此時會實際為 LocalDB，因為您是在本機執行應用程式）。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-135">The changes are automatically persisted to a database on the server (actually LocalDB at this point, because you are running the application locally).</span></span>

![](knockoutjs-template/_static/image7.png)

## <a name="architecture-of-the-spa-template"></a><span data-ttu-id="d4a4f-136">SPA 範本的架構</span><span class="sxs-lookup"><span data-stu-id="d4a4f-136">Architecture of the SPA Template</span></span>

<span data-ttu-id="d4a4f-137">下圖顯示應用程式的主要組建區塊。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-137">This diagram shows the main building blocks for the application.</span></span>

![](knockoutjs-template/_static/image8.png)

<span data-ttu-id="d4a4f-138">在伺服器端，ASP.NET MVC 會提供 HTML，並處理以表單為基礎的驗證。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-138">On the server side, ASP.NET MVC serves the HTML and also handles forms-based authentication.</span></span>

<span data-ttu-id="d4a4f-139">ASP.NET Web API 會處理與 ToDoLists 和 ToDoItems 相關的所有要求，包括取得、建立、更新和刪除。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-139">ASP.NET Web API handles all requests that relate to the ToDoLists and ToDoItems, including getting, creating, updating and deleting.</span></span> <span data-ttu-id="d4a4f-140">用戶端會使用 JSON 格式的 Web API 來交換資料。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-140">The client exchanges data with Web API in JSON format.</span></span>

<span data-ttu-id="d4a4f-141">Entity Framework （EF）是 O/RM 層。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-141">Entity Framework (EF) is the O/RM layer.</span></span> <span data-ttu-id="d4a4f-142">它會在 ASP.NET 的物件導向世界和基礎資料庫之間進行協調。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-142">It mediates between the object-oriented world of ASP.NET and the underlying database.</span></span> <span data-ttu-id="d4a4f-143">資料庫使用 LocalDB，但是您可以在 web.config 檔案中變更此設定。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-143">The database uses LocalDB but you can change this in the Web.config file.</span></span> <span data-ttu-id="d4a4f-144">通常您會使用 LocalDB 進行本機開發，然後使用 EF code first 的遷移，部署到伺服器上的 SQL database。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-144">Typically you would use LocalDB for local development and then deploy to a SQL database on the server, using EF code-first migration.</span></span>

<span data-ttu-id="d4a4f-145">在用戶端上，挖的 .js 程式庫會處理來自 AJAX 要求的頁面更新。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-145">On the client side, the Knockout.js library handles page updates from AJAX requests.</span></span> <span data-ttu-id="d4a4f-146">[挖加] 會使用資料系結來同步處理頁面與最新的資料。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-146">Knockout uses data binding to synchronize the page with the latest data.</span></span> <span data-ttu-id="d4a4f-147">如此一來，您就不需要撰寫任何逐步解說 JSON 資料並更新 DOM 的程式碼。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-147">That way, you don't have to write any of the code that walks through the JSON data and updates the DOM.</span></span> <span data-ttu-id="d4a4f-148">相反地，您會將宣告式屬性放在 HTML 中，告訴您如何呈現資料。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-148">Instead, you put declarative attributes in the HTML that tell Knockout how to present the data.</span></span>

<span data-ttu-id="d4a4f-149">此架構的其中一項優點是，它會將展示層與應用程式邏輯隔開。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-149">A big advantage of this architecture is that it separates the presentation layer from the application logic.</span></span> <span data-ttu-id="d4a4f-150">您可以建立 Web API 部分，而不需要知道網頁的外觀。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-150">You can create the Web API portion without knowing anything about how your web page will look.</span></span> <span data-ttu-id="d4a4f-151">在用戶端上，您可以建立「視圖模型」來表示該資料，而視圖模型會使用「挖結」來系結至 HTML。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-151">On the client side, you create a "view model" to represent that data, and the view model uses Knockout to bind to the HTML.</span></span> <span data-ttu-id="d4a4f-152">這可讓您輕鬆地變更 HTML，而不需要變更視圖模型。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-152">That lets you easily change the HTML without changing the view model.</span></span> <span data-ttu-id="d4a4f-153">（我們稍後會探討挖起來）。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-153">(We'll look at Knockout a bit later.)</span></span>

## <a name="models"></a><span data-ttu-id="d4a4f-154">模型</span><span class="sxs-lookup"><span data-stu-id="d4a4f-154">Models</span></span>

<span data-ttu-id="d4a4f-155">在 Visual Studio 專案中，[模型] 資料夾包含伺服器端所使用的模型。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-155">In the Visual Studio project, the Models folder contains the models that are used on the server side.</span></span> <span data-ttu-id="d4a4f-156">（用戶端上也有模型，我們將會取得）。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-156">(There are also models on the client side; we'll get to those.)</span></span>

![](knockoutjs-template/_static/image9.png)

<span data-ttu-id="d4a4f-157">**TodoItem、TodoList**</span><span class="sxs-lookup"><span data-stu-id="d4a4f-157">**TodoItem, TodoList**</span></span>

<span data-ttu-id="d4a4f-158">這些是 Entity Framework Code First 的資料庫模型。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-158">These are the database models for Entity Framework Code First.</span></span> <span data-ttu-id="d4a4f-159">請注意，這些模型具有指向彼此的屬性。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-159">Notice that these models have properties that point to each other.</span></span> <span data-ttu-id="d4a4f-160">`ToDoList` 包含 ToDoItems 的集合，而且每個 `ToDoItem` 都有其父 ToDoList 的參考。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-160">`ToDoList` contains a collection of ToDoItems, and each `ToDoItem` has a reference back to its parent ToDoList.</span></span> <span data-ttu-id="d4a4f-161">這些屬性稱為「導覽屬性」，它們代表待辦事項清單和其待辦專案的一對多關聯性。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-161">These properties are called navigation properties, and they represent the one-to-many relation a to-do list and its to-do items.</span></span>

<span data-ttu-id="d4a4f-162">`ToDoItem` 類別也會使用 **[ForeignKey]** 屬性，指定 `ToDoListId` 是 `ToDoList` 資料表的外鍵。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-162">The `ToDoItem` class also uses the **[ForeignKey]** attribute to specify that `ToDoListId` is a foreign key into the `ToDoList` table.</span></span> <span data-ttu-id="d4a4f-163">這會告訴 EF 將外鍵條件約束加入至資料庫。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-163">This tells EF to add a foreign-key constraint to the database.</span></span>

[!code-csharp[Main](knockoutjs-template/samples/sample1.cs)]

<span data-ttu-id="d4a4f-164">**TodoItemDto, TodoListDto**</span><span class="sxs-lookup"><span data-stu-id="d4a4f-164">**TodoItemDto, TodoListDto**</span></span>

<span data-ttu-id="d4a4f-165">這些類別會定義將傳送至用戶端的資料。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-165">These classes define the data that will be sent to the client.</span></span> <span data-ttu-id="d4a4f-166">「DTO」代表「資料傳輸物件」。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-166">"DTO" stands for "data transfer object."</span></span> <span data-ttu-id="d4a4f-167">DTO 會定義實體如何序列化為 JSON。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-167">The DTO defines how the entities will be serialized into JSON.</span></span> <span data-ttu-id="d4a4f-168">一般來說，使用 Dto 的原因有好幾個：</span><span class="sxs-lookup"><span data-stu-id="d4a4f-168">In general, there are several reasons to use DTOs:</span></span>

- <span data-ttu-id="d4a4f-169">控制要序列化的屬性。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-169">To control which properties are serialized.</span></span> <span data-ttu-id="d4a4f-170">DTO 可以包含來自領域模型的屬性子集。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-170">The DTO can contain a subset of the properties from the domain model.</span></span> <span data-ttu-id="d4a4f-171">基於安全性理由，您可能會這麼做（隱藏敏感性資料），或只是要減少您傳送的資料量。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-171">You might do this for security reasons (to hide sensitive data) or simply to reduce the amount of data that you send.</span></span>
- <span data-ttu-id="d4a4f-172">若要變更資料的形狀（例如，將更複雜的資料結構壓平合併）。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-172">To change the shape of the data – e.g. to flatten a more complex data structure.</span></span>
- <span data-ttu-id="d4a4f-173">若要將任何商務邏輯從 DTO 中排除（關注點分離）。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-173">To keep any business logic out of the DTO (separation of concerns).</span></span>
- <span data-ttu-id="d4a4f-174">如果您的網域模型因某些原因而無法序列化。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-174">If your domain models cannot be serialized for some reason.</span></span> <span data-ttu-id="d4a4f-175">例如，當您序列化物件時，迴圈參考可能會造成問題，方法是在 Web API 中處理這個問題（請參閱[處理迴圈物件參考](../../../web-api/overview/formats-and-model-binding/json-and-xml-serialization.md#handling_circular_object_references)）。但是，使用 DTO 就完全避免此問題。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-175">For example, circular references can cause problems when you serialize an object There are ways to handle this problem in Web API (see [Handling Circular Object References](../../../web-api/overview/formats-and-model-binding/json-and-xml-serialization.md#handling_circular_object_references)); but using a DTO simply avoids the problem altogether.</span></span>

<span data-ttu-id="d4a4f-176">在 SPA 範本中，Dto 包含與網域模型相同的資料。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-176">In the SPA template, the DTOs contains the same data as the domain models.</span></span> <span data-ttu-id="d4a4f-177">不過，它們仍然很有用，因為它們會避免導覽屬性中的迴圈參考，並示範一般 DTO 模式。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-177">However, they are still useful because they avoid circular references from the navigation properties, and they demonstrate the general DTO pattern.</span></span>

<span data-ttu-id="d4a4f-178">**AccountModels.cs**</span><span class="sxs-lookup"><span data-stu-id="d4a4f-178">**AccountModels.cs**</span></span>

<span data-ttu-id="d4a4f-179">此檔案包含網站成員資格的模型。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-179">This file contains models for site membership.</span></span> <span data-ttu-id="d4a4f-180">`UserProfile` 類別會定義成員資格資料庫中使用者設定檔的架構。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-180">The `UserProfile` class defines the schema for user profiles in the membership DB.</span></span> <span data-ttu-id="d4a4f-181">（在此案例中，唯一的資訊是使用者識別碼和使用者名稱）。此檔案中的其他模型類別是用來建立使用者註冊和登入表單。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-181">(In this case, the only information is the user ID and the user name.) The other model classes in this file are used to create the user registration and login forms.</span></span>

## <a name="entity-framework"></a><span data-ttu-id="d4a4f-182">Entity Framework</span><span class="sxs-lookup"><span data-stu-id="d4a4f-182">Entity Framework</span></span>

<span data-ttu-id="d4a4f-183">SPA 範本使用 EF Code First。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-183">The SPA template uses EF Code First.</span></span> <span data-ttu-id="d4a4f-184">在 Code First 開發中，您會先在程式碼中定義模型，然後 EF 會使用模型來建立資料庫。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-184">In Code First development, you define the models first in code, and then EF uses the model to create the database.</span></span> <span data-ttu-id="d4a4f-185">您也可以使用 EF 搭配現有的資料庫（[Database First](https://msdn.microsoft.com/data/jj206878.aspx)）。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-185">You can also use EF with an existing database ([Database First](https://msdn.microsoft.com/data/jj206878.aspx)).</span></span>

<span data-ttu-id="d4a4f-186">[模型] 資料夾中的 `TodoItemContext` 類別衍生自**DbCoNtext**。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-186">The `TodoItemContext` class in the Models folder derives from **DbContext**.</span></span> <span data-ttu-id="d4a4f-187">這個類別會在模型和 EF 之間提供「粘連」。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-187">This class provides the "glue" between the models and EF.</span></span> <span data-ttu-id="d4a4f-188">`TodoItemContext` 包含 `ToDoItem` 集合和 `TodoList` 集合。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-188">The `TodoItemContext` holds a `ToDoItem` collection and a `TodoList` collection.</span></span> <span data-ttu-id="d4a4f-189">若要查詢資料庫，您只需要針對這些集合撰寫 LINQ 查詢即可。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-189">To query the database, you simply write a LINQ query against these collections.</span></span> <span data-ttu-id="d4a4f-190">例如，以下是您可以如何選取使用者 "Alice" 的所有待辦事項清單：</span><span class="sxs-lookup"><span data-stu-id="d4a4f-190">For example, here is how you can select all of the to-do lists for user "Alice":</span></span>

[!code-csharp[Main](knockoutjs-template/samples/sample2.cs)]

<span data-ttu-id="d4a4f-191">您也可以將新的專案加入至集合、更新專案或刪除集合中的專案，並將變更保存至資料庫。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-191">You can also add new items to the collection, update items, or delete items from the collection, and persist the changes to the database.</span></span>

## <a name="aspnet-web-api-controllers"></a><span data-ttu-id="d4a4f-192">ASP.NET Web API 控制器</span><span class="sxs-lookup"><span data-stu-id="d4a4f-192">ASP.NET Web API Controllers</span></span>

<span data-ttu-id="d4a4f-193">在 ASP.NET Web API 中，控制器是處理 HTTP 要求的物件。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-193">In ASP.NET Web API, controllers are objects that handle HTTP requests.</span></span> <span data-ttu-id="d4a4f-194">如前所述，SPA 範本會使用 Web API 來啟用 `ToDoList` 和 `ToDoItem` 實例上的 CRUD 作業。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-194">As mentioned, the SPA template uses Web API to enable CRUD operations on `ToDoList` and `ToDoItem` instances.</span></span> <span data-ttu-id="d4a4f-195">控制器位於解決方案的 [控制器] 資料夾中。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-195">The controllers are located in the Controllers folder of the solution.</span></span>

![](knockoutjs-template/_static/image10.png)

- <span data-ttu-id="d4a4f-196">`TodoController`：處理待辦事項的 HTTP 要求</span><span class="sxs-lookup"><span data-stu-id="d4a4f-196">`TodoController`: Handles HTTP requests for to-do items</span></span>
- <span data-ttu-id="d4a4f-197">`TodoListController`：處理待辦事項清單的 HTTP 要求。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-197">`TodoListController`: Handles HTTP requests for to-do lists.</span></span>

<span data-ttu-id="d4a4f-198">這些名稱很重要，因為 Web API 會比對 URI 路徑與控制器名稱。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-198">These names are significant, because Web API matches the URI path to the controller name.</span></span> <span data-ttu-id="d4a4f-199">（若要瞭解 Web API 如何將 HTTP 要求路由傳送至控制器，請參閱[ASP.NET Web API 中的路由](../../../web-api/overview/web-api-routing-and-actions/routing-in-aspnet-web-api.md)）。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-199">(To learn how Web API routes HTTP requests to controllers, see [Routing in ASP.NET Web API](../../../web-api/overview/web-api-routing-and-actions/routing-in-aspnet-web-api.md).)</span></span>

<span data-ttu-id="d4a4f-200">讓我們看一下 `ToDoListController` 類別。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-200">Let's look at the `ToDoListController` class.</span></span> <span data-ttu-id="d4a4f-201">它包含單一資料成員：</span><span class="sxs-lookup"><span data-stu-id="d4a4f-201">It contains a single data member:</span></span>

[!code-csharp[Main](knockoutjs-template/samples/sample3.cs)]

<span data-ttu-id="d4a4f-202">如先前所述，`TodoItemContext` 用來與 EF 通訊。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-202">The `TodoItemContext` is used to communicate with EF, as described earlier.</span></span> <span data-ttu-id="d4a4f-203">控制器上的方法會執行 CRUD 作業。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-203">The methods on the controller implement the CRUD operations.</span></span> <span data-ttu-id="d4a4f-204">Web API 會將來自用戶端的 HTTP 要求對應到控制器方法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="d4a4f-204">Web API maps HTTP requests from the client to controller methods, as follows:</span></span>

| <span data-ttu-id="d4a4f-205">HTTP 要求</span><span class="sxs-lookup"><span data-stu-id="d4a4f-205">HTTP Request</span></span> | <span data-ttu-id="d4a4f-206">控制器方法</span><span class="sxs-lookup"><span data-stu-id="d4a4f-206">Controller Method</span></span> | <span data-ttu-id="d4a4f-207">說明</span><span class="sxs-lookup"><span data-stu-id="d4a4f-207">Description</span></span> |
| --- | --- | --- |
| <span data-ttu-id="d4a4f-208">GET /api/todo</span><span class="sxs-lookup"><span data-stu-id="d4a4f-208">GET /api/todo</span></span> | `GetTodoLists` | <span data-ttu-id="d4a4f-209">取得待辦事項清單的集合。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-209">Gets a collection of to-do lists.</span></span> |
| <span data-ttu-id="d4a4f-210">取得/api/todo/*識別碼*</span><span class="sxs-lookup"><span data-stu-id="d4a4f-210">GET /api/todo/*id*</span></span> | `GetTodoList` | <span data-ttu-id="d4a4f-211">依識別碼取得待辦事項清單</span><span class="sxs-lookup"><span data-stu-id="d4a4f-211">Gets a to-do list by ID</span></span> |
| <span data-ttu-id="d4a4f-212">PUT/api/todo/*id*</span><span class="sxs-lookup"><span data-stu-id="d4a4f-212">PUT /api/todo/*id*</span></span> | `PutTodoList` | <span data-ttu-id="d4a4f-213">更新待辦事項清單。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-213">Updates a to-do list.</span></span> |
| <span data-ttu-id="d4a4f-214">POST /api/todo</span><span class="sxs-lookup"><span data-stu-id="d4a4f-214">POST /api/todo</span></span> | `PostTodoList` | <span data-ttu-id="d4a4f-215">建立新的待辦事項清單。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-215">Creates a new to-do list.</span></span> |
| <span data-ttu-id="d4a4f-216">刪除/api/todo/*識別碼*</span><span class="sxs-lookup"><span data-stu-id="d4a4f-216">DELETE /api/todo/*id*</span></span> | `DeleteTodoList` | <span data-ttu-id="d4a4f-217">刪除待辦事項清單。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-217">Deletes a TODO list.</span></span> |

<span data-ttu-id="d4a4f-218">請注意，某些作業的 Uri 包含識別碼值的預留位置。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-218">Notice that the URIs for some operations contain placeholders for the ID value.</span></span> <span data-ttu-id="d4a4f-219">例如，若要刪除識別碼為42的清單，URI 為 `/api/todo/42`。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-219">For example, to delete a to-list with an ID of 42, the URI is `/api/todo/42`.</span></span>

<span data-ttu-id="d4a4f-220">若要深入瞭解如何使用 Web API 進行 CRUD 作業，請參閱[建立支援 Crud 作業的 WEB api](../../../web-api/overview/older-versions/creating-a-web-api-that-supports-crud-operations.md)。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-220">To learn more about using Web API for CRUD operations, see [Creating a Web API that Supports CRUD Operations](../../../web-api/overview/older-versions/creating-a-web-api-that-supports-crud-operations.md).</span></span> <span data-ttu-id="d4a4f-221">此控制器的程式碼相當簡單。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-221">The code for this controller is fairly straightforward.</span></span> <span data-ttu-id="d4a4f-222">以下是一些有趣的點：</span><span class="sxs-lookup"><span data-stu-id="d4a4f-222">Here are some interesting points:</span></span>

- <span data-ttu-id="d4a4f-223">`GetTodoLists` 方法會使用 LINQ 查詢，依據登入使用者的識別碼來篩選結果。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-223">The `GetTodoLists` method uses a LINQ query to filter the results by the ID of the logged-in user.</span></span> <span data-ttu-id="d4a4f-224">如此一來，使用者只會看到屬於他或她的資料。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-224">That way, a user only sees the data that belongs to him or her.</span></span> <span data-ttu-id="d4a4f-225">另請注意，Select 語句是用來將 `ToDoList` 實例轉換成 `TodoListDto` 實例。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-225">Also, notice that a Select statement is used to convert the `ToDoList` instances into `TodoListDto` instances.</span></span>
- <span data-ttu-id="d4a4f-226">PUT 和 POST 方法會先檢查模型狀態，然後再修改資料庫。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-226">The PUT and POST methods check the model state before modifying the database.</span></span> <span data-ttu-id="d4a4f-227">如果**ModelState**為 false，則這些方法會傳回 HTTP 400，不正確的要求。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-227">If **ModelState.IsValid** is false, these methods return HTTP 400, Bad Request.</span></span> <span data-ttu-id="d4a4f-228">在[模型驗證](../../../web-api/overview/formats-and-model-binding/model-validation-in-aspnet-web-api.md)中深入瞭解 Web API 中的模型驗證。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-228">Read more about model validation in Web API at [Model Validation](../../../web-api/overview/formats-and-model-binding/model-validation-in-aspnet-web-api.md).</span></span>
- <span data-ttu-id="d4a4f-229">控制器類別也會以 **[授權]** 屬性裝飾。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-229">The controller class is also decorated with the **[Authorize]** attribute.</span></span> <span data-ttu-id="d4a4f-230">這個屬性會檢查 HTTP 要求是否已驗證。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-230">This attribute checks whether the HTTP request is authenticated.</span></span> <span data-ttu-id="d4a4f-231">如果要求未通過驗證，用戶端會收到 HTTP 401 （未經授權）。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-231">If the request is not authenticated, the client receives HTTP 401, Unauthorized.</span></span> <span data-ttu-id="d4a4f-232">[在 ASP.NET Web API 中深入瞭解驗證和授權中](../../../web-api/overview/security/authentication-and-authorization-in-aspnet-web-api.md)的驗證。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-232">Read more about authentication at [Authentication and Authorization in ASP.NET Web API](../../../web-api/overview/security/authentication-and-authorization-in-aspnet-web-api.md).</span></span>

<span data-ttu-id="d4a4f-233">`TodoController` 類別非常類似 `TodoListController`。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-233">The `TodoController` class is very similar to `TodoListController`.</span></span> <span data-ttu-id="d4a4f-234">最大的差別在於它不會定義任何 GET 方法，因為用戶端會取得待辦事項，以及每個待辦事項清單。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-234">The biggest difference is that it does not define any GET methods, because the client will get the to-do items along with each to-do list.</span></span>

## <a name="mvc-controllers-and-views"></a><span data-ttu-id="d4a4f-235">MVC 控制器和 Views</span><span class="sxs-lookup"><span data-stu-id="d4a4f-235">MVC Controllers and Views</span></span>

<span data-ttu-id="d4a4f-236">MVC 控制器也位於解決方案的 [控制器] 資料夾中。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-236">The MVC controllers are also located in the Controllers folder of the solution.</span></span> <span data-ttu-id="d4a4f-237">`HomeController` 呈現應用程式的主要 HTML。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-237">`HomeController` renders the main HTML for the application.</span></span> <span data-ttu-id="d4a4f-238">Home 控制器的視圖定義于 Views/Home/Index. cshtml 中。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-238">The view for the Home controller is defined in Views/Home/Index.cshtml.</span></span> <span data-ttu-id="d4a4f-239">主視圖會根據使用者是否登入，呈現不同的內容：</span><span class="sxs-lookup"><span data-stu-id="d4a4f-239">The Home view renders different content depending on whether the user is logged in:</span></span>

[!code-cshtml[Main](knockoutjs-template/samples/sample4.cshtml)]

<span data-ttu-id="d4a4f-240">當使用者登入時，他們會看到主要 UI。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-240">When users are logged in, they see the main UI.</span></span> <span data-ttu-id="d4a4f-241">否則，他們會看到登入面板。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-241">Otherwise, they see the login panel.</span></span> <span data-ttu-id="d4a4f-242">請注意，此條件式轉譯會在伺服器端進行。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-242">Note that this conditional rendering happens on the server side.</span></span> <span data-ttu-id="d4a4f-243">永遠不會嘗試在用戶端&#8212;上隱藏機密內容。在此情況中，監看未經處理的 HTTP 訊息的人可以看到您在 HTTP 回應中傳送的任何內容。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-243">Never try to hide sensitive content on the client side&#8212;anything that you send in an HTTP response is visible to someone who is watching the raw HTTP messages.</span></span>

## <a name="client-side-javascript-and-knockoutjs"></a><span data-ttu-id="d4a4f-244">用戶端 JavaScript 和挖式 .js</span><span class="sxs-lookup"><span data-stu-id="d4a4f-244">Client-Side JavaScript and Knockout.js</span></span>

<span data-ttu-id="d4a4f-245">現在讓我們從應用程式的伺服器端轉換至用戶端。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-245">Now let's turn from the server side of the application to the client.</span></span> <span data-ttu-id="d4a4f-246">SPA 範本會結合 jQuery 和挖式 .js 來建立流暢的互動式 UI。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-246">The SPA template uses a combination of jQuery and Knockout.js to create a smooth, interactive UI.</span></span> <span data-ttu-id="d4a4f-247">挖式 .js 是 JavaScript 程式庫，可讓您輕鬆地將 HTML 系結至資料。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-247">Knockout.js is a JavaScript library that makes it easy to bind HTML to data.</span></span> <span data-ttu-id="d4a4f-248">挖式 .js 會使用稱為「模型-視圖-ViewModel」的模式。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-248">Knockout.js uses a pattern called "Model-View-ViewModel."</span></span>

- <span data-ttu-id="d4a4f-249">此模型是網域資料（ToDo 清單和 ToDo 專案）。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-249">The model is the domain data (ToDo lists and ToDo items).</span></span>
- <span data-ttu-id="d4a4f-250">此視圖為 HTML 檔案。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-250">The view is the HTML document.</span></span>
- <span data-ttu-id="d4a4f-251">視圖模型是包含模型資料的 JavaScript 物件。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-251">The view-model is a JavaScript object that holds the model data.</span></span> <span data-ttu-id="d4a4f-252">視圖模型是 UI 的程式碼抽象概念。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-252">The view-model is a code abstraction of the UI.</span></span> <span data-ttu-id="d4a4f-253">它不知道 HTML 標記法。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-253">It has no knowledge of the HTML representation.</span></span> <span data-ttu-id="d4a4f-254">相反地，它代表視圖的抽象功能，例如「待辦事項清單」。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-254">Instead, it represents abstract features of the view, such as "a list of ToDo items".</span></span>

<span data-ttu-id="d4a4f-255">此視圖會資料系結至視圖模型。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-255">The view is data-bound to the view-model.</span></span> <span data-ttu-id="d4a4f-256">視圖模型的更新會自動反映在視圖中。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-256">Updates to the view-model are automatically reflected in the view.</span></span> <span data-ttu-id="d4a4f-257">系結也適用于另一個方向。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-257">Bindings work the other direction as well.</span></span> <span data-ttu-id="d4a4f-258">DOM 中的事件（例如按一下）會將資料系結至視圖模型上的函式，以觸發 AJAX 呼叫。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-258">Events in the DOM (such as clicks) are data-bound to functions on the view model, which trigger AJAX calls.</span></span>

<span data-ttu-id="d4a4f-259">SPA 範本會將用戶端 JavaScript 組織成三個層級：</span><span class="sxs-lookup"><span data-stu-id="d4a4f-259">The SPA template organizes the client-side JavaScript into three layers:</span></span>

- <span data-ttu-id="d4a4f-260">todo. datacoNtext：傳送 AJAX 要求。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-260">todo.datacontext.js: Sends AJAX requests.</span></span>
- <span data-ttu-id="d4a4f-261">todo：定義模型。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-261">todo.model.js: Defines the models.</span></span>
- <span data-ttu-id="d4a4f-262">viewmodel .js：定義視圖模型。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-262">todo.viewmodel.js: Defines the view model.</span></span>

![](knockoutjs-template/_static/image11.png)

<span data-ttu-id="d4a4f-263">這些腳本檔案位於解決方案的腳本/應用程式資料夾中。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-263">These script files are located in the Scripts/app folder of the solution.</span></span>

![](knockoutjs-template/_static/image12.png)

<span data-ttu-id="d4a4f-264">**todo。 datacoNtext**會處理對 Web API 控制器的所有 AJAX 呼叫。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-264">**todo.datacontext** handles all AJAX calls to the Web API controllers.</span></span> <span data-ttu-id="d4a4f-265">（在 ajaxlogin 中，會在其他位置定義用於登入的 AJAX 呼叫）。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-265">(The AJAX calls for logging in are defined elsewhere, in ajaxlogin.js.)</span></span>

<span data-ttu-id="d4a4f-266">**todo。 model .js**會定義待辦事項清單的用戶端（瀏覽器）模型。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-266">**todo.model.js** defines the client-side (browser) models for the to-do lists.</span></span> <span data-ttu-id="d4a4f-267">有兩個模型類別： todoItem 和 todoList。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-267">There are two model classes: todoItem and todoList.</span></span>

<span data-ttu-id="d4a4f-268">模型類別中的許多屬性都屬於 "ko. 可觀察" 類型。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-268">Many of the properties in the model classes are of type "ko.observable".</span></span> <span data-ttu-id="d4a4f-269">可預見值是挖的神奇之處。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-269">Observables are how Knockout does its magic.</span></span> <span data-ttu-id="d4a4f-270">從[挖空的檔](http://knockoutjs.com/documentation/introduction.html)：可觀察的是可以通知訂閱者有關變更的「JavaScript 物件」。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-270">From the [Knockout documentation](http://knockoutjs.com/documentation/introduction.html): An observable is a "JavaScript object that can notify subscribers about changes."</span></span> <span data-ttu-id="d4a4f-271">當可觀察的值變更時，挖的會更新系結至這些可預見值的任何 HTML 元素。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-271">When the value of an observable changes, Knockout updates any HTML elements that are bound to those observables.</span></span> <span data-ttu-id="d4a4f-272">例如，todoItem 具有 title 和作業屬性的可預見值：</span><span class="sxs-lookup"><span data-stu-id="d4a4f-272">For example, todoItem has observables for the title and isDone properties:</span></span>

[!code-javascript[Main](knockoutjs-template/samples/sample5.js)]

<span data-ttu-id="d4a4f-273">您也可以在程式碼中訂閱可觀察的。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-273">You can also subscribe to an observable in code.</span></span> <span data-ttu-id="d4a4f-274">例如，todoItem 類別會訂閱 "作業" 和 "title" 屬性中的變更：</span><span class="sxs-lookup"><span data-stu-id="d4a4f-274">For example, the todoItem class subscribes to changes in the "isDone" and "title" properties:</span></span>

[!code-javascript[Main](knockoutjs-template/samples/sample6.js)]

<span data-ttu-id="d4a4f-275">**視圖模型**</span><span class="sxs-lookup"><span data-stu-id="d4a4f-275">**View Model**</span></span>

<span data-ttu-id="d4a4f-276">視圖模型會定義在 viewmodel 中。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-276">The view model is defined in todo.viewmodel.js.</span></span> <span data-ttu-id="d4a4f-277">視圖模型是應用程式將 HTML 網頁元素系結至網域資料的中心點。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-277">The view model is the central point where the application binds the HTML page elements to the domain data.</span></span> <span data-ttu-id="d4a4f-278">在 SPA 範本中，視圖模型包含 todoLists 的可觀察陣列。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-278">In the SPA template, the view model contains an observable array of todoLists.</span></span> <span data-ttu-id="d4a4f-279">視圖模型中的下列程式碼會告訴「挖對」套用系結：</span><span class="sxs-lookup"><span data-stu-id="d4a4f-279">The following code in the view model tells Knockout to apply the bindings:</span></span>

[!code-javascript[Main](knockoutjs-template/samples/sample7.js)]

## <a name="html-and-data-binding"></a><span data-ttu-id="d4a4f-280">HTML 和資料系結</span><span class="sxs-lookup"><span data-stu-id="d4a4f-280">HTML and Data Binding</span></span>

<span data-ttu-id="d4a4f-281">頁面的主要 HTML 定義于 Views/Home/Index. cshtml 中。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-281">The main HTML for the page is defined in Views/Home/Index.cshtml.</span></span> <span data-ttu-id="d4a4f-282">由於我們使用的是資料系結，因此 HTML 只是實際呈現內容的範本。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-282">Because we are using data-binding, the HTML is only a template for what actually gets rendered.</span></span> <span data-ttu-id="d4a4f-283">挖式會使用*宣告*式系結。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-283">Knockout uses *declarative* bindings.</span></span> <span data-ttu-id="d4a4f-284">您可以藉由將「資料系結」屬性加入至專案，將頁面元素系結至資料。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-284">You bind page elements to data by adding a "data-bind" attribute to the element.</span></span> <span data-ttu-id="d4a4f-285">以下是一個非常簡單的範例，取自挖的檔：</span><span class="sxs-lookup"><span data-stu-id="d4a4f-285">Here is a very simple example, taken from the Knockout documentation:</span></span>

[!code-html[Main](knockoutjs-template/samples/sample8.html)]

<span data-ttu-id="d4a4f-286">在此範例中，「挖加」會以 `myItems.count()`的值更新 **&lt;範圍&gt;** 元素的內容。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-286">In this example, Knockout updates the contents of the **&lt;span&gt;** element with the value of `myItems.count()`.</span></span> <span data-ttu-id="d4a4f-287">每當此值變更時，挖的會更新檔。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-287">Whenever this value changes, Knockout updates the document.</span></span>

<span data-ttu-id="d4a4f-288">挖的會提供數種不同的系結類型。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-288">Knockout provides a number of different binding types.</span></span> <span data-ttu-id="d4a4f-289">以下是 SPA 範本中使用的一些系結：</span><span class="sxs-lookup"><span data-stu-id="d4a4f-289">Here are some of the bindings used in the SPA template:</span></span>

- <span data-ttu-id="d4a4f-290">**foreach**：可讓您逐一查看迴圈，並將相同的標記套用至清單中的每個專案。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-290">**foreach**: Lets you iterate through a loop and apply the same markup to each item in the list.</span></span> <span data-ttu-id="d4a4f-291">這是用來呈現待辦事項清單和待辦事項專案。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-291">This is used to render the to-do lists and to-do items.</span></span> <span data-ttu-id="d4a4f-292">在**foreach**中，系結會套用至清單的元素。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-292">Within the **foreach**, the bindings are applied to the elements of the list.</span></span>
- <span data-ttu-id="d4a4f-293">**visible**：用來切換可見度。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-293">**visible**: Used to toggle visibility.</span></span> <span data-ttu-id="d4a4f-294">當集合是空的，或讓錯誤訊息顯示時，隱藏標記。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-294">Hide markup when a collection is empty, or make the error message visible.</span></span>
- <span data-ttu-id="d4a4f-295">**值**：用來填入表單值。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-295">**value**: Used to populate form values.</span></span>
- <span data-ttu-id="d4a4f-296">**按一下**：將 click 事件系結至視圖模型上的函式。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-296">**click**: Binds a click event to a function on the view model.</span></span>

## <a name="anti-csrf-protection"></a><span data-ttu-id="d4a4f-297">反 CSRF 保護</span><span class="sxs-lookup"><span data-stu-id="d4a4f-297">Anti-CSRF Protection</span></span>

<span data-ttu-id="d4a4f-298">跨網站偽造要求（CSRF）是一種攻擊，惡意網站會將要求傳送至使用者目前登入的弱點網站。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-298">Cross-Site Request Forgery (CSRF) is an attack where a malicious site sends a request to a vulnerable site where the user is currently logged in.</span></span> <span data-ttu-id="d4a4f-299">為了協助防止 CSRF 攻擊，ASP.NET MVC 會使用*防偽權杖*，也稱為要求驗證權杖。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-299">To help prevent CSRF attacks, ASP.NET MVC uses *anti-forgery tokens*, also called request verification tokens.</span></span> <span data-ttu-id="d4a4f-300">其概念是伺服器會將隨機產生的權杖放入網頁中。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-300">The idea is that the server puts a randomly generated token into a web page.</span></span> <span data-ttu-id="d4a4f-301">當用戶端將資料提交至伺服器時，它必須在要求訊息中包含此值。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-301">When the client submits data to the server, it must include this value in the request message.</span></span>

<span data-ttu-id="d4a4f-302">防偽 token 可以使用，因為由於相同來源的原則，惡意網頁無法讀取使用者的權杖。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-302">Anti-forgery tokens work because the malicious page cannot read the user's tokens, due to same-origin policies.</span></span> <span data-ttu-id="d4a4f-303">（相同來源原則會防止裝載于兩個不同網站的檔存取彼此的內容）。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-303">(Same-origin policies prevent documents hosted on two different sites from accessing each other's content.)</span></span>

<span data-ttu-id="d4a4f-304">ASP.NET MVC 透過[AntiForgery](https://msdn.microsoft.com/library/system.web.helpers.antiforgery.aspx)類別和[[ValidateAntiForgeryToken]](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute.aspx)屬性，提供反偽造標記的內建支援。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-304">ASP.NET MVC provides built-in support for anti-forgery tokens, through the [AntiForgery](https://msdn.microsoft.com/library/system.web.helpers.antiforgery.aspx) class and the [[ValidateAntiForgeryToken]](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute.aspx) attribute.</span></span> <span data-ttu-id="d4a4f-305">目前，此功能不會內建在 Web API 中。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-305">Currently, this functionality is not built into Web API.</span></span> <span data-ttu-id="d4a4f-306">不過，SPA 範本包含適用于 Web API 的自訂執行。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-306">However, the SPA template includes a custom implementation for Web API.</span></span> <span data-ttu-id="d4a4f-307">這段程式碼定義于 [`ValidateHttpAntiForgeryTokenAttribute`] 類別中，位於解決方案的 [篩選] 資料夾中。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-307">This code is defined in the `ValidateHttpAntiForgeryTokenAttribute` class, which is located in the Filters folder of the solution.</span></span> <span data-ttu-id="d4a4f-308">若要深入瞭解 Web API 中的反 CSRF，請參閱[防止跨網站偽造要求（CSRF）攻擊](../../../web-api/overview/security/preventing-cross-site-request-forgery-csrf-attacks.md)。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-308">To learn more about anti-CSRF in Web API, see [Preventing Cross-Site Request Forgery (CSRF) Attacks](../../../web-api/overview/security/preventing-cross-site-request-forgery-csrf-attacks.md).</span></span>

## <a name="conclusion"></a><span data-ttu-id="d4a4f-309">結論</span><span class="sxs-lookup"><span data-stu-id="d4a4f-309">Conclusion</span></span>

<span data-ttu-id="d4a4f-310">SPA 範本的設計可讓您快速開始撰寫現代化的互動式 web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-310">The SPA template is designed to get you started quickly writing modern, interactive web applications.</span></span> <span data-ttu-id="d4a4f-311">它會使用挖的 .js 程式庫來分隔資料和應用程式邏輯的呈現（HTML 標籤）。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-311">It uses the Knockout.js library to separate presentation (HTML markup) from the data and application logic.</span></span> <span data-ttu-id="d4a4f-312">但是，挖不是您可以用來建立 SPA 的唯一 JavaScript 程式庫。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-312">But Knockout is not the only JavaScript library you can use to create a SPA.</span></span> <span data-ttu-id="d4a4f-313">如果您想要探索一些其他選項，請查看已[建立社區的 SPA 範本](../templates/index.md)。</span><span class="sxs-lookup"><span data-stu-id="d4a4f-313">If you want to explore some other options, take a look at the [community-created SPA templates](../templates/index.md).</span></span>
