---
uid: web-api/overview/error-handling/web-api-global-error-handling
title: ASP.NET Web API 2-ASP.NET 4.x 中的全域錯誤處理
author: davidmatson
description: 概述 ASP.NET 4.x 的 ASP.NET Web API 2 中的全域錯誤處理。
ms.author: riande
ms.date: 02/03/2014
ms.custom: seoapril2019
ms.assetid: bffd7863-f63b-4b23-a13c-372b5492e9fb
msc.legacyurl: /web-api/overview/error-handling/web-api-global-error-handling
msc.type: authoredcontent
ms.openlocfilehash: 94f2d6d31d0b37f9bb0077e6258c70a2dfb1918d
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/06/2020
ms.locfileid: "78557278"
---
# <a name="global-error-handling-in-aspnet-web-api-2"></a><span data-ttu-id="c9d46-103">ASP.NET Web API 2 中的全域錯誤處理</span><span class="sxs-lookup"><span data-stu-id="c9d46-103">Global Error Handling in ASP.NET Web API 2</span></span>

<span data-ttu-id="c9d46-104">依[David Matson](https://github.com/davidmatson)、 [Rick Anderson](https://twitter.com/RickAndMSFT)</span><span class="sxs-lookup"><span data-stu-id="c9d46-104">by [David Matson](https://github.com/davidmatson), [Rick Anderson](https://twitter.com/RickAndMSFT)</span></span>

<span data-ttu-id="c9d46-105">本主題概要說明 ASP.NET 4.x 的 ASP.NET Web API 2 中的全域錯誤處理。</span><span class="sxs-lookup"><span data-stu-id="c9d46-105">This topic provides an overview of global error handling in ASP.NET Web API 2 for ASP.NET 4.x.</span></span> <span data-ttu-id="c9d46-106">現在，Web API 中沒有簡單的方法可全域記錄或處理錯誤。</span><span class="sxs-lookup"><span data-stu-id="c9d46-106">Today there's no easy way in Web API to log or handle errors globally.</span></span> <span data-ttu-id="c9d46-107">某些未處理的例外狀況可以透過[例外狀況篩選器](exception-handling.md)來處理，但是例外狀況篩選無法處理的情況有好幾種。</span><span class="sxs-lookup"><span data-stu-id="c9d46-107">Some unhandled exceptions can be processed via [exception filters](exception-handling.md), but there are a number of cases that exception filters can't handle.</span></span> <span data-ttu-id="c9d46-108">例如:</span><span class="sxs-lookup"><span data-stu-id="c9d46-108">For example:</span></span>

1. <span data-ttu-id="c9d46-109">從控制器建構函式擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c9d46-109">Exceptions thrown from controller constructors.</span></span>
2. <span data-ttu-id="c9d46-110">從訊息處理常式擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c9d46-110">Exceptions thrown from message handlers.</span></span>
3. <span data-ttu-id="c9d46-111">在路由期間擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c9d46-111">Exceptions thrown during routing.</span></span>
4. <span data-ttu-id="c9d46-112">回應內容序列化期間擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c9d46-112">Exceptions thrown during response content serialization .</span></span>

<span data-ttu-id="c9d46-113">我們想要提供一個簡單、一致的方式來記錄和處理這些例外狀況（可能的話）。</span><span class="sxs-lookup"><span data-stu-id="c9d46-113">We want to provide a simple, consistent way to log and handle (where possible) these exceptions.</span></span> 

<span data-ttu-id="c9d46-114">處理例外狀況有兩個主要案例，這是我們可以傳送錯誤回應的情況，而我們只會記錄例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c9d46-114">There are two major cases for handling exceptions, the case where we are able to send an error response and the case where all we can do is log the exception.</span></span> <span data-ttu-id="c9d46-115">第二種情況的範例是當串流回應內容中途擲回例外狀況時。在此情況下，因為狀態碼、標頭和部分內容已在網路上消失，所以傳送新的回應訊息的時間太晚，因此我們只會中止連接。</span><span class="sxs-lookup"><span data-stu-id="c9d46-115">An example for the latter case is when an exception is thrown in the middle of streaming response content; in that case it is too late to send a new response message since the status code, headers, and partial content have already gone across the wire, so we simply abort the connection.</span></span> <span data-ttu-id="c9d46-116">雖然無法處理例外狀況來產生新的回應訊息，但仍支援記錄例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c9d46-116">Even though the exception can't be handled to produce a new response message, we still support logging the exception.</span></span> <span data-ttu-id="c9d46-117">在我們可以偵測到錯誤的情況下，我們可以傳回適當的錯誤回應，如下所示：</span><span class="sxs-lookup"><span data-stu-id="c9d46-117">In cases where we can detect an error, we can return an appropriate error response as shown in the following:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample1.cs?highlight=6)]

### <a name="existing-options"></a><span data-ttu-id="c9d46-118">現有選項</span><span class="sxs-lookup"><span data-stu-id="c9d46-118">Existing Options</span></span>

<span data-ttu-id="c9d46-119">除了例外狀況[篩選](exception-handling.md)之外，現在還可以使用[訊息處理常式](../advanced/http-message-handlers.md)來觀察所有500層級的回應，但是對這些回應採取行動是很艱難的，因為它們缺少原始錯誤的相關內容。</span><span class="sxs-lookup"><span data-stu-id="c9d46-119">In addition to [exception filters](exception-handling.md), [message handlers](../advanced/http-message-handlers.md) can be used today to observe all 500-level responses, but acting on those responses is difficult, as they lack context about the original error.</span></span> <span data-ttu-id="c9d46-120">訊息處理常式也有一些與例外狀況篩選準則相關的限制，它們可以處理這些情況。雖然 Web API 具有追蹤基礎結構來捕捉錯誤狀況，但追蹤基礎結構是為了診斷目的而設計，而且不適合在生產環境中執行。</span><span class="sxs-lookup"><span data-stu-id="c9d46-120">Message handlers also have some of the same limitations as exception filters regarding the cases they can handle.While Web API does have tracing infrastructure that captures error conditions the tracing infrastructure is for diagnostics purposes and is not designed or suited for running in production environments.</span></span> <span data-ttu-id="c9d46-121">全域例外狀況處理和記錄應該是可以在生產環境中執行並插入現有監視解決方案（例如， [ELMAH](https://code.google.com/p/elmah/) ）的服務。</span><span class="sxs-lookup"><span data-stu-id="c9d46-121">Global exception handling and logging should be services that can run during production and be plugged into existing monitoring solutions (for example, [ELMAH](https://code.google.com/p/elmah/) ).</span></span>

### <a name="solution-overview"></a><span data-ttu-id="c9d46-122">方案概觀</span><span class="sxs-lookup"><span data-stu-id="c9d46-122">Solution Overview</span></span>

 <span data-ttu-id="c9d46-123">我們提供兩個新的使用者可取代服務（ [iexceptionlogger 實作](../releases/whats-new-in-aspnet-web-api-21.md)和 IExceptionHandler）來記錄和處理未處理的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c9d46-123">We provide two new user-replaceable services, [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md) and IExceptionHandler, to log and handle unhandled exceptions.</span></span> <span data-ttu-id="c9d46-124">服務非常類似，但有兩個主要差異：</span><span class="sxs-lookup"><span data-stu-id="c9d46-124">The services are very similar, with two main differences:</span></span>

1. <span data-ttu-id="c9d46-125">我們支援註冊多個例外狀況記錄器，但只能登錄一個例外狀況處理常式。</span><span class="sxs-lookup"><span data-stu-id="c9d46-125">We support registering multiple exception loggers but only a single exception handler.</span></span>
2. <span data-ttu-id="c9d46-126">例外狀況記錄器一律會被呼叫，即使我們即將中止連接也一樣。</span><span class="sxs-lookup"><span data-stu-id="c9d46-126">Exception loggers always get called, even if we're about to abort the connection.</span></span> <span data-ttu-id="c9d46-127">只有當我們仍然可以選擇要傳送的回應訊息時，才會呼叫例外狀況處理常式。</span><span class="sxs-lookup"><span data-stu-id="c9d46-127">Exception handlers only get called when we're still able to choose which response message to send.</span></span>

<span data-ttu-id="c9d46-128">這兩種服務都會提供例外狀況內容的存取權，其中包含偵測到例外狀況之位置的相關資訊，特別是[HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx)、 [HttpRequestCoNtext](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx)、擲回的例外狀況和例外狀況來源（下面的詳細資料）。</span><span class="sxs-lookup"><span data-stu-id="c9d46-128">Both services provide access to an exception context containing relevant information from the point where the exception was detected, particularly the [HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx), the [HttpRequestContext](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx), the thrown exception and the exception source (details below).</span></span>

### <a name="design-principles"></a><span data-ttu-id="c9d46-129">設計原則</span><span class="sxs-lookup"><span data-stu-id="c9d46-129">Design Principles</span></span>

1. <span data-ttu-id="c9d46-130">**沒有重大變更**因為這項功能是在次要版本中加入，所以影響解決方案的一個重要條件約束就是不會有任何重大變更，可以是類型合約或行為。</span><span class="sxs-lookup"><span data-stu-id="c9d46-130">**No breaking changes** Because this functionality is being added in a minor release, one important constraint impacting the solution is that there be no breaking changes, either to type contracts or to behavior.</span></span> <span data-ttu-id="c9d46-131">此條件約束會根據現有的 catch 區塊（將例外狀況轉換為500回應）來排除一些清除。</span><span class="sxs-lookup"><span data-stu-id="c9d46-131">This constraint ruled out some cleanup we would like to have done in terms of existing catch blocks turning exceptions into 500 responses.</span></span> <span data-ttu-id="c9d46-132">在後續的主要版本中，我們可能會考慮這項額外的清除作業。</span><span class="sxs-lookup"><span data-stu-id="c9d46-132">This additional cleanup is something we might consider for a subsequent major release.</span></span> <span data-ttu-id="c9d46-133">如果這對您很重要，請在[ASP.NET Web API user voice](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception)進行投票。</span><span class="sxs-lookup"><span data-stu-id="c9d46-133">If this is important to you please vote on it at [ASP.NET Web API user voice](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception).</span></span>
2. <span data-ttu-id="c9d46-134">**維護與 WEB API 結構的一致性**Web API 的篩選器管線是處理跨領域考慮的絕佳方式，可彈性地在動作特定的控制器特定或全域範圍內套用邏輯。</span><span class="sxs-lookup"><span data-stu-id="c9d46-134">**Maintaining consistency with Web API constructs** Web API's filter pipeline is a great way to handle cross-cutting concerns with the flexibility of applying the logic at an action-specific, controller-specific or global scope.</span></span> <span data-ttu-id="c9d46-135">篩選準則（包括例外狀況篩選器）一律會有動作和控制器內容，即使是在全域範圍註冊也一樣。</span><span class="sxs-lookup"><span data-stu-id="c9d46-135">Filters, including exception filters, always have action and controller contexts, even when registered at the global scope.</span></span> <span data-ttu-id="c9d46-136">該合約對篩選而言是合理的，但這表示例外狀況篩選（即使是全域範圍）並不適用于某些例外狀況處理案例，例如來自訊息處理常式的例外狀況，而不存在任何動作或控制器內容。</span><span class="sxs-lookup"><span data-stu-id="c9d46-136">That contract makes sense for filters, but it means that exception filters, even globally scoped ones, aren't a good fit for some exception handling cases, such as exceptions from message handlers, where no action or controller context exists.</span></span> <span data-ttu-id="c9d46-137">如果我們想要使用篩選準則所提供的彈性範圍來處理例外狀況，我們仍然需要例外狀況篩選準則。</span><span class="sxs-lookup"><span data-stu-id="c9d46-137">If we want to use the flexible scoping afforded by filters for exception handling, we still need exception filters.</span></span> <span data-ttu-id="c9d46-138">但是，如果我們需要處理控制器內容以外的例外狀況，我們也需要個別的結構來進行完整全域錯誤處理（沒有控制器內容和動作內容條件約束的專案）。</span><span class="sxs-lookup"><span data-stu-id="c9d46-138">But if we need to handle exception outside of a controller context, we also need a separate construct for full global error handling (something without the controller context and action context constraints).</span></span>

### <a name="when-to-use"></a><span data-ttu-id="c9d46-139">使用時機</span><span class="sxs-lookup"><span data-stu-id="c9d46-139">When to Use</span></span>

- <span data-ttu-id="c9d46-140">例外狀況記錄器是查看 Web API 所捕捉到的所有未處理例外狀況的解決方案。</span><span class="sxs-lookup"><span data-stu-id="c9d46-140">Exception loggers are the solution to seeing all unhandled exception caught by Web API.</span></span>
- <span data-ttu-id="c9d46-141">例外狀況處理常式是自訂 Web API 所攔截到未處理之例外狀況的所有可能回應的解決方案。</span><span class="sxs-lookup"><span data-stu-id="c9d46-141">Exception handlers are the solution for customizing all possible responses to unhandled exceptions caught by Web API.</span></span>
- <span data-ttu-id="c9d46-142">例外狀況篩選是處理與特定動作或控制器相關之未處理例外狀況的最簡單解決方案。</span><span class="sxs-lookup"><span data-stu-id="c9d46-142">Exception filters are the easiest solution for processing the subset unhandled exceptions related to a specific action or controller.</span></span>

### <a name="service-details"></a><span data-ttu-id="c9d46-143">服務詳細資料</span><span class="sxs-lookup"><span data-stu-id="c9d46-143">Service Details</span></span>

 <span data-ttu-id="c9d46-144">例外狀況記錄器和處理常式服務介面是接受個別內容的簡單非同步方法：</span><span class="sxs-lookup"><span data-stu-id="c9d46-144">The exception logger and handler service interfaces are simple async methods taking the respective contexts:</span></span> 

[!code-csharp[Main](web-api-global-error-handling/samples/sample2.cs)]

 <span data-ttu-id="c9d46-145">我們也會為這兩個介面提供基類。</span><span class="sxs-lookup"><span data-stu-id="c9d46-145">We also provide base classes for both of these interfaces.</span></span> <span data-ttu-id="c9d46-146">必須覆寫核心（同步或非同步）方法，才能在建議的時間進行記錄或處理。</span><span class="sxs-lookup"><span data-stu-id="c9d46-146">Overriding the core (sync or async) methods is all that is required to log or handle at the recommended times.</span></span> <span data-ttu-id="c9d46-147">針對記錄，`ExceptionLogger` 基類會確保每個例外狀況只會呼叫一次核心記錄方法（即使稍後再傳播呼叫堆疊並再次攔截）。</span><span class="sxs-lookup"><span data-stu-id="c9d46-147">For logging, the `ExceptionLogger` base class will ensure that the core logging method is only called once for each exception (even if it later propagates further up the call stack and is caught again).</span></span> <span data-ttu-id="c9d46-148">`ExceptionHandler` 基類只會針對呼叫堆疊頂端的例外狀況呼叫核心處理方法，並忽略舊版的嵌套 catch 區塊。</span><span class="sxs-lookup"><span data-stu-id="c9d46-148">The `ExceptionHandler` base class will call the core handling method only for exceptions at the top of the call stack, ignoring legacy nested catch blocks.</span></span> <span data-ttu-id="c9d46-149">（這些基類的簡化版本位於下列附錄中）。`IExceptionLogger` 和 `IExceptionHandler` 都會透過 `ExceptionContext`接收例外狀況的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="c9d46-149">(Simplified versions of these base classes are in the appendix below.) Both `IExceptionLogger` and `IExceptionHandler` receive information about the exception via an `ExceptionContext`.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample3.cs)]

<span data-ttu-id="c9d46-150">當架構呼叫例外狀況記錄器或例外狀況處理常式時，它一律會提供 `Exception` 和 `Request`。</span><span class="sxs-lookup"><span data-stu-id="c9d46-150">When the framework calls an exception logger or an exception handler, it will always provide an `Exception` and a `Request`.</span></span> <span data-ttu-id="c9d46-151">除了單元測試以外，它也一定會提供 `RequestContext`。</span><span class="sxs-lookup"><span data-stu-id="c9d46-151">Except for unit testing, it will also always provide a `RequestContext`.</span></span> <span data-ttu-id="c9d46-152">幾乎不會提供 `ControllerContext` 和 `ActionContext` （只有在從例外狀況篩選的 catch 區塊中呼叫時）。</span><span class="sxs-lookup"><span data-stu-id="c9d46-152">It will rarely provide a `ControllerContext` and `ActionContext` (only when calling from the catch block for exception filters).</span></span> <span data-ttu-id="c9d46-153">這很少會提供 `Response`（僅適用于在嘗試寫入回應的某些 IIS 案例中）。</span><span class="sxs-lookup"><span data-stu-id="c9d46-153">It will very rarely provide a `Response`(only in certain IIS cases when in the middle of trying to write the response).</span></span> <span data-ttu-id="c9d46-154">請注意，因為其中一些屬性可能 `null`，所以取用者必須先檢查 `null`，才能存取例外狀況類別的成員。`CatchBlock`</span><span class="sxs-lookup"><span data-stu-id="c9d46-154">Note that because some of these properties may be `null` it is up to the consumer to check for `null` before accessing members of the exception class.`CatchBlock`</span></span> <span data-ttu-id="c9d46-155">這是一個字串，表示哪個 catch 區塊看到例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c9d46-155">is a string indicating which catch block saw the exception.</span></span> <span data-ttu-id="c9d46-156">Catch 區塊字串如下所示：</span><span class="sxs-lookup"><span data-stu-id="c9d46-156">The catch block strings are as follows:</span></span>

- <span data-ttu-id="c9d46-157">HttpServer （SendAsync 方法）</span><span class="sxs-lookup"><span data-stu-id="c9d46-157">HttpServer (SendAsync method)</span></span>
- <span data-ttu-id="c9d46-158">System.web.HTTP.exceptionhandling.exceptioncatchblocks.HTTPcontrollerdispatcher.sendasync （SendAsync 方法）</span><span class="sxs-lookup"><span data-stu-id="c9d46-158">HttpControllerDispatcher (SendAsync method)</span></span>
- <span data-ttu-id="c9d46-159">System.web.HTTP.exceptionhandling.exceptioncatchblocks.HTTPbatchhandler.sendasync （SendAsync 方法）</span><span class="sxs-lookup"><span data-stu-id="c9d46-159">HttpBatchHandler (SendAsync method)</span></span>
- <span data-ttu-id="c9d46-160">IExceptionFilter （ApiController 在 ExecuteAsync 中處理例外狀況篩選器管線）</span><span class="sxs-lookup"><span data-stu-id="c9d46-160">IExceptionFilter (ApiController's processing of the exception filter pipeline in ExecuteAsync)</span></span>
- <span data-ttu-id="c9d46-161">OWIN 主機：</span><span class="sxs-lookup"><span data-stu-id="c9d46-161">OWIN host:</span></span>

    - <span data-ttu-id="c9d46-162">HttpMessageHandlerAdapter. BufferResponseContentAsync （用於緩衝輸出）</span><span class="sxs-lookup"><span data-stu-id="c9d46-162">HttpMessageHandlerAdapter.BufferResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="c9d46-163">HttpMessageHandlerAdapter. CopyResponseContentAsync （用於串流輸出）</span><span class="sxs-lookup"><span data-stu-id="c9d46-163">HttpMessageHandlerAdapter.CopyResponseContentAsync (for streaming output)</span></span>
- <span data-ttu-id="c9d46-164">Web 主機：</span><span class="sxs-lookup"><span data-stu-id="c9d46-164">Web host:</span></span>

    - <span data-ttu-id="c9d46-165">HttpControllerHandler. System.web.HTTP.webhost.HTTPcontrollerhandler.writebufferedresponsecontentasync 標（用於緩衝輸出）</span><span class="sxs-lookup"><span data-stu-id="c9d46-165">HttpControllerHandler.WriteBufferedResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="c9d46-166">HttpControllerHandler. System.web.HTTP.webhost.HTTPcontrollerhandler.writestreamedresponsecontentasync 標（用於串流輸出）</span><span class="sxs-lookup"><span data-stu-id="c9d46-166">HttpControllerHandler.WriteStreamedResponseContentAsync (for streaming output)</span></span>
    - <span data-ttu-id="c9d46-167">HttpControllerHandler. System.web.HTTP.webhost.HTTPcontrollerhandler.writeerrorresponsecontentasync 標（適用于在緩衝輸出模式下復原錯誤的失敗）</span><span class="sxs-lookup"><span data-stu-id="c9d46-167">HttpControllerHandler.WriteErrorResponseContentAsync (for failures in error recovery under buffered output mode)</span></span>

<span data-ttu-id="c9d46-168">您也可以透過靜態唯讀屬性取得 catch 區塊字串清單。</span><span class="sxs-lookup"><span data-stu-id="c9d46-168">The list of catch block strings is also available via static readonly properties.</span></span> <span data-ttu-id="c9d46-169">（核心 catch 區塊字串位於靜態 ExceptionCatchBlocks 上; 餘數會出現在每個 OWIN 和 web 主機的靜態類別）。`IsTopLevelCatchBlock`</span><span class="sxs-lookup"><span data-stu-id="c9d46-169">(The core catch block string are on the static ExceptionCatchBlocks; the remainder appear on one static class each for OWIN and web host).`IsTopLevelCatchBlock`</span></span> <span data-ttu-id="c9d46-170">有助於在呼叫堆疊的最上方，遵循建議的處理例外狀況模式。</span><span class="sxs-lookup"><span data-stu-id="c9d46-170">is helpful for following the recommended pattern of handling exceptions only at the top of the call stack.</span></span> <span data-ttu-id="c9d46-171">例外狀況處理常式可以讓例外狀況傳播，直到主機即將看到，而不會將例外狀況轉換成500回應。</span><span class="sxs-lookup"><span data-stu-id="c9d46-171">Rather than turning exceptions into 500 responses anywhere a nested catch block occurs, an exception handler can let exceptions propagate until they are about to be seen by the host.</span></span>

<span data-ttu-id="c9d46-172">除了 `ExceptionContext`以外，記錄器還會透過完整的 `ExceptionLoggerContext`取得一項額外的資訊：</span><span class="sxs-lookup"><span data-stu-id="c9d46-172">In addition to the `ExceptionContext`, a logger gets one more piece of information via the full `ExceptionLoggerContext`:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample4.cs)]

<span data-ttu-id="c9d46-173">第二個屬性（`CanBeHandled`）可讓記錄器識別無法處理的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c9d46-173">The second property, `CanBeHandled`, allows a logger to identify an exception that cannot be handled.</span></span> <span data-ttu-id="c9d46-174">當連接即將中止，而且無法傳送新的回應訊息時，將會通話記錄器，但***不***會呼叫此處理程式，而且記錄器可以從這個屬性識別此案例。</span><span class="sxs-lookup"><span data-stu-id="c9d46-174">When the connection is about to be aborted and no new response message can be sent, the loggers will be called but the handler will ***not*** be called, and the loggers can identify this scenario from this property.</span></span>

<span data-ttu-id="c9d46-175">在 `ExceptionContext`中，處理常式會進一步取得一個屬性，它可以在完整 `ExceptionHandlerContext` 上設定來處理例外狀況：</span><span class="sxs-lookup"><span data-stu-id="c9d46-175">In additional to the `ExceptionContext`, a handler gets one more property it can set on the full `ExceptionHandlerContext` to handle the exception:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample5.cs)]

<span data-ttu-id="c9d46-176">例外狀況處理常式會將 `Result` 屬性設定為動作結果（例如， [ExceptionResult](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx)、 [InternalServerErrorResult](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx)、 [StatusCodeResult](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx)或自訂的結果），藉此指出它已處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c9d46-176">An exception handler indicates that it has handled an exception by setting the `Result` property to an action result (for example, an [ExceptionResult](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx), [InternalServerErrorResult](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx), [StatusCodeResult](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx), or a custom result).</span></span> <span data-ttu-id="c9d46-177">如果 `Result` 屬性為 null，就會處理例外狀況，並重新擲回原始例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c9d46-177">If the `Result` property is null, the exception is unhandled and the original exception will be re-thrown.</span></span>

<span data-ttu-id="c9d46-178">對於呼叫堆疊頂端的例外狀況，我們採取額外的步驟，以確保回應適用于 API 呼叫端。</span><span class="sxs-lookup"><span data-stu-id="c9d46-178">For exceptions at the top of the call stack, we took an extra step to ensure the response is appropriate for API callers.</span></span> <span data-ttu-id="c9d46-179">如果例外狀況傳播到主機，則呼叫者會看到死亡的黃色螢幕或一些其他主機提供的回應，這通常是 HTML，通常不是適當的 API 錯誤回應。</span><span class="sxs-lookup"><span data-stu-id="c9d46-179">If the exception propagates up to the host, the caller would see the yellow screen of death or some other host provided response which is typically HTML and not usually an appropriate API error response.</span></span> <span data-ttu-id="c9d46-180">在這些情況下，結果會從非 null 開始，而且只有在自訂例外狀況處理常式明確地將它設回 `null` （未處理）時，例外狀況才會傳播到主機。</span><span class="sxs-lookup"><span data-stu-id="c9d46-180">In these cases, the Result starts out non-null, and only if a custom exception handler explicitly sets it back to `null` (unhandled) will the exception propagate to the host.</span></span> <span data-ttu-id="c9d46-181">在這種情況下，將 `Result` 設定為 `null` 會對兩個案例很有用：</span><span class="sxs-lookup"><span data-stu-id="c9d46-181">Setting `Result` to `null` in such cases can be useful for two scenarios:</span></span>

1. <span data-ttu-id="c9d46-182">OWIN 裝載的 Web API，以及在 Web API 之前註冊的自訂例外狀況處理中介軟體。</span><span class="sxs-lookup"><span data-stu-id="c9d46-182">OWIN hosted Web API with custom exception handling middleware registered before/outside Web API.</span></span>
2. <span data-ttu-id="c9d46-183">透過瀏覽器進行本機的偵錯工具，其中的黃色螢幕會實際為未處理的例外狀況提供有用的回應。</span><span class="sxs-lookup"><span data-stu-id="c9d46-183">Local debugging via a browser, where the yellow screen of death is actually a helpful response for an unhandled exception.</span></span>

<span data-ttu-id="c9d46-184">針對例外狀況記錄器和例外狀況處理常式，如果記錄器或處理常式本身擲回例外狀況，則不會執行任何動作來進行復原。</span><span class="sxs-lookup"><span data-stu-id="c9d46-184">For both exception loggers and exception handlers, we don't do anything to recover if the logger or handler itself throws an exception.</span></span> <span data-ttu-id="c9d46-185">（除了讓例外狀況傳播外，如果您有更好的方法，請在此頁面底部留下意見反應）。例外狀況記錄器和處理常式的合約是它們不應讓例外狀況傳播至其呼叫端;否則，例外狀況將只會傳播，而通常所有的主機都會產生 HTML 錯誤（例如 ASP）。NET 的黃色螢幕）傳送回用戶端（通常不是預期 JSON 或 XML 的 API 呼叫者慣用的選項）。</span><span class="sxs-lookup"><span data-stu-id="c9d46-185">(Other than letting the exception propagate, leave feedback at the bottom of this page if you have a better approach.) The contract for exception loggers and handlers is that they should not let exceptions propagate up to their callers; otherwise, the exception will just propagate, often all the way to the host resulting in an HTML error (like the ASP.NET's yellow screen) being sent back to the client (which usually isn't the preferred option for API callers that expect JSON or XML).</span></span>

## <a name="examples"></a><span data-ttu-id="c9d46-186">範例</span><span class="sxs-lookup"><span data-stu-id="c9d46-186">Examples</span></span>

### <a name="tracing-exception-logger"></a><span data-ttu-id="c9d46-187">追蹤例外狀況記錄器</span><span class="sxs-lookup"><span data-stu-id="c9d46-187">Tracing Exception Logger</span></span>

<span data-ttu-id="c9d46-188">下列例外狀況記錄器會將例外狀況資料傳送至設定的追蹤來源（包括 Visual Studio 中的 [調試輸出] 視窗）。</span><span class="sxs-lookup"><span data-stu-id="c9d46-188">The exception logger below send exception data to configured Trace sources (including the Debug output window in Visual Studio).</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample6.cs)]

### <a name="custom-error-message-exception-handler"></a><span data-ttu-id="c9d46-189">自訂錯誤訊息例外狀況處理常式</span><span class="sxs-lookup"><span data-stu-id="c9d46-189">Custom Error Message Exception Handler</span></span>

<span data-ttu-id="c9d46-190">下列程式會產生用戶端的自訂錯誤回應，包括聯絡支援的電子郵件地址。</span><span class="sxs-lookup"><span data-stu-id="c9d46-190">The following below produces a custom error response to clients, including an email address for contacting support.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample7.cs)]

## <a name="registering-exception-filters"></a><span data-ttu-id="c9d46-191">註冊例外狀況篩選準則</span><span class="sxs-lookup"><span data-stu-id="c9d46-191">Registering Exception Filters</span></span>

<span data-ttu-id="c9d46-192">如果您使用 [ASP.NET MVC 4 Web 應用程式] 專案範本來建立專案，請將您的 Web API 設定程式碼放在 `WebApiConfig` 類別內的 [ *App/_Start* ] 資料夾中：</span><span class="sxs-lookup"><span data-stu-id="c9d46-192">If you use the "ASP.NET MVC 4 Web Application" project template to create your project, put your Web API configuration code inside the `WebApiConfig` class, in the *App/_Start* folder:</span></span>

[!code-csharp[Main](exception-handling/samples/sample7.cs?highlight=5)]

## <a name="appendix-base-class-details"></a><span data-ttu-id="c9d46-193">附錄：基類詳細資料</span><span class="sxs-lookup"><span data-stu-id="c9d46-193">Appendix: Base Class Details</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample8.cs)]
