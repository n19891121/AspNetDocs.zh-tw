---
uid: web-api/overview/error-handling/web-api-global-error-handling
title: ASP.NET Web API 2 中的全域錯誤處理 - ASP.NET 4.x
author: davidmatson
description: ASP.NET 4.x ASP.NET Web API 2 中的全域錯誤處理概述。
ms.author: riande
ms.date: 02/03/2014
ms.custom: seoapril2019
ms.assetid: bffd7863-f63b-4b23-a13c-372b5492e9fb
msc.legacyurl: /web-api/overview/error-handling/web-api-global-error-handling
msc.type: authoredcontent
ms.openlocfilehash: 5ff54d2e4ed881ce927d0a401fb79d9b8bc5b8a1
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/06/2020
ms.locfileid: "80675421"
---
# <a name="global-error-handling-in-aspnet-web-api-2"></a><span data-ttu-id="58d63-103">ASP.NET Web API 2 中的全域錯誤處理</span><span class="sxs-lookup"><span data-stu-id="58d63-103">Global Error Handling in ASP.NET Web API 2</span></span>

<span data-ttu-id="58d63-104">由[大衛·馬特森](https://github.com/davidmatson),[里克·安德森](https://twitter.com/RickAndMSFT)</span><span class="sxs-lookup"><span data-stu-id="58d63-104">by [David Matson](https://github.com/davidmatson), [Rick Anderson](https://twitter.com/RickAndMSFT)</span></span>

<span data-ttu-id="58d63-105">本主題概述了ASP.NET web API 2 中針對ASP.NET 4.x 的全域錯誤處理。</span><span class="sxs-lookup"><span data-stu-id="58d63-105">This topic provides an overview of global error handling in ASP.NET Web API 2 for ASP.NET 4.x.</span></span> <span data-ttu-id="58d63-106">如今,Web API 中沒有簡單的方法來全域記錄或處理錯誤。</span><span class="sxs-lookup"><span data-stu-id="58d63-106">Today there's no easy way in Web API to log or handle errors globally.</span></span> <span data-ttu-id="58d63-107">某些未處理的異常可以通過[異常篩選器](exception-handling.md)進行處理,但有許多異常篩選器無法處理的情況。</span><span class="sxs-lookup"><span data-stu-id="58d63-107">Some unhandled exceptions can be processed via [exception filters](exception-handling.md), but there are a number of cases that exception filters can't handle.</span></span> <span data-ttu-id="58d63-108">例如：</span><span class="sxs-lookup"><span data-stu-id="58d63-108">For example:</span></span>

1. <span data-ttu-id="58d63-109">從控制器建構函式擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="58d63-109">Exceptions thrown from controller constructors.</span></span>
2. <span data-ttu-id="58d63-110">從訊息處理常式擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="58d63-110">Exceptions thrown from message handlers.</span></span>
3. <span data-ttu-id="58d63-111">在路由期間擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="58d63-111">Exceptions thrown during routing.</span></span>
4. <span data-ttu-id="58d63-112">在回應內容序列化期間擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="58d63-112">Exceptions thrown during response content serialization.</span></span>

<span data-ttu-id="58d63-113">我們希望提供一種簡單、一致的方式來記錄和處理這些異常(如果可能)。</span><span class="sxs-lookup"><span data-stu-id="58d63-113">We want to provide a simple, consistent way to log and handle (where possible) these exceptions.</span></span> 

<span data-ttu-id="58d63-114">處理異常有兩個主要情況,即我們能夠發送錯誤回應的情況,以及我們所能做的就是記錄異常的情況。</span><span class="sxs-lookup"><span data-stu-id="58d63-114">There are two major cases for handling exceptions, the case where we are able to send an error response and the case where all we can do is log the exception.</span></span> <span data-ttu-id="58d63-115">后一種情況的一個示例是在流式回應內容中間引發異常時;在流式回應內容中引發異常時,則為後一種情況。在這種情況下,發送新的回應消息為時已晚,因為狀態代碼、標頭和部分內容已經通過導線,因此我們只需中止連接即可。</span><span class="sxs-lookup"><span data-stu-id="58d63-115">An example for the latter case is when an exception is thrown in the middle of streaming response content; in that case it is too late to send a new response message since the status code, headers, and partial content have already gone across the wire, so we simply abort the connection.</span></span> <span data-ttu-id="58d63-116">即使無法處理異常以生成新的回應消息,我們仍支持記錄異常。</span><span class="sxs-lookup"><span data-stu-id="58d63-116">Even though the exception can't be handled to produce a new response message, we still support logging the exception.</span></span> <span data-ttu-id="58d63-117">在可以檢測到錯誤的情況下,我們可以返回適當的錯誤回應,如下所示:</span><span class="sxs-lookup"><span data-stu-id="58d63-117">In cases where we can detect an error, we can return an appropriate error response as shown in the following:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample1.cs?highlight=6)]

### <a name="existing-options"></a><span data-ttu-id="58d63-118">現有選項</span><span class="sxs-lookup"><span data-stu-id="58d63-118">Existing Options</span></span>

<span data-ttu-id="58d63-119">除了[異常篩選器](exception-handling.md)之外,[消息處理程式](../advanced/http-message-handlers.md)今天還可用於觀察所有 500 級回應,但對這些回應進行操作很困難,因為它們缺少有關原始錯誤的上下文。</span><span class="sxs-lookup"><span data-stu-id="58d63-119">In addition to [exception filters](exception-handling.md), [message handlers](../advanced/http-message-handlers.md) can be used today to observe all 500-level responses, but acting on those responses is difficult, as they lack context about the original error.</span></span> <span data-ttu-id="58d63-120">消息處理程式也有一些與異常篩選器相同的限制,涉及它們可以處理的情況。</span><span class="sxs-lookup"><span data-stu-id="58d63-120">Message handlers also have some of the same limitations as exception filters regarding the cases they can handle.</span></span> <span data-ttu-id="58d63-121">雖然 Web API 確實具有捕獲錯誤條件的追蹤基礎結構,但追蹤基礎結構用於診斷目的,並且不適合在生產環境中運行。</span><span class="sxs-lookup"><span data-stu-id="58d63-121">While Web API does have tracing infrastructure that captures error conditions the tracing infrastructure is for diagnostics purposes and is not designed or suited for running in production environments.</span></span> <span data-ttu-id="58d63-122">全域異常處理和日誌記錄應該是可在生產期間運行並插入現有監視解決方案(例如[ELMAH)](https://code.google.com/p/elmah/)的服務。</span><span class="sxs-lookup"><span data-stu-id="58d63-122">Global exception handling and logging should be services that can run during production and be plugged into existing monitoring solutions (for example, [ELMAH](https://code.google.com/p/elmah/)).</span></span>

### <a name="solution-overview"></a><span data-ttu-id="58d63-123">方案概觀</span><span class="sxs-lookup"><span data-stu-id="58d63-123">Solution Overview</span></span>

 <span data-ttu-id="58d63-124">我們提供兩種新的用戶可替換服務[,IexceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md)和IexceptionHandler,用於記錄和處理未處理的異常。</span><span class="sxs-lookup"><span data-stu-id="58d63-124">We provide two new user-replaceable services, [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md) and IExceptionHandler, to log and handle unhandled exceptions.</span></span> <span data-ttu-id="58d63-125">服務非常相似,主要有兩個區別:</span><span class="sxs-lookup"><span data-stu-id="58d63-125">The services are very similar, with two main differences:</span></span>

1. <span data-ttu-id="58d63-126">我們支援註冊多個異常記錄器,但僅支援單個異常處理程式。</span><span class="sxs-lookup"><span data-stu-id="58d63-126">We support registering multiple exception loggers but only a single exception handler.</span></span>
2. <span data-ttu-id="58d63-127">異常記錄器總是被調用,即使我們即將中止連接。</span><span class="sxs-lookup"><span data-stu-id="58d63-127">Exception loggers always get called, even if we're about to abort the connection.</span></span> <span data-ttu-id="58d63-128">只有在我們仍可以選擇要發送的回應消息時,才會調用異常處理程式。</span><span class="sxs-lookup"><span data-stu-id="58d63-128">Exception handlers only get called when we're still able to choose which response message to send.</span></span>

<span data-ttu-id="58d63-129">這兩個服務都提供從檢測到異常點包含相關信息的異常上下文的訪問,特別是[HttpRequestMessage、HttpRequestContext、](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx)引發異常和異常源(詳情見下文[HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx))。</span><span class="sxs-lookup"><span data-stu-id="58d63-129">Both services provide access to an exception context containing relevant information from the point where the exception was detected, particularly the [HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx), the [HttpRequestContext](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx), the thrown exception and the exception source (details below).</span></span>

### <a name="design-principles"></a><span data-ttu-id="58d63-130">設計原則</span><span class="sxs-lookup"><span data-stu-id="58d63-130">Design Principles</span></span>

1. <span data-ttu-id="58d63-131">**沒有變更**由於此功能是在次要版本中添加的,因此影響解決方案的一個重要約束是,對於類型協定或行為,沒有重大更改。</span><span class="sxs-lookup"><span data-stu-id="58d63-131">**No breaking changes** Because this functionality is being added in a minor release, one important constraint impacting the solution is that there be no breaking changes, either to type contracts or to behavior.</span></span> <span data-ttu-id="58d63-132">此約束排除了我們希望在現有 catch 塊方面進行的一些清理,將異常轉換為 500 個回應。</span><span class="sxs-lookup"><span data-stu-id="58d63-132">This constraint ruled out some cleanup we would like to have done in terms of existing catch blocks turning exceptions into 500 responses.</span></span> <span data-ttu-id="58d63-133">對於後續的主要版本,我們可以考慮此附加清理。</span><span class="sxs-lookup"><span data-stu-id="58d63-133">This additional cleanup is something we might consider for a subsequent major release.</span></span> <span data-ttu-id="58d63-134">如果這對你很重要,請[ASP.NETWeb API 用戶語音](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception)投。</span><span class="sxs-lookup"><span data-stu-id="58d63-134">If this is important to you please vote on it at [ASP.NET Web API user voice](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception).</span></span>
2. <span data-ttu-id="58d63-135">**與 Web API 建構保持一致性**Web API 的篩選器管道是處理跨領域問題的絕佳方法,它可靈活地將邏輯應用於特定於操作、特定於控制器或全域的範圍。</span><span class="sxs-lookup"><span data-stu-id="58d63-135">**Maintaining consistency with Web API constructs** Web API's filter pipeline is a great way to handle cross-cutting concerns with the flexibility of applying the logic at an action-specific, controller-specific or global scope.</span></span> <span data-ttu-id="58d63-136">篩選器(包括異常篩選器)始終具有操作和控制器上下文,即使在全域作用域中註冊也是如此。</span><span class="sxs-lookup"><span data-stu-id="58d63-136">Filters, including exception filters, always have action and controller contexts, even when registered at the global scope.</span></span> <span data-ttu-id="58d63-137">該協定對篩選器有意義,但它意味著異常篩選器(即使是全域範圍篩選器)不適合某些異常處理情況,例如消息處理程序的異常,其中不存在操作或控制器上下文。</span><span class="sxs-lookup"><span data-stu-id="58d63-137">That contract makes sense for filters, but it means that exception filters, even globally scoped ones, aren't a good fit for some exception handling cases, such as exceptions from message handlers, where no action or controller context exists.</span></span> <span data-ttu-id="58d63-138">如果我們想要使用篩選器提供的靈活範圍來處理異常處理,我們仍然需要異常篩選器。</span><span class="sxs-lookup"><span data-stu-id="58d63-138">If we want to use the flexible scoping afforded by filters for exception handling, we still need exception filters.</span></span> <span data-ttu-id="58d63-139">但是,如果需要在控制器上下文之外處理異常,我們還需要一個單獨的構造來進行完整的全域錯誤處理(沒有控制器上下文和操作上下文約束)。</span><span class="sxs-lookup"><span data-stu-id="58d63-139">But if we need to handle exception outside of a controller context, we also need a separate construct for full global error handling (something without the controller context and action context constraints).</span></span>

### <a name="when-to-use"></a><span data-ttu-id="58d63-140">使用時機</span><span class="sxs-lookup"><span data-stu-id="58d63-140">When to Use</span></span>

- <span data-ttu-id="58d63-141">異常記錄器是查看 Web API 捕獲的所有未處理異常的解決方案。</span><span class="sxs-lookup"><span data-stu-id="58d63-141">Exception loggers are the solution to seeing all unhandled exception caught by Web API.</span></span>
- <span data-ttu-id="58d63-142">異常處理程式是自訂 Web API 捕獲的未處理異常的所有可能回應的解決方案。</span><span class="sxs-lookup"><span data-stu-id="58d63-142">Exception handlers are the solution for customizing all possible responses to unhandled exceptions caught by Web API.</span></span>
- <span data-ttu-id="58d63-143">異常篩選器是處理與特定操作或控制器相關的子集未處理異常的最簡單解決方案。</span><span class="sxs-lookup"><span data-stu-id="58d63-143">Exception filters are the easiest solution for processing the subset unhandled exceptions related to a specific action or controller.</span></span>

### <a name="service-details"></a><span data-ttu-id="58d63-144">服務詳細資料</span><span class="sxs-lookup"><span data-stu-id="58d63-144">Service Details</span></span>

 <span data-ttu-id="58d63-145">例外紀錄器與處理程式服務介面是採用相應上下文的簡單非同步方法:</span><span class="sxs-lookup"><span data-stu-id="58d63-145">The exception logger and handler service interfaces are simple async methods taking the respective contexts:</span></span> 

[!code-csharp[Main](web-api-global-error-handling/samples/sample2.cs)]

 <span data-ttu-id="58d63-146">我們還為這兩個介面提供基類。</span><span class="sxs-lookup"><span data-stu-id="58d63-146">We also provide base classes for both of these interfaces.</span></span> <span data-ttu-id="58d63-147">重寫核心(同步或非同步)方法是在建議的時間記錄或處理所需的全部方法。</span><span class="sxs-lookup"><span data-stu-id="58d63-147">Overriding the core (sync or async) methods is all that is required to log or handle at the recommended times.</span></span> <span data-ttu-id="58d63-148">對於日誌記錄,`ExceptionLogger`基類將確保每個異常只調用一次核心日誌記錄方法(即使它稍後在調用堆棧上傳播並進一步傳播並再次捕獲)。</span><span class="sxs-lookup"><span data-stu-id="58d63-148">For logging, the `ExceptionLogger` base class will ensure that the core logging method is only called once for each exception (even if it later propagates further up the call stack and is caught again).</span></span> <span data-ttu-id="58d63-149">基`ExceptionHandler`類將僅針對調用堆疊頂部的異常調用核心處理方法,而忽略舊嵌套 catch 塊。</span><span class="sxs-lookup"><span data-stu-id="58d63-149">The `ExceptionHandler` base class will call the core handling method only for exceptions at the top of the call stack, ignoring legacy nested catch blocks.</span></span> <span data-ttu-id="58d63-150">(這些基類的簡化版本見下面的附錄。與`IExceptionLogger``IExceptionHandler`都透過接收有關的`ExceptionContext`資訊 。</span><span class="sxs-lookup"><span data-stu-id="58d63-150">(Simplified versions of these base classes are in the appendix below.) Both `IExceptionLogger` and `IExceptionHandler` receive information about the exception via an `ExceptionContext`.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample3.cs)]

<span data-ttu-id="58d63-151">當框架呼叫例外紀錄器或例外處理程式時,它會始終提供與`Exception` `Request` 。</span><span class="sxs-lookup"><span data-stu-id="58d63-151">When the framework calls an exception logger or an exception handler, it will always provide an `Exception` and a `Request`.</span></span> <span data-ttu-id="58d63-152">除了單元測試外,它還會始終提供`RequestContext`。</span><span class="sxs-lookup"><span data-stu-id="58d63-152">Except for unit testing, it will also always provide a `RequestContext`.</span></span> <span data-ttu-id="58d63-153">它很少提供`ControllerContext``ActionContext`和 (僅在從異常篩選器的 catch 塊調用時)。</span><span class="sxs-lookup"><span data-stu-id="58d63-153">It will rarely provide a `ControllerContext` and `ActionContext` (only when calling from the catch block for exception filters).</span></span> <span data-ttu-id="58d63-154">它很少提供`Response`(僅在某些 IIS 情況下,當嘗試編寫回應時)。</span><span class="sxs-lookup"><span data-stu-id="58d63-154">It will very rarely provide a `Response`(only in certain IIS cases when in the middle of trying to write the response).</span></span> <span data-ttu-id="58d63-155">請注意,由於其中一些屬性可能`null`由消費者在訪問異常類的`null`成員 之前進行檢查。`CatchBlock`</span><span class="sxs-lookup"><span data-stu-id="58d63-155">Note that because some of these properties may be `null` it is up to the consumer to check for `null` before accessing members of the exception class.`CatchBlock`</span></span> <span data-ttu-id="58d63-156">是指示哪個 catch 塊看到異常的字串。</span><span class="sxs-lookup"><span data-stu-id="58d63-156">is a string indicating which catch block saw the exception.</span></span> <span data-ttu-id="58d63-157">catch 塊字串如下所示:</span><span class="sxs-lookup"><span data-stu-id="58d63-157">The catch block strings are as follows:</span></span>

- <span data-ttu-id="58d63-158">HttpServer(傳送同步方法)</span><span class="sxs-lookup"><span data-stu-id="58d63-158">HttpServer (SendAsync method)</span></span>
- <span data-ttu-id="58d63-159">HTTPController 調度程式 (傳送同步方法)</span><span class="sxs-lookup"><span data-stu-id="58d63-159">HttpControllerDispatcher (SendAsync method)</span></span>
- <span data-ttu-id="58d63-160">HTTPBatchhandler(傳送同步方法)</span><span class="sxs-lookup"><span data-stu-id="58d63-160">HttpBatchHandler (SendAsync method)</span></span>
- <span data-ttu-id="58d63-161">IExceptionFilter(ApiController 在 ExecuteAsync 中處理異常篩選器導管)</span><span class="sxs-lookup"><span data-stu-id="58d63-161">IExceptionFilter (ApiController's processing of the exception filter pipeline in ExecuteAsync)</span></span>
- <span data-ttu-id="58d63-162">OWIN 主機:</span><span class="sxs-lookup"><span data-stu-id="58d63-162">OWIN host:</span></span>

    - <span data-ttu-id="58d63-163">HTTPMessageHandlerAdapter.緩衝區回應內容同步(用於緩衝輸出)</span><span class="sxs-lookup"><span data-stu-id="58d63-163">HttpMessageHandlerAdapter.BufferResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="58d63-164">HTTPMessageHandlerAdapter.複製回應內容同步(用於流式處理輸出)</span><span class="sxs-lookup"><span data-stu-id="58d63-164">HttpMessageHandlerAdapter.CopyResponseContentAsync (for streaming output)</span></span>
- <span data-ttu-id="58d63-165">網路主機:</span><span class="sxs-lookup"><span data-stu-id="58d63-165">Web host:</span></span>

    - <span data-ttu-id="58d63-166">HTTPControllerHandler.寫入緩衝回應內容同步(用於緩衝輸出)</span><span class="sxs-lookup"><span data-stu-id="58d63-166">HttpControllerHandler.WriteBufferedResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="58d63-167">HTTPControllerHandler.寫入流式回應內容同步(用於流式處理輸出)</span><span class="sxs-lookup"><span data-stu-id="58d63-167">HttpControllerHandler.WriteStreamedResponseContentAsync (for streaming output)</span></span>
    - <span data-ttu-id="58d63-168">HTTPControllerHandler.寫入錯誤回應內容同步(對於緩衝輸出模式下錯誤復原失敗)</span><span class="sxs-lookup"><span data-stu-id="58d63-168">HttpControllerHandler.WriteErrorResponseContentAsync (for failures in error recovery under buffered output mode)</span></span>

<span data-ttu-id="58d63-169">catch 塊字串的清單也可通過靜態唯讀屬性提供。</span><span class="sxs-lookup"><span data-stu-id="58d63-169">The list of catch block strings is also available via static readonly properties.</span></span> <span data-ttu-id="58d63-170">(核心 catch 塊字串位於靜態異常捕獲塊上;其餘字串出現在一個靜態類中,每個靜態類用於 OWIN 和 Web 主機)。`IsTopLevelCatchBlock`</span><span class="sxs-lookup"><span data-stu-id="58d63-170">(The core catch block string are on the static ExceptionCatchBlocks; the remainder appear on one static class each for OWIN and web host).`IsTopLevelCatchBlock`</span></span> <span data-ttu-id="58d63-171">有助於遵循僅在調用堆疊頂部處理異常的建議模式。</span><span class="sxs-lookup"><span data-stu-id="58d63-171">is helpful for following the recommended pattern of handling exceptions only at the top of the call stack.</span></span> <span data-ttu-id="58d63-172">異常處理程式可以允許異常傳播到主機即將看到之前,而不是將異常轉換為 500 個回應。</span><span class="sxs-lookup"><span data-stu-id="58d63-172">Rather than turning exceptions into 500 responses anywhere a nested catch block occurs, an exception handler can let exceptions propagate until they are about to be seen by the host.</span></span>

<span data-ttu-id="58d63-173">除了`ExceptionContext`, 記錄器`ExceptionLoggerContext`通過完整 獲取了一條資訊:</span><span class="sxs-lookup"><span data-stu-id="58d63-173">In addition to the `ExceptionContext`, a logger gets one more piece of information via the full `ExceptionLoggerContext`:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample4.cs)]

<span data-ttu-id="58d63-174">第二個屬性`CanBeHandled`允許記錄器標識無法處理的異常。</span><span class="sxs-lookup"><span data-stu-id="58d63-174">The second property, `CanBeHandled`, allows a logger to identify an exception that cannot be handled.</span></span> <span data-ttu-id="58d63-175">當連線即將中止,並且無法傳送新的回應訊息時,將呼叫紀錄器,但不會呼叫處理程式,並且記錄器可以從此屬性識別此***not***方案 。</span><span class="sxs-lookup"><span data-stu-id="58d63-175">When the connection is about to be aborted and no new response message can be sent, the loggers will be called but the handler will ***not*** be called, and the loggers can identify this scenario from this property.</span></span>

<span data-ttu-id="58d63-176">在`ExceptionContext`除 中,處理程式還可以獲取一個可以設置在`ExceptionHandlerContext`full 上處理異常的屬性:</span><span class="sxs-lookup"><span data-stu-id="58d63-176">In additional to the `ExceptionContext`, a handler gets one more property it can set on the full `ExceptionHandlerContext` to handle the exception:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample5.cs)]

<span data-ttu-id="58d63-177">`Result`例外處理程式透過設定為操作結果(例如,[異常結果](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx),[內部伺服器錯誤結果](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx),[狀態代碼結果](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx)或自訂結果)來指示它已處理異常。</span><span class="sxs-lookup"><span data-stu-id="58d63-177">An exception handler indicates that it has handled an exception by setting the `Result` property to an action result (for example, an [ExceptionResult](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx), [InternalServerErrorResult](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx), [StatusCodeResult](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx), or a custom result).</span></span> <span data-ttu-id="58d63-178">如果`Result`屬性為 null,則異常將未處理,並且將重新引發原始異常。</span><span class="sxs-lookup"><span data-stu-id="58d63-178">If the `Result` property is null, the exception is unhandled and the original exception will be re-thrown.</span></span>

<span data-ttu-id="58d63-179">對於調用堆疊頂部的異常,我們採取了額外的步驟,以確保回應適合 API 調用方。</span><span class="sxs-lookup"><span data-stu-id="58d63-179">For exceptions at the top of the call stack, we took an extra step to ensure the response is appropriate for API callers.</span></span> <span data-ttu-id="58d63-180">如果異常傳播到主機,調用方將看到死亡黃色螢幕或其他一些主機提供的回應,這些回應通常是 HTML,通常不是適當的 API 錯誤回應。</span><span class="sxs-lookup"><span data-stu-id="58d63-180">If the exception propagates up to the host, the caller would see the yellow screen of death or some other host provided response which is typically HTML and not usually an appropriate API error response.</span></span> <span data-ttu-id="58d63-181">在這些情況下,結果開始為非空,只有當自定義異常處理程式顯式將其設置回`null`(未處理)時,異常才會傳播到主機。</span><span class="sxs-lookup"><span data-stu-id="58d63-181">In these cases, the Result starts out non-null, and only if a custom exception handler explicitly sets it back to `null` (unhandled) will the exception propagate to the host.</span></span> <span data-ttu-id="58d63-182">在這種情況下`Result`,`null`設定為 可用於以下兩種情況:</span><span class="sxs-lookup"><span data-stu-id="58d63-182">Setting `Result` to `null` in such cases can be useful for two scenarios:</span></span>

1. <span data-ttu-id="58d63-183">OWIN 託管 Web API,具有在 Web API 之前 / 外部註冊的自訂異常處理中間件。</span><span class="sxs-lookup"><span data-stu-id="58d63-183">OWIN hosted Web API with custom exception handling middleware registered before/outside Web API.</span></span>
2. <span data-ttu-id="58d63-184">通過瀏覽器進行本地調試,其中死亡黃色螢幕實際上是對未處理異常的有用回應。</span><span class="sxs-lookup"><span data-stu-id="58d63-184">Local debugging via a browser, where the yellow screen of death is actually a helpful response for an unhandled exception.</span></span>

<span data-ttu-id="58d63-185">對於異常記錄器和異常處理程式,如果記錄器或處理程式本身引發異常,則不執行任何恢復操作。</span><span class="sxs-lookup"><span data-stu-id="58d63-185">For both exception loggers and exception handlers, we don't do anything to recover if the logger or handler itself throws an exception.</span></span> <span data-ttu-id="58d63-186">(除了讓異常傳播外,如果您有更好的方法,請將反饋保留在此頁面的底部。異常記錄器和處理程式的協定是,它們不應讓異常傳播到其調用方;否則,異常將只傳播到主機,導致 HTML 錯誤(如 ASP)。NET 的黃色螢幕)被發送回用戶端(對於希望 JSON 或 XML 的 API 調用方來說,這通常不是首選選項)。</span><span class="sxs-lookup"><span data-stu-id="58d63-186">(Other than letting the exception propagate, leave feedback at the bottom of this page if you have a better approach.) The contract for exception loggers and handlers is that they should not let exceptions propagate up to their callers; otherwise, the exception will just propagate, often all the way to the host resulting in an HTML error (like ASP.NET's yellow screen) being sent back to the client (which usually isn't the preferred option for API callers that expect JSON or XML).</span></span>

## <a name="examples"></a><span data-ttu-id="58d63-187">範例</span><span class="sxs-lookup"><span data-stu-id="58d63-187">Examples</span></span>

### <a name="tracing-exception-logger"></a><span data-ttu-id="58d63-188">追蹤例外記錄器</span><span class="sxs-lookup"><span data-stu-id="58d63-188">Tracing Exception Logger</span></span>

<span data-ttu-id="58d63-189">下面的異常記錄器將異常數據發送到配置的跟蹤源(包括 Visual Studio 中的調試輸出視窗)。</span><span class="sxs-lookup"><span data-stu-id="58d63-189">The exception logger below sends exception data to configured Trace sources (including the Debug output window in Visual Studio).</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample6.cs)]

### <a name="custom-error-message-exception-handler"></a><span data-ttu-id="58d63-190">自訂錯誤訊息異常處理程式</span><span class="sxs-lookup"><span data-stu-id="58d63-190">Custom Error Message Exception Handler</span></span>

<span data-ttu-id="58d63-191">下面的異常處理程式生成對用戶端的自定義錯誤回應,包括用於聯繫支援的電子郵寄地址。</span><span class="sxs-lookup"><span data-stu-id="58d63-191">The exception handler below produces a custom error response to clients, including an email address for contacting support.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample7.cs)]

## <a name="registering-exception-filters"></a><span data-ttu-id="58d63-192">註冊例外篩選器</span><span class="sxs-lookup"><span data-stu-id="58d63-192">Registering Exception Filters</span></span>

<span data-ttu-id="58d63-193">如果使用「ASP.NET MVC 4 Web 應用程式」專案範本建立專案,請將`WebApiConfig`Web API 設定代碼 放入類別中,放入*App_Start*資料夾中:</span><span class="sxs-lookup"><span data-stu-id="58d63-193">If you use the "ASP.NET MVC 4 Web Application" project template to create your project, put your Web API configuration code inside the `WebApiConfig` class, in the *App_Start* folder:</span></span>

[!code-csharp[Main](exception-handling/samples/sample7.cs?highlight=5)]

## <a name="appendix-base-class-details"></a><span data-ttu-id="58d63-194">附錄:基本課程詳細資訊</span><span class="sxs-lookup"><span data-stu-id="58d63-194">Appendix: Base Class Details</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample8.cs)]
