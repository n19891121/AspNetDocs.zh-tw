---
uid: mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-cs
title: '反復專案 #5 –建立單元測試C#（） |Microsoft Docs'
author: microsoft
description: 在第五個反復專案中，我們會藉由新增單元測試，讓應用程式更容易維護和修改。 我們會模擬我們的資料模型類別，並建立適用于 o 的單元測試 。
ms.author: riande
ms.date: 02/20/2009
ms.assetid: 28ad8f80-b8a5-444e-b478-8b15a846060c
msc.legacyurl: /mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-cs
msc.type: authoredcontent
ms.openlocfilehash: 32e81cce34a0e0b1f6b01934334e1b66dce89651
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/06/2020
ms.locfileid: "78544300"
---
# <a name="iteration-5--create-unit-tests-c"></a><span data-ttu-id="2dd02-104">反復專案 #5 –建立單元測試C#（）</span><span class="sxs-lookup"><span data-stu-id="2dd02-104">Iteration #5 – Create unit tests (C#)</span></span>

<span data-ttu-id="2dd02-105">由[Microsoft](https://github.com/microsoft)</span><span class="sxs-lookup"><span data-stu-id="2dd02-105">by [Microsoft](https://github.com/microsoft)</span></span>

[<span data-ttu-id="2dd02-106">下載程式代碼</span><span class="sxs-lookup"><span data-stu-id="2dd02-106">Download Code</span></span>](iteration-5-create-unit-tests-cs/_static/contactmanager_5_cs1.zip)

> <span data-ttu-id="2dd02-107">在第五個反復專案中，我們會藉由新增單元測試，讓應用程式更容易維護和修改。</span><span class="sxs-lookup"><span data-stu-id="2dd02-107">In the fifth iteration, we make our application easier to maintain and modify by adding unit tests.</span></span> <span data-ttu-id="2dd02-108">我們會模擬我們的資料模型類別，並為我們的控制器和驗證邏輯建立單元測試。</span><span class="sxs-lookup"><span data-stu-id="2dd02-108">We mock our data model classes and build unit tests for our controllers and validation logic.</span></span>

## <a name="building-a-contact-management-aspnet-mvc-application-c"></a><span data-ttu-id="2dd02-109">建立連絡人管理 ASP.NET MVC 應用程式（C#）</span><span class="sxs-lookup"><span data-stu-id="2dd02-109">Building a Contact Management ASP.NET MVC Application (C#)</span></span>

<span data-ttu-id="2dd02-110">在這一系列的教學課程中，我們從一開始就建立了整個連絡人管理應用程式。</span><span class="sxs-lookup"><span data-stu-id="2dd02-110">In this series of tutorials, we build an entire Contact Management application from start to finish.</span></span> <span data-ttu-id="2dd02-111">連絡人管理員應用程式可讓您儲存連絡人資訊名稱、電話號碼和電子郵件地址，以取得人員清單。</span><span class="sxs-lookup"><span data-stu-id="2dd02-111">The Contact Manager application enables you to store contact information - names, phone numbers and email addresses - for a list of people.</span></span>

<span data-ttu-id="2dd02-112">我們會透過多個反復專案來建立應用程式。</span><span class="sxs-lookup"><span data-stu-id="2dd02-112">We build the application over multiple iterations.</span></span> <span data-ttu-id="2dd02-113">在每次反覆運算時，我們會逐漸改善應用程式。</span><span class="sxs-lookup"><span data-stu-id="2dd02-113">With each iteration, we gradually improve the application.</span></span> <span data-ttu-id="2dd02-114">這個多個反復專案方法的目標，是要讓您瞭解每項變更的原因。</span><span class="sxs-lookup"><span data-stu-id="2dd02-114">The goal of this multiple iteration approach is to enable you to understand the reason for each change.</span></span>

- <span data-ttu-id="2dd02-115">反復專案 #1-建立應用程式。</span><span class="sxs-lookup"><span data-stu-id="2dd02-115">Iteration #1 - Create the application.</span></span> <span data-ttu-id="2dd02-116">在第一個反復專案中，我們會以最簡單的方式建立連絡人管理員。</span><span class="sxs-lookup"><span data-stu-id="2dd02-116">In the first iteration, we create the Contact Manager in the simplest way possible.</span></span> <span data-ttu-id="2dd02-117">我們新增對基本資料庫作業的支援：建立、讀取、更新和刪除（CRUD）。</span><span class="sxs-lookup"><span data-stu-id="2dd02-117">We add support for basic database operations: Create, Read, Update, and Delete (CRUD).</span></span>

- <span data-ttu-id="2dd02-118">反復專案 #2-讓應用程式看起來不錯。</span><span class="sxs-lookup"><span data-stu-id="2dd02-118">Iteration #2 - Make the application look nice.</span></span> <span data-ttu-id="2dd02-119">在此反復專案中，我們藉由修改預設的 ASP.NET MVC view 主版頁面和級聯樣式表，來改善應用程式的外觀。</span><span class="sxs-lookup"><span data-stu-id="2dd02-119">In this iteration, we improve the appearance of the application by modifying the default ASP.NET MVC view master page and cascading style sheet.</span></span>

- <span data-ttu-id="2dd02-120">反復專案 #3-新增表單驗證。</span><span class="sxs-lookup"><span data-stu-id="2dd02-120">Iteration #3 - Add form validation.</span></span> <span data-ttu-id="2dd02-121">在第三個反復專案中，我們會新增基本表單驗證。</span><span class="sxs-lookup"><span data-stu-id="2dd02-121">In the third iteration, we add basic form validation.</span></span> <span data-ttu-id="2dd02-122">我們會防止人們提交表單，而不需要完成必要的表單欄位。</span><span class="sxs-lookup"><span data-stu-id="2dd02-122">We prevent people from submitting a form without completing required form fields.</span></span> <span data-ttu-id="2dd02-123">我們也會驗證電子郵件地址和電話號碼。</span><span class="sxs-lookup"><span data-stu-id="2dd02-123">We also validate email addresses and phone numbers.</span></span>

- <span data-ttu-id="2dd02-124">反復專案 #4-讓應用程式鬆散結合。</span><span class="sxs-lookup"><span data-stu-id="2dd02-124">Iteration #4 - Make the application loosely coupled.</span></span> <span data-ttu-id="2dd02-125">在這第四次的反復專案中，我們會利用數種軟體設計模式，讓您更輕鬆地維護和修改 Contact Manager 應用程式。</span><span class="sxs-lookup"><span data-stu-id="2dd02-125">In this fourth iteration, we take advantage of several software design patterns to make it easier to maintain and modify the Contact Manager application.</span></span> <span data-ttu-id="2dd02-126">例如，我們會重構應用程式，以使用存放庫模式和相依性插入模式。</span><span class="sxs-lookup"><span data-stu-id="2dd02-126">For example, we refactor our application to use the Repository pattern and the Dependency Injection pattern.</span></span>

- <span data-ttu-id="2dd02-127">反復專案 #5-建立單元測試。</span><span class="sxs-lookup"><span data-stu-id="2dd02-127">Iteration #5 - Create unit tests.</span></span> <span data-ttu-id="2dd02-128">在第五個反復專案中，我們會藉由新增單元測試，讓應用程式更容易維護和修改。</span><span class="sxs-lookup"><span data-stu-id="2dd02-128">In the fifth iteration, we make our application easier to maintain and modify by adding unit tests.</span></span> <span data-ttu-id="2dd02-129">我們會模擬我們的資料模型類別，並為我們的控制器和驗證邏輯建立單元測試。</span><span class="sxs-lookup"><span data-stu-id="2dd02-129">We mock our data model classes and build unit tests for our controllers and validation logic.</span></span>

- <span data-ttu-id="2dd02-130">反復專案 #6-使用以測試為導向的開發。</span><span class="sxs-lookup"><span data-stu-id="2dd02-130">Iteration #6 - Use test-driven development.</span></span> <span data-ttu-id="2dd02-131">在此第六個反復專案中，我們會先撰寫單元測試，並針對單元測試撰寫程式碼，以將新功能加入至應用程式。</span><span class="sxs-lookup"><span data-stu-id="2dd02-131">In this sixth iteration, we add new functionality to our application by writing unit tests first and writing code against the unit tests.</span></span> <span data-ttu-id="2dd02-132">在此反復專案中，我們會新增連絡人群組。</span><span class="sxs-lookup"><span data-stu-id="2dd02-132">In this iteration, we add contact groups.</span></span>

- <span data-ttu-id="2dd02-133">反復專案 #7-新增 Ajax 功能。</span><span class="sxs-lookup"><span data-stu-id="2dd02-133">Iteration #7 - Add Ajax functionality.</span></span> <span data-ttu-id="2dd02-134">在第七次的反復專案中，我們藉由新增 Ajax 的支援來改善應用程式的回應性和效能。</span><span class="sxs-lookup"><span data-stu-id="2dd02-134">In the seventh iteration, we improve the responsiveness and performance of our application by adding support for Ajax.</span></span>

## <a name="this-iteration"></a><span data-ttu-id="2dd02-135">這個反復專案</span><span class="sxs-lookup"><span data-stu-id="2dd02-135">This Iteration</span></span>

<span data-ttu-id="2dd02-136">在連絡人管理員應用程式的上一個反復專案中，我們重構了應用程式，以進行更鬆散的結合。</span><span class="sxs-lookup"><span data-stu-id="2dd02-136">In the previous iteration of the Contact Manager application, we refactored the application to be more loosely coupled.</span></span> <span data-ttu-id="2dd02-137">我們將應用程式分成不同的控制器、服務和儲存機制層。</span><span class="sxs-lookup"><span data-stu-id="2dd02-137">We separated the application into distinct controller, service, and repository layers.</span></span> <span data-ttu-id="2dd02-138">每一層都會透過介面與其底下的圖層互動。</span><span class="sxs-lookup"><span data-stu-id="2dd02-138">Each layer interacts with the layer beneath it through interfaces.</span></span>

<span data-ttu-id="2dd02-139">我們已重構應用程式，讓應用程式更容易維護和修改。</span><span class="sxs-lookup"><span data-stu-id="2dd02-139">We refactored the application to make the application easier to maintain and modify.</span></span> <span data-ttu-id="2dd02-140">例如，如果我們需要使用新的資料存取技術，我們可以直接變更存放庫層，而不需要觸及控制器或服務層。</span><span class="sxs-lookup"><span data-stu-id="2dd02-140">For example, if we need to use a new data access technology, we can simply change the repository layer without touching the controller or service layer.</span></span> <span data-ttu-id="2dd02-141">藉由讓連絡人管理員鬆散結合，我們讓應用程式更有彈性地進行變更。</span><span class="sxs-lookup"><span data-stu-id="2dd02-141">By making the Contact Manager loosely coupled, we ve made the application more resilient to change.</span></span>

<span data-ttu-id="2dd02-142">但是，當我們需要將新功能加入至 Contact Manager 應用程式時，會發生什麼事？</span><span class="sxs-lookup"><span data-stu-id="2dd02-142">But, what happens when we need to add a new feature to the Contact Manager application?</span></span> <span data-ttu-id="2dd02-143">或者，當我們修正 bug 時，會發生什麼事？</span><span class="sxs-lookup"><span data-stu-id="2dd02-143">Or, what happens when we fix a bug?</span></span> <span data-ttu-id="2dd02-144">不過，只要您接觸程式碼，就會產生新 bug 的風險，但這是一項很好的證明，那就是撰寫程式碼的事實。</span><span class="sxs-lookup"><span data-stu-id="2dd02-144">A sad, but well proven, truth of writing code is that whenever you touch code you create the risk of introducing new bugs.</span></span>

<span data-ttu-id="2dd02-145">例如，您的經理可能會要求您將新功能新增至連絡人管理員。</span><span class="sxs-lookup"><span data-stu-id="2dd02-145">For example, one fine day, your manager might ask you to add a new feature to the Contact Manager.</span></span> <span data-ttu-id="2dd02-146">她想要加入連絡人群組的支援。</span><span class="sxs-lookup"><span data-stu-id="2dd02-146">She wants you to add support for Contact Groups.</span></span> <span data-ttu-id="2dd02-147">她希望您可以讓使用者將他們的連絡人組織成像是朋友、Business 等等的群組。</span><span class="sxs-lookup"><span data-stu-id="2dd02-147">She wants you to enable users to organize their contacts into groups such as Friends, Business, and so on.</span></span>

<span data-ttu-id="2dd02-148">若要執行這項新功能，您必須修改 Contact Manager 應用程式的全部三個層級。</span><span class="sxs-lookup"><span data-stu-id="2dd02-148">In order to implement this new feature, you'll need to modify all three layers of the Contact Manager application.</span></span> <span data-ttu-id="2dd02-149">您必須將新功能新增至控制器、服務層和存放庫。</span><span class="sxs-lookup"><span data-stu-id="2dd02-149">You'll need to add new functionality to the controllers, the service layer, and the repository.</span></span> <span data-ttu-id="2dd02-150">一旦您開始修改程式碼，就會有風險的重大功能。</span><span class="sxs-lookup"><span data-stu-id="2dd02-150">As soon as you start modifying code, you risk breaking functionality that worked before.</span></span>

<span data-ttu-id="2dd02-151">將我們的應用程式重構成不同的層級，如同我們在先前的反復專案中所做的，是個好的。</span><span class="sxs-lookup"><span data-stu-id="2dd02-151">Refactoring our application into separate layers, as we did in the previous iteration, was a good thing.</span></span> <span data-ttu-id="2dd02-152">這是件好事，因為它可讓我們對整個階層進行變更，而不需要觸及應用程式的其餘部分。</span><span class="sxs-lookup"><span data-stu-id="2dd02-152">It was a good thing because it enables us to make changes to entire layers without touching the rest of the application.</span></span> <span data-ttu-id="2dd02-153">不過，如果您想要讓某一層中的程式碼更容易維護和修改，您必須建立程式碼的單元測試。</span><span class="sxs-lookup"><span data-stu-id="2dd02-153">However, if you want to make the code within a layer easier to maintain and modify, you need to create unit tests for the code.</span></span>

<span data-ttu-id="2dd02-154">您可以使用單元測試來測試個別的程式碼單位。</span><span class="sxs-lookup"><span data-stu-id="2dd02-154">You use a unit test to test an individual unit of code.</span></span> <span data-ttu-id="2dd02-155">這些程式碼單位小於整個應用層。</span><span class="sxs-lookup"><span data-stu-id="2dd02-155">These units of code are smaller than entire application layers.</span></span> <span data-ttu-id="2dd02-156">一般來說，您會使用單元測試來驗證程式代碼中的特定方法是否以您預期的方式運作。</span><span class="sxs-lookup"><span data-stu-id="2dd02-156">Typically, you use a unit test to verify whether a particular method in your code behaves in the way that you expect.</span></span> <span data-ttu-id="2dd02-157">例如，您可以為 ContactManagerService 類別所公開的 CreateContact （）方法建立單元測試。</span><span class="sxs-lookup"><span data-stu-id="2dd02-157">For example, you would create a unit test for the CreateContact() method exposed by the ContactManagerService class.</span></span>

<span data-ttu-id="2dd02-158">應用程式的單元測試就像安全的網路一樣。</span><span class="sxs-lookup"><span data-stu-id="2dd02-158">The unit tests for an application work just like a safety net.</span></span> <span data-ttu-id="2dd02-159">每當您修改應用程式中的程式碼時，您可以執行一組單元測試，以檢查修改是否會中斷現有的功能。</span><span class="sxs-lookup"><span data-stu-id="2dd02-159">Whenever you modify code in an application, you can run a set of unit tests to check whether the modification breaks existing functionality.</span></span> <span data-ttu-id="2dd02-160">單元測試可讓您的程式碼安全地進行修改。</span><span class="sxs-lookup"><span data-stu-id="2dd02-160">Unit tests make your code safe to modify.</span></span> <span data-ttu-id="2dd02-161">單元測試可讓您應用程式中的所有程式碼更有彈性地進行變更。</span><span class="sxs-lookup"><span data-stu-id="2dd02-161">Unit tests make all of the code in your application more resilient to change.</span></span>

<span data-ttu-id="2dd02-162">在此反復專案中，我們會將單元測試新增至連絡人管理員應用程式。</span><span class="sxs-lookup"><span data-stu-id="2dd02-162">In this iteration, we add unit tests to our Contact Manager application.</span></span> <span data-ttu-id="2dd02-163">如此一來，在下一個反復專案中，我們可以將連絡人群組新增至應用程式，而不必擔心中斷現有的功能。</span><span class="sxs-lookup"><span data-stu-id="2dd02-163">That way, in the next iteration, we can add Contact Groups to our application without worrying about breaking existing functionality.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="2dd02-164">有各種單元測試架構，包括 NUnit、xUnit.net 和 MbUnit。</span><span class="sxs-lookup"><span data-stu-id="2dd02-164">There are a variety of unit testing frameworks including NUnit, xUnit.net, and MbUnit.</span></span> <span data-ttu-id="2dd02-165">在本教學課程中，我們會使用 Visual Studio 隨附的單元測試架構。</span><span class="sxs-lookup"><span data-stu-id="2dd02-165">In this tutorial, we use the unit testing framework included with Visual Studio.</span></span> <span data-ttu-id="2dd02-166">不過，您可以輕鬆地使用其中一個替代架構。</span><span class="sxs-lookup"><span data-stu-id="2dd02-166">However, you could just as easily use one of these alternative frameworks.</span></span>

## <a name="what-gets-tested"></a><span data-ttu-id="2dd02-167">已測試的內容</span><span class="sxs-lookup"><span data-stu-id="2dd02-167">What Gets Tested</span></span>

<span data-ttu-id="2dd02-168">在完美的世界中，單元測試會涵蓋所有程式碼。</span><span class="sxs-lookup"><span data-stu-id="2dd02-168">In the perfect world, all of your code would be covered by unit tests.</span></span> <span data-ttu-id="2dd02-169">在完美的世界中，您會有完美的安全網路。</span><span class="sxs-lookup"><span data-stu-id="2dd02-169">In the perfect world, you would have the perfect safety net.</span></span> <span data-ttu-id="2dd02-170">無論變更是否中斷現有的功能，您都可以藉由執行單元測試來修改應用程式中的任何程式程式碼，並立即得知。</span><span class="sxs-lookup"><span data-stu-id="2dd02-170">You would be able to modify any line of code in your application and know instantly, by executing your unit tests, whether the change broke existing functionality.</span></span>

<span data-ttu-id="2dd02-171">不過，我們不會在完美的世界中生活。</span><span class="sxs-lookup"><span data-stu-id="2dd02-171">However, we don t live in a perfect world.</span></span> <span data-ttu-id="2dd02-172">實際上，撰寫單元測試時，您會專注于撰寫商務邏輯的測試（例如，驗證邏輯）。</span><span class="sxs-lookup"><span data-stu-id="2dd02-172">In practice, when writing unit tests, you concentrate on writing tests for your business logic (for example, validation logic).</span></span> <span data-ttu-id="2dd02-173">特別的是，您*不會*為數據存取邏輯或您的 view 邏輯撰寫單元測試。</span><span class="sxs-lookup"><span data-stu-id="2dd02-173">In particular, you *do not* write unit tests for your data access logic or your view logic.</span></span>

<span data-ttu-id="2dd02-174">單元測試必須非常快速地執行，才能發揮效用。</span><span class="sxs-lookup"><span data-stu-id="2dd02-174">To be useful, unit tests must execute very quickly.</span></span> <span data-ttu-id="2dd02-175">您可以輕鬆地累積應用程式的數百個（甚至數千個）單元測試。</span><span class="sxs-lookup"><span data-stu-id="2dd02-175">You easily can accumulate hundreds (or even thousands) of unit tests for an application.</span></span> <span data-ttu-id="2dd02-176">如果單元測試需要很長的時間來執行，則您會避免執行它們。</span><span class="sxs-lookup"><span data-stu-id="2dd02-176">If the unit tests take a long time to run then you'll avoid executing them.</span></span> <span data-ttu-id="2dd02-177">換句話說，長時間執行的單元測試在日常編碼的用途上毫無用處。</span><span class="sxs-lookup"><span data-stu-id="2dd02-177">In other words, long running unit tests are useless for day to day coding purposes.</span></span>

<span data-ttu-id="2dd02-178">因此，您通常不會針對與資料庫互動的程式碼撰寫單元測試。</span><span class="sxs-lookup"><span data-stu-id="2dd02-178">For this reason, you typically do not write unit tests for code that interacts with a database.</span></span> <span data-ttu-id="2dd02-179">對即時資料庫執行數百個單元測試的速度太慢。</span><span class="sxs-lookup"><span data-stu-id="2dd02-179">Running hundreds of unit tests against a live database would be too slow.</span></span> <span data-ttu-id="2dd02-180">相反地，您會模擬資料庫，並撰寫與模擬資料庫互動的程式碼（我們會在下面討論模擬資料庫）。</span><span class="sxs-lookup"><span data-stu-id="2dd02-180">Instead, you mock your database and write code that interacts with the mock database (we discuss mocking a database below).</span></span>

<span data-ttu-id="2dd02-181">基於類似的理由，您通常不會針對 views 撰寫單元測試。</span><span class="sxs-lookup"><span data-stu-id="2dd02-181">For a similar reason, you typically do not write unit tests for views.</span></span> <span data-ttu-id="2dd02-182">為了測試檢視，您必須啟動 web 伺服器。</span><span class="sxs-lookup"><span data-stu-id="2dd02-182">In order to test a view, you must spin up a web server.</span></span> <span data-ttu-id="2dd02-183">由於啟動網頁伺服器是相當緩慢的程式，因此不建議您為您的視圖建立單元測試。</span><span class="sxs-lookup"><span data-stu-id="2dd02-183">Because spinning up a web server is a relatively slow process, creating unit tests for your views is not recommended.</span></span>

<span data-ttu-id="2dd02-184">如果您的視圖包含複雜的邏輯，則您應該考慮將邏輯移至 Helper 方法中。</span><span class="sxs-lookup"><span data-stu-id="2dd02-184">If your view contains complicated logic then you should consider moving the logic into Helper methods.</span></span> <span data-ttu-id="2dd02-185">您可以針對執行的 Helper 方法撰寫單元測試，而不需要啟動 web 伺服器。</span><span class="sxs-lookup"><span data-stu-id="2dd02-185">You can write unit tests for Helper methods that execute without spinning up a web server.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="2dd02-186">在撰寫單元測試時，撰寫資料存取邏輯或 view 邏輯的測試並不是個好主意，而在建立功能或整合測試時，這些測試可能非常有説明。</span><span class="sxs-lookup"><span data-stu-id="2dd02-186">While writing tests for data access logic or view logic is not a good idea when writing unit tests, these tests can be very valuable when building functional or integration tests.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="2dd02-187">ASP.NET MVC 是 Web Forms View 引擎。</span><span class="sxs-lookup"><span data-stu-id="2dd02-187">ASP.NET MVC is the Web Forms View Engine.</span></span> <span data-ttu-id="2dd02-188">雖然 Web form View 引擎相依于 web 伺服器，但其他視圖引擎可能不是。</span><span class="sxs-lookup"><span data-stu-id="2dd02-188">While the Web Forms View Engine is dependent on a web server, other view engines might not be.</span></span>

## <a name="using-a-mock-object-framework"></a><span data-ttu-id="2dd02-189">使用 Mock 物件架構</span><span class="sxs-lookup"><span data-stu-id="2dd02-189">Using a Mock Object Framework</span></span>

<span data-ttu-id="2dd02-190">在建立單元測試時，您幾乎都需要利用 Mock 物件架構。</span><span class="sxs-lookup"><span data-stu-id="2dd02-190">When building unit tests, you almost always need to take advantage of a Mock Object framework.</span></span> <span data-ttu-id="2dd02-191">Mock 物件架構可讓您在應用程式中建立類別的模擬和 stub。</span><span class="sxs-lookup"><span data-stu-id="2dd02-191">A Mock Object framework enables you to create mocks and stubs for the classes in your application.</span></span>

<span data-ttu-id="2dd02-192">例如，您可以使用 Mock 物件架構來產生存放庫類別的模擬版本。</span><span class="sxs-lookup"><span data-stu-id="2dd02-192">For example, you can use a Mock Object framework to generate a mock version of your repository class.</span></span> <span data-ttu-id="2dd02-193">如此一來，您就可以在單元測試中使用模擬儲存機制類別，而不是實際的儲存機制類別。</span><span class="sxs-lookup"><span data-stu-id="2dd02-193">That way, you can use the mock repository class instead of the real repository class in your unit tests.</span></span> <span data-ttu-id="2dd02-194">使用 mock 存放庫可讓您在執行單元測試時，避免執行資料庫程式碼。</span><span class="sxs-lookup"><span data-stu-id="2dd02-194">Using the mock repository enables you to avoid executing database code when executing a unit test.</span></span>

<span data-ttu-id="2dd02-195">Visual Studio 不包含 Mock 物件架構。</span><span class="sxs-lookup"><span data-stu-id="2dd02-195">Visual Studio does not include a Mock Object framework.</span></span> <span data-ttu-id="2dd02-196">不過，有數個適用于 .NET framework 的商業和開放原始碼模擬物件架構：</span><span class="sxs-lookup"><span data-stu-id="2dd02-196">However, there are several commercial and open source Mock Object frameworks available for the .NET framework:</span></span>

1. <span data-ttu-id="2dd02-197">Moq-此架構適用于開放原始碼 BSD 授權。</span><span class="sxs-lookup"><span data-stu-id="2dd02-197">Moq - This framework is available under the open source BSD license.</span></span> <span data-ttu-id="2dd02-198">您可以從[https://code.google.com/p/moq/](https://code.google.com/p/moq/)下載 Moq。</span><span class="sxs-lookup"><span data-stu-id="2dd02-198">You can download Moq from [https://code.google.com/p/moq/](https://code.google.com/p/moq/).</span></span>
2. <span data-ttu-id="2dd02-199">Rhino 模擬-此架構適用于開放原始碼 BSD 授權。</span><span class="sxs-lookup"><span data-stu-id="2dd02-199">Rhino Mocks - This framework is available under the open source BSD license.</span></span> <span data-ttu-id="2dd02-200">您可以從[http://ayende.com/projects/rhino-mocks.aspx](http://ayende.com/projects/rhino-mocks.aspx)下載 Rhino 模擬。</span><span class="sxs-lookup"><span data-stu-id="2dd02-200">You can download Rhino Mocks from [http://ayende.com/projects/rhino-mocks.aspx](http://ayende.com/projects/rhino-mocks.aspx).</span></span>
3. <span data-ttu-id="2dd02-201">Typemock Isolator-這是商業架構。</span><span class="sxs-lookup"><span data-stu-id="2dd02-201">Typemock Isolator - This is a commercial framework.</span></span> <span data-ttu-id="2dd02-202">您可以從[http://www.typemock.com/](http://www.typemock.com/)下載試用版。</span><span class="sxs-lookup"><span data-stu-id="2dd02-202">You can download a trial version from [http://www.typemock.com/](http://www.typemock.com/).</span></span>

<span data-ttu-id="2dd02-203">在本教學課程中，我決定使用 Moq。</span><span class="sxs-lookup"><span data-stu-id="2dd02-203">In this tutorial, I decided to use Moq.</span></span> <span data-ttu-id="2dd02-204">不過，您可以輕鬆地使用 Rhino 模擬或 Typemock Isolator 來建立 Contact Manager 應用程式的 Mock 物件。</span><span class="sxs-lookup"><span data-stu-id="2dd02-204">However, you could just as easily use Rhino Mocks or Typemock Isolator to create the Mock objects for the Contact Manager application.</span></span>

<span data-ttu-id="2dd02-205">在您可以使用 Moq 之前，您需要完成下列步驟：</span><span class="sxs-lookup"><span data-stu-id="2dd02-205">Before you can use Moq, you need to complete the following steps:</span></span>

1. <span data-ttu-id="2dd02-206">。</span><span class="sxs-lookup"><span data-stu-id="2dd02-206">.</span></span>
2. <span data-ttu-id="2dd02-207">在解壓縮下載內容之前，請確定您以滑鼠右鍵按一下檔案，然後按一下標示為 [**解除封鎖**] 的按鈕（請參閱 [圖 1]）。</span><span class="sxs-lookup"><span data-stu-id="2dd02-207">Before you unzip the download, make sure that you right-click the file and click the button labeled **Unblock** (see Figure 1).</span></span>
3. <span data-ttu-id="2dd02-208">將下載解壓縮。</span><span class="sxs-lookup"><span data-stu-id="2dd02-208">Unzip the download.</span></span>
4. <span data-ttu-id="2dd02-209">以滑鼠右鍵按一下 [ContactManager] 專案中的 [參考] 資料夾，然後選取 [**加入參考**]，即可加入 Moq 元件的參考。</span><span class="sxs-lookup"><span data-stu-id="2dd02-209">Add a reference to the Moq assembly by right-clicking the References folder in the ContactManager.Tests project and selecting **Add Reference**.</span></span> <span data-ttu-id="2dd02-210">在 [流覽] 索引標籤下，流覽至您解壓縮 Moq 的資料夾，然後選取 [Moq] 元件。</span><span class="sxs-lookup"><span data-stu-id="2dd02-210">Under the Browse tab, browse to the folder where you unzipped Moq and select the Moq.dll assembly.</span></span> <span data-ttu-id="2dd02-211">按一下 [確定] 按鈕。</span><span class="sxs-lookup"><span data-stu-id="2dd02-211">Click the **OK** button.</span></span>
5. <span data-ttu-id="2dd02-212">完成這些步驟之後，[參考] 資料夾看起來應該如 [圖 2] 所示。</span><span class="sxs-lookup"><span data-stu-id="2dd02-212">After you complete these steps, your References folder should look like Figure 2.</span></span>

<span data-ttu-id="2dd02-213">[![解除封鎖 Moq](iteration-5-create-unit-tests-cs/_static/image1.jpg)](iteration-5-create-unit-tests-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="2dd02-213">[![Unblocking Moq](iteration-5-create-unit-tests-cs/_static/image1.jpg)](iteration-5-create-unit-tests-cs/_static/image1.png)</span></span>

<span data-ttu-id="2dd02-214">**圖 01**：解除封鎖 Moq （[按一下以觀看完整大小的影像](iteration-5-create-unit-tests-cs/_static/image2.png)）</span><span class="sxs-lookup"><span data-stu-id="2dd02-214">**Figure 01**: Unblocking Moq([Click to view full-size image](iteration-5-create-unit-tests-cs/_static/image2.png))</span></span>

<span data-ttu-id="2dd02-215">[新增 Moq 之後的 ![參考](iteration-5-create-unit-tests-cs/_static/image2.jpg)](iteration-5-create-unit-tests-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="2dd02-215">[![References after adding Moq](iteration-5-create-unit-tests-cs/_static/image2.jpg)](iteration-5-create-unit-tests-cs/_static/image3.png)</span></span>

<span data-ttu-id="2dd02-216">**圖 02**：新增 Moq 之後的參考（[按一下以查看完整大小的影像](iteration-5-create-unit-tests-cs/_static/image4.png)）</span><span class="sxs-lookup"><span data-stu-id="2dd02-216">**Figure 02**: References after adding Moq([Click to view full-size image](iteration-5-create-unit-tests-cs/_static/image4.png))</span></span>

## <a name="creating-unit-tests-for-the-service-layer"></a><span data-ttu-id="2dd02-217">建立服務層的單元測試</span><span class="sxs-lookup"><span data-stu-id="2dd02-217">Creating Unit Tests for the Service Layer</span></span>

<span data-ttu-id="2dd02-218">讓我們從為我們的 Contact Manager 應用程式服務層建立一組單元測試開始。</span><span class="sxs-lookup"><span data-stu-id="2dd02-218">Let s start by creating a set of unit tests for our Contact Manager application s service layer.</span></span> <span data-ttu-id="2dd02-219">我們將使用這些測試來驗證我們的驗證邏輯。</span><span class="sxs-lookup"><span data-stu-id="2dd02-219">We'll use these tests to verify our validation logic.</span></span>

<span data-ttu-id="2dd02-220">在 ContactManager 專案中建立名為 [模型] 的新資料夾。</span><span class="sxs-lookup"><span data-stu-id="2dd02-220">Create a new folder named Models in the ContactManager.Tests project.</span></span> <span data-ttu-id="2dd02-221">接下來，以滑鼠右鍵按一下 [模型] 資料夾，然後選取 [**加入]、[新增測試**]。</span><span class="sxs-lookup"><span data-stu-id="2dd02-221">Next, right-click the Models folder and select **Add, New Test**.</span></span> <span data-ttu-id="2dd02-222">[圖 3] 所示的 [**加入新測試**] 對話方塊隨即出現。</span><span class="sxs-lookup"><span data-stu-id="2dd02-222">The **Add New Test** dialog shown in Figure 3 appears.</span></span> <span data-ttu-id="2dd02-223">選取 [**單元測試**] 範本，並為新的測試 ContactManagerServiceTest.cs 命名。</span><span class="sxs-lookup"><span data-stu-id="2dd02-223">Select the **Unit Test** template and name your new test ContactManagerServiceTest.cs.</span></span> <span data-ttu-id="2dd02-224">按一下 [**確定]** 按鈕，將新的測試加入至測試專案。</span><span class="sxs-lookup"><span data-stu-id="2dd02-224">Click the **OK** button to add your new test to your Test Project.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="2dd02-225">一般來說，您會想要測試專案的資料夾結構，以符合 ASP.NET MVC 專案的資料夾結構。</span><span class="sxs-lookup"><span data-stu-id="2dd02-225">In general, you want the folder structure of your Test Project to match the folder structure of your ASP.NET MVC project.</span></span> <span data-ttu-id="2dd02-226">例如，您將控制器測試放在 [控制器] 資料夾、[模型] 資料夾中的模型測試等等。</span><span class="sxs-lookup"><span data-stu-id="2dd02-226">For example, you place controller tests in a Controllers folder, model tests in a Models folder, and so on.</span></span>

<span data-ttu-id="2dd02-227">[![Models\ContactManagerServiceTest.cs](iteration-5-create-unit-tests-cs/_static/image3.jpg)](iteration-5-create-unit-tests-cs/_static/image5.png)</span><span class="sxs-lookup"><span data-stu-id="2dd02-227">[![Models\ContactManagerServiceTest.cs](iteration-5-create-unit-tests-cs/_static/image3.jpg)](iteration-5-create-unit-tests-cs/_static/image5.png)</span></span>

<span data-ttu-id="2dd02-228">**圖 03**： Models\ContactManagerServiceTest.cs （[按一下以觀看完整大小的影像](iteration-5-create-unit-tests-cs/_static/image6.png)）</span><span class="sxs-lookup"><span data-stu-id="2dd02-228">**Figure 03**: Models\ContactManagerServiceTest.cs([Click to view full-size image](iteration-5-create-unit-tests-cs/_static/image6.png))</span></span>

<span data-ttu-id="2dd02-229">一開始，我們想要測試 ContactManagerService 類別所公開的 CreateContact （）方法。</span><span class="sxs-lookup"><span data-stu-id="2dd02-229">Initially, we want to test the CreateContact() method exposed by the ContactManagerService class.</span></span> <span data-ttu-id="2dd02-230">我們將建立下列五項測試：</span><span class="sxs-lookup"><span data-stu-id="2dd02-230">We'll create the following five tests:</span></span>

- <span data-ttu-id="2dd02-231">CreateContact （）-當有效的連絡人傳遞至方法時，CreateContact （）的測試會傳回 true 值。</span><span class="sxs-lookup"><span data-stu-id="2dd02-231">CreateContact() - Tests that CreateContact() returns the value true when a valid Contact is passed to the method.</span></span>
- <span data-ttu-id="2dd02-232">CreateContactRequiredFirstName （）-當具有遺漏名字的連絡人傳遞至 CreateContact （）方法時，測試是否將錯誤訊息加入至模型狀態。</span><span class="sxs-lookup"><span data-stu-id="2dd02-232">CreateContactRequiredFirstName() - Tests that an error message is added to model state when a Contact with a missing first name is passed to the CreateContact() method.</span></span>
- <span data-ttu-id="2dd02-233">CreateContactRequiredLastName （）-測試將遺失姓氏的連絡人傳遞至 CreateContact （）方法時，會將錯誤訊息加入至模型狀態。</span><span class="sxs-lookup"><span data-stu-id="2dd02-233">CreateContactRequiredLastName() - Tests that an error message is added to model state when a Contact with a missing last name is passed to the CreateContact() method.</span></span>
- <span data-ttu-id="2dd02-234">CreateContactInvalidPhone （）-當具有無效電話號碼的連絡人傳遞至 CreateContact （）方法時，測試是否將錯誤訊息新增至模型狀態。</span><span class="sxs-lookup"><span data-stu-id="2dd02-234">CreateContactInvalidPhone() - Tests that an error message is added to model state when a Contact with an invalid phone number is passed to the CreateContact() method.</span></span>
- <span data-ttu-id="2dd02-235">CreateContactInvalidEmail （）-測試將具有無效電子郵件地址的連絡人傳遞至 CreateContact （）方法時，會將錯誤訊息加入至模型狀態。</span><span class="sxs-lookup"><span data-stu-id="2dd02-235">CreateContactInvalidEmail() - Tests that an error message is added to model state when a Contact with an invalid email address is passed to the CreateContact() method..</span></span>

<span data-ttu-id="2dd02-236">第一次測試會確認有效的連絡人不會產生驗證錯誤。</span><span class="sxs-lookup"><span data-stu-id="2dd02-236">The first test verifies that a valid Contact does not generate a validation error.</span></span> <span data-ttu-id="2dd02-237">其餘的測試會檢查每個驗證規則。</span><span class="sxs-lookup"><span data-stu-id="2dd02-237">The remaining tests check each of the validation rules.</span></span>

<span data-ttu-id="2dd02-238">這些測試的程式碼包含在 [清單 1] 中。</span><span class="sxs-lookup"><span data-stu-id="2dd02-238">The code for these tests is contained in Listing 1.</span></span>

<span data-ttu-id="2dd02-239">**清單 1-Models\ContactManagerServiceTest.cs**</span><span class="sxs-lookup"><span data-stu-id="2dd02-239">**Listing 1 - Models\ContactManagerServiceTest.cs**</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample1.cs)]

<span data-ttu-id="2dd02-240">因為我們使用 [清單 1] 中的 Contact 類別，所以我們需要在測試專案中加入 Microsoft Entity Framework 的參考。</span><span class="sxs-lookup"><span data-stu-id="2dd02-240">Because we use the Contact class in Listing 1, we need to add a reference to the Microsoft Entity Framework to our Test project.</span></span> <span data-ttu-id="2dd02-241">加入 System.object 元件的參考。</span><span class="sxs-lookup"><span data-stu-id="2dd02-241">Add a reference to the System.Data.Entity assembly.</span></span>

<span data-ttu-id="2dd02-242">[清單 1] 包含名為 Initialize （）的方法，它會以 [TestInitialize] 屬性裝飾。</span><span class="sxs-lookup"><span data-stu-id="2dd02-242">Listing 1 contains a method named Initialize() that is decorated with the [TestInitialize] attribute.</span></span> <span data-ttu-id="2dd02-243">在執行每個單元測試之前，會自動呼叫這個方法（在每個單元測試之前都會呼叫5次）。</span><span class="sxs-lookup"><span data-stu-id="2dd02-243">This method is called automatically before each of the unit tests is run (it is called 5 times right before each of the unit tests).</span></span> <span data-ttu-id="2dd02-244">Initialize （）方法會使用下列程式程式碼建立模擬儲存機制：</span><span class="sxs-lookup"><span data-stu-id="2dd02-244">The Initialize() method creates a mock repository with the following line of code:</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample2.cs)]

<span data-ttu-id="2dd02-245">這行程式碼會使用 Moq 架構，從 IContactManagerRepository 介面產生 mock 存放庫。</span><span class="sxs-lookup"><span data-stu-id="2dd02-245">This line of code uses the Moq framework to generate a mock repository from the IContactManagerRepository interface.</span></span> <span data-ttu-id="2dd02-246">模擬儲存機制會用來取代實際的 EntityContactManagerRepository，以避免在每個單元測試執行時存取資料庫。</span><span class="sxs-lookup"><span data-stu-id="2dd02-246">The mock repository is used instead of the actual EntityContactManagerRepository to avoid accessing the database when each unit test is run.</span></span> <span data-ttu-id="2dd02-247">Mock 存放庫會實 IContactManagerRepository 介面的方法，但方法不會實際執行任何動作。</span><span class="sxs-lookup"><span data-stu-id="2dd02-247">The mock repository implements the methods of the IContactManagerRepository interface, but the methods don t actually do anything.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="2dd02-248">使用 Moq 架構時，\_mockRepository 和 \_mockRepository 之間有區別。</span><span class="sxs-lookup"><span data-stu-id="2dd02-248">When using the Moq framework, there is a distinction between \_mockRepository and \_mockRepository.Object.</span></span> <span data-ttu-id="2dd02-249">前者指的是 Mock&lt;IContactManagerRepository&gt; 類別，其中包含指定模擬儲存機制行為方式的方法。</span><span class="sxs-lookup"><span data-stu-id="2dd02-249">The former refers to the Mock&lt;IContactManagerRepository&gt; class that contains methods for specifying how the mock repository will behave.</span></span> <span data-ttu-id="2dd02-250">後者是指實 IContactManagerRepository 介面的實際 mock 存放庫。</span><span class="sxs-lookup"><span data-stu-id="2dd02-250">The latter refers to the actual mock repository that implements the IContactManagerRepository interface.</span></span>

<span data-ttu-id="2dd02-251">建立 ContactManagerService 類別的實例時，會在 Initialize （）方法中使用 mock 存放庫。</span><span class="sxs-lookup"><span data-stu-id="2dd02-251">The mock repository is used in the Initialize() method when creating an instance of the ContactManagerService class.</span></span> <span data-ttu-id="2dd02-252">所有的個別單元測試都會使用這個 ContactManagerService 類別的實例。</span><span class="sxs-lookup"><span data-stu-id="2dd02-252">All of the individual unit tests use this instance of the ContactManagerService class.</span></span>

<span data-ttu-id="2dd02-253">[清單 1] 包含五個對應至每個單元測試的方法。</span><span class="sxs-lookup"><span data-stu-id="2dd02-253">Listing 1 contains five methods that correspond to each of the unit tests.</span></span> <span data-ttu-id="2dd02-254">這些方法都是以 [TestMethod] 屬性裝飾。</span><span class="sxs-lookup"><span data-stu-id="2dd02-254">Each of these methods is decorated with the [TestMethod] attribute.</span></span> <span data-ttu-id="2dd02-255">當您執行單元測試時，會呼叫具有這個屬性的任何方法。</span><span class="sxs-lookup"><span data-stu-id="2dd02-255">When you run the unit tests, any method that has this attribute is called.</span></span> <span data-ttu-id="2dd02-256">換句話說，任何以 [TestMethod] 屬性裝飾的方法都是單元測試。</span><span class="sxs-lookup"><span data-stu-id="2dd02-256">In other words, any method that is decorated with the [TestMethod] attribute is a unit test.</span></span>

<span data-ttu-id="2dd02-257">第一個單元測試（名為 CreateContact （））會確認當 Contact 類別的有效實例傳遞給方法時，呼叫 CreateContact （）會傳回 true 值。</span><span class="sxs-lookup"><span data-stu-id="2dd02-257">The first unit test, named CreateContact(), verifies that calling CreateContact() returns the value true when a valid instance of the Contact class is passed to the method.</span></span> <span data-ttu-id="2dd02-258">此測試會建立 Contact 類別的實例，並呼叫 CreateContact （）方法，並確認 CreateContact （）傳回值 true。</span><span class="sxs-lookup"><span data-stu-id="2dd02-258">The test creates an instance of the Contact class, calls the CreateContact() method, and verifies that CreateContact() returns the value true.</span></span>

<span data-ttu-id="2dd02-259">其餘的測試會確認使用不正確連絡人呼叫 CreateContact （）方法時，此方法會傳回 false，而預期的驗證錯誤訊息會加入至模型狀態。</span><span class="sxs-lookup"><span data-stu-id="2dd02-259">The remaining tests verify that when the CreateContact() method is called with an invalid Contact then the method returns false and the expected validation error message is added to model state.</span></span> <span data-ttu-id="2dd02-260">例如，CreateContactRequiredFirstName （）測試會使用其 FirstName 屬性的空字串，建立 Contact 類別的實例。</span><span class="sxs-lookup"><span data-stu-id="2dd02-260">For example, the CreateContactRequiredFirstName() test creates an instance of the Contact class with an empty string for its FirstName property.</span></span> <span data-ttu-id="2dd02-261">接下來，使用不正確 Contact 呼叫 CreateContact （）方法。</span><span class="sxs-lookup"><span data-stu-id="2dd02-261">Next, the CreateContact() method is called with the invalid Contact.</span></span> <span data-ttu-id="2dd02-262">最後，測試會確認 CreateContact （）傳回 false，而且模型狀態包含預期的驗證錯誤訊息「需要名字。」</span><span class="sxs-lookup"><span data-stu-id="2dd02-262">Finally, the test verifies that CreateContact() returns false and that model state contains the expected validation error message "First name is required."</span></span>

<span data-ttu-id="2dd02-263">您可以選取 [**測試]、[執行]、[方案中的所有測試] （CTRL + R、A）** 中的功能表選項，以執行 [清單 1] 中的單元測試。</span><span class="sxs-lookup"><span data-stu-id="2dd02-263">You can run the unit tests in Listing 1 by selecting the menu option **Test, Run, All Tests in Solution (CTRL+R, A)**.</span></span> <span data-ttu-id="2dd02-264">測試的結果會顯示在 [測試結果] 視窗中（請參閱 [圖 4]）。</span><span class="sxs-lookup"><span data-stu-id="2dd02-264">The results of the tests are displayed in the Test Results window (see Figure 4).</span></span>

<span data-ttu-id="2dd02-265">[![測試結果](iteration-5-create-unit-tests-cs/_static/image4.jpg)](iteration-5-create-unit-tests-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="2dd02-265">[![Test Results](iteration-5-create-unit-tests-cs/_static/image4.jpg)](iteration-5-create-unit-tests-cs/_static/image7.png)</span></span>

<span data-ttu-id="2dd02-266">**圖 04**：測試結果（[按一下以觀看完整大小的影像](iteration-5-create-unit-tests-cs/_static/image8.png)）</span><span class="sxs-lookup"><span data-stu-id="2dd02-266">**Figure 04**: Test Results ([Click to view full-size image](iteration-5-create-unit-tests-cs/_static/image8.png))</span></span>

## <a name="creating-unit-tests-for-controllers"></a><span data-ttu-id="2dd02-267">建立控制器的單元測試</span><span class="sxs-lookup"><span data-stu-id="2dd02-267">Creating Unit Tests for Controllers</span></span>

<span data-ttu-id="2dd02-268">NETMVC 應用程式控制使用者互動的流程。</span><span class="sxs-lookup"><span data-stu-id="2dd02-268">ASP.NETMVC application control the flow of user interaction.</span></span> <span data-ttu-id="2dd02-269">測試控制器時，您會想要測試控制器是否傳回正確的動作結果和查看資料。</span><span class="sxs-lookup"><span data-stu-id="2dd02-269">When testing a controller, you want to test whether the controller returns the right action result and view data.</span></span> <span data-ttu-id="2dd02-270">您也可能想要測試控制器是否以預期的方式與模型類別互動。</span><span class="sxs-lookup"><span data-stu-id="2dd02-270">You also might want to test whether a controller interacts with model classes in the manner expected.</span></span>

<span data-ttu-id="2dd02-271">例如，[清單 2] 包含 Contact controller Create （）方法的兩個單元測試。</span><span class="sxs-lookup"><span data-stu-id="2dd02-271">For example, Listing 2 contains two unit tests for the Contact controller Create() method.</span></span> <span data-ttu-id="2dd02-272">第一個單元測試會確認當有效的連絡人傳遞至 Create （）方法時，Create （）方法會重新導向至索引動作。</span><span class="sxs-lookup"><span data-stu-id="2dd02-272">The first unit test verifies that when a valid Contact is passed to the Create() method then the Create() method redirects to the Index action.</span></span> <span data-ttu-id="2dd02-273">換句話說，當傳遞有效的連絡人時，Create （）方法應該會傳回代表索引動作的 RedirectToRouteResult。</span><span class="sxs-lookup"><span data-stu-id="2dd02-273">In other words, when passed a valid Contact, the Create() method should return a RedirectToRouteResult that represents the Index action.</span></span>

<span data-ttu-id="2dd02-274">我們不想在測試控制器層時測試 ContactManager 服務層級。</span><span class="sxs-lookup"><span data-stu-id="2dd02-274">We don t want to test the ContactManager service layer when we are testing the controller layer.</span></span> <span data-ttu-id="2dd02-275">因此，我們會在 Initialize 方法中，使用下列程式碼來模擬服務層：</span><span class="sxs-lookup"><span data-stu-id="2dd02-275">Therefore, we mock the service layer with the following code in the Initialize method:</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample3.cs)]

<span data-ttu-id="2dd02-276">在 CreateValidContact （）單元測試中，我們會使用下列程式程式碼來模擬呼叫服務層 CreateContact （）方法的行為：</span><span class="sxs-lookup"><span data-stu-id="2dd02-276">In the CreateValidContact() unit test, we mock the behavior of calling the service layer CreateContact() method with the following line of code:</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample4.cs)]

<span data-ttu-id="2dd02-277">這行程式碼會在呼叫其 CreateContact （）方法時，讓 mock ContactManager 服務傳回值 true。</span><span class="sxs-lookup"><span data-stu-id="2dd02-277">This line of code causes the mock ContactManager service to return the value true when its CreateContact() method is called.</span></span> <span data-ttu-id="2dd02-278">藉由模擬服務層級，我們可以測試控制器的行為，而不需要在服務層中執行任何程式碼。</span><span class="sxs-lookup"><span data-stu-id="2dd02-278">By mocking the service layer, we can test the behavior of our controller without needing to execute any code in the service layer.</span></span>

<span data-ttu-id="2dd02-279">第二個單元測試會在將不正確連絡人傳遞至方法時，確認 Create （）動作是否會傳回 Create view。</span><span class="sxs-lookup"><span data-stu-id="2dd02-279">The second unit test verifies that the Create() action returns the Create view when an invalid contact is passed to the method.</span></span> <span data-ttu-id="2dd02-280">我們會讓服務層 CreateContact （）方法以下列程式程式碼傳回 false 值：</span><span class="sxs-lookup"><span data-stu-id="2dd02-280">We cause the service layer CreateContact() method to return the value false with the following line of code:</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample5.cs)]

<span data-ttu-id="2dd02-281">如果 Create （）方法如預期般運作，則當服務層傳回 false 值時，應該會傳回 Create view。</span><span class="sxs-lookup"><span data-stu-id="2dd02-281">If the Create() method behaves as we expect then it should return the Create view when the service layer returns the value false.</span></span> <span data-ttu-id="2dd02-282">如此一來，控制器就可以在 [建立] 視圖中顯示驗證錯誤訊息，而且使用者有機會更正該不正確連絡人屬性。</span><span class="sxs-lookup"><span data-stu-id="2dd02-282">That way, the controller can display the validation error messages in the Create view and the user has a chance to correct that invalid Contact properties.</span></span>

<span data-ttu-id="2dd02-283">如果您打算為控制器建立單元測試，則需要從您的控制器動作傳回明確的視圖名稱。</span><span class="sxs-lookup"><span data-stu-id="2dd02-283">If you plan to build unit tests for your controllers then you need to return explicit view names from your controller actions.</span></span> <span data-ttu-id="2dd02-284">例如，不會傳回如下所示的視圖：</span><span class="sxs-lookup"><span data-stu-id="2dd02-284">For example, do not return a view like this:</span></span>

<span data-ttu-id="2dd02-285">return View （）;</span><span class="sxs-lookup"><span data-stu-id="2dd02-285">return View();</span></span>

<span data-ttu-id="2dd02-286">相反地，會傳回如下所示的視圖：</span><span class="sxs-lookup"><span data-stu-id="2dd02-286">Instead, return the view like this:</span></span>

<span data-ttu-id="2dd02-287">return View （"Create"）;</span><span class="sxs-lookup"><span data-stu-id="2dd02-287">return View("Create");</span></span>

<span data-ttu-id="2dd02-288">如果您在傳回 view 時不是明確的，則 ViewResult. ViewName 屬性會傳回空字串。</span><span class="sxs-lookup"><span data-stu-id="2dd02-288">If you are not explicit when returning a view then the ViewResult.ViewName property returns an empty string.</span></span>

<span data-ttu-id="2dd02-289">**清單 2-Controllers\ContactControllerTest.cs**</span><span class="sxs-lookup"><span data-stu-id="2dd02-289">**Listing 2 - Controllers\ContactControllerTest.cs**</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample6.cs)]

## <a name="summary"></a><span data-ttu-id="2dd02-290">總結</span><span class="sxs-lookup"><span data-stu-id="2dd02-290">Summary</span></span>

<span data-ttu-id="2dd02-291">在此反復專案中，我們為連絡人管理員應用程式建立單元測試。</span><span class="sxs-lookup"><span data-stu-id="2dd02-291">In this iteration, we created unit tests for our Contact Manager application.</span></span> <span data-ttu-id="2dd02-292">我們可以隨時執行這些單元測試，以確認我們的應用程式仍然以我們預期的方式運作。</span><span class="sxs-lookup"><span data-stu-id="2dd02-292">We can run these unit tests at any time to verify that our application still behaves in the manner that we expect.</span></span> <span data-ttu-id="2dd02-293">單元測試會作為我們應用程式的安全網路，讓我們能夠在未來安全地修改應用程式。</span><span class="sxs-lookup"><span data-stu-id="2dd02-293">The unit tests act as a safety net for our application enabling us to safely modify our application in the future.</span></span>

<span data-ttu-id="2dd02-294">我們建立了兩組單元測試。</span><span class="sxs-lookup"><span data-stu-id="2dd02-294">We created two sets of unit tests.</span></span> <span data-ttu-id="2dd02-295">首先，我們會藉由建立服務層的單元測試來測試我們的驗證邏輯。</span><span class="sxs-lookup"><span data-stu-id="2dd02-295">First, we tested our validation logic by creating unit tests for our service layer.</span></span> <span data-ttu-id="2dd02-296">接下來，我們會藉由建立控制器層的單元測試來測試流程式控制制邏輯。</span><span class="sxs-lookup"><span data-stu-id="2dd02-296">Next, we tested our flow control logic by creating unit tests for our controller layer.</span></span> <span data-ttu-id="2dd02-297">測試我們的服務層時，我們會模擬我們的存放庫層，將我們的服務層級的測試與我們的存放庫層隔離。</span><span class="sxs-lookup"><span data-stu-id="2dd02-297">When testing our service layer, we isolated our tests for our service layer from our repository layer by mocking our repository layer.</span></span> <span data-ttu-id="2dd02-298">測試控制器層時，我們會藉由模擬服務層級，為控制器層隔離測試。</span><span class="sxs-lookup"><span data-stu-id="2dd02-298">When testing the controller layer, we isolated our tests for our controller layer by mocking the service layer.</span></span>

<span data-ttu-id="2dd02-299">在下一個反復專案中，我們會修改 Contact Manager 應用程式，使其支援連絡人群組。</span><span class="sxs-lookup"><span data-stu-id="2dd02-299">In the next iteration, we modify the Contact Manager application so that it supports Contact Groups.</span></span> <span data-ttu-id="2dd02-300">我們會使用稱為「測試導向開發」的軟體設計程式，將這種新功能新增至我們的應用程式。</span><span class="sxs-lookup"><span data-stu-id="2dd02-300">We'll add this new functionality to our application using a software design process called test-driven development.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="2dd02-301">[上一頁](iteration-4-make-the-application-loosely-coupled-cs.md)
> [下一頁](iteration-6-use-test-driven-development-cs.md)</span><span class="sxs-lookup"><span data-stu-id="2dd02-301">[Previous](iteration-4-make-the-application-loosely-coupled-cs.md)
[Next](iteration-6-use-test-driven-development-cs.md)</span></span>
