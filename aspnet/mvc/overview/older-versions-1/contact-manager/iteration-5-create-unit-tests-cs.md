---
uid: mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-cs
title: 反覆運算#5 = 創建單元測試 (C#) |微軟文件
author: rick-anderson
description: 在第五次反覆運算中,我們通過添加單元測試使應用程式更易於維護和修改。 我們模擬我們的資料模型類,並為 o...
ms.author: riande
ms.date: 02/20/2009
ms.assetid: 28ad8f80-b8a5-444e-b478-8b15a846060c
msc.legacyurl: /mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-cs
msc.type: authoredcontent
ms.openlocfilehash: c005a8ffc3b09c126d796f2feb74d402cb784aa2
ms.sourcegitcommit: 022f79dbc1350e0c6ffaa1e7e7c6e850cdabf9af
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/17/2020
ms.locfileid: "81542348"
---
# <a name="iteration-5--create-unit-tests-c"></a><span data-ttu-id="24994-104">反覆項目 #5 – 建立單元測試 (C#)</span><span class="sxs-lookup"><span data-stu-id="24994-104">Iteration #5 – Create unit tests (C#)</span></span>

<span data-ttu-id="24994-105">由[微軟](https://github.com/microsoft)</span><span class="sxs-lookup"><span data-stu-id="24994-105">by [Microsoft](https://github.com/microsoft)</span></span>

[<span data-ttu-id="24994-106">下載代碼</span><span class="sxs-lookup"><span data-stu-id="24994-106">Download Code</span></span>](iteration-5-create-unit-tests-cs/_static/contactmanager_5_cs1.zip)

> <span data-ttu-id="24994-107">在第五次反覆運算中,我們通過添加單元測試使應用程式更易於維護和修改。</span><span class="sxs-lookup"><span data-stu-id="24994-107">In the fifth iteration, we make our application easier to maintain and modify by adding unit tests.</span></span> <span data-ttu-id="24994-108">我們類比數據模型類,並為控制器和驗證邏輯構建單元測試。</span><span class="sxs-lookup"><span data-stu-id="24994-108">We mock our data model classes and build unit tests for our controllers and validation logic.</span></span>

## <a name="building-a-contact-management-aspnet-mvc-application-c"></a><span data-ttu-id="24994-109">編譯聯絡人管理ASP.NET MVC 應用程式 (C#)</span><span class="sxs-lookup"><span data-stu-id="24994-109">Building a Contact Management ASP.NET MVC Application (C#)</span></span>

<span data-ttu-id="24994-110">在本系列教程中,我們從頭到尾構建整個聯繫人管理應用程式。</span><span class="sxs-lookup"><span data-stu-id="24994-110">In this series of tutorials, we build an entire Contact Management application from start to finish.</span></span> <span data-ttu-id="24994-111">透過聯絡人管理員應用程式,您可以儲存連絡人資訊 (姓名、電話號碼和電子郵件位址) 人員清單。</span><span class="sxs-lookup"><span data-stu-id="24994-111">The Contact Manager application enables you to store contact information - names, phone numbers and email addresses - for a list of people.</span></span>

<span data-ttu-id="24994-112">我們通過多次反覆運算構建應用程式。</span><span class="sxs-lookup"><span data-stu-id="24994-112">We build the application over multiple iterations.</span></span> <span data-ttu-id="24994-113">每次反覆運算時,我們都會逐步改進應用程式。</span><span class="sxs-lookup"><span data-stu-id="24994-113">With each iteration, we gradually improve the application.</span></span> <span data-ttu-id="24994-114">此多反覆運算方法的目標是使您能夠瞭解每次更改的原因。</span><span class="sxs-lookup"><span data-stu-id="24994-114">The goal of this multiple iteration approach is to enable you to understand the reason for each change.</span></span>

- <span data-ttu-id="24994-115">反覆運算#1 - 創建應用程式。</span><span class="sxs-lookup"><span data-stu-id="24994-115">Iteration #1 - Create the application.</span></span> <span data-ttu-id="24994-116">在第一次反覆運算中,我們以最簡單的方式創建聯繫人管理器。</span><span class="sxs-lookup"><span data-stu-id="24994-116">In the first iteration, we create the Contact Manager in the simplest way possible.</span></span> <span data-ttu-id="24994-117">我們添加對基本資料庫操作的支援:創建、讀取、更新和刪除 (CRUD)。</span><span class="sxs-lookup"><span data-stu-id="24994-117">We add support for basic database operations: Create, Read, Update, and Delete (CRUD).</span></span>

- <span data-ttu-id="24994-118">反覆運算#2 - 使應用程式看起來不錯。</span><span class="sxs-lookup"><span data-stu-id="24994-118">Iteration #2 - Make the application look nice.</span></span> <span data-ttu-id="24994-119">在此反覆運算中,我們通過修改預設ASP.NET MVC 檢視母版頁和級聯樣式表來改進應用程式的外觀。</span><span class="sxs-lookup"><span data-stu-id="24994-119">In this iteration, we improve the appearance of the application by modifying the default ASP.NET MVC view master page and cascading style sheet.</span></span>

- <span data-ttu-id="24994-120">反覆運算#3 - 添加表單驗證。</span><span class="sxs-lookup"><span data-stu-id="24994-120">Iteration #3 - Add form validation.</span></span> <span data-ttu-id="24994-121">在第三個反覆運算中,我們添加基本表單驗證。</span><span class="sxs-lookup"><span data-stu-id="24994-121">In the third iteration, we add basic form validation.</span></span> <span data-ttu-id="24994-122">我們防止人們在未填寫所需表單欄位的情況下提交表單。</span><span class="sxs-lookup"><span data-stu-id="24994-122">We prevent people from submitting a form without completing required form fields.</span></span> <span data-ttu-id="24994-123">我們還驗證電子郵件地址和電話號碼。</span><span class="sxs-lookup"><span data-stu-id="24994-123">We also validate email addresses and phone numbers.</span></span>

- <span data-ttu-id="24994-124">反覆運算#4 - 使應用程式鬆散耦合。</span><span class="sxs-lookup"><span data-stu-id="24994-124">Iteration #4 - Make the application loosely coupled.</span></span> <span data-ttu-id="24994-125">在第四次反覆運算中,我們利用多種軟體設計模式,使維護和修改聯繫人管理器應用程式變得更加容易。</span><span class="sxs-lookup"><span data-stu-id="24994-125">In this fourth iteration, we take advantage of several software design patterns to make it easier to maintain and modify the Contact Manager application.</span></span> <span data-ttu-id="24994-126">例如,我們重構應用程式以使用存儲庫模式和依賴項注入模式。</span><span class="sxs-lookup"><span data-stu-id="24994-126">For example, we refactor our application to use the Repository pattern and the Dependency Injection pattern.</span></span>

- <span data-ttu-id="24994-127">反覆運算#5 - 創建單元測試。</span><span class="sxs-lookup"><span data-stu-id="24994-127">Iteration #5 - Create unit tests.</span></span> <span data-ttu-id="24994-128">在第五次反覆運算中,我們通過添加單元測試使應用程式更易於維護和修改。</span><span class="sxs-lookup"><span data-stu-id="24994-128">In the fifth iteration, we make our application easier to maintain and modify by adding unit tests.</span></span> <span data-ttu-id="24994-129">我們類比數據模型類,並為控制器和驗證邏輯構建單元測試。</span><span class="sxs-lookup"><span data-stu-id="24994-129">We mock our data model classes and build unit tests for our controllers and validation logic.</span></span>

- <span data-ttu-id="24994-130">反覆運算#6 - 使用測試驅動開發。</span><span class="sxs-lookup"><span data-stu-id="24994-130">Iteration #6 - Use test-driven development.</span></span> <span data-ttu-id="24994-131">在第六次反覆運算中,我們首先編寫單元測試並針對單元測試編寫代碼,從而向應用程式添加新功能。</span><span class="sxs-lookup"><span data-stu-id="24994-131">In this sixth iteration, we add new functionality to our application by writing unit tests first and writing code against the unit tests.</span></span> <span data-ttu-id="24994-132">在此反覆運算中,我們添加聯繫人組。</span><span class="sxs-lookup"><span data-stu-id="24994-132">In this iteration, we add contact groups.</span></span>

- <span data-ttu-id="24994-133">反覆運算#7 - 添加Ajax功能。</span><span class="sxs-lookup"><span data-stu-id="24994-133">Iteration #7 - Add Ajax functionality.</span></span> <span data-ttu-id="24994-134">在第七次反覆運算中,我們通過增加對Ajax的支援來提高應用程式的回應性和性能。</span><span class="sxs-lookup"><span data-stu-id="24994-134">In the seventh iteration, we improve the responsiveness and performance of our application by adding support for Ajax.</span></span>

## <a name="this-iteration"></a><span data-ttu-id="24994-135">此反覆運算</span><span class="sxs-lookup"><span data-stu-id="24994-135">This Iteration</span></span>

<span data-ttu-id="24994-136">在 Contact Manager 應用程式的上一次反覆運算中,我們將應用程式重構為更鬆散耦合。</span><span class="sxs-lookup"><span data-stu-id="24994-136">In the previous iteration of the Contact Manager application, we refactored the application to be more loosely coupled.</span></span> <span data-ttu-id="24994-137">我們將應用程式劃分為不同的控制器、服務和存儲庫層。</span><span class="sxs-lookup"><span data-stu-id="24994-137">We separated the application into distinct controller, service, and repository layers.</span></span> <span data-ttu-id="24994-138">每個層通過介面與層交互。</span><span class="sxs-lookup"><span data-stu-id="24994-138">Each layer interacts with the layer beneath it through interfaces.</span></span>

<span data-ttu-id="24994-139">我們重構了應用程式,使應用程式更易於維護和修改。</span><span class="sxs-lookup"><span data-stu-id="24994-139">We refactored the application to make the application easier to maintain and modify.</span></span> <span data-ttu-id="24994-140">例如,如果需要使用新的數據存取技術,我們可以簡單地更改儲存庫層而不接觸控制器或服務層。</span><span class="sxs-lookup"><span data-stu-id="24994-140">For example, if we need to use a new data access technology, we can simply change the repository layer without touching the controller or service layer.</span></span> <span data-ttu-id="24994-141">通過使聯繫人管理器鬆散耦合,我們使應用程式對更改更具彈性。</span><span class="sxs-lookup"><span data-stu-id="24994-141">By making the Contact Manager loosely coupled, we ve made the application more resilient to change.</span></span>

<span data-ttu-id="24994-142">但是,當我們需要向聯繫人管理器應用程式添加新功能時,會發生什麼情況?</span><span class="sxs-lookup"><span data-stu-id="24994-142">But, what happens when we need to add a new feature to the Contact Manager application?</span></span> <span data-ttu-id="24994-143">或者,當我們修復 Bug 時會發生什麼情況?</span><span class="sxs-lookup"><span data-stu-id="24994-143">Or, what happens when we fix a bug?</span></span> <span data-ttu-id="24994-144">編寫代碼的可悲但經過充分驗證的事實是,每當您觸控程式碼時,都會產生引入新 Bug 的風險。</span><span class="sxs-lookup"><span data-stu-id="24994-144">A sad, but well proven, truth of writing code is that whenever you touch code you create the risk of introducing new bugs.</span></span>

<span data-ttu-id="24994-145">例如,一天好,您的經理可能會要求您向聯繫人管理器添加新功能。</span><span class="sxs-lookup"><span data-stu-id="24994-145">For example, one fine day, your manager might ask you to add a new feature to the Contact Manager.</span></span> <span data-ttu-id="24994-146">她希望您添加對聯繫人組的支援。</span><span class="sxs-lookup"><span data-stu-id="24994-146">She wants you to add support for Contact Groups.</span></span> <span data-ttu-id="24994-147">她希望您允許使用者將聯繫人組織成"朋友"、"業務"等組。</span><span class="sxs-lookup"><span data-stu-id="24994-147">She wants you to enable users to organize their contacts into groups such as Friends, Business, and so on.</span></span>

<span data-ttu-id="24994-148">為了實現此新功能,您需要修改聯繫人管理器應用程式的所有三個層。</span><span class="sxs-lookup"><span data-stu-id="24994-148">In order to implement this new feature, you'll need to modify all three layers of the Contact Manager application.</span></span> <span data-ttu-id="24994-149">您需要向控制器、服務層和儲存庫添加新功能。</span><span class="sxs-lookup"><span data-stu-id="24994-149">You'll need to add new functionality to the controllers, the service layer, and the repository.</span></span> <span data-ttu-id="24994-150">一旦開始修改代碼,您就可能會破壞以前起作用的功能。</span><span class="sxs-lookup"><span data-stu-id="24994-150">As soon as you start modifying code, you risk breaking functionality that worked before.</span></span>

<span data-ttu-id="24994-151">像上次反覆運算中所做的那樣,將應用程式重構為單獨的層是一件好事。</span><span class="sxs-lookup"><span data-stu-id="24994-151">Refactoring our application into separate layers, as we did in the previous iteration, was a good thing.</span></span> <span data-ttu-id="24994-152">這是一件好事,因為它使我們能夠對整個層進行更改,而無需接觸應用程式的其餘部分。</span><span class="sxs-lookup"><span data-stu-id="24994-152">It was a good thing because it enables us to make changes to entire layers without touching the rest of the application.</span></span> <span data-ttu-id="24994-153">但是,如果要使層中的代碼更易於維護和修改,則需要為代碼創建單元測試。</span><span class="sxs-lookup"><span data-stu-id="24994-153">However, if you want to make the code within a layer easier to maintain and modify, you need to create unit tests for the code.</span></span>

<span data-ttu-id="24994-154">使用單元測試來測試單個代碼單元。</span><span class="sxs-lookup"><span data-stu-id="24994-154">You use a unit test to test an individual unit of code.</span></span> <span data-ttu-id="24994-155">這些代碼單位小於整個應用程式層。</span><span class="sxs-lookup"><span data-stu-id="24994-155">These units of code are smaller than entire application layers.</span></span> <span data-ttu-id="24994-156">通常,使用單元測試來驗證代碼中的特定方法的行為方式是否達到預期。</span><span class="sxs-lookup"><span data-stu-id="24994-156">Typically, you use a unit test to verify whether a particular method in your code behaves in the way that you expect.</span></span> <span data-ttu-id="24994-157">例如,您將為 ContactManager 服務類公開的 CreateContact() 方法創建單元測試。</span><span class="sxs-lookup"><span data-stu-id="24994-157">For example, you would create a unit test for the CreateContact() method exposed by the ContactManagerService class.</span></span>

<span data-ttu-id="24994-158">應用程式單元測試工作就像安全網一樣。</span><span class="sxs-lookup"><span data-stu-id="24994-158">The unit tests for an application work just like a safety net.</span></span> <span data-ttu-id="24994-159">每當修改應用程式中的代碼時,都可以運行一組單元測試,以檢查修改是否破壞了現有功能。</span><span class="sxs-lookup"><span data-stu-id="24994-159">Whenever you modify code in an application, you can run a set of unit tests to check whether the modification breaks existing functionality.</span></span> <span data-ttu-id="24994-160">單元測試使代碼可以安全地修改。</span><span class="sxs-lookup"><span data-stu-id="24994-160">Unit tests make your code safe to modify.</span></span> <span data-ttu-id="24994-161">單元測試使應用程式中的所有代碼都更具更改的彈性。</span><span class="sxs-lookup"><span data-stu-id="24994-161">Unit tests make all of the code in your application more resilient to change.</span></span>

<span data-ttu-id="24994-162">在此反覆運算中,我們將單元測試添加到我們的聯繫人管理器應用程式中。</span><span class="sxs-lookup"><span data-stu-id="24994-162">In this iteration, we add unit tests to our Contact Manager application.</span></span> <span data-ttu-id="24994-163">這樣,在下一次反覆運算中,我們可以將聯繫人組添加到我們的應用程式中,而不必擔心破壞現有功能。</span><span class="sxs-lookup"><span data-stu-id="24994-163">That way, in the next iteration, we can add Contact Groups to our application without worrying about breaking existing functionality.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="24994-164">有多種單元測試框架,包括 NUnit、xUnit.net 和 MbUnit。</span><span class="sxs-lookup"><span data-stu-id="24994-164">There are a variety of unit testing frameworks including NUnit, xUnit.net, and MbUnit.</span></span> <span data-ttu-id="24994-165">在本教學中,我們使用 Visual Studio 附帶的單位測試框架。</span><span class="sxs-lookup"><span data-stu-id="24994-165">In this tutorial, we use the unit testing framework included with Visual Studio.</span></span> <span data-ttu-id="24994-166">但是,您可以同樣輕鬆地使用這些替代框架之一。</span><span class="sxs-lookup"><span data-stu-id="24994-166">However, you could just as easily use one of these alternative frameworks.</span></span>

## <a name="what-gets-tested"></a><span data-ttu-id="24994-167">測試內容</span><span class="sxs-lookup"><span data-stu-id="24994-167">What Gets Tested</span></span>

<span data-ttu-id="24994-168">在理想情況下,所有代碼都將由單元測試覆蓋。</span><span class="sxs-lookup"><span data-stu-id="24994-168">In the perfect world, all of your code would be covered by unit tests.</span></span> <span data-ttu-id="24994-169">在完美的世界,你會有完美的安全網。</span><span class="sxs-lookup"><span data-stu-id="24994-169">In the perfect world, you would have the perfect safety net.</span></span> <span data-ttu-id="24994-170">您將能夠修改應用程式中的任何代碼行,並通過執行單元測試立即知道更改是否中斷了現有功能。</span><span class="sxs-lookup"><span data-stu-id="24994-170">You would be able to modify any line of code in your application and know instantly, by executing your unit tests, whether the change broke existing functionality.</span></span>

<span data-ttu-id="24994-171">然而,我們並不生活在一個完美的世界。</span><span class="sxs-lookup"><span data-stu-id="24994-171">However, we don t live in a perfect world.</span></span> <span data-ttu-id="24994-172">實際上,在編寫單元測試時,您專注於為業務邏輯編寫測試(例如,驗證邏輯)。</span><span class="sxs-lookup"><span data-stu-id="24994-172">In practice, when writing unit tests, you concentrate on writing tests for your business logic (for example, validation logic).</span></span> <span data-ttu-id="24994-173">特別是,您*不會*為數據訪問邏輯或視圖邏輯編寫單元測試。</span><span class="sxs-lookup"><span data-stu-id="24994-173">In particular, you *do not* write unit tests for your data access logic or your view logic.</span></span>

<span data-ttu-id="24994-174">為了有用,單元測試必須非常快速地執行。</span><span class="sxs-lookup"><span data-stu-id="24994-174">To be useful, unit tests must execute very quickly.</span></span> <span data-ttu-id="24994-175">您可以輕鬆地為應用程式累積數百(甚至數千個)單元測試。</span><span class="sxs-lookup"><span data-stu-id="24994-175">You easily can accumulate hundreds (or even thousands) of unit tests for an application.</span></span> <span data-ttu-id="24994-176">如果單元測試需要很長時間才能運行,則可以避免執行它們。</span><span class="sxs-lookup"><span data-stu-id="24994-176">If the unit tests take a long time to run then you'll avoid executing them.</span></span> <span data-ttu-id="24994-177">換句話說,對於日常編碼目的,長時間運行單元測試是無用的。</span><span class="sxs-lookup"><span data-stu-id="24994-177">In other words, long running unit tests are useless for day to day coding purposes.</span></span>

<span data-ttu-id="24994-178">因此,您通常不會為與資料庫互動的代碼編寫單元測試。</span><span class="sxs-lookup"><span data-stu-id="24994-178">For this reason, you typically do not write unit tests for code that interacts with a database.</span></span> <span data-ttu-id="24994-179">對即時資料庫運行數百個單元測試將太慢。</span><span class="sxs-lookup"><span data-stu-id="24994-179">Running hundreds of unit tests against a live database would be too slow.</span></span> <span data-ttu-id="24994-180">相反,您模擬資料庫並編寫與模擬資料庫交互的代碼(我們討論下面嘲笑資料庫)。</span><span class="sxs-lookup"><span data-stu-id="24994-180">Instead, you mock your database and write code that interacts with the mock database (we discuss mocking a database below).</span></span>

<span data-ttu-id="24994-181">出於類似的原因,您通常不會為檢視編寫單元測試。</span><span class="sxs-lookup"><span data-stu-id="24994-181">For a similar reason, you typically do not write unit tests for views.</span></span> <span data-ttu-id="24994-182">為了測試檢視,必須啟動 Web 伺服器。</span><span class="sxs-lookup"><span data-stu-id="24994-182">In order to test a view, you must spin up a web server.</span></span> <span data-ttu-id="24994-183">由於旋轉 Web 伺服器是一個相對緩慢的過程,因此不建議為檢視創建單元測試。</span><span class="sxs-lookup"><span data-stu-id="24994-183">Because spinning up a web server is a relatively slow process, creating unit tests for your views is not recommended.</span></span>

<span data-ttu-id="24994-184">如果檢視包含複雜的邏輯,則應考慮將邏輯移動到説明程式方法中。</span><span class="sxs-lookup"><span data-stu-id="24994-184">If your view contains complicated logic then you should consider moving the logic into Helper methods.</span></span> <span data-ttu-id="24994-185">您可以為在不旋轉 Web 伺服器的情況下執行的 Helper 方法編寫單元測試。</span><span class="sxs-lookup"><span data-stu-id="24994-185">You can write unit tests for Helper methods that execute without spinning up a web server.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="24994-186">雖然編寫數據訪問邏輯或視圖邏輯的測試在編寫單元測試時不是個好主意,但這些測試在構建功能或集成測試時可能非常有價值。</span><span class="sxs-lookup"><span data-stu-id="24994-186">While writing tests for data access logic or view logic is not a good idea when writing unit tests, these tests can be very valuable when building functional or integration tests.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="24994-187">ASP.NET MVC 是 Web 窗體檢視引擎。</span><span class="sxs-lookup"><span data-stu-id="24994-187">ASP.NET MVC is the Web Forms View Engine.</span></span> <span data-ttu-id="24994-188">雖然 Web 窗體檢視引擎依賴於 Web 伺服器,但其他檢視引擎可能不是。</span><span class="sxs-lookup"><span data-stu-id="24994-188">While the Web Forms View Engine is dependent on a web server, other view engines might not be.</span></span>

## <a name="using-a-mock-object-framework"></a><span data-ttu-id="24994-189">使用模擬物件框架</span><span class="sxs-lookup"><span data-stu-id="24994-189">Using a Mock Object Framework</span></span>

<span data-ttu-id="24994-190">構建單元測試時,您幾乎總是需要利用類比物件框架。</span><span class="sxs-lookup"><span data-stu-id="24994-190">When building unit tests, you almost always need to take advantage of a Mock Object framework.</span></span> <span data-ttu-id="24994-191">類比物件框架使您能夠為應用程式中的類創建類比和存根。</span><span class="sxs-lookup"><span data-stu-id="24994-191">A Mock Object framework enables you to create mocks and stubs for the classes in your application.</span></span>

<span data-ttu-id="24994-192">例如,可以使用 Mock Object 框架生成儲存庫類的類比版本。</span><span class="sxs-lookup"><span data-stu-id="24994-192">For example, you can use a Mock Object framework to generate a mock version of your repository class.</span></span> <span data-ttu-id="24994-193">這樣,您可以在單元測試中使用類比存儲庫類而不是真正的存儲庫類。</span><span class="sxs-lookup"><span data-stu-id="24994-193">That way, you can use the mock repository class instead of the real repository class in your unit tests.</span></span> <span data-ttu-id="24994-194">使用類比儲存庫使您能夠在執行單元測試時避免執行資料庫代碼。</span><span class="sxs-lookup"><span data-stu-id="24994-194">Using the mock repository enables you to avoid executing database code when executing a unit test.</span></span>

<span data-ttu-id="24994-195">可視化工作室不包括類比物件框架。</span><span class="sxs-lookup"><span data-stu-id="24994-195">Visual Studio does not include a Mock Object framework.</span></span> <span data-ttu-id="24994-196">但是,有幾種商業和開源模擬物件框架可用於 .NET 框架:</span><span class="sxs-lookup"><span data-stu-id="24994-196">However, there are several commercial and open source Mock Object frameworks available for the .NET framework:</span></span>

1. <span data-ttu-id="24994-197">Moq - 此框架在開源 BSD 許可證下可用。</span><span class="sxs-lookup"><span data-stu-id="24994-197">Moq - This framework is available under the open source BSD license.</span></span> <span data-ttu-id="24994-198">你可以從[https://code.google.com/p/moq/](https://code.google.com/p/moq/)下載莫克。</span><span class="sxs-lookup"><span data-stu-id="24994-198">You can download Moq from [https://code.google.com/p/moq/](https://code.google.com/p/moq/).</span></span>
2. <span data-ttu-id="24994-199">犀牛類比 - 此框架可在開源 BSD 許可證下提供。</span><span class="sxs-lookup"><span data-stu-id="24994-199">Rhino Mocks - This framework is available under the open source BSD license.</span></span> <span data-ttu-id="24994-200">你可以從[http://ayende.com/projects/rhino-mocks.aspx](http://ayende.com/projects/rhino-mocks.aspx)下載犀牛類比。</span><span class="sxs-lookup"><span data-stu-id="24994-200">You can download Rhino Mocks from [http://ayende.com/projects/rhino-mocks.aspx](http://ayende.com/projects/rhino-mocks.aspx).</span></span>
3. <span data-ttu-id="24994-201">類型隔離器 - 這是一個商業框架。</span><span class="sxs-lookup"><span data-stu-id="24994-201">Typemock Isolator - This is a commercial framework.</span></span> <span data-ttu-id="24994-202">可以從 下載試用[http://www.typemock.com/](http://www.typemock.com/)版 。</span><span class="sxs-lookup"><span data-stu-id="24994-202">You can download a trial version from [http://www.typemock.com/](http://www.typemock.com/).</span></span>

<span data-ttu-id="24994-203">在本教學中,我決定使用 Moq。</span><span class="sxs-lookup"><span data-stu-id="24994-203">In this tutorial, I decided to use Moq.</span></span> <span data-ttu-id="24994-204">但是,您可以同樣輕鬆地使用 Rhino Mocks 或 Typemock 隔離器為聯絡人管理器應用程式創建 Mock 物件。</span><span class="sxs-lookup"><span data-stu-id="24994-204">However, you could just as easily use Rhino Mocks or Typemock Isolator to create the Mock objects for the Contact Manager application.</span></span>

<span data-ttu-id="24994-205">在使用 Moq 之前,您需要完成以下步驟:</span><span class="sxs-lookup"><span data-stu-id="24994-205">Before you can use Moq, you need to complete the following steps:</span></span>

1. <span data-ttu-id="24994-206">.</span><span class="sxs-lookup"><span data-stu-id="24994-206">.</span></span>
2. <span data-ttu-id="24994-207">在解壓縮下載之前,請確保右鍵按一下檔並按下標記為 **「取消阻止」** 的按鈕(參見圖 1)。</span><span class="sxs-lookup"><span data-stu-id="24994-207">Before you unzip the download, make sure that you right-click the file and click the button labeled **Unblock** (see Figure 1).</span></span>
3. <span data-ttu-id="24994-208">解壓縮下載。</span><span class="sxs-lookup"><span data-stu-id="24994-208">Unzip the download.</span></span>
4. <span data-ttu-id="24994-209">通過右鍵按一下 ContactManager 中的「引用」資料夾並選擇 **「添加引用**」,添加對 Moq 程式集的引用。</span><span class="sxs-lookup"><span data-stu-id="24994-209">Add a reference to the Moq assembly by right-clicking the References folder in the ContactManager.Tests project and selecting **Add Reference**.</span></span> <span data-ttu-id="24994-210">在「瀏覽」選項卡下,瀏覽到解壓縮 Moq 的資料夾,然後選擇 Moq.dll 程式集。</span><span class="sxs-lookup"><span data-stu-id="24994-210">Under the Browse tab, browse to the folder where you unzipped Moq and select the Moq.dll assembly.</span></span> <span data-ttu-id="24994-211">按一下 [確定]\*\*\*\* 按鈕。</span><span class="sxs-lookup"><span data-stu-id="24994-211">Click the **OK** button.</span></span>
5. <span data-ttu-id="24994-212">完成這些步驟后,參考文件應類似於圖 2。</span><span class="sxs-lookup"><span data-stu-id="24994-212">After you complete these steps, your References folder should look like Figure 2.</span></span>

<span data-ttu-id="24994-213">[![解除阻止莫克](iteration-5-create-unit-tests-cs/_static/image1.jpg)](iteration-5-create-unit-tests-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="24994-213">[![Unblocking Moq](iteration-5-create-unit-tests-cs/_static/image1.jpg)](iteration-5-create-unit-tests-cs/_static/image1.png)</span></span>

<span data-ttu-id="24994-214">**圖 01**: 取消封鎖 Moq([按下以檢視全尺寸影像](iteration-5-create-unit-tests-cs/_static/image2.png))</span><span class="sxs-lookup"><span data-stu-id="24994-214">**Figure 01**: Unblocking Moq([Click to view full-size image](iteration-5-create-unit-tests-cs/_static/image2.png))</span></span>

<span data-ttu-id="24994-215">[![新增 Moq 後的參考](iteration-5-create-unit-tests-cs/_static/image2.jpg)](iteration-5-create-unit-tests-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="24994-215">[![References after adding Moq](iteration-5-create-unit-tests-cs/_static/image2.jpg)](iteration-5-create-unit-tests-cs/_static/image3.png)</span></span>

<span data-ttu-id="24994-216">**圖 02**: 新增 Moq([按下以檢視全尺寸影像](iteration-5-create-unit-tests-cs/_static/image4.png))後的參考</span><span class="sxs-lookup"><span data-stu-id="24994-216">**Figure 02**: References after adding Moq([Click to view full-size image](iteration-5-create-unit-tests-cs/_static/image4.png))</span></span>

## <a name="creating-unit-tests-for-the-service-layer"></a><span data-ttu-id="24994-217">為服務層建立單元測試</span><span class="sxs-lookup"><span data-stu-id="24994-217">Creating Unit Tests for the Service Layer</span></span>

<span data-ttu-id="24994-218">讓我們首先為聯繫人管理器應用程式的服務層創建一組單元測試。</span><span class="sxs-lookup"><span data-stu-id="24994-218">Let s start by creating a set of unit tests for our Contact Manager application s service layer.</span></span> <span data-ttu-id="24994-219">我們將使用這些測試來驗證我們的驗證邏輯。</span><span class="sxs-lookup"><span data-stu-id="24994-219">We'll use these tests to verify our validation logic.</span></span>

<span data-ttu-id="24994-220">在 ContactManager.測試項目中創建名為" 模型" 的新資料夾。</span><span class="sxs-lookup"><span data-stu-id="24994-220">Create a new folder named Models in the ContactManager.Tests project.</span></span> <span data-ttu-id="24994-221">接下來,右鍵按兩下"模型"資料夾並選擇 **「添加、新建測試**」。</span><span class="sxs-lookup"><span data-stu-id="24994-221">Next, right-click the Models folder and select **Add, New Test**.</span></span> <span data-ttu-id="24994-222">將顯示圖 3 所示**的「添加新測試**」對話方塊。</span><span class="sxs-lookup"><span data-stu-id="24994-222">The **Add New Test** dialog shown in Figure 3 appears.</span></span> <span data-ttu-id="24994-223">選擇 **「單元測試」** 樣本並命名新測試ContactManager ServiceTest.cs。</span><span class="sxs-lookup"><span data-stu-id="24994-223">Select the **Unit Test** template and name your new test ContactManagerServiceTest.cs.</span></span> <span data-ttu-id="24994-224">按下 **「確定」** 按鈕將新測試添加到測試專案。</span><span class="sxs-lookup"><span data-stu-id="24994-224">Click the **OK** button to add your new test to your Test Project.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="24994-225">通常,您希望測試項目的資料夾結構與 ASP.NET MVC 專案的資料夾結構匹配。</span><span class="sxs-lookup"><span data-stu-id="24994-225">In general, you want the folder structure of your Test Project to match the folder structure of your ASP.NET MVC project.</span></span> <span data-ttu-id="24994-226">例如,將控制器測試放在控制器資料夾中,在模型資料夾中放置模型測試,等等。</span><span class="sxs-lookup"><span data-stu-id="24994-226">For example, you place controller tests in a Controllers folder, model tests in a Models folder, and so on.</span></span>

<span data-ttu-id="24994-227">[![型號_連絡管理員服務測試.cs](iteration-5-create-unit-tests-cs/_static/image3.jpg)](iteration-5-create-unit-tests-cs/_static/image5.png)</span><span class="sxs-lookup"><span data-stu-id="24994-227">[![Models\ContactManagerServiceTest.cs](iteration-5-create-unit-tests-cs/_static/image3.jpg)](iteration-5-create-unit-tests-cs/_static/image5.png)</span></span>

<span data-ttu-id="24994-228">**圖 03**:型號_ContactManagerServiceTest.cs([按下以檢視全尺寸影像](iteration-5-create-unit-tests-cs/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="24994-228">**Figure 03**: Models\ContactManagerServiceTest.cs([Click to view full-size image](iteration-5-create-unit-tests-cs/_static/image6.png))</span></span>

<span data-ttu-id="24994-229">最初,我們要測試 ContactManager 服務類公開的 CreateContact() 方法。</span><span class="sxs-lookup"><span data-stu-id="24994-229">Initially, we want to test the CreateContact() method exposed by the ContactManagerService class.</span></span> <span data-ttu-id="24994-230">我們將建立以下五個測試:</span><span class="sxs-lookup"><span data-stu-id="24994-230">We'll create the following five tests:</span></span>

- <span data-ttu-id="24994-231">創建聯絡人() - 當有效的聯繫人傳遞給方法時,創建聯繫人() 的測試返回該值為 true。</span><span class="sxs-lookup"><span data-stu-id="24994-231">CreateContact() - Tests that CreateContact() returns the value true when a valid Contact is passed to the method.</span></span>
- <span data-ttu-id="24994-232">創建聯絡人需要先名() - 測試當缺少名字的聯繫人傳遞給 CreateContact() 方法時,錯誤訊息是否添加到模型狀態。</span><span class="sxs-lookup"><span data-stu-id="24994-232">CreateContactRequiredFirstName() - Tests that an error message is added to model state when a Contact with a missing first name is passed to the CreateContact() method.</span></span>
- <span data-ttu-id="24994-233">創建聯絡人需要LastName() - 測試當缺少姓氏的聯絡人傳遞給 CreateContact() 方法時,將錯誤消息添加到模型狀態。</span><span class="sxs-lookup"><span data-stu-id="24994-233">CreateContactRequiredLastName() - Tests that an error message is added to model state when a Contact with a missing last name is passed to the CreateContact() method.</span></span>
- <span data-ttu-id="24994-234">建立聯絡人無效電話() - 測試當電話號碼無效的聯繫人傳遞給 CreateContact() 方法時,錯誤訊息是否添加到模型狀態。</span><span class="sxs-lookup"><span data-stu-id="24994-234">CreateContactInvalidPhone() - Tests that an error message is added to model state when a Contact with an invalid phone number is passed to the CreateContact() method.</span></span>
- <span data-ttu-id="24994-235">創建聯絡人無效電子郵件() - 測試當具有無效電子郵件地址的連絡人傳遞給 CreateContact() 方法時,錯誤訊息是否添加到模型狀態。</span><span class="sxs-lookup"><span data-stu-id="24994-235">CreateContactInvalidEmail() - Tests that an error message is added to model state when a Contact with an invalid email address is passed to the CreateContact() method..</span></span>

<span data-ttu-id="24994-236">第一個測試驗證有效的聯繫人未生成驗證錯誤。</span><span class="sxs-lookup"><span data-stu-id="24994-236">The first test verifies that a valid Contact does not generate a validation error.</span></span> <span data-ttu-id="24994-237">其餘的測試檢查每個驗證規則。</span><span class="sxs-lookup"><span data-stu-id="24994-237">The remaining tests check each of the validation rules.</span></span>

<span data-ttu-id="24994-238">這些測試的代碼包含在清單 1 中。</span><span class="sxs-lookup"><span data-stu-id="24994-238">The code for these tests is contained in Listing 1.</span></span>

<span data-ttu-id="24994-239">**清單1 - 型號_聯繫管理員服務測試.cs**</span><span class="sxs-lookup"><span data-stu-id="24994-239">**Listing 1 - Models\ContactManagerServiceTest.cs**</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample1.cs)]

<span data-ttu-id="24994-240">由於我們使用清單 1 中的 Contact 類,因此我們需要將對 Microsoft 實體框架的引用添加到我們的測試專案中。</span><span class="sxs-lookup"><span data-stu-id="24994-240">Because we use the Contact class in Listing 1, we need to add a reference to the Microsoft Entity Framework to our Test project.</span></span> <span data-ttu-id="24994-241">添加對系統.Data.實體程式集的引用。</span><span class="sxs-lookup"><span data-stu-id="24994-241">Add a reference to the System.Data.Entity assembly.</span></span>

<span data-ttu-id="24994-242">清單1包含一個名為初始化()的方法,該方法用 [測試初始化] 屬性進行修飾。</span><span class="sxs-lookup"><span data-stu-id="24994-242">Listing 1 contains a method named Initialize() that is decorated with the [TestInitialize] attribute.</span></span> <span data-ttu-id="24994-243">在運行每個單元測試之前自動調用此方法(在每個單元測試之前調用此方法 5 次)。</span><span class="sxs-lookup"><span data-stu-id="24994-243">This method is called automatically before each of the unit tests is run (it is called 5 times right before each of the unit tests).</span></span> <span data-ttu-id="24994-244">初始化()方法建立具有以下代碼行的模擬儲存庫:</span><span class="sxs-lookup"><span data-stu-id="24994-244">The Initialize() method creates a mock repository with the following line of code:</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample2.cs)]

<span data-ttu-id="24994-245">此代碼行使用 Moq 框架從 IContactManagerRepository 介面生成類比儲存庫。</span><span class="sxs-lookup"><span data-stu-id="24994-245">This line of code uses the Moq framework to generate a mock repository from the IContactManagerRepository interface.</span></span> <span data-ttu-id="24994-246">使用類比儲存庫而不是實際的實體聯繫人管理器儲存庫,以避免在運行每個單元測試時訪問資料庫。</span><span class="sxs-lookup"><span data-stu-id="24994-246">The mock repository is used instead of the actual EntityContactManagerRepository to avoid accessing the database when each unit test is run.</span></span> <span data-ttu-id="24994-247">類比儲存庫實現 IContactManagerRepository 介面的方法,但這些方法實際上不執行任何操作。</span><span class="sxs-lookup"><span data-stu-id="24994-247">The mock repository implements the methods of the IContactManagerRepository interface, but the methods don t actually do anything.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="24994-248">使用 Moq 框架時,mockRepository 和\_\_mockRepository.Object 區別是有區別的。</span><span class="sxs-lookup"><span data-stu-id="24994-248">When using the Moq framework, there is a distinction between \_mockRepository and \_mockRepository.Object.</span></span> <span data-ttu-id="24994-249">前者是指類&lt;比 IContactManagerManagerRepository&gt;類,該類包含用於指定類比儲存庫如何執行的方法。</span><span class="sxs-lookup"><span data-stu-id="24994-249">The former refers to the Mock&lt;IContactManagerRepository&gt; class that contains methods for specifying how the mock repository will behave.</span></span> <span data-ttu-id="24994-250">後者是指實現 IContactManager 儲存庫介面的實際類比儲存庫。</span><span class="sxs-lookup"><span data-stu-id="24994-250">The latter refers to the actual mock repository that implements the IContactManagerRepository interface.</span></span>

<span data-ttu-id="24994-251">創建 ContactManagerService 類的實例時,類比儲存庫在初始化() 方法中使用。</span><span class="sxs-lookup"><span data-stu-id="24994-251">The mock repository is used in the Initialize() method when creating an instance of the ContactManagerService class.</span></span> <span data-ttu-id="24994-252">所有單獨的單元測試都使用此聯繫人管理器服務類的此實例。</span><span class="sxs-lookup"><span data-stu-id="24994-252">All of the individual unit tests use this instance of the ContactManagerService class.</span></span>

<span data-ttu-id="24994-253">清單1包含與每個單元測試對應的五種方法。</span><span class="sxs-lookup"><span data-stu-id="24994-253">Listing 1 contains five methods that correspond to each of the unit tests.</span></span> <span data-ttu-id="24994-254">這些方法中的每一個都用 [TestMethod] 屬性進行修飾。</span><span class="sxs-lookup"><span data-stu-id="24994-254">Each of these methods is decorated with the [TestMethod] attribute.</span></span> <span data-ttu-id="24994-255">運行單元測試時,將調用具有此屬性的任何方法。</span><span class="sxs-lookup"><span data-stu-id="24994-255">When you run the unit tests, any method that has this attribute is called.</span></span> <span data-ttu-id="24994-256">換句話說,使用 [TestMethod] 屬性修飾的任何方法都是單元測試。</span><span class="sxs-lookup"><span data-stu-id="24994-256">In other words, any method that is decorated with the [TestMethod] attribute is a unit test.</span></span>

<span data-ttu-id="24994-257">第一個單元測試名為 CreateContact(),驗證在將 Contact 類的有效實例傳遞給該方法時調用 CreateContact() 傳回該值為 true。</span><span class="sxs-lookup"><span data-stu-id="24994-257">The first unit test, named CreateContact(), verifies that calling CreateContact() returns the value true when a valid instance of the Contact class is passed to the method.</span></span> <span data-ttu-id="24994-258">測試創建 Contact 類的實例,調用 CreateContact() 方法,並驗證 CreateContact() 傳回該值為 true。</span><span class="sxs-lookup"><span data-stu-id="24994-258">The test creates an instance of the Contact class, calls the CreateContact() method, and verifies that CreateContact() returns the value true.</span></span>

<span data-ttu-id="24994-259">其餘測試驗證當使用無效的 Contact 呼叫 CreateContact() 方法時,該方法將返回 false,並且預期的驗證錯誤訊息將添加到模型狀態。</span><span class="sxs-lookup"><span data-stu-id="24994-259">The remaining tests verify that when the CreateContact() method is called with an invalid Contact then the method returns false and the expected validation error message is added to model state.</span></span> <span data-ttu-id="24994-260">例如,"創建連絡人需求名稱()「測試將創建聯繫人類的實例,該類的 FirstName 屬性具有空字串。</span><span class="sxs-lookup"><span data-stu-id="24994-260">For example, the CreateContactRequiredFirstName() test creates an instance of the Contact class with an empty string for its FirstName property.</span></span> <span data-ttu-id="24994-261">接下來,使用無效的聯繫人調用 CreateContact() 方法。</span><span class="sxs-lookup"><span data-stu-id="24994-261">Next, the CreateContact() method is called with the invalid Contact.</span></span> <span data-ttu-id="24994-262">最後,測試驗證 CreateContact() 傳回 false,並且模型狀態包含預期的驗證錯誤訊息" 需要名字。</span><span class="sxs-lookup"><span data-stu-id="24994-262">Finally, the test verifies that CreateContact() returns false and that model state contains the expected validation error message "First name is required."</span></span>

<span data-ttu-id="24994-263">您可以通過選擇功能表選項 **「測試」、「執行」、「解決方案中的所有測試」(CTRL+R、A)** 來在清單 1 中執行單元測試。</span><span class="sxs-lookup"><span data-stu-id="24994-263">You can run the unit tests in Listing 1 by selecting the menu option **Test, Run, All Tests in Solution (CTRL+R, A)**.</span></span> <span data-ttu-id="24994-264">測試結果顯示在「測試結果」視窗中(參見圖 4)。</span><span class="sxs-lookup"><span data-stu-id="24994-264">The results of the tests are displayed in the Test Results window (see Figure 4).</span></span>

<span data-ttu-id="24994-265">[![測試結果](iteration-5-create-unit-tests-cs/_static/image4.jpg)](iteration-5-create-unit-tests-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="24994-265">[![Test Results](iteration-5-create-unit-tests-cs/_static/image4.jpg)](iteration-5-create-unit-tests-cs/_static/image7.png)</span></span>

<span data-ttu-id="24994-266">**圖 04**: 測試結果 ([按下以檢視全尺寸影像](iteration-5-create-unit-tests-cs/_static/image8.png))</span><span class="sxs-lookup"><span data-stu-id="24994-266">**Figure 04**: Test Results ([Click to view full-size image](iteration-5-create-unit-tests-cs/_static/image8.png))</span></span>

## <a name="creating-unit-tests-for-controllers"></a><span data-ttu-id="24994-267">為控制器建立單元測試</span><span class="sxs-lookup"><span data-stu-id="24994-267">Creating Unit Tests for Controllers</span></span>

<span data-ttu-id="24994-268">ASP.NETMVC 應用程式控制使用者互動流。</span><span class="sxs-lookup"><span data-stu-id="24994-268">ASP.NETMVC application control the flow of user interaction.</span></span> <span data-ttu-id="24994-269">測試控制器時,要測試控制器是否返回正確的操作結果並查看數據。</span><span class="sxs-lookup"><span data-stu-id="24994-269">When testing a controller, you want to test whether the controller returns the right action result and view data.</span></span> <span data-ttu-id="24994-270">您可能還希望測試控制器是否與模型類以預期的方式交互。</span><span class="sxs-lookup"><span data-stu-id="24994-270">You also might want to test whether a controller interacts with model classes in the manner expected.</span></span>

<span data-ttu-id="24994-271">例如,清單 2 包含聯絡人控制器 Create() 方法的兩個單元測試。</span><span class="sxs-lookup"><span data-stu-id="24994-271">For example, Listing 2 contains two unit tests for the Contact controller Create() method.</span></span> <span data-ttu-id="24994-272">第一個單元測試驗證當有效的聯繫人傳遞到 Create() 方法時,Create() 方法重定向到 Index 操作。</span><span class="sxs-lookup"><span data-stu-id="24994-272">The first unit test verifies that when a valid Contact is passed to the Create() method then the Create() method redirects to the Index action.</span></span> <span data-ttu-id="24994-273">換句話說,當傳遞有效的聯繫人時,Create() 方法應返回表示索引操作的重定向到RouteResult。</span><span class="sxs-lookup"><span data-stu-id="24994-273">In other words, when passed a valid Contact, the Create() method should return a RedirectToRouteResult that represents the Index action.</span></span>

<span data-ttu-id="24994-274">在測試控制器層時,我們不想測試 ContactManager 服務層。</span><span class="sxs-lookup"><span data-stu-id="24994-274">We don t want to test the ContactManager service layer when we are testing the controller layer.</span></span> <span data-ttu-id="24994-275">因此,我們在初始化方法中使用以下代碼模擬服務層:</span><span class="sxs-lookup"><span data-stu-id="24994-275">Therefore, we mock the service layer with the following code in the Initialize method:</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample3.cs)]

<span data-ttu-id="24994-276">在 CreateValidContact() 單元測試中,我們用以下代碼行模擬呼叫服務層 CreateContact() 方法的行為:</span><span class="sxs-lookup"><span data-stu-id="24994-276">In the CreateValidContact() unit test, we mock the behavior of calling the service layer CreateContact() method with the following line of code:</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample4.cs)]

<span data-ttu-id="24994-277">此代碼行在調用其 CreateContact() 方法時,會導致類比 ContactManager 服務返回該值 true。</span><span class="sxs-lookup"><span data-stu-id="24994-277">This line of code causes the mock ContactManager service to return the value true when its CreateContact() method is called.</span></span> <span data-ttu-id="24994-278">通過類比服務層,我們可以測試控制器的行為,而無需在服務層中執行任何代碼。</span><span class="sxs-lookup"><span data-stu-id="24994-278">By mocking the service layer, we can test the behavior of our controller without needing to execute any code in the service layer.</span></span>

<span data-ttu-id="24994-279">第二個單元測試驗證 Create() 操作在將無效聯繫人傳遞給方法時是否返回"創建"視圖。</span><span class="sxs-lookup"><span data-stu-id="24994-279">The second unit test verifies that the Create() action returns the Create view when an invalid contact is passed to the method.</span></span> <span data-ttu-id="24994-280">我們使服務層 CreateContact() 方法使用以下代碼行傳回錯誤值:</span><span class="sxs-lookup"><span data-stu-id="24994-280">We cause the service layer CreateContact() method to return the value false with the following line of code:</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample5.cs)]

<span data-ttu-id="24994-281">如果 Create() 方法按預期方式進行,則當服務層返回值為 false 時,它應返回"創建"視圖。</span><span class="sxs-lookup"><span data-stu-id="24994-281">If the Create() method behaves as we expect then it should return the Create view when the service layer returns the value false.</span></span> <span data-ttu-id="24994-282">這樣,控制器可以在"創建"視圖中顯示驗證錯誤消息,並且使用者有機會更正無效的"連絡人"屬性。</span><span class="sxs-lookup"><span data-stu-id="24994-282">That way, the controller can display the validation error messages in the Create view and the user has a chance to correct that invalid Contact properties.</span></span>

<span data-ttu-id="24994-283">如果計劃為控制器生成單元測試,則需要從控制器操作中返回顯式視圖名稱。</span><span class="sxs-lookup"><span data-stu-id="24994-283">If you plan to build unit tests for your controllers then you need to return explicit view names from your controller actions.</span></span> <span data-ttu-id="24994-284">例如,不要返回如下所示的視圖:</span><span class="sxs-lookup"><span data-stu-id="24994-284">For example, do not return a view like this:</span></span>

<span data-ttu-id="24994-285">返回視圖();</span><span class="sxs-lookup"><span data-stu-id="24994-285">return View();</span></span>

<span data-ttu-id="24994-286">相反,返回檢視如下所示:</span><span class="sxs-lookup"><span data-stu-id="24994-286">Instead, return the view like this:</span></span>

<span data-ttu-id="24994-287">返回視圖("創建");</span><span class="sxs-lookup"><span data-stu-id="24994-287">return View("Create");</span></span>

<span data-ttu-id="24994-288">如果在返回檢視時不是顯式,則ViewResult.ViewName 屬性將返回一個空字串。</span><span class="sxs-lookup"><span data-stu-id="24994-288">If you are not explicit when returning a view then the ViewResult.ViewName property returns an empty string.</span></span>

<span data-ttu-id="24994-289">**清單2 - 控制器\連絡控制器測試.cs**</span><span class="sxs-lookup"><span data-stu-id="24994-289">**Listing 2 - Controllers\ContactControllerTest.cs**</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample6.cs)]

## <a name="summary"></a><span data-ttu-id="24994-290">總結</span><span class="sxs-lookup"><span data-stu-id="24994-290">Summary</span></span>

<span data-ttu-id="24994-291">在此反覆運算中,我們為聯繫人管理器應用程式創建了單元測試。</span><span class="sxs-lookup"><span data-stu-id="24994-291">In this iteration, we created unit tests for our Contact Manager application.</span></span> <span data-ttu-id="24994-292">我們可以隨時運行這些單元測試,以驗證我們的應用程式是否仍按預期方式運行。</span><span class="sxs-lookup"><span data-stu-id="24994-292">We can run these unit tests at any time to verify that our application still behaves in the manner that we expect.</span></span> <span data-ttu-id="24994-293">單元測試作為我們應用程式的安全網,使我們能夠在未來安全地修改我們的應用程式。</span><span class="sxs-lookup"><span data-stu-id="24994-293">The unit tests act as a safety net for our application enabling us to safely modify our application in the future.</span></span>

<span data-ttu-id="24994-294">我們創建了兩組單元測試。</span><span class="sxs-lookup"><span data-stu-id="24994-294">We created two sets of unit tests.</span></span> <span data-ttu-id="24994-295">首先,我們通過為服務層創建單元測試來測試驗證邏輯。</span><span class="sxs-lookup"><span data-stu-id="24994-295">First, we tested our validation logic by creating unit tests for our service layer.</span></span> <span data-ttu-id="24994-296">接下來,我們通過為控制器層創建單元測試來測試流量控制邏輯。</span><span class="sxs-lookup"><span data-stu-id="24994-296">Next, we tested our flow control logic by creating unit tests for our controller layer.</span></span> <span data-ttu-id="24994-297">在測試服務層時,我們通過類比存儲庫層將服務層的測試與存儲庫層隔離開來。</span><span class="sxs-lookup"><span data-stu-id="24994-297">When testing our service layer, we isolated our tests for our service layer from our repository layer by mocking our repository layer.</span></span> <span data-ttu-id="24994-298">測試控制器層時,我們通過類比服務層來隔離控制器層的測試。</span><span class="sxs-lookup"><span data-stu-id="24994-298">When testing the controller layer, we isolated our tests for our controller layer by mocking the service layer.</span></span>

<span data-ttu-id="24994-299">在下一次反覆運算中,我們修改聯繫人管理器應用程式,以便它支援連絡人組。</span><span class="sxs-lookup"><span data-stu-id="24994-299">In the next iteration, we modify the Contact Manager application so that it supports Contact Groups.</span></span> <span data-ttu-id="24994-300">我們將使用稱為測試驅動開發的軟體設計過程將這項新功能添加到我們的應用程式中。</span><span class="sxs-lookup"><span data-stu-id="24994-300">We'll add this new functionality to our application using a software design process called test-driven development.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="24994-301">[前一個](iteration-4-make-the-application-loosely-coupled-cs.md)
> [下一個](iteration-6-use-test-driven-development-cs.md)</span><span class="sxs-lookup"><span data-stu-id="24994-301">[Previous](iteration-4-make-the-application-loosely-coupled-cs.md)
[Next](iteration-6-use-test-driven-development-cs.md)</span></span>
