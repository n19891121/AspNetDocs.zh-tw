---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: ASP.NET MVC 和 Web Pages 中的 XSRF/CSRF 防護 |Microsoft Docs
author: Rick-Anderson
description: 跨網站偽造要求（也稱為 XSRF 或 CSRF）是對 web 託管應用程式的攻擊，而惡意網站可能會影響 interacti 。
ms.author: riande
ms.date: 03/14/2013
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: fb7e76101cbe6a874ddf5b3429ca2dc6d474334b
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/28/2019
ms.locfileid: "74595766"
---
# <a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a><span data-ttu-id="c519e-103">ASP.NET MVC 和 ASP.NET Web Pages 中的 XSRF/CSRF 防護</span><span class="sxs-lookup"><span data-stu-id="c519e-103">XSRF/CSRF Prevention in ASP.NET MVC and Web Pages</span></span>

<span data-ttu-id="c519e-104">依[Rick Anderson]((https://twitter.com/RickAndMSFT))</span><span class="sxs-lookup"><span data-stu-id="c519e-104">by [Rick Anderson]((https://twitter.com/RickAndMSFT))</span></span>

> <span data-ttu-id="c519e-105">跨網站偽造要求（也稱為 XSRF 或 CSRF）是對 web 裝載應用程式的攻擊，因此惡意網站可能會影響用戶端瀏覽器與該瀏覽器信任的網站之間的互動。</span><span class="sxs-lookup"><span data-stu-id="c519e-105">Cross-site request forgery (also known as XSRF or CSRF) is an attack against web-hosted applications whereby a malicious web site can influence the interaction between a client browser and a web site trusted by that browser.</span></span> <span data-ttu-id="c519e-106">由於網頁瀏覽器會在每次要求網站時自動傳送驗證權杖，因此可以進行這些攻擊。</span><span class="sxs-lookup"><span data-stu-id="c519e-106">These attacks are made possible because web browsers will send authentication tokens automatically with every request to a web site.</span></span> <span data-ttu-id="c519e-107">標準範例是驗證 cookie，例如 ASP。NET 的表單驗證票證。</span><span class="sxs-lookup"><span data-stu-id="c519e-107">The canonical example is an authentication cookie, such as ASP.NET's Forms Authentication ticket.</span></span> <span data-ttu-id="c519e-108">不過，使用任何持續性驗證機制（例如 Windows 驗證、基本等等）的網站，都可以受到這些攻擊的目標。</span><span class="sxs-lookup"><span data-stu-id="c519e-108">However, web sites which use any persistent authentication mechanism (such as Windows Authentication, Basic, and so forth) can be targeted by these attacks.</span></span>
> 
> <span data-ttu-id="c519e-109">XSRF 攻擊與網路釣魚攻擊不同。</span><span class="sxs-lookup"><span data-stu-id="c519e-109">An XSRF attack is distinct from a phishing attack.</span></span> <span data-ttu-id="c519e-110">網路釣魚攻擊需要來自犧牲者的互動。</span><span class="sxs-lookup"><span data-stu-id="c519e-110">Phishing attacks require interaction from the victim.</span></span> <span data-ttu-id="c519e-111">在網路釣魚攻擊中，惡意網站會模擬目標網站，而受害者會愚弄為攻擊者提供機密資訊。</span><span class="sxs-lookup"><span data-stu-id="c519e-111">In a phishing attack, a malicious web site will mimic the target web site, and the victim is fooled into providing sensitive information to the attacker.</span></span> <span data-ttu-id="c519e-112">在 XSRF 攻擊中，犧牲者通常不需要進行任何互動。</span><span class="sxs-lookup"><span data-stu-id="c519e-112">In an XSRF attack, there is often no interaction necessary from the victim.</span></span> <span data-ttu-id="c519e-113">相反地，攻擊者會依賴瀏覽器自動將所有相關的 cookie 傳送至目的地網站。</span><span class="sxs-lookup"><span data-stu-id="c519e-113">Rather, the attacker is relying on the browser automatically sending all relevant cookies to the destination web site.</span></span>
> 
> <span data-ttu-id="c519e-114">如需詳細資訊，請參閱[Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)（OWASP） [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))。</span><span class="sxs-lookup"><span data-stu-id="c519e-114">For more information, see the [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span></span>

## <a name="anatomy-of-an-attack"></a><span data-ttu-id="c519e-115">攻擊的剖析</span><span class="sxs-lookup"><span data-stu-id="c519e-115">Anatomy of an attack</span></span>

<span data-ttu-id="c519e-116">若要逐步完成 XSRF 攻擊，請考慮想要執行一些線上銀行交易的使用者。</span><span class="sxs-lookup"><span data-stu-id="c519e-116">To walk through an XSRF attack, consider a user who wants to perform some online banking transactions.</span></span> <span data-ttu-id="c519e-117">此使用者會先造訪 WoodgroveBank.com 和登入，此時回應標頭會包含她的驗證 cookie：</span><span class="sxs-lookup"><span data-stu-id="c519e-117">This user first visits WoodgroveBank.com and logs in, at which point the response header will contain her authentication cookie:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

<span data-ttu-id="c519e-118">因為驗證 cookie 是會話 cookie，所以瀏覽器會在瀏覽器進程結束時自動清除。</span><span class="sxs-lookup"><span data-stu-id="c519e-118">Because the authentication cookie is a session cookie, it will be automatically cleared by the browser when the browser process exits.</span></span> <span data-ttu-id="c519e-119">不過，在該時間之前，瀏覽器會自動包含每個要求到 WoodgroveBank.com 的 cookie。</span><span class="sxs-lookup"><span data-stu-id="c519e-119">However, until that time, the browser will automatically include the cookie with each request to WoodgroveBank.com.</span></span> <span data-ttu-id="c519e-120">使用者現在想要將 $1000 轉移到另一個帳戶，因此她會在銀行網站上填滿表單，而瀏覽器會對伺服器提出此要求：</span><span class="sxs-lookup"><span data-stu-id="c519e-120">The user now wants to transfer $1000 to another account, so she fills out a form on the banking site, and the browser makes this request to the server:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

<span data-ttu-id="c519e-121">由於這項作業有副作用（它會起始貨幣交易），因此銀行網站已選擇要求 HTTP POST，以起始這項操作。</span><span class="sxs-lookup"><span data-stu-id="c519e-121">Because this operation has a side effect (it initiates a monetary transaction), the banking site has chosen to require an HTTP POST in order to initiate this operation.</span></span> <span data-ttu-id="c519e-122">伺服器會從要求讀取驗證權杖、查詢目前使用者的帳戶號碼、確認有足夠的資金存在，然後在目的地帳戶中起始交易。</span><span class="sxs-lookup"><span data-stu-id="c519e-122">The server reads the authentication token from the request, looks up the current user's account number, verifies that sufficient funds exist, and then initiates the transaction into the destination account.</span></span>

<span data-ttu-id="c519e-123">她的線上銀行完成後，使用者離開銀行網站，流覽網站上的其他位置。</span><span class="sxs-lookup"><span data-stu-id="c519e-123">Her online banking complete, the user navigates away from the banking site and visits other locations on the web.</span></span> <span data-ttu-id="c519e-124">其中一個網站– fabrikam.com –在內嵌于 &lt;iframe&gt;的頁面上包含下列標記：</span><span class="sxs-lookup"><span data-stu-id="c519e-124">One of those sites – fabrikam.com – includes the following markup on a page embedded within an &lt;iframe&gt;:</span></span>

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

<span data-ttu-id="c519e-125">這會導致瀏覽器提出此要求：</span><span class="sxs-lookup"><span data-stu-id="c519e-125">Which then causes the browser to make this request:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

<span data-ttu-id="c519e-126">攻擊者利用的事實是，使用者對於目標網站可能還是會有有效的驗證權杖，而她使用一小部分的 JAVAscript 讓瀏覽器自動對目標網站進行 HTTP POST。</span><span class="sxs-lookup"><span data-stu-id="c519e-126">The attacker is exploiting the fact that the user might still have a valid authentication token for the target web site, and she is using a small snippet of Javascript to cause the browser to make an HTTP POST to the target site automatically.</span></span> <span data-ttu-id="c519e-127">如果驗證權杖仍然有效，銀行網站將會起始 $250 傳輸到攻擊者選擇的帳戶。</span><span class="sxs-lookup"><span data-stu-id="c519e-127">If the authentication token is still valid, the banking site will initiate a transfer of $250 into the account of the attacker's choosing.</span></span>

### <a name="ineffective-mitigations"></a><span data-ttu-id="c519e-128">不正確緩和措施</span><span class="sxs-lookup"><span data-stu-id="c519e-128">Ineffective mitigations</span></span>

<span data-ttu-id="c519e-129">值得注意的是，在上述案例中，WoodgroveBank.com 是透過 SSL 存取，而且具有僅限 SSL 的驗證 cookie 並不足以阻止攻擊。</span><span class="sxs-lookup"><span data-stu-id="c519e-129">It is interesting to note that in the above scenario, the fact that WoodgroveBank.com was being accessed via SSL and had an SSL-only authentication cookie was insufficient to thwart the attack.</span></span> <span data-ttu-id="c519e-130">攻擊者可以在她的 &lt;表單&gt; 元素中指定[URI 配置](http://en.wikipedia.org/wiki/URI_scheme)（HTTPs），而瀏覽器會繼續將未到期的 cookie 傳送至目標網站，只要那些 cookie 與預定目標的 URI 配置一致即可。</span><span class="sxs-lookup"><span data-stu-id="c519e-130">The attacker is able to specify the [URI scheme](http://en.wikipedia.org/wiki/URI_scheme) (https) in her &lt;form&gt; element, and the browser will continue to send unexpired cookies to the target site as long as those cookies are consistent with the URI scheme of the intended target.</span></span>

<span data-ttu-id="c519e-131">其中一個人可能會認為，使用者不應該直接造訪不受信任的網站，因為只造訪信任的網站有助於在線上保持安全。</span><span class="sxs-lookup"><span data-stu-id="c519e-131">One could argue that the user should simply not visit untrusted sites, as visiting only trusted sites is helps to remain safe online.</span></span> <span data-ttu-id="c519e-132">事實上，這種做法並不一定可行。</span><span class="sxs-lookup"><span data-stu-id="c519e-132">There is some truth to this, but unfortunately this advice is not always practical.</span></span> <span data-ttu-id="c519e-133">可能是使用者「信任」當地新聞網站 ConsolidatedMessenger。</span><span class="sxs-lookup"><span data-stu-id="c519e-133">Perhaps the user "trusts" the local news site ConsolidatedMessenger.</span></span> <span data-ttu-id="c519e-134">ConsolidatedMessenger.com 並改為造訪該網站，但該網站具有 XSS 弱點，可讓攻擊者插入在 fabrikam.com 上執行的相同程式碼片段。</span><span class="sxs-lookup"><span data-stu-id="c519e-134">ConsolidatedMessenger.com and goes to visit that site instead, but that site has an XSS vulnerability which allows an attacker to inject the same snippet of code that was running on fabrikam.com.</span></span>

<span data-ttu-id="c519e-135">您可以確認傳入要求的[推薦者標頭](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14)參考您的網域。</span><span class="sxs-lookup"><span data-stu-id="c519e-135">You can verify that incoming requests have a [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) referencing your domain.</span></span> <span data-ttu-id="c519e-136">這會停止從協力廠商網域中不知情提交的要求。</span><span class="sxs-lookup"><span data-stu-id="c519e-136">This will stop requests unwittingly submitted from a third-party domain.</span></span> <span data-ttu-id="c519e-137">不過，有些人會因為隱私權的緣故而停用其瀏覽器的推薦者標頭，而攻擊者有時可能會在受害者已安裝特定不安全軟體時偽造該標頭。</span><span class="sxs-lookup"><span data-stu-id="c519e-137">However, some people disable their browser's Referer header for privacy reasons, and attackers can sometimes spoof that header if the victim has certain insecure software installed.</span></span> <span data-ttu-id="c519e-138">驗證[推薦者標頭](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14)不會被視為防止 XSRF 攻擊的安全方法。</span><span class="sxs-lookup"><span data-stu-id="c519e-138">Verifying the [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) is not considered a secure approach to preventing XSRF attacks.</span></span>

## <a name="web-stack-runtime-xsrf-mitigations"></a><span data-ttu-id="c519e-139">Web Stack 執行時間 XSRF 緩和措施</span><span class="sxs-lookup"><span data-stu-id="c519e-139">Web Stack Runtime XSRF mitigations</span></span>

<span data-ttu-id="c519e-140">ASP.NET Web Stack 執行時間會使用[同步器權杖模式](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern)的變體，來防禦 XSRF 攻擊。</span><span class="sxs-lookup"><span data-stu-id="c519e-140">The ASP.NET Web Stack Runtime uses a variant of the [synchronizer token pattern](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern) to defend against XSRF attacks.</span></span> <span data-ttu-id="c519e-141">同步器權杖模式的一般形式是，兩個反 XSRF 權杖會連同每個 HTTP POST （除了驗證 token）提交至伺服器：一個權杖做為 cookie，另一個則當做表單值。</span><span class="sxs-lookup"><span data-stu-id="c519e-141">The general form of the synchronizer token pattern is that two anti-XSRF tokens are submitted to the server with each HTTP POST (In addition to the authentication token): one token as a cookie, and the other as a form value.</span></span> <span data-ttu-id="c519e-142">ASP.NET 執行時間所產生的權杖值不具決定性，也不能由攻擊者預測。</span><span class="sxs-lookup"><span data-stu-id="c519e-142">The token values generated by the ASP.NET runtime are not deterministic or predictable by an attacker.</span></span> <span data-ttu-id="c519e-143">提交權杖時，只有在兩個權杖通過比較檢查時，伺服器才會允許要求繼續進行。</span><span class="sxs-lookup"><span data-stu-id="c519e-143">When the tokens are submitted, the server will allow the request to proceed only if both tokens pass a comparison check.</span></span>

<span data-ttu-id="c519e-144">XSRF 要求驗證*會話權杖*會儲存為 HTTP cookie，而且目前在其承載中包含下列資訊：</span><span class="sxs-lookup"><span data-stu-id="c519e-144">The XSRF request verification *session token* is stored as an HTTP cookie and currently contains the following information in its payload:</span></span>

- <span data-ttu-id="c519e-145">由隨機128位識別碼組成的安全性權杖。</span><span class="sxs-lookup"><span data-stu-id="c519e-145">A security token, consisting of a random 128-bit identifier.</span></span>   
 <span data-ttu-id="c519e-146">下圖顯示使用 Internet Explorer F12 開發人員工具顯示的 XSRF 要求驗證會話權杖：（請注意，這是目前的執行，甚至可能會變更）。</span><span class="sxs-lookup"><span data-stu-id="c519e-146">The following image shows the XSRF request verification session token displayed with the Internet Explorer F12 developer tools: (Note this is the current implementation and is subject, even likely, to change.)</span></span>

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

<span data-ttu-id="c519e-147">*欄位 token*會儲存為 `<input type="hidden" />`，並在其裝載中包含下列資訊：</span><span class="sxs-lookup"><span data-stu-id="c519e-147">The *field token* is stored as an `<input type="hidden" />` and contains the following information in its payload:</span></span>

- <span data-ttu-id="c519e-148">登入使用者的使用者名稱（如果已驗證的話）。</span><span class="sxs-lookup"><span data-stu-id="c519e-148">The logged-in user's username (if authenticated).</span></span>
- <span data-ttu-id="c519e-149">[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)提供的任何其他資料。</span><span class="sxs-lookup"><span data-stu-id="c519e-149">Any additional data provided by an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span></span>

<span data-ttu-id="c519e-150">反 XSRF token 的裝載會經過加密和簽署，因此當您使用工具檢查權杖時，就無法查看使用者名稱。</span><span class="sxs-lookup"><span data-stu-id="c519e-150">The payloads of the anti-XSRF tokens are encrypted and signed, so you can't view the username when using tools to examine the tokens.</span></span> <span data-ttu-id="c519e-151">當 web 應用程式以 ASP.NET 4.0 為目標時，密碼編譯服務會由[MachineKey 提供。編碼](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx)常式。</span><span class="sxs-lookup"><span data-stu-id="c519e-151">When the web application is targeting ASP.NET 4.0, cryptographic services are provided by the [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) routine.</span></span> <span data-ttu-id="c519e-152">當 web 應用程式的目標為 ASP.NET 4.5 或更高版本時，MachineKey 會提供密碼編譯服務[。保護](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110))常式，以提供更佳的效能、擴充性和安全性。</span><span class="sxs-lookup"><span data-stu-id="c519e-152">When the web application is targeting ASP.NET 4.5 or higher, cryptographic services are provided by the [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) routine, which offers better performance, extensibility, and security.</span></span> <span data-ttu-id="c519e-153">如需更多詳細資料，請參閱下列 blog 文章：</span><span class="sxs-lookup"><span data-stu-id="c519e-153">See the following blog posts for more details:</span></span>

- [<span data-ttu-id="c519e-154">ASP.NET 4.5 中的密碼編譯改善，pt. 1</span><span class="sxs-lookup"><span data-stu-id="c519e-154">Cryptographic Improvements in ASP.NET 4.5, pt. 1</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [<span data-ttu-id="c519e-155">ASP.NET 4.5 中的密碼編譯改良功能，pt. 2</span><span class="sxs-lookup"><span data-stu-id="c519e-155">Cryptographic Improvements in ASP.NET 4.5, pt. 2</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [<span data-ttu-id="c519e-156">ASP.NET 4.5 的密碼編譯增強功能，pt. 3</span><span class="sxs-lookup"><span data-stu-id="c519e-156">Cryptographic Improvements in ASP.NET 4.5, pt. 3</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a><span data-ttu-id="c519e-157">產生權杖</span><span class="sxs-lookup"><span data-stu-id="c519e-157">Generating the tokens</span></span>

<span data-ttu-id="c519e-158">若要產生反 XSRF token，請從 MVC 視圖呼叫[@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx)方法，或從 Razor 頁面 @AntiForgery.GetHtml（）。</span><span class="sxs-lookup"><span data-stu-id="c519e-158">To generate the anti-XSRF tokens, call the [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) method from an MVC view or @AntiForgery.GetHtml() from a Razor page.</span></span> <span data-ttu-id="c519e-159">執行時間接著會執行下列步驟：</span><span class="sxs-lookup"><span data-stu-id="c519e-159">The runtime will then perform the following steps:</span></span>

1. <span data-ttu-id="c519e-160">如果目前的 HTTP 要求已經包含反 XSRF 會話權杖（反 XSRF cookie \_\_RequestVerificationToken），則會從它解壓縮安全性權杖。</span><span class="sxs-lookup"><span data-stu-id="c519e-160">If the current HTTP request already contains an anti-XSRF session token (the anti-XSRF cookie \_\_RequestVerificationToken), the security token is extracted from it.</span></span> <span data-ttu-id="c519e-161">如果 HTTP 要求不包含反 XSRF 會話 token，或如果安全性權杖的解壓縮失敗，則會產生新的隨機反 XSRF token。</span><span class="sxs-lookup"><span data-stu-id="c519e-161">If the HTTP request does not contain an anti-XSRF session token or if extraction of the security token fails, a new random anti-XSRF token will be generated.</span></span>
2. <span data-ttu-id="c519e-162">會使用上述步驟（1）中的安全性權杖，以及目前登入使用者的身分識別，來產生反 XSRF 欄位 token。</span><span class="sxs-lookup"><span data-stu-id="c519e-162">An anti-XSRF field token is generated using the security token from step (1) above and the identity of the current logged-in user.</span></span> <span data-ttu-id="c519e-163">（如需有關判斷使用者身分識別的詳細資訊，請參閱下面的「 **[具有特殊支援的案例](#_Scenarios_with_special)** 」一節）。此外，如果已設定[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) ，執行時間會呼叫其[GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx)方法，並在欄位 token 中包含傳回的字串。</span><span class="sxs-lookup"><span data-stu-id="c519e-163">(For more information on determining user identity, see the **[Scenarios with special support](#_Scenarios_with_special)** section below.) Additionally, if an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) is configured, the runtime will call its [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) method and include the returned string in the field token.</span></span> <span data-ttu-id="c519e-164">（如需詳細資訊，請參閱設定 **[和](#_Configuration_and_extensibility)** 擴充性一節）。</span><span class="sxs-lookup"><span data-stu-id="c519e-164">(See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.)</span></span>
3. <span data-ttu-id="c519e-165">如果在步驟（1）中產生新的反 XSRF token，則會建立新的會話權杖以包含它，並將其新增至輸出 HTTP cookie 集合。</span><span class="sxs-lookup"><span data-stu-id="c519e-165">If a new anti-XSRF token was generated in step (1), a new session token will be created to contain it and will be added to the outbound HTTP cookies collection.</span></span> <span data-ttu-id="c519e-166">步驟（2）中的欄位 token 將會包裝在 `<input type="hidden" />` 元素中，而此 HTML 標籤會是 `Html.AntiForgeryToken()` 或 `AntiForgery.GetHtml()`的傳回值。</span><span class="sxs-lookup"><span data-stu-id="c519e-166">The field token from step (2) will be wrapped in an `<input type="hidden" />` element, and this HTML markup will be the return value of `Html.AntiForgeryToken()` or `AntiForgery.GetHtml()`.</span></span>

## <a name="validating-the-tokens"></a><span data-ttu-id="c519e-167">驗證權杖</span><span class="sxs-lookup"><span data-stu-id="c519e-167">Validating the tokens</span></span>

<span data-ttu-id="c519e-168">若要驗證傳入的防 XSRF token，開發人員在其 MVC 動作或控制器上包含[ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx)屬性，或她從 Razor 頁面呼叫 `@AntiForgery.Validate()`。</span><span class="sxs-lookup"><span data-stu-id="c519e-168">To validate the incoming anti-XSRF tokens, the developer includes a [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) attribute on her MVC action or controller, or she calls `@AntiForgery.Validate()` from her Razor page.</span></span> <span data-ttu-id="c519e-169">執行時間將會執行下列步驟：</span><span class="sxs-lookup"><span data-stu-id="c519e-169">The runtime will perform the following steps:</span></span>

1. <span data-ttu-id="c519e-170">系統會讀取傳入會話權杖和欄位權杖，並從每個權杖提取反 XSRF token。</span><span class="sxs-lookup"><span data-stu-id="c519e-170">The incoming session token and field token are read and the anti-XSRF token extracted from each.</span></span> <span data-ttu-id="c519e-171">XSRF 權杖在世代常式中的每個步驟（2）都必須相同。</span><span class="sxs-lookup"><span data-stu-id="c519e-171">The anti-XSRF tokens must be identical per step (2) in the generation routine.</span></span>
2. <span data-ttu-id="c519e-172">如果目前的使用者已通過驗證，則會與欄位權杖中儲存的使用者名稱進行比較。</span><span class="sxs-lookup"><span data-stu-id="c519e-172">If the current user is authenticated, her username is compared with the username stored in the field token.</span></span> <span data-ttu-id="c519e-173">使用者名稱必須相符。</span><span class="sxs-lookup"><span data-stu-id="c519e-173">The usernames must match.</span></span>
3. <span data-ttu-id="c519e-174">如果已設定[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) ，執行時間會呼叫其*ValidateAdditionalData*方法。</span><span class="sxs-lookup"><span data-stu-id="c519e-174">If an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) is configured, the runtime calls its *ValidateAdditionalData* method.</span></span> <span data-ttu-id="c519e-175">此方法必須傳回布林值*true*。</span><span class="sxs-lookup"><span data-stu-id="c519e-175">The method must return the Boolean value *true*.</span></span>

<span data-ttu-id="c519e-176">如果驗證成功，則允許要求繼續進行。</span><span class="sxs-lookup"><span data-stu-id="c519e-176">If validation succeeds, the request is allowed to proceed.</span></span> <span data-ttu-id="c519e-177">如果驗證失敗，架構將會擲回*HttpAntiForgeryException*。</span><span class="sxs-lookup"><span data-stu-id="c519e-177">If validation fails, the framework will throw an *HttpAntiForgeryException*.</span></span>

## <a name="failure-conditions"></a><span data-ttu-id="c519e-178">失敗狀況</span><span class="sxs-lookup"><span data-stu-id="c519e-178">Failure conditions</span></span>

<span data-ttu-id="c519e-179">從 ASP.NET Web Stack 執行時間 v2 開始，驗證期間擲回的任何*HttpAntiForgeryException*都會包含錯誤發生的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="c519e-179">Starting with The ASP.NET Web Stack Runtime v2, any *HttpAntiForgeryException* that is thrown during validation will contain detailed information about what went wrong.</span></span> <span data-ttu-id="c519e-180">目前定義的失敗狀況如下：</span><span class="sxs-lookup"><span data-stu-id="c519e-180">The currently defined failure conditions are:</span></span>

- <span data-ttu-id="c519e-181">會話權杖或表單權杖不存在於要求中。</span><span class="sxs-lookup"><span data-stu-id="c519e-181">The session token or form token is not present in the request.</span></span>
- <span data-ttu-id="c519e-182">會話權杖或表單 token 無法讀取。</span><span class="sxs-lookup"><span data-stu-id="c519e-182">The session token or form token is unreadable.</span></span> <span data-ttu-id="c519e-183">最有可能的原因是執行 ASP.NET Web Stack 執行時間不相符的伺服器陣列，或在 web.config 中的 &lt;machineKey&gt; 元素與電腦之間不同的伺服器陣列。</span><span class="sxs-lookup"><span data-stu-id="c519e-183">The most likely cause of this is a farm running mismatched versions of The ASP.NET Web Stack Runtime or a farm where the &lt;machineKey&gt; element in Web.config differs between machines.</span></span> <span data-ttu-id="c519e-184">您可以使用 Fiddler 之類的工具來強制執行此例外狀況，方法是利用反 XSRF token 來進行篡改。</span><span class="sxs-lookup"><span data-stu-id="c519e-184">You can use a tool such as Fiddler to force this exception by tampering with either anti-XSRF token.</span></span>
- <span data-ttu-id="c519e-185">已交換會話權杖和欄位 token。</span><span class="sxs-lookup"><span data-stu-id="c519e-185">The session token and field token were swapped.</span></span>
- <span data-ttu-id="c519e-186">會話權杖和欄位權杖包含不相符的安全性權杖。</span><span class="sxs-lookup"><span data-stu-id="c519e-186">The session token and field token contain mismatched security tokens.</span></span>
- <span data-ttu-id="c519e-187">內嵌在欄位 token 內的使用者名稱不符合目前登入的使用者名稱。</span><span class="sxs-lookup"><span data-stu-id="c519e-187">The username embedded within the field token does not match the current logged-in user's username.</span></span>
- <span data-ttu-id="c519e-188">*[IAntiForgeryAdditionalDataProvider. ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* 方法傳回*false*。</span><span class="sxs-lookup"><span data-stu-id="c519e-188">The *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* method returned *false*.</span></span>

<span data-ttu-id="c519e-189">防 XSRF 設施也可能在權杖產生或驗證期間執行額外檢查，而這些檢查期間的失敗可能會導致擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c519e-189">The anti-XSRF facilities may also perform additional checking during token generation or validation, and failures during these checks may result in exceptions being thrown.</span></span> <span data-ttu-id="c519e-190">如需詳細資訊，請參閱[WIF/ACS/以宣告為基礎的驗證](#_WIF_ACS)和設定 **[和](#_Configuration_and_extensibility)** 擴充性章節。</span><span class="sxs-lookup"><span data-stu-id="c519e-190">See the [WIF / ACS / claims-based authentication](#_WIF_ACS) and **[Configuration and extensibility](#_Configuration_and_extensibility)** sections for more information.</span></span>

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a><span data-ttu-id="c519e-191">具有特殊支援的案例</span><span class="sxs-lookup"><span data-stu-id="c519e-191">Scenarios with special support</span></span>

### <a name="anonymous-authentication"></a><span data-ttu-id="c519e-192">匿名驗證</span><span class="sxs-lookup"><span data-stu-id="c519e-192">Anonymous authentication</span></span>

<span data-ttu-id="c519e-193">反 XSRF 系統包含匿名使用者的特殊支援，其中「匿名」定義為使用者，其中*IIdentity. IsAuthenticated*屬性會傳回*false*。</span><span class="sxs-lookup"><span data-stu-id="c519e-193">The anti-XSRF system contains special support for anonymous users, where "anonymous" is defined as a user where the *IIdentity.IsAuthenticated* property returns *false*.</span></span> <span data-ttu-id="c519e-194">案例包括提供登入頁面的 XSRF 保護（在使用者經過驗證之前）和自訂驗證配置，其中應用程式會使用*IIdentity*以外的機制來識別使用者。</span><span class="sxs-lookup"><span data-stu-id="c519e-194">Scenarios include providing XSRF protection to the login page (before the user is authenticated) and custom authentication schemes where the application uses a mechanism other than *IIdentity* to identify users.</span></span>

<span data-ttu-id="c519e-195">若要支援這些案例，請記得會話和欄位權杖是由安全性權杖聯結，這是128位隨機產生的不透明識別碼。</span><span class="sxs-lookup"><span data-stu-id="c519e-195">To support these scenarios, recall that the session and field tokens are joined by a security token, which is a 128-bit randomly-generated opaque identifier.</span></span> <span data-ttu-id="c519e-196">此安全性權杖會在流覽網站時用來追蹤個別使用者的會話，因此它會有效地提供匿名識別碼的用途。</span><span class="sxs-lookup"><span data-stu-id="c519e-196">This security token is used to track an individual user's session as she navigates the site, so it effectively serves the purpose of an anonymous identifier.</span></span> <span data-ttu-id="c519e-197">空字串是用來取代上述產生和驗證常式的使用者名稱。</span><span class="sxs-lookup"><span data-stu-id="c519e-197">An empty string is used in place of the username for the generation and validation routines described above.</span></span>

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a><span data-ttu-id="c519e-198">WIF/ACS/以宣告為基礎的驗證</span><span class="sxs-lookup"><span data-stu-id="c519e-198">WIF / ACS / claims-based authentication</span></span>

<span data-ttu-id="c519e-199">一般來說，.NET Framework 內建的*IIdentity*類別具有*IIdentity.Name*足夠的屬性，可唯一識別特定應用程式內的特定使用者。</span><span class="sxs-lookup"><span data-stu-id="c519e-199">Normally, the *IIdentity* classes built in to the .NET Framework have the property that *IIdentity.Name* is sufficient to uniquely identify a particular user within a particular application.</span></span> <span data-ttu-id="c519e-200">例如， *FormsIdentity.Name*會傳回儲存在成員資格資料庫中的使用者名稱（這對於根據該資料庫的所有應用程式而言是唯一的）， *WindowsIdentity.Name*會傳回使用者的網域限定身分識別等等。</span><span class="sxs-lookup"><span data-stu-id="c519e-200">For example, *FormsIdentity.Name* returns the username stored in the membership database (which is unique for all applications depending on that database), *WindowsIdentity.Name* returns the domain-qualified identity of the user, and so on.</span></span> <span data-ttu-id="c519e-201">這些系統不僅提供驗證，他們也會將使用者*識別*為應用程式。</span><span class="sxs-lookup"><span data-stu-id="c519e-201">These systems provide not only authentication; they also *identify* users to an application.</span></span>

<span data-ttu-id="c519e-202">另一方面，以宣告為基礎的驗證不一定需要識別特定的使用者。</span><span class="sxs-lookup"><span data-stu-id="c519e-202">Claims-based authentication, on the other hand, does not necessarily require identifying a particular user.</span></span> <span data-ttu-id="c519e-203">相反地， *ClaimsPrincipal*和*ClaimsIdentity*類型會與一組*宣告實例相關*聯，其中個別宣告可能是「為18個以上的年齡」或「系統管理員」。</span><span class="sxs-lookup"><span data-stu-id="c519e-203">Instead, the *ClaimsPrincipal* and *ClaimsIdentity* types are associated with a set of *Claim* instances, where the individual claims might be "is 18+ years of age" or "is an administrator" to anything else.</span></span> <span data-ttu-id="c519e-204">由於不一定會識別使用者，因此執行時間無法使用*ClaimsIdentity.Name*屬性做為這個特定使用者的唯一識別碼。</span><span class="sxs-lookup"><span data-stu-id="c519e-204">Since the user hasn't necessarily been identified, the runtime cannot use the *ClaimsIdentity.Name* property as a unique identifier for this particular user.</span></span> <span data-ttu-id="c519e-205">小組已看過真實世界的範例，其中*ClaimsIdentity.Name*會傳回*null*、傳回易記（顯示）名稱，否則會傳回不適合做為使用者唯一識別碼使用的字串。</span><span class="sxs-lookup"><span data-stu-id="c519e-205">The team has seen real-world examples where *ClaimsIdentity.Name* returns *null*, returns a friendly (display) name, or otherwise returns a string that isn't appropriate for use as a unique identifier for the user.</span></span>

<span data-ttu-id="c519e-206">許多使用以宣告為基礎的驗證的部署，特別是使用[Azure 存取控制服務](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx)（ACS）。</span><span class="sxs-lookup"><span data-stu-id="c519e-206">Many of deployments which use claims-based authentication are using [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) in particular.</span></span> <span data-ttu-id="c519e-207">ACS 可讓開發人員設定個別身分*識別提供者*（例如 ADFS、Microsoft 帳戶提供者、OpenID 提供者，例如 yahoo！等），而身分識別提供者會傳回*名稱識別碼*。</span><span class="sxs-lookup"><span data-stu-id="c519e-207">ACS allows the developer to configure individual *identity providers* (such as ADFS, the Microsoft Account provider, OpenID providers like Yahoo!, etc.), and the identity providers return *name identifiers*.</span></span> <span data-ttu-id="c519e-208">這些名稱識別碼可能包含個人識別資訊（PII）（例如電子郵件地址），或者可以像私人個人識別碼（PPID）一樣匿名。</span><span class="sxs-lookup"><span data-stu-id="c519e-208">These name identifiers may contain Personally Identifiable Information (PII) like an email address, or they could be anonymized like a Private Personal Identifier (PPID).</span></span> <span data-ttu-id="c519e-209">無論是什麼，在流覽網站時，元組（識別提供者、名稱識別碼）可充分做為特定使用者的適當追蹤權杖，因此在產生和時，ASP.NET Web Stack 執行時間可以使用元組來取代使用者名稱正在驗證反 XSRF 欄位標記。</span><span class="sxs-lookup"><span data-stu-id="c519e-209">Regardless, the tuple (identity provider, name identifier) sufficiently serves as an appropriate tracking token for a particular user while she is browsing the site, so the ASP.NET Web Stack Runtime can use the tuple in place of the username when generating and validating anti-XSRF field tokens.</span></span> <span data-ttu-id="c519e-210">識別提供者的特定 Uri 和名稱識別碼如下：</span><span class="sxs-lookup"><span data-stu-id="c519e-210">The particular URIs for the identity provider and the name identifier are :</span></span>

- `https://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

<span data-ttu-id="c519e-211">（如需詳細資訊，請參閱此[ACS 檔頁面](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx)）。</span><span class="sxs-lookup"><span data-stu-id="c519e-211">(see this [ACS doc page](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) for more info.)</span></span>

<span data-ttu-id="c519e-212">產生或驗證權杖時，ASP.NET Web Stack 執行時間會在執行時間嘗試系結至類型：</span><span class="sxs-lookup"><span data-stu-id="c519e-212">When generating or validating a token, the ASP.NET Web Stack Runtime will at runtime try binding to the types:</span></span>

- <span data-ttu-id="c519e-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` （適用于 WIF SDK）。</span><span class="sxs-lookup"><span data-stu-id="c519e-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (For the WIF SDK.)</span></span>
- <span data-ttu-id="c519e-214">`System.Security.Claims.ClaimsIdentity` （適用于 .NET 4.5）。</span><span class="sxs-lookup"><span data-stu-id="c519e-214">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5).</span></span>

<span data-ttu-id="c519e-215">如果這些類型存在，而且目前使用者的*IIIIdentity*會執行或子類別其中一種類型，反 XSRF 設施將會在產生和驗證權杖時，使用（識別提供者，名稱識別碼）元組來取代使用者名稱。</span><span class="sxs-lookup"><span data-stu-id="c519e-215">If these types exist, and if the current user's *IIIIdentity* implements or subclasses one of these types, the anti-XSRF facility will use the (identity provider, name identifier) tuple in place of the username when generating and validating the tokens.</span></span> <span data-ttu-id="c519e-216">如果沒有這類元組，要求將會失敗，並顯示錯誤，說明開發人員如何設定防 XSRF 系統，以瞭解使用中的特定宣告式驗證機制。</span><span class="sxs-lookup"><span data-stu-id="c519e-216">If no such tuple is present, the request will fail with an error describing to the developer how to configure the anti-XSRF system to understand the particular claims-based authentication mechanism in use.</span></span> <span data-ttu-id="c519e-217">如需詳細資訊，請參閱設定 **[和](#_Configuration_and_extensibility)** 擴充性一節。</span><span class="sxs-lookup"><span data-stu-id="c519e-217">See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.</span></span>

### <a name="oauth--openid-authentication"></a><span data-ttu-id="c519e-218">OAuth/OpenID 驗證</span><span class="sxs-lookup"><span data-stu-id="c519e-218">OAuth / OpenID authentication</span></span>

<span data-ttu-id="c519e-219">最後，防 XSRF 設施對於使用 OAuth 或 OpenID 驗證的應用程式具有特殊支援。</span><span class="sxs-lookup"><span data-stu-id="c519e-219">Finally, the anti-XSRF facility has special support for applications which use OAuth or OpenID authentication.</span></span> <span data-ttu-id="c519e-220">這種支援是以啟發學習法為基礎：如果目前*IIdentity.Name*的開頭是 HTTP://或 HTTPs://，則會使用序數比較子（而不是預設的 OrdinalIgnoreCase 比較子）來完成使用者名稱比較。</span><span class="sxs-lookup"><span data-stu-id="c519e-220">This support is heuristic-based: if the current *IIdentity.Name* begins with http:// or https://, then username comparisons will be done using an Ordinal comparer rather than the default OrdinalIgnoreCase comparer.</span></span>

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a><span data-ttu-id="c519e-221">設定和擴充性</span><span class="sxs-lookup"><span data-stu-id="c519e-221">Configuration and extensibility</span></span>

<span data-ttu-id="c519e-222">有時候，開發人員可能會想要更嚴密地控制反 XSRF 的產生和驗證行為。</span><span class="sxs-lookup"><span data-stu-id="c519e-222">Occasionally, developers may want tighter control over the anti-XSRF generation and validation behaviors.</span></span> <span data-ttu-id="c519e-223">例如，可能是 MVC 和網頁協助程式的預設行為，會自動將 HTTP cookie 新增到回應中，而開發人員可能會想要在其他地方保存權杖。</span><span class="sxs-lookup"><span data-stu-id="c519e-223">For example, perhaps the MVC and Web Pages helpers' default behavior of automatically adding HTTP cookies to the response is undesirable, and the developer may wish to persist the tokens elsewhere.</span></span> <span data-ttu-id="c519e-224">有兩個 Api 可協助您：</span><span class="sxs-lookup"><span data-stu-id="c519e-224">There exist two APIs to assist with this:</span></span>

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

<span data-ttu-id="c519e-225">*GetTokens*方法會以現有的 XSRF 要求驗證會話權杖（可能是 null）做為輸入，並產生新的 XSRF 要求驗證會話權杖和欄位 token 作為輸出。</span><span class="sxs-lookup"><span data-stu-id="c519e-225">The *GetTokens* method takes as input an existing XSRF request verification session token (which may be null) and produces as output a new XSRF request verification session token and field token.</span></span> <span data-ttu-id="c519e-226">標記只是不透明的字串，沒有裝飾，實例的*formToken*值不會包裝在 &lt;輸入&gt; 標記中。</span><span class="sxs-lookup"><span data-stu-id="c519e-226">The tokens are simply opaque strings with no decoration; the *formToken* value will for instance not be wrapped in an &lt;input&gt; tag.</span></span> <span data-ttu-id="c519e-227">*NewCookieToken*值可以是 null;如果發生這種情況，則*oldCookieToken*值仍然有效，而且不需要設定新的回應 cookie。</span><span class="sxs-lookup"><span data-stu-id="c519e-227">The *newCookieToken* value may be null; if this occurs, then the *oldCookieToken* value is still valid and no new response cookie need be set.</span></span> <span data-ttu-id="c519e-228">*GetTokens*的呼叫者會負責保存任何必要的回應 cookie，或產生任何必要的標記;*GetTokens*方法本身不會將回應改變為副作用。</span><span class="sxs-lookup"><span data-stu-id="c519e-228">The caller of *GetTokens* is responsible for persisting any necessary response cookies or generating any necessary markup; the *GetTokens* method itself will not alter the response as a side effect.</span></span> <span data-ttu-id="c519e-229">*Validate*方法會接受傳入的會話和欄位權杖，並對它們執行上述驗證邏輯。</span><span class="sxs-lookup"><span data-stu-id="c519e-229">The *Validate* method takes the incoming session and field tokens and runs the aforementioned validation logic over them.</span></span>

### <a name="antiforgeryconfig"></a><span data-ttu-id="c519e-230">AntiForgeryConfig</span><span class="sxs-lookup"><span data-stu-id="c519e-230">AntiForgeryConfig</span></span>

<span data-ttu-id="c519e-231">開發人員可以從應用程式\_開始設定防 XSRF 系統。</span><span class="sxs-lookup"><span data-stu-id="c519e-231">The developer may configure the anti-XSRF system from Application\_Start.</span></span> <span data-ttu-id="c519e-232">以程式設計方式設定。</span><span class="sxs-lookup"><span data-stu-id="c519e-232">Configuration is programmatic.</span></span> <span data-ttu-id="c519e-233">靜態*AntiForgeryConfig*類型的屬性如下所述。</span><span class="sxs-lookup"><span data-stu-id="c519e-233">The properties of the static *AntiForgeryConfig* type are described below.</span></span> <span data-ttu-id="c519e-234">大部分使用宣告的使用者會想要設定 UniqueClaimTypeIdentifier 屬性。</span><span class="sxs-lookup"><span data-stu-id="c519e-234">Most users using claims will want to set the UniqueClaimTypeIdentifier property.</span></span>

| <span data-ttu-id="c519e-235">**Property**</span><span class="sxs-lookup"><span data-stu-id="c519e-235">**Property**</span></span> | <span data-ttu-id="c519e-236">**說明**</span><span class="sxs-lookup"><span data-stu-id="c519e-236">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="c519e-237">**AdditionalDataProvider**</span><span class="sxs-lookup"><span data-stu-id="c519e-237">**AdditionalDataProvider**</span></span> | <span data-ttu-id="c519e-238">在權杖產生期間提供額外資料，並在權杖驗證期間耗用額外資料的[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) 。</span><span class="sxs-lookup"><span data-stu-id="c519e-238">An [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) that provides additional data during token generation and consumes additional data during token validation.</span></span> <span data-ttu-id="c519e-239">預設值為*null*。</span><span class="sxs-lookup"><span data-stu-id="c519e-239">The default value is *null*.</span></span> <span data-ttu-id="c519e-240">如需詳細資訊，請參閱[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)一節。</span><span class="sxs-lookup"><span data-stu-id="c519e-240">For more information, see the [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) section.</span></span> |
| <span data-ttu-id="c519e-241">**CookieName**</span><span class="sxs-lookup"><span data-stu-id="c519e-241">**CookieName**</span></span> | <span data-ttu-id="c519e-242">提供用來儲存反 XSRF 會話權杖之 HTTP cookie 名稱的字串。</span><span class="sxs-lookup"><span data-stu-id="c519e-242">A string that provides the name of the HTTP cookie that is used to store the anti-XSRF session token.</span></span> <span data-ttu-id="c519e-243">如果未設定此值，系統就會根據應用程式的已部署虛擬路徑自動產生名稱。</span><span class="sxs-lookup"><span data-stu-id="c519e-243">If this value is not set, a name will be automatically generated based on the application's deployed virtual path.</span></span> <span data-ttu-id="c519e-244">預設值為*null*。</span><span class="sxs-lookup"><span data-stu-id="c519e-244">The default value is *null*.</span></span> |
| <span data-ttu-id="c519e-245">**RequireSsl**</span><span class="sxs-lookup"><span data-stu-id="c519e-245">**RequireSsl**</span></span> | <span data-ttu-id="c519e-246">布林值，指出是否需要透過 SSL 保護的通道提交防 XSRF token。</span><span class="sxs-lookup"><span data-stu-id="c519e-246">A Boolean that dictates whether the anti-XSRF tokens are required to be submitted over an SSL-secured channel.</span></span> <span data-ttu-id="c519e-247">如果此值為*true*，任何自動產生的 cookie 都會設定 "secure" 旗標，而如果從不是透過 SSL 提交的要求中呼叫，則會擲回反 XSRF api。</span><span class="sxs-lookup"><span data-stu-id="c519e-247">If this value is *true*, any automatically-generated cookies will have the "secure" flag set, and the anti-XSRF APIs will throw if called from within a request that is not submitted via SSL.</span></span> <span data-ttu-id="c519e-248">預設值為 *false*。</span><span class="sxs-lookup"><span data-stu-id="c519e-248">The default value is *false*.</span></span> |
| <span data-ttu-id="c519e-249">**SuppressIdentityHeuristicChecks**</span><span class="sxs-lookup"><span data-stu-id="c519e-249">**SuppressIdentityHeuristicChecks**</span></span> | <span data-ttu-id="c519e-250">布林值，指定反 XSRF 系統是否應停用對宣告式身分識別的支援。</span><span class="sxs-lookup"><span data-stu-id="c519e-250">A Boolean that dictates whether the anti-XSRF system should deactivate its support for claims-based identities.</span></span> <span data-ttu-id="c519e-251">如果此值為*true*，則系統會假設*IIdentity.Name*適合做為每個使用者的唯一識別碼，而且不會嘗試使用 WIF/ACS/中所述的特殊案例*IClaimsIdentity*或*ClClaimsIdentity* [以宣告為基礎的驗證](#_WIF_ACS)一節。</span><span class="sxs-lookup"><span data-stu-id="c519e-251">If this value is *true*, the system will assume that *IIdentity.Name* is appropriate for use as a unique per-user identifier and will not try to special-case *IClaimsIdentity* or *ClClaimsIdentity* as described in the [WIF / ACS / claims-based authentication](#_WIF_ACS) section.</span></span> <span data-ttu-id="c519e-252">預設值是 `false`。</span><span class="sxs-lookup"><span data-stu-id="c519e-252">The default value is `false`.</span></span> |
| <span data-ttu-id="c519e-253">**UniqueClaimTypeIdentifier**</span><span class="sxs-lookup"><span data-stu-id="c519e-253">**UniqueClaimTypeIdentifier**</span></span> | <span data-ttu-id="c519e-254">字串，指出哪個宣告類型適合做為唯一的每一使用者識別碼使用。</span><span class="sxs-lookup"><span data-stu-id="c519e-254">A string that indicates which claim type is appropriate for use as a unique per-user identifier.</span></span> <span data-ttu-id="c519e-255">如果設定了這個值，而目前的*IIdentity*是以宣告為基礎，則系統會嘗試解壓縮*UniqueClaimTypeIdentifier*所指定之類型的宣告，而在下列情況下，將會使用對應的值來取代使用者的使用者名稱。正在產生欄位 token。</span><span class="sxs-lookup"><span data-stu-id="c519e-255">If this value is set and the current *IIdentity* is claims-based, the system will attempt to extract a claim of the type specified by *UniqueClaimTypeIdentifier*, and the corresponding value will be used in place of the user's username when generating the field token.</span></span> <span data-ttu-id="c519e-256">如果找不到宣告類型，系統就會讓要求失敗。</span><span class="sxs-lookup"><span data-stu-id="c519e-256">If the claim type is not found, the system will fail the request.</span></span> <span data-ttu-id="c519e-257">預設值為*null*，表示系統應該使用先前描述的（識別提供者名稱識別碼）元組來取代使用者的使用者名稱。</span><span class="sxs-lookup"><span data-stu-id="c519e-257">The default value is *null*, which indicates that the system should use the (identity provider, name identifier) tuple as previously described in place of the user's username.</span></span> |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a><span data-ttu-id="c519e-258">IAntiForgeryAdditionalDataProvider</span><span class="sxs-lookup"><span data-stu-id="c519e-258">IAntiForgeryAdditionalDataProvider</span></span>

<span data-ttu-id="c519e-259">*[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* 類型可讓開發人員在每個權杖中來回往返額外的資料，以擴充反 XSRF 系統的行為。</span><span class="sxs-lookup"><span data-stu-id="c519e-259">The *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* type allows developers to extend the behavior of the anti-XSRF system by round-tripping additional data in each token.</span></span> <span data-ttu-id="c519e-260">每次產生欄位標記時，會呼叫*GetAdditionalData*方法，而傳回值會內嵌在產生的權杖中。</span><span class="sxs-lookup"><span data-stu-id="c519e-260">The *GetAdditionalData* method is called each time a field token is generated, and the return value is embedded within the generated token.</span></span> <span data-ttu-id="c519e-261">實施者可能會從這個方法傳回時間戳記、nonce 或任何其他值。</span><span class="sxs-lookup"><span data-stu-id="c519e-261">An implementer could return a timestamp, a nonce, or any other value she wishes from this method.</span></span>

<span data-ttu-id="c519e-262">同樣地，每次驗證欄位 token 時都會呼叫*ValidateAdditionalData*方法，而在標記中內嵌的「其他資料」字串則會傳遞至方法。</span><span class="sxs-lookup"><span data-stu-id="c519e-262">Similarly, the *ValidateAdditionalData* method is called each time a field token is validated, and the "additional data" string that was embedded within the token is passed to the method.</span></span> <span data-ttu-id="c519e-263">驗證常式可能會執行超時（藉由檢查目前時間與建立權杖時所儲存的時間）、nonce 檢查常式或任何其他所需的邏輯。</span><span class="sxs-lookup"><span data-stu-id="c519e-263">The validation routine could implement a timeout (by checking the current time against the time that was stored when the token was created), a nonce checking routine, or any other desired logic.</span></span>

## <a name="design-decisions-and-security-considerations"></a><span data-ttu-id="c519e-264">設計決策和安全性考慮</span><span class="sxs-lookup"><span data-stu-id="c519e-264">Design decisions and security considerations</span></span>

<span data-ttu-id="c519e-265">在技術上，只有在嘗試保護匿名/未驗證的使用者以防止 XSRF 攻擊時，才需要提供連結會話和欄位權杖的安全性權杖。</span><span class="sxs-lookup"><span data-stu-id="c519e-265">The security token that links the session and field tokens is technically only necessary when trying to protect anonymous / unauthenticated users against XSRF attacks.</span></span> <span data-ttu-id="c519e-266">當使用者通過驗證時，驗證權杖本身（可能是以 cookie 形式提交）可以用來作為同步器權杖組的一半。</span><span class="sxs-lookup"><span data-stu-id="c519e-266">When the user is authenticated, the authentication token itself (presumably submitted in the form of a cookie) could be used as one half of a synchronizer token pair.</span></span> <span data-ttu-id="c519e-267">不過，有有效的案例可保護未驗證的使用者所叫用的登入頁面，而且即使是已驗證的使用者，一律會產生及驗證安全性權杖，而使反 XSRF 邏輯變得更簡單。</span><span class="sxs-lookup"><span data-stu-id="c519e-267">However, there are valid scenarios for protecting login pages hit by unauthenticated users, and the anti-XSRF logic was made simpler by always generating and validating the security token, even for authenticated users.</span></span> <span data-ttu-id="c519e-268">它也會在欄位權杖遭攻擊者洩露時提供一些額外的保護，因為設定或猜測會話權杖會是攻擊者解決的另一個障礙。</span><span class="sxs-lookup"><span data-stu-id="c519e-268">It also does provide some additional protection in the event that a field token is ever compromised by an attacker, as setting or guessing the session token would be another hurdle for the attacker to overcome.</span></span>

<span data-ttu-id="c519e-269">當多個應用程式裝載于單一網域時，開發人員應該小心使用。</span><span class="sxs-lookup"><span data-stu-id="c519e-269">Developers should use caution when multiple applications are hosted in a single domain.</span></span> <span data-ttu-id="c519e-270">例如，雖然*example1.cloudapp.net*和*example2.cloudapp.net*是不同的主機，但在 cloudapp.net 網域下 *\** 的所有主機之間，都有隱含的信任關係。</span><span class="sxs-lookup"><span data-stu-id="c519e-270">For example, even though *example1.cloudapp.net* and *example2.cloudapp.net* are different hosts, there is an implicit trust relationship between all hosts under the *\*.cloudapp.net* domain.</span></span> <span data-ttu-id="c519e-271">此隱含信任關係[允許可能不受信任的主機影響彼此的 cookie](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) （控管 AJAX 要求的相同來源原則不一定會套用至 HTTP cookie）。</span><span class="sxs-lookup"><span data-stu-id="c519e-271">This implicit trust relationship [allows potentially untrusted hosts to affect each other's cookies](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (the same-origin policies that govern AJAX requests do not necessarily apply to HTTP cookies).</span></span> <span data-ttu-id="c519e-272">ASP.NET Web Stack 執行時間提供了一些緩和措施，因為使用者名稱會內嵌到欄位 token 中，因此即使惡意子域能夠覆寫會話權杖，也無法為使用者產生有效的欄位 token。</span><span class="sxs-lookup"><span data-stu-id="c519e-272">The ASP.NET Web Stack Runtime provides some mitigation in that the username is embedded into the field token, so even if a malicious subdomain is able to overwrite a session token it will be unable to generate a valid field token for the user.</span></span> <span data-ttu-id="c519e-273">不過，在這種環境中裝載時，內建的反 XSRF 常式仍然無法防禦會話劫持或登入 XSRF。</span><span class="sxs-lookup"><span data-stu-id="c519e-273">However, when hosted in such an environment the built-in anti-XSRF routines still cannot defend against session hijacking or login XSRF.</span></span>

<span data-ttu-id="c519e-274">反 XSRF 常式目前不會抵禦[點擊劫持](https://www.owasp.org/index.php/Clickjacking)。</span><span class="sxs-lookup"><span data-stu-id="c519e-274">The anti-XSRF routines currently do not defend against [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="c519e-275">想要自行防禦點擊劫持的應用程式，可以藉由傳送每個回應的 X 框架選項： SAMEORIGIN 標頭，輕鬆地執行此動作。</span><span class="sxs-lookup"><span data-stu-id="c519e-275">Applications that wish to defend themselves against clickjacking may easily do so by sending an X-Frame-Options: SAMEORIGIN header with each response.</span></span> <span data-ttu-id="c519e-276">所有最近的瀏覽器都支援此標頭。</span><span class="sxs-lookup"><span data-stu-id="c519e-276">This header is supported by all recent browsers.</span></span> <span data-ttu-id="c519e-277">如需詳細資訊，請參閱[IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx)、 [SDL blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx)和[OWASP](https://www.owasp.org/index.php/Clickjacking)。</span><span class="sxs-lookup"><span data-stu-id="c519e-277">For more information, see the [IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), the [SDL blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), and [OWASP](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="c519e-278">在未來的版本中，ASP.NET Web Stack 執行時間可能會讓 MVC 和網頁反 XSRF helper 自動設定此標頭，讓應用程式得以自動保護以防止此攻擊。</span><span class="sxs-lookup"><span data-stu-id="c519e-278">The ASP.NET Web Stack Runtime may in some future release make the MVC and Web Pages anti-XSRF helpers automatically set this header so that applications are automatically protected against this attack.</span></span>

<span data-ttu-id="c519e-279">Web 開發人員應該繼續確保其網站不容易遭受 XSS 攻擊。</span><span class="sxs-lookup"><span data-stu-id="c519e-279">Web developers should continue to ensure that their site is not vulnerable to XSS attacks.</span></span> <span data-ttu-id="c519e-280">XSS 攻擊的功能非常強大，而成功的惡意探索也會破壞 ASP.NET Web Stack 執行時間防禦 XSRF 攻擊。</span><span class="sxs-lookup"><span data-stu-id="c519e-280">XSS attacks are very powerful, and a successful exploit would also break the ASP.NET Web Stack Runtime defenses against XSRF attacks.</span></span>

## <a name="acknowledgment"></a><span data-ttu-id="c519e-281">確認</span><span class="sxs-lookup"><span data-stu-id="c519e-281">Acknowledgment</span></span>

<span data-ttu-id="c519e-282">[@LeviBroderick](https://twitter.com/LeviBroderick)，他寫了大部分的 ASP.NET 安全性程式碼，這是大部分的資訊。</span><span class="sxs-lookup"><span data-stu-id="c519e-282">[@LeviBroderick](https://twitter.com/LeviBroderick), who wrote much of the ASP.NET security code the bulk of this information.</span></span>
